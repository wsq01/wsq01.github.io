<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Python类和对象 |  学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-python/Python类和对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Python类和对象
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/15/python/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2022-12-15T05:38:43.000Z" itemprop="datePublished">2022-12-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">15.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">60 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="class：定义类"><a href="#class：定义类" class="headerlink" title="class：定义类"></a>class：定义类</h1><p>定义一个类使用<code>class</code>关键字实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名：</span><br><span class="line">  多个（≥0）类属性...</span><br><span class="line">  多个（≥0）类方法...</span><br></pre></td></tr></table></figure>
<p>无论是类属性还是类方法，对于类来说，它们都不是必需的。另外，类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。</p>
<p>类属性指的就是包含在类中的变量；类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。</p>
<p>Python 类是由类头（<code>class</code>类名）和类体（统一缩进的变量和函数）构成。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheFirstDemo</span>:</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个类属性</span></span><br><span class="line">  add = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置，如上面程序中第二行的字符串，就是<code>TheFirstDemo</code>这个类的说明文档。</p>
<p>另外分析上面的代码可以看到，我们创建了一个名为<code>TheFirstDemo</code>的类，其包含了一个名为<code>add</code>的类属性。注意，根据定义属性位置的不同，在各个类方法之外定义的变量称为类属性或类变量（如<code>add</code>属性）。</p>
<p>同时，<code>TheFirstDemo</code>类中还包含一个<code>say()</code>类方法，该方法包含两个参数，分别是<code>self</code>和<code>content</code>。<code>content</code>参数就只是一个普通参数，没有特殊含义，但<code>self</code>比较特殊，并不是普通的参数。</p>
<p>更确切地说，<code>say()</code>是一个实例方法，除此之外，Python 类中还可以定义类方法和静态方法。</p>
<p>事实上，我们完全可以创建一个没有任何类属性和类方法的类，换句话说，Python 允许创建空类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以看到，如果一个类没有任何类属性和类方法，那么可以直接用<code>pass</code>关键字作为类体即可。</p>
<h1 id="init-类构造方法"><a href="#init-类构造方法" class="headerlink" title="init()类构造方法"></a><strong>init</strong>()类构造方法</h1><p>在创建类时，我们可以手动添加一个<code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p>
<p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,...):</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure>
<p>另外，<code>__init__()</code>方法可以包含多个参数，但必须包含一个名为<code>self</code>的参数，且必须作为第一个参数。也就是说，类的构造方法最少也要有一个<code>self</code>参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheFirstDemo</span>:</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">#构造方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用构造方法&quot;</span>)</span><br><span class="line">  <span class="comment"># 下面定义了一个类属性</span></span><br><span class="line">  add = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>注意，即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含<code>self</code>参数的构造方法。</p>
<p>仅包含<code>self</code>参数的<code>__init__()</code>构造方法，又称为类的默认构造方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan = TheFirstDemo()</span><br></pre></td></tr></table></figure>
<p>这行代码的含义是创建一个名为<code>zhangsan</code>的<code>TheFirstDemo</code>类对象。运行代码可看到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用构造方法</span><br></pre></td></tr></table></figure>
<p>显然，在创建<code>zhangsan</code>这个对象时，隐式调用了我们手动创建的<code>__init__()</code>构造方法。</p>
<p>在<code>__init__()</code>构造方法中，除了<code>self</code>参数外，还可以自定义一些参数，参数之间使用逗号进行分割。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;这是一个学习Python定义的一个类&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, add</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&quot;的英文名为:&quot;</span>, add)</span><br><span class="line"><span class="comment">#创建 add 对象，并传递参数给构造函数</span></span><br><span class="line">add = CLanguage(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然构造方法中有<code>self、name、add</code>3 个参数，但实际需要传参的仅有<code>name</code>和<code>add</code>，也就是说，<code>self</code>不需要手动传递参数。</p>
<h1 id="类对象的创建和使用"><a href="#类对象的创建和使用" class="headerlink" title="类对象的创建和使用"></a>类对象的创建和使用</h1><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><p>对已定义好的类进行实例化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名(参数)</span><br></pre></td></tr></table></figure>
<p>定义类时，如果没有手动添加<code>__init__()</code>构造方法，又或者添加的<code>__init__()</code>中仅有一个<code>self</code>参数，则创建类对象时的参数可以省略不写。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="comment"># 下面定义了2个类变量</span></span><br><span class="line">  name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">  add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, add</span>):</span><br><span class="line">    <span class="comment">#下面定义 2 个实例变量</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.add = add</span><br><span class="line">    <span class="built_in">print</span>(name,<span class="string">&quot;的英文名为：&quot;</span>,add)</span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"><span class="comment"># 将该CLanguage对象赋给clanguage变量</span></span><br><span class="line">clanguage = CLanguage(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，由于构造方法除<code>self</code>参数外，还包含 2 个参数，且这 2 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的<code>name</code>值和<code>add</code>值（<code>self</code>参数是特殊参数，不需要手动传值，Python 会自动传给它值）。</p>
<p>类变量和实例变量，简单地理解，定义在各个类方法之外（包含在类中）的变量为类变量（或者类属性），定义在类方法中的变量为实例变量（或者实例属性）。</p>
<h2 id="类对象的使用"><a href="#类对象的使用" class="headerlink" title="类对象的使用"></a>类对象的使用</h2><p>定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：</p>
<ul>
<li>访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；</li>
<li>调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。</li>
</ul>
<h4 id="类对象访问变量或方法"><a href="#类对象访问变量或方法" class="headerlink" title="类对象访问变量或方法"></a>类对象访问变量或方法</h4><p>使用已创建好的类对象访问类中实例变量的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类对象名.变量名</span><br></pre></td></tr></table></figure>
<p>使用类对象调用类中方法的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(参数)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输出name和add实例变量的值</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.name,clanguage.add)</span><br><span class="line"><span class="comment">#修改实例变量的值</span></span><br><span class="line">clanguage.name=<span class="string">&quot;小红&quot;</span></span><br><span class="line">clanguage.add=<span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment">#调用clanguage的say()方法</span></span><br><span class="line">clanguage.say(<span class="string">&quot;人生苦短，我用Python&quot;</span>)</span><br><span class="line"><span class="comment">#再次输出name和add的值</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.name,clanguage.add)</span><br></pre></td></tr></table></figure>
<h4 id="给类对象动态添加-x2F-删除变量"><a href="#给类对象动态添加-x2F-删除变量" class="headerlink" title="给类对象动态添加&#x2F;删除变量"></a>给类对象动态添加&#x2F;删除变量</h4><p>Python 支持为已创建好的对象动态增加实例变量：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为clanguage对象增加一个money实例变量</span></span><br><span class="line">clanguage.money= <span class="number">159.9</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.money) <span class="comment"># 159.9</span></span><br></pre></td></tr></table></figure>
<p>动态删除使用<code>del</code>语句即可实现：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除新添加的 money 实例变量</span></span><br><span class="line"><span class="keyword">del</span> clanguage.money</span><br><span class="line"><span class="comment">#再次尝试输出 money，此时会报错</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.money)</span><br></pre></td></tr></table></figure>
<p>运行程序会发现，结果显示<code>AttributeError</code>错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:/Users/mengma/Desktop/1.py&quot;, line 29, in &lt;module&gt;</span><br><span class="line">    print(clanguage.money)</span><br><span class="line">AttributeError: &#x27;CLanguage&#x27; object has no attribute &#x27;money&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="给类对象动态添加方法"><a href="#给类对象动态添加方法" class="headerlink" title="给类对象动态添加方法"></a>给类对象动态添加方法</h4><p>Python 也允许为对象动态增加方法。以<code>Clanguage</code>类为例，由于其内部只包含一个<code>say()</code>方法，因此该类实例化出的<code>clanguage</code>对象也只包含一个<code>say()</code>方法。但其实，我们还可以为<code>clanguage</code>对象动态添加其它方法。</p>
<p>需要注意的一点是，为<code>clanguage</code>对象动态增加的方法，Python 不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为<code>self</code>也没用）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;---info函数---&quot;</span>, self)</span><br><span class="line"><span class="comment"># 使用info对clanguage的foo方法赋值（动态绑定方法）</span></span><br><span class="line">clanguage.foo = info</span><br><span class="line"><span class="comment"># Python不会自动将调用者绑定到第一个参数，</span></span><br><span class="line"><span class="comment"># 因此程序需要手动将调用者绑定为第一个参数</span></span><br><span class="line">clanguage.foo(clanguage)  <span class="comment"># ①</span></span><br><span class="line"><span class="comment"># 使用lambda表达式为clanguage对象的bar方法赋值（动态绑定方法）</span></span><br><span class="line">clanguage.bar = <span class="keyword">lambda</span> self: <span class="built_in">print</span>(<span class="string">&#x27;--lambda表达式--&#x27;</span>, self)</span><br><span class="line">clanguage.bar(clanguage) <span class="comment"># ②</span></span><br></pre></td></tr></table></figure>
<p>上面的第 8 行和第 10 行代码分别使用函数、lambda 表达式为<code>clanguage</code>对象动态增加了方法，但对于动态增加的方法，Python 不会自动将方法调用者绑定到它们的第一个参数，因此程序必须手动为第一个参数传入参数值，如上面程序中 ① 号、② 号代码所示。</p>
<p>有没有不用手动给<code>self</code>传值的方法呢？通过借助<code>types</code>模块下的<code>MethodType</code>可以实现：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self,content</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小明的英文名为：%s&quot;</span> % content)</span><br><span class="line"><span class="comment"># 导入MethodType</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">clanguage.info = MethodType(info, clanguage)</span><br><span class="line"><span class="comment"># 第一个参数已经绑定了，无需传入</span></span><br><span class="line">clanguage.info(<span class="string">&quot;xiaoming&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，由于使用<code>MethodType</code>包装<code>info()</code>函数时，已经将该函数的<code>self</code>参数绑定为<code>clanguage</code>，因此后续再使用<code>info()</code>函数时，就不用再给<code>self</code>参数绑定值了。</p>
<h1 id="self用法"><a href="#self用法" class="headerlink" title="self用法"></a>self用法</h1><p>在定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将<code>self</code>参数作为方法的第一个参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在执行构造方法&quot;</span>)</span><br><span class="line">  <span class="comment"># 定义一个study()实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self,name</span>):</span><br><span class="line">    <span class="built_in">print</span>(name,<span class="string">&quot;正在学Python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>事实上，Python 只是规定，无论是构造方法还是实例方法，最少要包含一个参数，并没有规定该参数的具体名称。之所以将其命名为<code>self</code>，只是程序员之间约定俗成的一种习惯（大家一看到<code>self</code>，就知道它的作用）。</p>
<p>那么，<code>self</code>参数的具体作用是什么呢？打个比方，如果把类比作造房子的图纸，那么类实例化后的对象是真正可以住的房子。根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？</p>
<p>当然是通过<code>self</code>参数，它就相当于每个房子的门钥匙，可以保证每个房子的主人仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。</p>
<p>其实 Python 类方法中的<code>self</code>参数就相当于 C++ 中的<code>this</code>指针。</p>
<p>也就是说，同一个类可以产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，换句话说，Python 会自动绑定类方法的第一个参数指向调用该方法的对象。如此，Python 解释器就能知道到底要操作哪个对象的方法了。</p>
<p>因此，程序在调用实例方法和构造方法时，不需要手动为第一个参数传值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在执行构造方法&quot;</span>)</span><br><span class="line">  <span class="comment"># 定义一个study()实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self, <span class="string">&quot;正在学Python&quot;</span>)</span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.study()</span><br><span class="line">lisi = Person()</span><br><span class="line">lisi.study()</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>study()</code>中的<code>self</code>代表该方法的调用者，即谁调用该方法，那么<code>self</code>就代表谁。因此，该程序的运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在执行构造方法</span><br><span class="line">&lt;__main__.Person object at 0x0000021ADD7D21D0&gt; 正在学Python</span><br><span class="line">正在执行构造方法</span><br><span class="line">&lt;__main__.Person object at 0x0000021ADD7D2E48&gt; 正在学Python</span><br></pre></td></tr></table></figure>
<p>另外，对于构造函数中的<code>self</code>参数，其代表的是当前正在初始化的类对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name=name</span><br><span class="line">zhangsan = Person(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(zhangsan.name) <span class="comment"># zhangsan</span></span><br><span class="line">lisi = Person(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lisi.name) <span class="comment"># lisi</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>zhangsan</code>在进行初始化时，调用的构造函数中<code>self</code>代表的是<code>zhangsan</code>；而<code>lisi</code>在进行初始化时，调用的构造函数中<code>self</code>代表的是<code>lisi</code>。</p>
<p>值得一提的是，除了类对象可以直接调用类方法，还有一种函数调用的方式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self)</span><br><span class="line">zhangsan = Person()</span><br><span class="line"><span class="comment">#第一种方式</span></span><br><span class="line">zhangsan.who()</span><br><span class="line"><span class="comment">#第二种方式</span></span><br><span class="line">who = zhangsan.who</span><br><span class="line">who()<span class="comment">#通过 who 变量调用zhangsan对象中的 who() 方法</span></span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Person object at 0x0000025C26F021D0&gt;</span><br><span class="line">&lt;__main__.Person object at 0x0000025C26F021D0&gt;</span><br></pre></td></tr></table></figure>
<p>显然，无论采用哪种方法，<code>self</code>所表示的都是实际调用该方法的对象。</p>
<p>总之，无论是类中的构造函数还是普通的类方法，实际调用它们的谁，则第一个参数<code>self</code>就代表谁。</p>
<h1 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h1><p>无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。</p>
<p>在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：</p>
<ul>
<li>类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；</li>
<li>类体中，所有函数内部：以<code>self.变量名</code>的方式定义的变量，称为实例属性或实例变量；</li>
<li>类体中，所有函数内部：以“变量名&#x3D;变量值”的方式定义的变量，称为局部变量。</li>
</ul>
<p>类方法也可细分为实例方法、静态方法和类方法。</p>
<h2 id="类变量（类属性）"><a href="#类变量（类属性）" class="headerlink" title="类变量（类属性）"></a>类变量（类属性）</h2><p>类变量指的是在类中，但在各个类方法外定义的变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="comment"># 下面定义了2个类变量</span></span><br><span class="line">  name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">  add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>上面程序中，<code>name</code>和<code>add</code>就属于类变量。</p>
<p>类变量的特点是，所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。类变量的调用方式有 2 种，既可以使用类名直接调用，也可以使用类的实例化对象调用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用类名直接调用</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="comment">#修改类变量的值</span></span><br><span class="line">CLanguage.name = <span class="string">&quot;小红&quot;</span></span><br><span class="line">CLanguage.add = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaohong</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过类名不仅可以调用类变量，也可以修改它的值。</p>
<p>当然，也可以使用类对象来调用所属类中的类变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br><span class="line"><span class="built_in">print</span>(clang.add)</span><br></pre></td></tr></table></figure>
<p>注意，因为类变量为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前，各类对象中类变量的值：&quot;</span>)</span><br><span class="line">clang1 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang1.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang1.add) <span class="comment"># xiaoming</span></span><br><span class="line">clang2 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后，各类对象中类变量的值：&quot;</span>)</span><br><span class="line">CLanguage.name = <span class="string">&quot;小红&quot;</span></span><br><span class="line">CLanguage.add = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang1.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang1.add) <span class="comment"># xiaohong</span></span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaohong</span></span><br></pre></td></tr></table></figure>
<p>显然，通过类名修改类变量，会作用到所有的实例化对象（例如这里的<code>clang1</code>和<code>clang2</code>）。</p>
<p>注意，通过类对象是无法修改类变量的。通过类对象对类变量赋值，其本质将不再是修改类变量的值，而是在给该对象定义新的实例变量。</p>
<p>值得一提的是，除了可以通过类名访问类变量之外，还可以动态地为类和对象添加类变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">CLanguage.catalog = <span class="number">13</span></span><br><span class="line"><span class="built_in">print</span>(clang.catalog) <span class="comment"># 13</span></span><br></pre></td></tr></table></figure>
<h2 id="实例变量（实例属性）"><a href="#实例变量（实例属性）" class="headerlink" title="实例变量（实例属性）"></a>实例变量（实例属性）</h2><p>实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。另外，实例变量只能通过对象名访问，无法通过类名访问。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">    <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    self.catalog = <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>此<code>CLanguage</code>类中，<code>name、add</code>以及<code>catalog</code>都是实例变量。其中，由于<code>__init__()</code>函数在创建类对象时会自动调用，而<code>say()</code>方法需要类对象手动调用。因此，<code>CLanguage</code>类的类对象都会包含<code>name</code>和<code>add</code>实例变量，而只有调用了<code>say()</code>方法的类对象，才包含<code>catalog</code>实例变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="comment">#由于 clang 对象未调用 say() 方法，因此其没有 catalog 变量，下面这行代码会报错</span></span><br><span class="line"><span class="comment">#print(clang.catalog)</span></span><br><span class="line">clang2 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="comment">#只有调用 say()，才会拥有 catalog 实例变量</span></span><br><span class="line">clang2.say()</span><br><span class="line"><span class="built_in">print</span>(clang2.catalog) <span class="comment"># 13</span></span><br></pre></td></tr></table></figure>
<p>通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的实例变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#clang访问类变量</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaoming</span></span><br><span class="line">clang.name = <span class="string">&quot;小红&quot;</span></span><br><span class="line">clang.add = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment">#clang实例变量的值</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaohong</span></span><br><span class="line"><span class="comment">#类变量的值</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaoming</span></span><br></pre></td></tr></table></figure>
<p>显然，通过类对象是无法修改类变量的值的，本质其实是给<code>clang</code>对象新添加<code>name</code>和<code>add</code>这 2 个实例变量。</p>
<p>类中，实例变量和类变量可以同名，但这种情况下使用类对象将无法调用类变量，它会首选实例变量，这也是不推荐“类变量使用对象名调用”的原因。</p>
<p>另外，和类变量不同，通过某个对象修改实例变量的值，不会影响类的其它实例化对象，更不会影响同名的类变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  name = <span class="string">&quot;小明&quot;</span>  <span class="comment">#类变量</span></span><br><span class="line">  add = <span class="string">&quot;xiaoming&quot;</span>  <span class="comment">#类变量</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小红&quot;</span>   <span class="comment">#实例变量</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaohong&quot;</span>   <span class="comment">#实例变量</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    self.catalog = <span class="number">13</span>  <span class="comment">#实例变量</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#修改 clang 对象的实例变量</span></span><br><span class="line">clang.name = <span class="string">&quot;小李&quot;</span></span><br><span class="line">clang.add = <span class="string">&quot;xiaoli&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小李</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaoli</span></span><br><span class="line">clang2 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaohong</span></span><br><span class="line"><span class="comment">#输出类变量的值</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaoming</span></span><br></pre></td></tr></table></figure>
<p>不仅如此，Python 只支持为特定的对象添加实例变量。例如，在之前代码的基础上，为<code>clang</code>对象添加<code>money</code>实例变量：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang.money = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(clang.money)</span><br></pre></td></tr></table></figure>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>除了实例变量，类方法中还可以定义局部变量。局部变量直接以“变量名&#x3D;值”的方式进行定义：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self,money</span>):</span><br><span class="line">    sale = <span class="number">0.8</span>*money</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优惠后的价格为：&quot;</span>,sale)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.count(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>通常情况下，定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。</p>
<h1 id="实例方法、静态方法和类方法"><a href="#实例方法、静态方法和类方法" class="headerlink" title="实例方法、静态方法和类方法"></a>实例方法、静态方法和类方法</h1><p>类方法可分为类方法、实例方法和静态方法。采用<code>@classmethod</code>修饰的方法为类方法；采用<code>@staticmethod</code>修饰的方法为静态方法；不用任何修饰的方法为实例方法。</p>
<h2 id="类实例方法"><a href="#类实例方法" class="headerlink" title="类实例方法"></a>类实例方法</h2><p>通常情况下，在类中定义的方法默认都是实例方法。类的构造方法理论上也属于实例方法，只不过它比较特殊。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#类构造方法，也属于实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用 say() 实例方法&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>实例方法最大的特点就是，它最少也要包含一个<code>self</code>参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。实例方法通常会用类对象直接调用：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">clang.say() <span class="comment"># 正在调用 say() 实例方法</span></span><br></pre></td></tr></table></figure>
<p>当然，Python 也支持使用类名调用实例方法，但此方式需要手动给<code>self</code>参数传值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类名调用实例方法，需手动给 self 参数传值</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line">CLanguage.say(clang) <span class="comment"># 正在调用 say() 实例方法</span></span><br></pre></td></tr></table></figure>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为<code>cls</code>，Python 会自动将类本身绑定给<code>cls</code>参数（注意，绑定的不是类对象）。也就是说，我们在调用类方法时，无需显式为<code>cls</code>参数传参。</p>
<p>和<code>self</code>一样，<code>cls</code>参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。</p>
<p>和实例方法最大的不同在于，类方法需要使用<code>@classmethod</code>修饰符进行修饰：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#类构造方法，也属于实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="comment">#下面定义了一个类方法</span></span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用类方法&quot;</span>, cls)</span><br></pre></td></tr></table></figure>
<p>如果没有<code>＠classmethod</code>，则 Python 解释器会将<code>info()</code>方法认定为实例方法，而不是类方法。</p>
<p>类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用类名直接调用类方法</span></span><br><span class="line">CLanguage.info()</span><br><span class="line"><span class="comment">#使用类对象调用类方法</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.info()</span><br></pre></td></tr></table></figure>
<h2 id="类静态方法"><a href="#类静态方法" class="headerlink" title="类静态方法"></a>类静态方法</h2><p>静态方法，其实就是函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。</p>
<p>静态方法没有类似<code>self、cls</code>这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</p>
<p>静态方法需要使用<code>@staticmethod</code>修饰：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">name, add</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, add)</span><br></pre></td></tr></table></figure>
<p>静态方法的调用，既可以使用类名，也可以使用类对象：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用类名直接调用静态方法</span></span><br><span class="line">CLanguage.info(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="comment">#使用类对象调用静态方法</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.info(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;xiaohong&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。</p>
<h1 id="类调用实例方法"><a href="#类调用实例方法" class="headerlink" title="类调用实例方法"></a>类调用实例方法</h1><p>实例方法的调用方式有 2 种，既可以采用类对象调用，也可以直接通过类名调用。</p>
<p>通常情况下，我们习惯使用类对象调用类中的实例方法。但如果想用类调用实例方法，不能像如下这样：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我正在学 Python&quot;</span>)</span><br><span class="line"><span class="comment">#通过类名直接调用实例方法</span></span><br><span class="line">CLanguage.info()</span><br></pre></td></tr></table></figure>
<p>运行上面代码，程序会报出如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\demo.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    CLanguage.info()</span><br><span class="line">TypeError: info() missing 1 required positional argument: &#x27;self&#x27;</span><br></pre></td></tr></table></figure>
<p>其中，最后一行报错信息提示我们，调用<code>info()</code>类方式时缺少给<code>self</code>参数传参。这意味着，和使用类对象调用实例方法不同，通过类名直接调用实例方法时，Python 并不会自动给<code>self</code>参数传值。</p>
<p><code>self</code>参数需要的是方法的实际调用者（是类对象），而这里只提供了类名，当然无法自动传值。</p>
<p>因此，如果想通过类名直接调用实例方法，就必须手动为<code>self</code>参数传值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我正在学 Python&quot;</span>)</span><br><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#通过类名直接调用实例方法</span></span><br><span class="line">CLanguage.info(clang)</span><br></pre></td></tr></table></figure>
<p>可以看到，通过手动将<code>clang</code>这个类对象传给了<code>self</code>参数，使得程序得以正确执行。实际上，这里调用实例方法的形式完全是等价于<code>clang.info()</code>。</p>
<p>值得一提的是，上面的报错信息只是让我们手动为<code>self</code>参数传值，但并没有规定必须传一个该类的对象，其实完全可以任意传入一个参数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self,<span class="string">&quot;正在学 Python&quot;</span>)</span><br><span class="line"><span class="comment">#通过类名直接调用实例方法</span></span><br><span class="line">CLanguage.info(<span class="string">&quot;zhangsan&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 正在学 Python</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>&quot;zhangsan&quot;</code>这个字符串传给了<code>info()</code>方法的<code>self</code>参数。显然，无论是<code>info()</code>方法中使用<code>self</code>参数调用其它类方法，还是使用<code>self</code>参数定义新的实例变量，胡乱的给<code>self</code>参数传参都将会导致程序运行崩溃。</p>
<p>总的来说，Python 中允许使用类名直接调用实例方法，但必须手动为该方法的第一个<code>self</code>参数传递参数，这种调用方法的方式被称为“非绑定方法”。</p>
<p>用类的实例对象访问类成员的方式称为绑定方法，而用类名调用类成员的方式称为非绑定方法。</p>
<h1 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h1><p>通过使用描述符，可以让程序员在引用一个对象属性时自定义要完成的工作。</p>
<p>本质上看，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。</p>
<p>描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 property、方法、类方法、静态方法和<code>super</code>类型。</p>
<p>描述符类基于以下 3 个特殊方法，换句话说，这 3 个方法组成了描述符协议：</p>
<ul>
<li><code>__set__(self, obj, type=None)</code>：在设置属性时将调用这一方法；</li>
<li><code>__get__(self, obj, value)</code>：在读取属性时将调用这一方法；</li>
<li><code>__delete__(self, obj)</code>：对属性调用<code>del</code>时将调用这一方法。</li>
</ul>
<p>其中，实现了<code>setter</code>和<code>getter</code>方法的描述符类被称为数据描述符；反之，如果只实现了<code>getter</code>方法，则称为非数据描述符。</p>
<p>实际上，在每次查找属性时，描述符协议中的方法都由类对象的特殊方法<code>__getattribute__()</code>调用（注意不要和<code>__getattr__()</code>弄混）。也就是说，每次使用类对象.属性（或者<code>getattr(类对象，属性值)</code>）的调用方式时，都会隐式地调用<code>__getattribute__()</code>，它会按照下列顺序查找该属性：</p>
<ul>
<li>验证该属性是否为类实例对象的数据描述符；</li>
<li>如果不是，就查看该属性是否能在类实例对象的<code>__dict__</code>中找到；</li>
<li>最后，查看该属性是否为类实例对象的非数据描述符。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#描述符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">revealAccess</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initval = <span class="literal">None</span>, name = <span class="string">&#x27;var&#x27;</span></span>):</span><br><span class="line">    self.val = initval</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, objtype</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Retrieving&quot;</span>,self.name)</span><br><span class="line">    <span class="keyword">return</span> self.val</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, val</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;updating&quot;</span>,self.name)</span><br><span class="line">    self.val = val</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span>:</span><br><span class="line">  x = revealAccess(<span class="number">10</span>,<span class="string">&#x27;var &quot;x&quot;&#x27;</span>)</span><br><span class="line">  y = <span class="number">5</span></span><br><span class="line">m = myClass()</span><br><span class="line"><span class="built_in">print</span>(m.x)</span><br><span class="line">m.x = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(m.x)</span><br><span class="line"><span class="built_in">print</span>(m.y)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrieving var &quot;x&quot;</span><br><span class="line">10</span><br><span class="line">updating var &quot;x&quot;</span><br><span class="line">Retrieving var &quot;x&quot;</span><br><span class="line">20</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>从这个例子可以看到，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的<code>__get__()</code>方法，并返回它的值；同样，每次在对该属性赋值时，也会调用<code>__set__()</code>方法。</p>
<p>注意，虽然上面例子中没有使用<code>__del__()</code>方法，但也很容易理解，当每次使用<code>del</code>类对象.属性（或者 delattr(类对象，属性)）语句时，都会调用该方法。</p>
<h1 id="property-函数"><a href="#property-函数" class="headerlink" title="property()函数"></a>property()函数</h1><p>我们一直在用“类对象.属性”的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。正常情况下，类包含的属性应该是隐藏的，只允许通过类提供的方法来间接实现对类属性的访问和操作。</p>
<p>因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个<code>getter</code>（或<code>setter</code>）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#构造函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name </span><br><span class="line">  <span class="comment">#设置 name 属性值的函数 </span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="comment">#访问nema属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.name</span><br><span class="line">  <span class="comment">#删除name属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">delname</span>(<span class="params">self</span>):</span><br><span class="line">    self.name=<span class="string">&quot;xxx&quot;</span></span><br><span class="line">clang = CLanguage(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="comment">#获取name属性值</span></span><br><span class="line"><span class="built_in">print</span>(clang.getname()) <span class="comment"># 小明</span></span><br><span class="line"><span class="comment">#设置name属性值</span></span><br><span class="line">clang.setname(<span class="string">&quot;Python教程&quot;</span>) <span class="comment"># Python教程</span></span><br><span class="line"><span class="built_in">print</span>(clang.getname())</span><br><span class="line"><span class="comment">#删除name属性值</span></span><br><span class="line">clang.delname()</span><br><span class="line"><span class="built_in">print</span>(clang.getname()) <span class="comment"># xxx</span></span><br></pre></td></tr></table></figure>
<p>Python 中提供了<code>property()</code>函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性名=property(fget=None, fset=None, fdel=None, doc=None)</span><br></pre></td></tr></table></figure>
<p>其中，<code>fget</code>参数用于指定获取该属性值的类方法，<code>fset</code>参数用于指定设置该属性值的方法，<code>fdel</code>参数用于指定删除该属性值的方法，最后的<code>doc</code>是一个文档字符串，用于说明此函数的作用。</p>
<p>注意，在使用<code>property()</code>函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，<code>property()</code>函数中参数的指定并不是完全随意的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#构造函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n</span>):</span><br><span class="line">    self.__name = n</span><br><span class="line">  <span class="comment">#设置 name 属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self,n</span>):</span><br><span class="line">    self.__name = n</span><br><span class="line">  <span class="comment">#访问nema属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__name</span><br><span class="line">  <span class="comment">#删除name属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">delname</span>(<span class="params">self</span>):</span><br><span class="line">    self.__name=<span class="string">&quot;xxx&quot;</span></span><br><span class="line">  <span class="comment">#为name 属性配置 property() 函数</span></span><br><span class="line">  name = <span class="built_in">property</span>(getname, setname, delname, <span class="string">&#x27;指明出处&#x27;</span>)</span><br><span class="line"><span class="comment">#调取说明文档的 2 种方式</span></span><br><span class="line"><span class="comment">#print(CLanguage.name.__doc__)</span></span><br><span class="line"><span class="built_in">help</span>(CLanguage.name)</span><br><span class="line">clang = CLanguage(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="comment">#调用 getname() 方法</span></span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br><span class="line"><span class="comment">#调用 setname() 方法</span></span><br><span class="line">clang.name=<span class="string">&quot;Python教程&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br><span class="line"><span class="comment">#调用 delname() 方法</span></span><br><span class="line"><span class="keyword">del</span> clang.name</span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Help on property:</span><br><span class="line"></span><br><span class="line">    指明出处</span><br><span class="line"></span><br><span class="line">小明</span><br><span class="line">Python教程</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>
<p>注意，在此程序中，由于<code>getname()</code>方法中需要返回<code>name</code>属性，如果使用<code>self.name</code>的话，其本身又被调用<code>getname()</code>，这将会先入无限死循环。为了避免这种情况的出现，程序中的<code>name</code>属性必须设置为私有属性，即使用<code>__name</code>（前面有 2 个下划线）。</p>
<p>当然，<code>property()</code>函数也可以少传入几个参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">property</span>(getname, setname)</span><br></pre></td></tr></table></figure>
<p>这意味着，<code>name</code>是一个可读写的属性，但不能删除，因为<code>property()</code>函数中并没有为<code>name</code>配置用于函数该属性的方法。也就是说，即便<code>CLanguage</code>类中设计有<code>delname()</code>函数，这种情况下也不能用来删除<code>name</code>属性。 </p>
<p>同理，还可以像如下这样使用<code>property()</code>函数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">property</span>(getname) <span class="comment"># name 属性可读，不可写，也不能删除</span></span><br><span class="line">name = <span class="built_in">property</span>(getname, setname,delname) <span class="comment"># name属性可读、可写、也可删除，就是没有说明文档</span></span><br></pre></td></tr></table></figure>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>简单的理解封装，即在设计类时，刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以“类对象.属性名”（或者“类对象.方法名(参数)”）的形式调用这些属性（或方法），而只能用未隐藏的类方法间接操作这些隐藏的属性和方法。</p>
<p>封装机制保证了类内部数据结构的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。</p>
<p>除此之外，对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，我们只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松实现用户对类中属性或方法的不合理操作。</p>
<h2 id="Python-类如何进行封装"><a href="#Python-类如何进行封装" class="headerlink" title="Python 类如何进行封装"></a>Python 类如何进行封装</h2><p>Python 类中的变量和函数，不是公有的（类似<code>public</code>属性），就是私有的（类似<code>private</code>）。</p>
<p>但是，Python 并没有提供<code>public、private</code>这些修饰符。为了实现类的封装，Python 采取了下面的方法：</p>
<ul>
<li>默认情况下，Python 类中的变量和方法都是公有的，它们的名称前都没有下划线（<code>_</code>）；</li>
<li>如果类中的变量和函数，其名称以双下划线<code>__</code>开头，则该变量（函数）为私有变量（私有函数）。</li>
</ul>
<p>除此之外，还可以定义以单下划线<code>_</code>开头的类属性或者类方法（例如<code>_name、_display(self)</code>），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法。</p>
<blockquote>
<p>注意，Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数<code>__init__(self)</code>），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) &lt; <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&#x27;名称长度必须大于1！&#x27;</span>)</span><br><span class="line">    self.__name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__name</span><br><span class="line">  <span class="comment">#为 name 配置 setter 和 getter 方法</span></span><br><span class="line">  name = <span class="built_in">property</span>(getname, setname)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setadd</span>(<span class="params">self, add</span>):</span><br><span class="line">    <span class="keyword">if</span> add.startswith(<span class="string">&quot;http://&quot;</span>):</span><br><span class="line">      self.__add = add</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&#x27;地址必须以 http:// 开头&#x27;</span>) </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getadd</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__add</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#为 add 配置 setter 和 getter 方法</span></span><br><span class="line">  add = <span class="built_in">property</span>(getadd, setadd)</span><br><span class="line">  <span class="comment">#定义个私有方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self.__name,self.__add)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = <span class="string">&quot;百度&quot;</span></span><br><span class="line">clang.add = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 百度</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># http://www.baidu.com</span></span><br></pre></td></tr></table></figure>
<p>上面程序中，<code>CLanguage</code>将<code>name</code>和<code>add</code>属性都隐藏了起来，但同时也提供了可操作它们的“窗口”，也就是各自的<code>setter</code>和<code>getter</code>方法，这些方法都是公有的。</p>
<p>不仅如此，以<code>add</code>属性的<code>setadd()</code>方法为例，通过在该方法内部添加控制逻辑，即通过调用<code>startswith()</code>方法，控制用户输入的地址必须以<code>http://</code>开头，否则程序将会执行<code>raise</code>语句抛出<code>ValueError</code>异常。</p>
<p>通过此程序的运行逻辑不难看出，通过对<code>CLanguage</code>类进行良好的封装，使得用户仅能通过暴露的<code>setter()</code>和<code>getter()</code>方法操作<code>name</code>和<code>add</code>属性，而通过对<code>setname()</code>和<code>setadd()</code>方法进行适当的设计，可以避免用户对类中属性的不合理操作，从而提高了类的可维护性和安全性。</p>
<p><code>CLanguage</code>类中还有一个<code>__display()</code>方法，由于该类方法为私有（<code>private</code>）方法，且该类没有提供操作该私有方法的“窗口”，因此我们无法在类的外部使用它。换句话说，如下调用<code>__display()</code>方法是不可行的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#尝试调用私有的 display() 方法</span></span><br><span class="line">clang.__display()</span><br></pre></td></tr></table></figure>
<p>这会导致如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\1.py&quot;, line 33, in &lt;module&gt;</span><br><span class="line">    clang.__display()</span><br><span class="line">AttributeError: &#x27;CLanguage&#x27; object has no attribute &#x27;__display&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用。</p>
<p>举个例子，假设现有一个<code>Shape</code>类，该类的<code>draw()</code>方法可以在屏幕上画出指定的形状，现在需要创建一个<code>Form</code>类，要求此类不但可以在屏幕上画出指定的形状，还可以计算出所画形状的面积。要创建这样的类，笨方法是将<code>draw()</code>方法直接复制到新类中，并添加计算面积的方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;画&quot;</span>,content)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;画&quot;</span>,content)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#....</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;此图形的面积为...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当然还有更简单的方法，就是使用类的继承机制。实现方法为：让<code>Form</code>类继承<code>Shape</code>类，这样当<code>Form</code>类对象调用<code>draw()</code>方法时，Python 解释器会先去 Form 中找以<code>draw</code>为名的方法，如果找不到，它还会自动去<code>Shape</code>类中找。如此，我们只需在<code>Form</code>类中添加计算面积的方法即可：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;画&quot;</span>,content)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#....</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;此图形的面积为...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>class Form(Shape)</code>就表示<code>Form</code>继承<code>Shape</code>。</p>
<p>Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。因此在上面这个样例中，<code>Form</code>是子类，<code>Shape</code>是父类。</p>
<p>子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>, 父类<span class="number">2</span>, ...)：</span><br><span class="line">  <span class="comment">#类定义部分</span></span><br></pre></td></tr></table></figure>
<p>注意，如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即一个子类可以同时拥有多个直接父类。</p>
<p>“派生”和继承是一个意思，只是观察角度不同而已。换句话说，继承是相对子类来说的，即子类继承自父类；而派生是相对于父类来说的，即父类派生出子类。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是一个人，名字是：&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;人也是高级动物&quot;</span>)</span><br><span class="line"><span class="comment">#同时继承 People 和 Animal 类</span></span><br><span class="line"><span class="comment">#其同时拥有 name 属性、say() 和 display() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">zhangsan.say()</span><br><span class="line">zhangsan.display()</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是一个人，名字是： 张三</span><br><span class="line">人也是高级动物</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然 Person 类为空类，但由于其继承自 People 和 Animal 这 2 个类，因此实际上 Person 并不空，它同时拥有这 2 个类所有的属性和方法。<br>没错，子类拥有父类所有的属性和方法，即便该属性或方法是私有（private）的。</p>
<h2 id="关于Python的多继承"><a href="#关于Python的多继承" class="headerlink" title="关于Python的多继承"></a>关于Python的多继承</h2><p>事实上，大部分面向对象的编程语言，都只支持单继承，即子类有且只能有一个父类。而 Python 却支持多继承（C++也支持多继承）。<br>和单继承相比，多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承。</p>
<p>使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = People</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;People类&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = Animal</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Animal类&quot;</span>,self.name)</span><br><span class="line"><span class="comment">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">zhangsan.say()</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People类 张三</span><br></pre></td></tr></table></figure>
<p>可以看到，当<code>Person</code>同时继承<code>People</code>类和<code>Animal</code>类时，<code>People</code>类在前，因此如果<code>People</code>和<code>Animal</code>拥有同名的类方法，实际调用的是<code>People</code>类中的。</p>
<h1 id="父类方法重写"><a href="#父类方法重写" class="headerlink" title="父类方法重写"></a>父类方法重写</h1><p>在 Python 中，子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。</p>
<p>但凡事都有例外，我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。</p>
<p>举个例子，鸟通常是有翅膀的，也会飞，因此我们可以像如下这样定义个和鸟相关的类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">  <span class="comment">#鸟有翅膀</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isWing</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟有翅膀&quot;</span>)</span><br><span class="line">  <span class="comment">#鸟会飞</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟会飞&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>但是，对于鸵鸟来说，它虽然也属于鸟类，也有翅膀，但是它只会奔跑，并不会飞。针对这种情况，可以这样定义鸵鸟类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">  <span class="comment"># 重写Bird类的fly()方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸵鸟不会飞&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，因为<code>Ostrich</code>继承自<code>Bird</code>，因此<code>Ostrich</code>类拥有<code>Bird</code>类的<code>isWing()</code>和<code>fly()</code>方法。其中，<code>isWing()</code>方法同样适合<code>Ostrich</code>，但<code>fly()</code>明显不适合，因此我们在<code>Ostrich</code>类中对<code>fly()</code>方法进行重写。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">  <span class="comment">#鸟有翅膀</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isWing</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟有翅膀&quot;</span>)</span><br><span class="line">  <span class="comment">#鸟会飞</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟会飞&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">  <span class="comment"># 重写Bird类的fly()方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸵鸟不会飞&quot;</span>)</span><br><span class="line"><span class="comment"># 创建Ostrich对象</span></span><br><span class="line">ostrich = Ostrich()</span><br><span class="line"><span class="comment">#调用 Ostrich 类中重写的 fly() 类方法</span></span><br><span class="line">ostrich.fly()</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鸵鸟不会飞</span><br></pre></td></tr></table></figure>
<p>显然，<code>ostrich</code>调用的是重写之后的<code>fly()</code>类方法。</p>
<h2 id="如何调用被重写的方法"><a href="#如何调用被重写的方法" class="headerlink" title="如何调用被重写的方法"></a>如何调用被重写的方法</h2><p>事实上，如果我们在子类中重写了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。</p>
<p>这就产生一个新的问题，即如果想调用父类中被重写的这个方法，该怎么办呢？</p>
<p>Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间中，调用类空间中的函数，只需要在调用该函数时备注类名即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">  <span class="comment">#鸟有翅膀</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isWing</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟有翅膀&quot;</span>)</span><br><span class="line">  <span class="comment">#鸟会飞</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟会飞&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">  <span class="comment"># 重写Bird类的fly()方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸵鸟不会飞&quot;</span>)</span><br><span class="line"><span class="comment"># 创建Ostrich对象</span></span><br><span class="line">ostrich = Ostrich()</span><br><span class="line"><span class="comment">#调用 Bird 类中的 fly() 方法</span></span><br><span class="line">Bird.fly(ostrich)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鸟会飞</span><br></pre></td></tr></table></figure>
<p>此程序中，需要大家注意的一点是，使用类名调用其类方法，Python 不会为该方法的第一个<code>self</code>参数自定绑定值，因此采用这种调用方法，需要手动为<code>self</code>参数赋值。</p>
<p>通过类名调用实例方法的这种方式，又被称为未绑定方法。</p>
<h1 id="super-函数"><a href="#super-函数" class="headerlink" title="super()函数"></a>super()函数</h1><p>Python 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。</p>
<p>但我们知道，Python 支持多继承，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法。显然，构造方法也是如此。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是人，名字为：&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,food</span>):</span><br><span class="line">    self.food = food</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是动物,我吃&quot;</span>,self.food)</span><br><span class="line"><span class="comment">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">per = Person(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">per.say()</span><br><span class="line"><span class="comment">#per.display()</span></span><br></pre></td></tr></table></figure>
<p>运行结果，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是人，名字为： zhangsan</span><br></pre></td></tr></table></figure>
<p>上面程序中，Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 per 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 per 对象的同时，还要给 name 属性进行赋值。</p>
<p>但如果去掉最后一行的注释，运行此行代码，Python 解释器会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\Demo.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    per.display()</span><br><span class="line">  File &quot;D:\python3.6\Demo.py&quot;, line 11, in display</span><br><span class="line">    print(&quot;我是动物,我吃&quot;,self.food)</span><br><span class="line">AttributeError: &#x27;Person&#x27; object has no attribute &#x27;food&#x27;</span><br></pre></td></tr></table></figure>
<p>这是因为，从 Animal 类中继承的 display() 方法中，需要用到 food 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 per 对象时，Animal 类的构造方法未得到执行，所以程序出错。</p>
<p>反过来也是如此，如果将第 13 行代码改为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(Animal, People)</span><br></pre></td></tr></table></figure>
<p>则在创建 per 对象时，会给 food 属性传值。这意味着，per.display() 能顺序执行，但 per.say() 将会报错。</p>
<p>针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。但需要注意，如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。</p>
<p>在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：</p>
<ul>
<li>类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；</li>
<li>使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。</li>
</ul>
<p>也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种，而调用其它父类构造方法的方式只能使用未绑定方法。</p>
<p>在 Python 3.x 中，<code>super()</code>函数的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super().__init__(...)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是人，名字为：&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,food</span>):</span><br><span class="line">    self.food = food</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是动物,我吃&quot;</span>,self.food)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="comment">#自定义构造方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,food</span>):</span><br><span class="line">    <span class="comment">#调用 People 类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(name)</span><br><span class="line">    <span class="comment">#super(Person,self).__init__(name) #执行效果和上一行相同</span></span><br><span class="line">    <span class="comment">#People.__init__(self,name)#使用未绑定方法调用 People 类构造方法</span></span><br><span class="line">    <span class="comment">#调用其它父类的构造方法，需手动给 self 传值</span></span><br><span class="line">    Animal.__init__(self,food)    </span><br><span class="line">per = Person(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;熟食&quot;</span>)</span><br><span class="line">per.say() <span class="comment"># 我是人，名字为： zhangsan</span></span><br><span class="line">per.display() <span class="comment"># 我是动物,我吃 熟食</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Person</code>类自定义的构造方法中，调用<code>People</code>类构造方法，可以使用<code>super()</code>函数，也可以使用未绑定方法。但是调用<code>Animal</code>类的构造方法，只能使用未绑定方法。</p>
<h1 id="slots-：限制类实例动态添加属性和方法"><a href="#slots-：限制类实例动态添加属性和方法" class="headerlink" title="__slots__：限制类实例动态添加属性和方法"></a>__slots__：限制类实例动态添加属性和方法</h1><p>了解了如何动态的为单个实例对象添加属性，甚至如果必要的话，还可以为所有的类实例对象统一添加属性（通过给类添加属性）。</p>
<p>那么，Python 是否也允许动态地为类或实例对象添加方法呢？答案是肯定的。我们知道，类方法又可细分为实例方法、静态方法和类方法，Python 语言允许为类动态地添加这 3 种方法；但对于实例对象，则只允许动态地添加实例方法，不能添加类方法和静态方法。</p>
<p>为单个实例对象添加方法，不会影响该类的其它实例对象；而如果为类动态地添加方法，则所有的实例对象都可以使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#下面定义了一个实例方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>)</span><br><span class="line"><span class="comment">#下面定义了一个类方法</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info2</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用类方法&quot;</span>)</span><br><span class="line"><span class="comment">#下面定义个静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info3</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用静态方法&quot;</span>)</span><br><span class="line"><span class="comment">#类可以动态添加以上 3 种方法，会影响所有实例对象</span></span><br><span class="line">CLanguage.info = info</span><br><span class="line">CLanguage.info2 = info2</span><br><span class="line">CLanguage.info3 = info3</span><br><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#如今，clang 具有以上 3 种方法</span></span><br><span class="line">clang.info()</span><br><span class="line">clang.info2()</span><br><span class="line">clang.info3()</span><br><span class="line"><span class="comment">#类实例对象只能动态添加实例方法，不会影响其它实例对象</span></span><br><span class="line">clang1 = CLanguage()</span><br><span class="line">clang1.info = info</span><br><span class="line"><span class="comment">#必须手动为 self 传值</span></span><br><span class="line">clang1.info(clang1)</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：<br>正在调用实例方法<br>正在调用类方法<br>正在调用静态方法<br>正在调用实例方法</p>
<p>显然，动态给类或者实例对象添加属性或方法，是非常灵活的。但与此同时，如果胡乱地使用，也会给程序带来一定的隐患，即程序中已经定义好的类，如果不做任何限制，是可以做动态的修改的。</p>
<p>庆幸的是，Python 提供了<code>__slots__</code>属性，通过它可以避免用户频繁的给实例对象动态地添加属性或方法。</p>
<p>再次声明，<code>__slots__</code>只能限制为实例对象动态添加属性和方法，而无法限制动态地为类添加属性和方法。</p>
<p><code>__slots__</code>属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    __slots__ = (&#x27;name&#x27;,&#x27;add&#x27;,&#x27;info&#x27;)</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>CLanguage</code>类中指定了<code>__slots__</code>属性，这意味着，该类的实例对象仅限于动态添加<code>name、add、info</code>这 3 个属性以及<code>name()、add()</code>和<code>info()</code>这 3 个方法。</p>
<p>注意，对于动态添加的方法，<code>__slots__</code>限制的是其方法名，并不限制参数的个数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self,name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>,self.name)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="comment">#为 clang 对象动态添加 info 实例方法</span></span><br><span class="line">clang.info = info</span><br><span class="line">clang.info(clang,<span class="string">&quot;Python教程&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在调用实例方法 小明</span><br></pre></td></tr></table></figure>
<p>还是在<code>CLanguage</code>类的基础上，添加如下代码并运行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self,name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>,self.name)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">clang.say = info</span><br><span class="line">clang.say(clang,<span class="string">&quot;Python教程&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行程序，显示如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\1.py&quot;, line 9, in &lt;module&gt;</span><br><span class="line">    clang.say = info</span><br><span class="line">AttributeError: &#x27;CLanguage&#x27; object has no attribute &#x27;say&#x27;</span><br></pre></td></tr></table></figure>
<p>显然，根据<code>__slots__</code>属性的设置，<code>CLanguage</code>类的实例对象是不能动态添加以 say 为名称的方法的。</p>
<p><code>__slots__</code>属性限制的对象是类的实例对象，而不是类，因此下面的代码是合法的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>)</span><br><span class="line">CLanguage.say = info</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.say()</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在调用实例方法</span><br></pre></td></tr></table></figure>
<p>当然，还可以为类动态添加类方法和静态方法，这里不再给出具体实例，读者可自行编写代码尝试。</p>
<p>此外，<code>__slots__</code>属性对由该类派生出来的子类，也是不起作用的。例如如下代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  __slots__ = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line"><span class="comment">#Clanguage 的空子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLangs</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#定义的实例方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>)</span><br><span class="line">clang = CLangs()</span><br><span class="line"><span class="comment">#为子类对象动态添加 say() 方法</span></span><br><span class="line">clang.say = info</span><br><span class="line">clang.say(clang)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在调用实例方法</span><br></pre></td></tr></table></figure>
<p>显然，<code>__slots__</code>属性只对当前所在的类起限制作用。</p>
<p>因此，如果子类也要限制外界为其实例对象动态地添加属性和方法，必须在子类中设置<code>__slots__</code>属性。</p>
<p>注意，如果为子类也设置有<code>__slots__</code>属性，那么子类实例对象允许动态添加的属性和方法，是子类中<code>__slots__</code>属性和父类<code>__slots__</code>属性的和。</p>
<h1 id="type-函数：动态创建类"><a href="#type-函数：动态创建类" class="headerlink" title="type()函数：动态创建类"></a>type()函数：动态创建类</h1><p>我们知道，<code>type()</code>函数属于 Python 内置函数，通常用来查看某个变量的具体类型。其实，<code>type()</code>函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。</p>
<p>type() 函数的语法格式有 2 种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type(obj) </span><br><span class="line">type(name, bases, dict)</span><br></pre></td></tr></table></figure>
<p>以上这 2 种语法格式，各参数的含义及功能分别是：</p>
<ul>
<li>第一种语法格式用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。</li>
<li>第二种语法格式用来创建类，其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看 3.4 的类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">3.4</span>))</span><br><span class="line"><span class="comment">#查看类对象的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(clangs))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&lt;class &#x27;__main__.CLanguage&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p><code>type()</code>函数的另一种用法，即创建一个新类，先来分析一个样例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个实例方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我要学 Python！&quot;</span>)</span><br><span class="line"><span class="comment">#使用 type() 函数创建类</span></span><br><span class="line">CLanguage = <span class="built_in">type</span>(<span class="string">&quot;CLanguage&quot;</span>,(<span class="built_in">object</span>,),<span class="built_in">dict</span>(say = say, name = <span class="string">&quot;C语言中文网&quot;</span>))</span><br><span class="line"><span class="comment">#创建一个 CLanguage 实例对象</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="comment">#调用 say() 方法和 name 属性</span></span><br><span class="line">clangs.say()</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br></pre></td></tr></table></figure>
<p>注意，Python 元组语法规定，当<code>(object,)</code>元组中只有一个元素时，最后的逗号（,）不能省略。</p>
<p>可以看到，此程序中通过<code>type()</code>创建了类，其类名为<code>CLanguage</code>，继承自<code>objects</code>类，且该类中还包含一个<code>say()</code>方法和一个<code>name</code>属性。</p>
<p>运行上面的程序，其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我要学 Python！</span><br><span class="line">C语言中文网</span><br></pre></td></tr></table></figure>
<p>可以看到，使用<code>type()</code>函数创建的类，和直接使用<code>class</code>定义的类并无差别。事实上，我们在使用<code>class</code>定义类时，Python 解释器底层依然是用<code>type()</code>来创建这个类。</p>
<h1 id="MetaClass元类"><a href="#MetaClass元类" class="headerlink" title="MetaClass元类"></a>MetaClass元类</h1><p><code>MetaClass</code>元类，本质也是一个类，但和普通类的用法不同，它可以对类内部的定义（包括类属性和类方法）进行动态的修改。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。</p>
<p>不要从字面上去理解元类的含义，事实上<code>MetaClass</code>中的<code>Meta</code>这个词根，起源于希腊语词汇 meta，包含“超越”和“改变”的意思。</p>
<p>举个例子，根据实际场景的需要，我们要为多个类添加一个 name 属性和一个 say() 方法。显然有多种方法可以实现，但其中一种方法就是使用 MetaClass 元类。</p>
<p>如果在创建类时，想用<code>MetaClass</code>元类动态地修改内部的属性或者方法，则类的创建过程将变得复杂：先创建 MetaClass 元类，然后用元类去创建类，最后使用该类的实例化对象实现功能。</p>
<p>如果想把一个类设计成<code>MetaClass</code>元类，其必须符合以下条件：</p>
<ul>
<li>必须显式继承自<code>type</code>类；</li>
<li>类中需要定义并实现<code>__new__()</code>方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该<code>__new__()</code>方法会自动被执行，用来修改新建的类。</li>
</ul>
<p>我们先尝试定义一个<code>MetaClass</code>元类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="comment"># cls代表动态修改的类</span></span><br><span class="line">    <span class="comment"># name代表动态修改的类名</span></span><br><span class="line">    <span class="comment"># bases代表被动态修改的类的所有父类</span></span><br><span class="line">    <span class="comment"># attr代表被动态修改的类的所有属性、方法组成的字典</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="comment"># 动态为该类添加一个name属性</span></span><br><span class="line">        attrs[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;C语言中文网&quot;</span></span><br><span class="line">        attrs[<span class="string">&#x27;say&#x27;</span>] = <span class="keyword">lambda</span> self: <span class="built_in">print</span>(<span class="string">&quot;调用 say() 实例方法&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,name,bases,attrs)</span><br></pre></td></tr></table></figure>
<p>此程序中，首先可以断定 FirstMetaClass 是一个类。其次，由于该类继承自 type 类，并且内部实现了 <strong>new</strong>() 方法，因此可以断定 FirstMetaCLass 是一个元类。</p>
<p>可以看到，在这个元类的<code>__new__()</code>方法中，手动添加了一个 name 属性和 say() 方法。这意味着，通过 FirstMetaClass 元类创建的类，会额外添加 name 属性和 say() 方法。通过如下代码，可以验证这个结论：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义类时，指定元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>(<span class="built_in">object</span>,metaclass=FirstMetaClass):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br><span class="line">clangs.say()</span><br></pre></td></tr></table></figure>
<p>可以看到，在创建类时，通过在标注父类的同时指定元类（格式为metaclass&#x3D;元类名），则当 Python 解释器在创建这该类时，FirstMetaClass 元类中的 <strong>new</strong> 方法就会被调用，从而实现动态修改类属性或者类方法的目的。</p>
<p>运行上面的程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网</span><br><span class="line">调用 say() 实例方法</span><br></pre></td></tr></table></figure>
<p>显然，<code>FirstMetaClass</code>元类的<code>__new__()</code>方法动态地为<code>Clanguage</code>类添加了<code>name</code>属性和<code>say()</code>方法，因此，即便该类在定义时是空类，它也依然有<code>name</code>属性和<code>say()</code>方法。</p>
<p>对于<code>MetaClass</code>元类，它多用于创建 API，因此我们几乎不会使用到它。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>我们都知道，Python 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赋值的是 CLanguage 类的实例对象&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPython</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赋值的是 CPython 类的实例对象&quot;</span>)</span><br><span class="line">a = CLanguage()</span><br><span class="line">a.say()</span><br><span class="line">a = CPython()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">赋值的是 CLanguage 类的实例对象</span><br><span class="line">赋值的是 CPython 类的实例对象</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>a</code>可以被先后赋值为<code>CLanguage</code>类和<code>CPython</code>类的对象，但这并不是多态。类的多态特性，还要满足以下 2 个前提条件：</p>
<ul>
<li>继承：多态一定是发生在子类和父类之间；</li>
<li>重写：子类重写了父类的方法。</li>
</ul>
<p>下面程序是对上面代码的改写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 Clanguage 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPython</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CPython 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLinux</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CLinux 类的say方法&quot;</span>)</span><br><span class="line">a = CLanguage()</span><br><span class="line">a.say()</span><br><span class="line">a = CPython()</span><br><span class="line">a.say()</span><br><span class="line">a = CLinux()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用的是 Clanguage 类的say方法</span><br><span class="line">调用的是 CPython 类的say方法</span><br><span class="line">调用的是 CLinux 类的say方法</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>CPython</code>和<code>CLinux</code>都继承自<code>CLanguage</code>类，且各自都重写了父类的<code>say()</code>方法。从运行结果可以看出，同一变量<code>a</code>在执行同一个<code>say()</code>方法时，由于<code>a</code>实际表示不同的类实例对象，因此<code>a.say()</code>调用的并不是同一个类中的<code>say()</code>方法，这就是多态。</p>
<p>其实，Python 在多态的基础上，衍生出了一种更灵活的编程机制。继续对上面的程序进行改写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WhoSay</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self,who</span>):</span><br><span class="line">    who.say()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 Clanguage 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPython</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CPython 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLinux</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CLinux 类的say方法&quot;</span>)</span><br><span class="line">a = WhoSay()</span><br><span class="line"><span class="comment">#调用 CLanguage 类的 say() 方法</span></span><br><span class="line">a.say(CLanguage())</span><br><span class="line"><span class="comment">#调用 CPython 类的 say() 方法</span></span><br><span class="line">a.say(CPython())</span><br><span class="line"><span class="comment">#调用 CLinux 类的 say() 方法</span></span><br><span class="line">a.say(CLinux())</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用的是 Clanguage 类的say方法</span><br><span class="line">调用的是 CPython 类的say方法</span><br><span class="line">调用的是 CLinux 类的say方法</span><br></pre></td></tr></table></figure>
<p>此程序中，通过给<code>WhoSay</code>类中的<code>say()</code>函数添加一个<code>who</code>参数，其内部利用传入的<code>who</code>调用<code>say()</code>方法。这意味着，当调用<code>WhoSay</code>类中的<code>say()</code>方法时，我们传给<code>who</code>参数的是哪个类的实例对象，它就会调用那个类中的<code>say()</code>方法。</p>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个。对于这些实例化对象个数固定的类，可以用枚举类来定义。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">  <span class="comment"># 为序列值指定value值</span></span><br><span class="line">  red = <span class="number">1</span></span><br><span class="line">  green = <span class="number">2</span></span><br><span class="line">  blue = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>如果想将一个类定义为枚举类，只需要令其继承自<code>enum</code>模块中的<code>Enum</code>类即可。例如在上面程序中，<code>Color</code>类继承自<code>Enum</code>类，则证明这是一个枚举类。</p>
<p>在<code>Color</code>枚举类中，<code>red、green、blue</code>都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为<code>name</code>和<code>value</code>，其中<code>name</code>属性值为该枚举值的变量名（如<code>red</code>），<code>value</code>代表该枚举值的序号（序号通常从 1 开始）。</p>
<p>和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调用枚举成员的 3 种方式</span></span><br><span class="line"><span class="built_in">print</span>(Color.red)</span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;red&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(Color(<span class="number">1</span>))</span><br><span class="line"><span class="comment">#调取枚举成员中的 value 和 name</span></span><br><span class="line"><span class="built_in">print</span>(Color.red.value)</span><br><span class="line"><span class="built_in">print</span>(Color.red.name)</span><br><span class="line"><span class="comment">#遍历枚举类中所有成员的 2 种方式</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> Color:</span><br><span class="line">  <span class="built_in">print</span>(color)</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">1</span><br><span class="line">red</span><br><span class="line">Color.red</span><br><span class="line">Color.green</span><br><span class="line">Color.blue</span><br></pre></td></tr></table></figure>
<p>枚举类成员之间不能比较大小，但可以用<code>==</code>或者<code>is</code>进行比较是否相等：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Color.red == Color.green) <span class="comment"># Flase</span></span><br><span class="line"><span class="built_in">print</span>(Color.red.name <span class="keyword">is</span> Color.green.name) <span class="comment"># Flase</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.red = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>除此之外，该枚举类还提供了一个<code>__members__</code>属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,member <span class="keyword">in</span> Color.__members__.items():</span><br><span class="line">  <span class="built_in">print</span>(name,<span class="string">&quot;-&gt;&quot;</span>,member)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red -&gt; Color.red</span><br><span class="line">green -&gt; Color.green</span><br><span class="line">blue -&gt; Color.blue</span><br></pre></td></tr></table></figure>
<p>值得一提的是，Python 枚举类中各个成员必须保证<code>name</code>互不相同，但<code>value</code>可以相同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">  <span class="comment"># 为序列值指定value值</span></span><br><span class="line">  red = <span class="number">1</span></span><br><span class="line">  green = <span class="number">1</span></span><br><span class="line">  blue = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;green&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.red</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Color</code>枚举类中<code>red</code>和<code>green</code>具有相同的值（都是 1），Python 允许这种情况的发生，它会将<code>green</code>当做是<code>red</code>的别名，因此当访问<code>green</code>成员时，最终输出的是<code>red</code>。</p>
<p>在实际编程过程中，如果想避免发生这种情况，可以借助<code>@unique</code>装饰器，这样当枚举类中出现相同值的成员时，程序会报<code>ValueError</code>错误。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入 unique</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum,unique</span><br><span class="line"><span class="comment">#添加 unique 装饰器</span></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">  <span class="comment"># 为序列值指定value值</span></span><br><span class="line">  red = <span class="number">1</span></span><br><span class="line">  green = <span class="number">1</span></span><br><span class="line">  blue = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;green&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>运行程序会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\demo.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    class Color(Enum):</span><br><span class="line">  File &quot;D:\python3.6\lib\enum.py&quot;, line 834, in unique</span><br><span class="line">    (enumeration, alias_details))</span><br><span class="line">ValueError: duplicate values found in &lt;enum &#x27;Color&#x27;&gt;: green -&gt; red</span><br></pre></td></tr></table></figure>
<p>除了通过继承<code>Enum</code>类的方法创建枚举类，还可以使用<code>Enum()</code>函数创建枚举类。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="comment">#创建一个枚举类</span></span><br><span class="line">Color = Enum(<span class="string">&quot;Color&quot;</span>,(<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>))</span><br><span class="line"><span class="comment">#调用枚举成员的 3 种方式</span></span><br><span class="line"><span class="built_in">print</span>(Color.red)</span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;red&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(Color(<span class="number">1</span>))</span><br><span class="line"><span class="comment">#调取枚举成员中的 value 和 name</span></span><br><span class="line"><span class="built_in">print</span>(Color.red.value)</span><br><span class="line"><span class="built_in">print</span>(Color.red.name)</span><br><span class="line"><span class="comment">#遍历枚举类中所有成员的 2 种方式</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> Color:</span><br><span class="line">  <span class="built_in">print</span>(color)</span><br></pre></td></tr></table></figure>
<p><code>Enum()</code>函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。</p>
<p>如上所示，仅通过一行代码，即创建了一个和前面的<code>Color</code>类相同的枚举类。运行程序，其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">1</span><br><span class="line">red</span><br><span class="line">Color.red</span><br><span class="line">Color.green</span><br><span class="line">Color.blue</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/12/15/python/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/01/09/python/Python%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            (no title)
          
        </div>
      </a>
    
    
      <a href="/2022/12/14/python/Python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title"></div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>