<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Linux 权限管理 |  学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Linux/权限管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux 权限管理
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-01-22T03:24:15.000Z" itemprop="datePublished">2022-01-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">31 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="chgrp命令：修改文件和目录的所属组"><a href="#chgrp命令：修改文件和目录的所属组" class="headerlink" title="chgrp命令：修改文件和目录的所属组"></a>chgrp命令：修改文件和目录的所属组</h1><p><code>chgrp</code>命令用于修改文件或目录的所属组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chgrp [-R] 所属组 文件名（目录名）</span></span><br></pre></td></tr></table></figure>
<p><code>-R</code>（注意是大写）选项常作用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息。</p>
<p>使用此命令需要注意的一点是，要被改变的群组名必须是真实存在的，否则命令无法正确执行，会提示<code>invaild group name</code>。</p>
<p>当以<code>root</code>身份登录 Linux 系统时，主目录中会存在一个名为<code>install.log</code>的文件，我们可以使用如下方法修改此文件的所属组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupadd group1</span></span><br><span class="line"><span class="comment">#新建用于测试的群组 group1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chgrp group1 install.log</span></span><br><span class="line"><span class="comment">#修改install.log文件的所属组为group1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll install.log</span></span><br><span class="line">-rw-r--r--. 1 root group1 78495 Nov 17 05:54 install.log</span><br><span class="line"><span class="comment">#修改生效</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chgrp testgroup install.log</span></span><br><span class="line"><span class="built_in">chgrp</span>: invaild group name <span class="string">&#x27;testgroup&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="chown命令：修改文件和目录的所有者和所属组"><a href="#chown命令：修改文件和目录的所有者和所属组" class="headerlink" title="chown命令：修改文件和目录的所有者和所属组"></a>chown命令：修改文件和目录的所有者和所属组</h1><p><code>chown</code>命令，<code>change owner</code>的缩写，主要用于修改文件或目录的所有者，也可以修改文件或目录的所属组。</p>
<p>当只需要修改所有者时，可使用如下<code>chown</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chown [-R] 所有者 文件或目录</span><br></pre></td></tr></table></figure>
<p><code>-R</code>（大写）选项表示连同子目录中的所有文件，都更改所有者。</p>
<p>如果需要同时更改所有者和所属组，<code>chown</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chown [-R] 所有者:所属组 文件或目录</span><br></pre></td></tr></table></figure>
<p>当然，<code>chown</code>命令也支持单纯的修改文件或目录的所属组，例如<code>chown:group install.log</code>就表示修改<code>install.log</code>文件的所属组，但修改所属组通常使用<code>chgrp</code>命令，因此并不推荐大家使用<code>chown</code>命令。</p>
<p>另外需要注意的一点是，使用<code>chown</code>命令修改文件或目录的所有者（或所属者）时，要保证使用者用户（或用户组）存在，否则该命令无法正确执行，会提示<code>invalid user</code>或者<code>invaild group</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch file</span></span><br><span class="line"><span class="comment">#由root用户创建file文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:12 file</span><br><span class="line"><span class="comment">#文件的所有者是root，普通用户user对这个文件拥有只读权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chown user file</span></span><br><span class="line"><span class="comment">#修改文件的所有者</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 user root 0 Apr 17 05:12 file</span><br><span class="line"><span class="comment">#所有者变成了user用户，这时user用户对这个文件就拥有了读、写权限</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过修改<code>file</code>文件的所有者，<code>user</code>用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。</p>
<p>Linux 系统中，用户等级权限的划分是非常清楚的，<code>root</code>用户拥有最高权限，可以修改任何文件的权限，而普通用户只能修改自己文件的权限（所有者是自己的文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /home/user</span></span><br><span class="line"><span class="comment">#进入user用户的家目录</span></span><br><span class="line">[root@localhost user]<span class="comment"># touch test</span></span><br><span class="line"><span class="comment">#由root用户新建文件test</span></span><br><span class="line">[root@localhost user]<span class="comment"># ll test</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:37 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#文件所有者和所属组都是root用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># su - user</span></span><br><span class="line"><span class="comment">#切换为user用户</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">chmod</span> 755 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">chmod</span>:更改<span class="string">&quot;test&quot;</span>的权限：不允许的操作 <span class="comment">#user用户不能修改test文件的权限</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment">#退回到root身份</span></span><br><span class="line">[root@localhost user]<span class="comment"># chown user test</span></span><br><span class="line"><span class="comment">#由root用户把test文件的所有者改为user用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># su - user</span></span><br><span class="line"><span class="comment">#切换为user用户</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">chmod</span> 755 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#user用户由于是test文件的所有者，所以可以修改文件的权限</span></span><br><span class="line">[user@localhost ~]$ ll <span class="built_in">test</span></span><br><span class="line">-rwxr-xr-x. 1 user root 0 Apr 17 05:37 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#查看权限</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>user</code>用户无权更改所有者为<code>root</code>用户文件的权限，只有普通用户是这个文件的所有者，才可以修改文件的权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chown user:group file</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 user group 0 Apr 17 05:12 file</span><br></pre></td></tr></table></figure>
<h1 id="权限位"><a href="#权限位" class="headerlink" title="权限位"></a>权限位</h1><p>最常见的文件权限有 3 种，即对文件的读（用<code>r</code>表示）、写（用<code>w</code>表示）和执行（用<code>x</code>表示，针对可执行文件或目录）权限。在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过<code>ls</code>命令即可看到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -al</span></span><br><span class="line">total 156</span><br><span class="line">drwxr-x---.   4    root   root     4096   Sep  8 14:06 .</span><br><span class="line">drwxr-xr-x.  23    root   root     4096   Sep  8 14:21 ..</span><br><span class="line">-rw-------.   1    root   root     1474   Sep  4 18:27 anaconda-ks.cfg</span><br><span class="line">-rw-------.   1    root   root      199   Sep  8 17:14 .bash_history</span><br><span class="line">-rw-r--r--.   1    root   root       24   Jan  6  2007 .bash_logout</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，每行的第一列表示的就是各文件针对不同用户设定的权限，一共 11 位，但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理。</p>
<p>因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符，以<code>ls</code>命令输出信息中的<code>.bash_logout</code>文件为例，设定不同用户的访问权限是<code>rw-r--r--</code>，各权限位的含义如图所示。</p>
<img src="/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/1.gif" class="" title="文件权限位">

<p>从图中可以看到，Linux 将访问文件的用户分为 3 类，分别是文件的所有者，所属组（也就是文件所属的群组）以及其他人。</p>
<p>除了所有者，以及所属群组中的用户可以访问文件外，其他用户（其他群组中的用户）也可以访问文件，这部分用户都归为其他人范畴。</p>
<p>很显然，Linux 系统为 3 种不同的用户身份，分别规定了是否对文件有读、写和执行权限。</p>
<h1 id="chmod命令：修改文件或目录的权限"><a href="#chmod命令：修改文件或目录的权限" class="headerlink" title="chmod命令：修改文件或目录的权限"></a>chmod命令：修改文件或目录的权限</h1><p><code>chmod</code>命令设定文件权限的方式有 2 种，分别可以使用数字或者符号来进行权限的变更。</p>
<h2 id="使用数字修改文件权限"><a href="#使用数字修改文件权限" class="headerlink" title="使用数字修改文件权限"></a>使用数字修改文件权限</h2><p>文件的基本权限由 9 个字符组成，以<code>rwxrw-r-x</code>为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r --&gt; 4</span><br><span class="line">w --&gt; 2</span><br><span class="line">x --&gt; 1</span><br></pre></td></tr></table></figure>
<p>由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（<code>r、w、x</code>），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</p>
<p>拿<code>rwxrw-r-x</code>来说，所有者、所属组和其他人分别对应的权限值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有者 = rwx = 4+2+1 = 7</span><br><span class="line">所属组 = rw- = 4+2 = 6</span><br><span class="line">其他人 = r-x = 4+1 = 5</span><br></pre></td></tr></table></figure>
<p>所以，此权限对应的权限值就是 765。</p>
<p>使用数字修改文件权限的<code>chmod</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chmod [-R] 权限值 文件名</span></span><br></pre></td></tr></table></figure>
<p><code>-R</code>（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p>
<p>例如，使用如下命令，即可完成对<code>.bashrc</code>目录文件的权限修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rw-r--r--. 1 root root 176 Sep 22 2004 .bashrc</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 777 .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure>
<p>通常我们以 Vim 编辑 Shell 文件批处理文件后，文件权限通常是<code>rw-rw-r--（644）</code>，那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为<code>rwxr-xr-x（755）</code>即可。</p>
<h2 id="chmod命令使用字母修改文件权限"><a href="#chmod命令使用字母修改文件权限" class="headerlink" title="chmod命令使用字母修改文件权限"></a>chmod命令使用字母修改文件权限</h2><p>既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（<code>rwx</code>），<code>chmod</code>命令中用<code>u、g、o</code>分别代表 3 种身份，还用<code>a</code>表示全部的身份（<code>all</code>的缩写）。另外，<code>chmod</code>命令仍使用<code>r、w、x</code>分别表示读、写、执行权限。</p>
<p>使用字母修改文件权限的<code>chmod</code>命令，其基本格式如图所示。</p>
<img src="/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/2.gif" class="" title="chmod 命令基本格式">

<p>例如，如果我们要设定<code>.bashrc</code>文件的权限为<code>rwxr-xr-x</code>，则可执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chmod u=rwx,go=rx .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure>
<p>如果想要增加<code>.bashrc</code>文件的每种用户都可做写操作的权限，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod a+w .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure>
<h1 id="umask详解：默认权限的设定和修改"><a href="#umask详解：默认权限的设定和修改" class="headerlink" title="umask详解：默认权限的设定和修改"></a>umask详解：默认权限的设定和修改</h1><p>Windows 系统中，新建的文件和目录时通过继承上级目录的权限获得的初始权限，而 Linux 不同，它是通过使用<code>umask</code>默认权限来给所有新建的文件和目录赋予初始权限的。</p>
<p>直接通过<code>umask</code>命令可得知<code>umask</code>默认权限的值即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line"><span class="comment">#root用户默认是0022，普通用户默认是 0002</span></span><br></pre></td></tr></table></figure>
<p><code>umask</code>默认权限确实由 4 个八进制数组成，但第 1 个数代表的是文件所具有的特殊权限（SetUID、SetGID、Sticky BIT）。也就是说，后 3 位数字 “022” 才是真正要用到的<code>umask</code>权限值，将其转变为字母形式为<code>----w--w-</code>。</p>
<p>注意，虽然<code>umask</code>默认权限是用来设定文件或目录的初始权限，但并不是直接将<code>umask</code>默认权限作为文件或目录的初始权限，还要对其进行”再加工”。</p>
<p>文件和目录的真正初始权限，可通过以下的计算得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限</span><br></pre></td></tr></table></figure>
<p>如果按照官方的标准算法，需要将<code>umask</code>默认权限使用二进制并经过逻辑与和逻辑非运算后，才能得到最终文件或目录的初始权限，计算过程比较复杂，且容易出错。</p>
<p>显然，如果想最终得到文件或目录的初始权限值，我们还需要了解文件和目录的最大默认权限值。在 Linux 系统中，文件和目录的最大默认权限是不一样的：</p>
<ul>
<li>对文件来讲，其可拥有的最大默认权限是 666，即<code>rw-rw-rw-</code>。也就是说，使用文件的任何用户都没有执行（<code>x</code>）权限。原因很简单，执行权限是文件的最高权限，赋予时绝对要慎重，因此绝不能在新建文件的时候就默认赋予，只能通过用户手工赋予。</li>
<li>对目录来讲，其可拥有的最大默认权限是 777，即<code>rwxrwxrwx</code>。</li>
</ul>
<p>接下来，我们利用字母权限的方式计算文件或目录的初始权限。以<code>umask</code>值为 022 为例，分别计算新建文件和目录的初始权限：</p>
<ul>
<li>文件的最大默认权限是 666，换算成字母就是<code>-rw-rw-rw-</code>，<code>umask</code>的值是 022，换算成字母为<code>-----w--w-</code>。把两个字母权限相减，得到<code>(-rw-rw-rw-) - (-----w--w-) = (-rw-r--r--)</code>，这就是新建文件的初始权限。我们测试一下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line"><span class="comment">#默认umask的值是0022</span></span><br><span class="line">[root@localhost ~]<span class="comment"># touch file  &lt;--新建file空文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -d file</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 18 02:36 file</span><br></pre></td></tr></table></figure></li>
<li>目录的默认权限最大可以是 777，换算成字母就是<code>drwxrwxrwx</code>，<code>umask</code>的值是 022，也就是<code>-----w--w-</code>。把两个字母权限相减，得到的就是新建目录的默认权限，即<code>(drwxrwxrwx) - (-----w--w-) = (drwxr-xr-x)</code>。我们再来测试一下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir catalog  &lt;--新建catalog目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -d catalog</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Apr 18 02:36 catalog</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，在计算文件或目录的初始权限时，不能直接使用最大默认权限和<code>umask</code>权限的数字形式做减法，这是不对的。例如，若<code>umask</code>默认权限的值为 033，按照数字形式计算文件的初始权限，666-033&#x3D;633，但我们按照字母的形式计算会得到<code>（rw-rw-rw-) - (----wx-wx) = (rw-r--r--)</code>，换算成数字形式是 644。</p>
<p>这里的减法，其实是“遮盖”的意思，也就是说，最大默认权限中和<code>umask</code>权限公共的部分，通过减法运算会被遮盖掉，最终剩下的“最大默认权限”，才是最终赋予文件或目录的初始权限。</p>
<h2 id="umask默认权限的修改方法"><a href="#umask默认权限的修改方法" class="headerlink" title="umask默认权限的修改方法"></a>umask默认权限的修改方法</h2><p><code>umask</code>权限值可以通过如下命令直接修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask 002</span></span><br><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0002</span><br><span class="line">[root@localhost ~]<span class="comment"># umask 033</span></span><br><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0033</span><br></pre></td></tr></table></figure>
<p>不过，这种方式修改的<code>umask</code>只是临时有效，一旦重启或重新登陆系统，就会失效。如果想让修改永久生效，则需要修改对应的环境变量配置文件<code>/etc/profile</code>。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/profile</span></span><br><span class="line">...省略部分内容...</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199]&amp;&amp;[ <span class="string">&quot;&#x27;id -gn&#x27;&quot;</span> = <span class="string">&quot;&#x27;id -un&#x27;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">umask</span> 002</span><br><span class="line">    <span class="comment">#如果UID大于199（普通用户），则使用此umask值</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">umask</span> 022</span><br><span class="line">    <span class="comment">#如果UID小于199（超级用户），则使用此umask值</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">…省略部分内容…</span><br></pre></td></tr></table></figure>
<p>普通用户的<code>umask</code>由<code>if</code>语句的第一段定义，而超级用户<code>root</code>的<code>umask</code>值由<code>else</code>语句定义即可。 修改此文件，则<code>umask</code>值就会永久生效。</p>
<h1 id="ACL访问控制权限"><a href="#ACL访问控制权限" class="headerlink" title="ACL访问控制权限"></a>ACL访问控制权限</h1><p>Linux 系统传统的权限控制方式，无非是利用 3 种身份（文件所有者，所属群组，其他用户），并分别搭配 3 种权限（读<code>r</code>，写<code>w</code>，访问<code>x</code>）。比如，我们可以通过<code>ls -l</code>命令查看当前目录中所有文件的详细信息，其中就包含对各文件的权限设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -l</span></span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Apr 15 16:33 Desktop</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Apr 15 16:33 Documents</span><br><span class="line">...</span><br><span class="line">-rwxr-xr-x. 2 root root 4096 Apr 15 16:33 post-install</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以上输出信息中，<code>rwxr-xr-x</code>就指明了不同用户访问文件的权限，即文件所有者拥有对文件的读、写、访问权限（<code>rwx</code>），文件所属群组拥有对文件的读、访问权限（<code>r-x</code>），其他用户拥有对文件的读、访问权限（<code>r-x</code>）。</p>
<p>权限前的字符，表示文件的具体类型，比如<code>d</code>表示目录，<code>-</code>表示普通文件，<code>l</code>表示连接文件，<code>b</code>表示设备文件，等等。</p>
<p>ACL，是<code>Access Control List</code>（访问控制列表）的缩写，在 Linux 系统中， ACL 可实现对单一用户设定访问文件的权限。也可以这么说，设定文件的访问权限，除了用传统方式（3 种身份搭配 3 种权限），还可以使用 ACL 进行设定。</p>
<h2 id="开启-ACL-权限"><a href="#开启-ACL-权限" class="headerlink" title="开启 ACL 权限"></a>开启 ACL 权限</h2><p>CentOS 6.x 系统中，ACL 权限默认处于开启状态，无需手工开启。但如果你的操作系统不是 CentOS 6.x，可以通过如下方式查看ACL权限是否开启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mount</span></span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">/dev/sda3 on I <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">…省略部分输出…</span><br><span class="line"><span class="comment">#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置</span></span><br><span class="line">[root@localhost ~]<span class="comment"># dumpe2fs -h /dev/sda3</span></span><br><span class="line"><span class="comment">#dumpe2fs是查询指定分区文件系统详细信息的命令</span></span><br><span class="line">…省略部分输出…</span><br><span class="line">Default mount options: user_xattr acl</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
<p>其中，<code>dumpe2fs</code>命令的<code>-h</code>选项表示仅显示超级块中的信息，而不显示磁盘块组的详细信息；</p>
<p>使用<code>mount</code>命令可以查看到系统中已经挂载的分区，而使用<code>dumpe2fs</code>命令可以查看到这个分区文件系统的详细信息。大家可以看到，我们的 ACL 权限是<code>/dev/sda3</code>分区的默认挂载选项，所以不需要手工挂载。</p>
<p>如果 Linux 系统如果没有默认挂载，可以执行如下命令实现手动挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mount -o remount,acl /</span></span><br><span class="line"><span class="comment">#重新挂载根分区，并加入ACL权限</span></span><br></pre></td></tr></table></figure>
<p>使用<code>mount</code>命令重新挂载，并加入 ACL 权限。但使用此命令只是临时生效，要想永久生效，需要修改<code>/etc/fstab</code>文件，修改方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#vi /etc/fstab</span></span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 /ext4 defaults,acl 1 1</span><br><span class="line"><span class="comment">#加入ACL权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount -o remount /</span></span><br><span class="line"><span class="comment">#重新挂载文件系统或重启系统，使修改生效</span></span><br></pre></td></tr></table></figure>
<p>在你需要开启 ACL 权限的分区行上（也就是说 ACL 权限针对的是分区），手工在<code>defaults</code>后面加入<code>&quot;，acl&quot;</code>即可永久在此分区中开启 ACL 权限。</p>
<h1 id="ACL权限设置"><a href="#ACL权限设置" class="headerlink" title="ACL权限设置"></a>ACL权限设置</h1><p>设定 ACl 权限，常用命令有 2 个，分别是<code>setfacl</code>和<code>getfacl</code>命令，前者用于给指定文件或目录设定 ACL 权限，后者用于查看是否配置成功。</p>
<p><code>getfacl</code>命令用于查看文件或目录当前设定的 ACL 权限信息。该命令的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# getfacl 文件名</span><br></pre></td></tr></table></figure>
<p><code>getfacl</code>命令的使用非常简单，且常和<code>setfacl</code>命令一起搭配使用。</p>
<p><code>setfacl</code>命令可直接设定用户或群组对指定文件的访问权限。此命令的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# setfacl 选项 文件名</span><br></pre></td></tr></table></figure>
<p>setfacl 命令选项及用法</p>
<p>选项	功能<br>-m 参数	设定 ACL 权限。如果是给予用户 ACL 权限，参数则使用 “u:用户名:权限” 的格式，例如 setfacl -m u:st:rx &#x2F;project 表示设定 st 用户对 project 目录具有 rx 权限；如果是给予组 ACL 权限，参数则使用 “g:组名:权限” 格式，例如 setfacl -m g:tgroup:rx &#x2F;project 表示设定群组 tgroup 对 project 目录具有 rx 权限。<br>-x 参数	删除指定用户（参数使用 u:用户名）或群组（参数使用 g:群组名）的 ACL 权限，例如 setfacl -x u:st &#x2F;project 表示删除 st 用户对 project 目录的 ACL 权限。<br>-b	删除所有的 ACL 权限，例如 setfacl -b &#x2F;project 表示删除有关 project 目录的所有 ACL 权限。<br>-d	设定默认 ACL 权限，命令格式为 “setfacl -m d:u:用户名:权限 文件名”（如果是群组，则使用 d:g:群组名:权限），只对目录生效，指目录中新建立的文件拥有此默认权限，例如 setfacl -m d:u:st:rx &#x2F;project 表示 st 用户对 project 目录中新建立的文件拥有 rx 权限。<br>-R	递归设定 ACL 权限，指设定的 ACL 权限会对目录下的所有子文件生效，命令格式为 “setfacl -m u:用户名:权限 -R 文件名”（群组使用 g:群组名:权限），例如 setfacl -m u:st:rx -R &#x2F;project 表示 st 用户对已存在于 project 目录中的子文件和子目录拥有 rx 权限。<br>-k	删除默认 ACL 权限。<br>setfacl -m：给用户或群组添加 ACL 权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># useradd zhangsan</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd lisi</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd st</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupadd tgroup &lt;-- 添加需要试验的用户和用户组，省略设定密码的过程</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir /project &lt;-- 建立需要分配权限的目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chown root:tgroup /project &lt;-- 改变/project目录的所有者和所属组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 770 /project  &lt;-- 指定/project目录的权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -d /project</span></span><br><span class="line">drwxrwx---. 2 root tgroup 4096 Apr 16 12:55 /project</span><br><span class="line"><span class="comment">#这时st学员来试听了，如何给她分配权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># setfacl -m u:st:rx /project</span></span><br><span class="line"><span class="comment">#给用户st赋予r-x权限，使用&quot;u:用户名：权限&quot; 格式</span></span><br><span class="line">[root@localhost /]<span class="comment"># cd /</span></span><br><span class="line">[root@localhost /]<span class="comment"># ll -d /project</span></span><br><span class="line">drwxrwx---+ 2 root tgroup 4096 Apr 16 12:55 /project</span><br><span class="line"><span class="comment">#如果查询时会发现，在权限位后面多了一个&quot;+&quot;，表示此目录拥有ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment">#查看/prpject目录的ACL权限</span></span><br><span class="line"><span class="comment">#file:project &lt;--文件名</span></span><br><span class="line"><span class="comment">#owner:root &lt;--文件的所有者</span></span><br><span class="line"><span class="comment">#group:tgroup &lt;--文件的所属组</span></span><br><span class="line">user::rwx &lt;--用户名栏是空的，说明是所有者的权限</span><br><span class="line">user:st:r-x &lt;--用户st的权限</span><br><span class="line">group::rwx &lt;--组名栏是空的，说明是所属组的权限</span><br><span class="line">mask::rwx &lt;--mask权限</span><br><span class="line">other::--- &lt;--其他人的权限</span><br></pre></td></tr></table></figure>
<p>可以看到，通过设定 ACL 权限，我们可以单独给 st 用户分配 r-x 权限，而无需给 st 用户设定任何身份。</p>
<p>同样的道理，也可以给用户组设定 ACL 权限，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># groupadd tgroup2</span></span><br><span class="line"><span class="comment">#添加新群组</span></span><br><span class="line">[root@localhost /]<span class="comment"># setfacl -m g:tgroup2:rwx project</span></span><br><span class="line"><span class="comment">#为组tgroup2纷配ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># ll -d project</span></span><br><span class="line">drwxrwx---+ 2 root tgroup 4096 1月19 04:21 project</span><br><span class="line"><span class="comment">#属组并没有更改</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment">#file: project</span></span><br><span class="line"><span class="comment">#owner: root</span></span><br><span class="line"><span class="comment">#group: tgroup</span></span><br><span class="line">user::rwx</span><br><span class="line">user:st:r-x</span><br><span class="line">group::rwx</span><br><span class="line">group:tgroup2:rwx &lt;-用户组tgroup2拥有了rwx权限</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>
<h2 id="setfacl-d：设定默认-ACL-权限"><a href="#setfacl-d：设定默认-ACL-权限" class="headerlink" title="setfacl -d：设定默认 ACL 权限"></a>setfacl -d：设定默认 ACL 权限</h2><p>既然已经对<code>project</code>目录设定了 ACL 权限，那么，如果在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的 ACL 权限呢？执行以下命令进行验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># cd project</span></span><br><span class="line">[root@localhost project]<span class="comment"># touch abc</span></span><br><span class="line">[root@localhost project]<span class="comment"># mkdir d1</span></span><br><span class="line"><span class="comment">#在/project目录中新建了abc文件和d1目录</span></span><br><span class="line">[root@localhost project]<span class="comment">#ll</span></span><br><span class="line">总用量4</span><br><span class="line">-rw-r--r-- 1 root root 01月19 05:20 abc</span><br><span class="line">drwxr-xr-x 2 root root 4096 1月19 05:20 d1</span><br></pre></td></tr></table></figure>
<p>可以看到，这两个新建立的文件权限位后面并没有 “+”，表示它们没有继承 ACL 权限。这说明，后建立的子文件或子目录，并不会继承父目录的 ACL 权限。</p>
<p>当然，我们可以手工给这两个文件分配 ACL 权限，但是如果在目录中再新建文件，都要手工指定，则显得过于麻烦。这时就需要用到默认 ACL 权限。</p>
<p>默认 ACL 权限的作用是，如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。需要注意的是，默认 ACL 权限只对目录生效。</p>
<p>例如，给 project 文件设定 st 用户访问 rx 的默认 ACL 权限，可执行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># setfacl -m d:u:st:rx project</span></span><br><span class="line">[root@localhost project]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment"># file: project</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: tgroup</span></span><br><span class="line">user:: rwx</span><br><span class="line">user:st:r-x</span><br><span class="line">group::rwx</span><br><span class="line">group:tgroup2:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx &lt;--多出了default字段</span><br><span class="line">default:user:st:r-x</span><br><span class="line">default:group::rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::---</span><br><span class="line">[root@localhost /]<span class="comment"># cd project</span></span><br><span class="line">[root@localhost project]<span class="comment"># touch bcd</span></span><br><span class="line">[root@localhost project]<span class="comment"># mkdir d2</span></span><br><span class="line"><span class="comment">#新建子文件和子目录</span></span><br><span class="line">[root@localhost project]<span class="comment"># ll 总用量8</span></span><br><span class="line">-rw-r--r-- 1 root root 01月19 05:20 abc</span><br><span class="line">-rw-rw----+ 1 root root 01月19 05:33 bcd</span><br><span class="line">drwxr-xr-x 2 root root 4096 1月19 05:20 d1</span><br><span class="line">drwxrwx---+ 2 root root 4096 1月19 05:33 d2</span><br><span class="line"><span class="comment">#新建的bcd和d2已经继承了父目录的ACL权限</span></span><br></pre></td></tr></table></figure>
<p>大家发现了吗？原先的 abc 和 d1 还是没有 ACL 权限，因为默认 ACL 权限是针对新建立的文件生效的。</p>
<p>对目录设定的默认 ACL 权限，可直接使用<code>setfacl -k</code>命令删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# setfacl -k project</span><br></pre></td></tr></table></figure>
<p>通过此命令，即可删除 project 目录的默认 ACL 权限，读者可自行通过 getfacl 命令查看。</p>
<h2 id="setfacl-R：设定递归-ACL-权限"><a href="#setfacl-R：设定递归-ACL-权限" class="headerlink" title="setfacl -R：设定递归 ACL 权限"></a>setfacl -R：设定递归 ACL 权限</h2><p>递归 ACL 权限指的是父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。</p>
<p>例如，给 project 目录设定 st 用户访问权限为 rx 的递归 ACL 权限，执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost project]<span class="comment"># setfacl -m u:st:rx -R project</span></span><br><span class="line">[root@localhost project]<span class="comment"># ll</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-r-xr--+ 1 root root 01月19 05:20 abc</span><br><span class="line">-rw-rwx--+ 1 root root 01月19 05:33 bcd</span><br><span class="line">drwxr-xr-x+ 2 root root 4096 1月19 05:20 d1</span><br><span class="line">drwxrwx---+ 2 root root 4096 1月19 05:33 d2</span><br><span class="line"><span class="comment">#abc和d1也拥有了ACL权限</span></span><br></pre></td></tr></table></figure>
<p>注意，默认 ACL 权限指的是针对父目录中后续建立的文件和目录会继承父目录的 ACL 权限；递归 ACL 权限指的是针对父目录中已经存在的所有子文件和子目录会继承父目录的 ACL 权限。</p>
<h2 id="setfacl-x：删除指定的-ACL-权限"><a href="#setfacl-x：删除指定的-ACL-权限" class="headerlink" title="setfacl -x：删除指定的 ACL 权限"></a>setfacl -x：删除指定的 ACL 权限</h2><p>使用<code>setfacl -x</code>命令，可以删除指定的 ACL 权限，例如，删除前面建立的<code>st</code>用户对<code>project</code>目录的 ACL 权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># setfacl -x u:st project</span></span><br><span class="line"><span class="comment">#删除指定用户和用户组的ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment"># file:project</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: tgroup</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">group:tgroup2:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line"><span class="comment">#st用户的权限已被删除</span></span><br></pre></td></tr></table></figure>
<h2 id="setfacl-b：删除指定文件的所有-ACL-权限"><a href="#setfacl-b：删除指定文件的所有-ACL-权限" class="headerlink" title="setfacl -b：删除指定文件的所有 ACL 权限"></a>setfacl -b：删除指定文件的所有 ACL 权限</h2><p>此命令可删除所有与指定文件或目录相关的 ACL 权限。例如，现在我们删除一切与<code>project</code>目录相关的 ACL 权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># setfacl -b project</span></span><br><span class="line"><span class="comment">#会删除文件的所有ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment">#file: project</span></span><br><span class="line"><span class="comment">#owner: root</span></span><br><span class="line"><span class="comment"># group: tgroup</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">other::---</span><br><span class="line"><span class="comment">#所有ACL权限已被删除</span></span><br></pre></td></tr></table></figure>


<h1 id="sudo命令用法详解：系统权限管理"><a href="#sudo命令用法详解：系统权限管理" class="headerlink" title="sudo命令用法详解：系统权限管理"></a>sudo命令用法详解：系统权限管理</h1><p>使用<code>su</code>命令可以让普通用户切换到<code>root</code>身份去执行某些特权命令，但存在一些问题，比如说：</p>
<ul>
<li>仅仅为了一个特权操作就直接赋予普通用户控制系统的完整权限；</li>
<li>当多人使用同一台主机时，如果大家都要使用<code>su</code>命令切换到<code>root</code>身份，那势必就需要<code>root</code>的密码，这就导致很多人都知道<code>root</code>的密码；</li>
</ul>
<p>考虑到使用<code>su</code>命令可能对系统安装造成的隐患，最常见的解决方法是使用<code>sudo</code>命令，此命令也可以让你切换至其他用户的身份去执行命令。</p>
<p>相对于使用<code>su</code>命令还需要新切换用户的密码，<code>sudo</code>命令的运行只需要知道自己的密码即可，甚至于，我们可以通过手动修改<code>sudo</code>的配置文件，使其无需任何密码即可运行。</p>
<p><code>sudo</code>命令默认只有<code>root</code>用户可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># sudo [-b] [-u 新使用者账号] 要执行的命令</span></span><br></pre></td></tr></table></figure>
<p>常用的选项与参数：</p>
<ul>
<li><code>-b</code>：将后续的命令放到背景中让系统自行运行，不对当前的 shell 环境产生影响。</li>
<li><code>-u</code>：后面可以接欲切换的用户名，若无此项则代表切换身份为<code>root</code>。</li>
<li><code>-l</code>：此选项的用法为<code>sudo -l</code>，用于显示当前用户可以用<code>sudo</code>执行那些命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  grep sshd /etc/passwd</span></span><br><span class="line">sshd:x:74:74:privilege-separated SSH:/var/empty/sshd:/sbin.nologin</span><br><span class="line">[root@localhost ~]<span class="comment">#  sudo -u sshd touch /tmp/mysshd</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  ll /tmp/mysshd</span></span><br><span class="line">-rw-r--r-- 1 sshd sshd 0 Feb 28 17:42 /tmp/mysshd</span><br></pre></td></tr></table></figure>
<p>本例中，无法使用<code>su - sshd</code>的方式成功切换到<code>sshd</code>账户中，因为此用户的默认 Shell 是<code>/sbin/nologin</code>。这时就显现出<code>sudo</code>的优势，我们可以使用<code>sudo</code>以<code>sshd</code>的身份在<code>/tmp</code>目录下创建<code>mysshd</code>文件，可以看到，新创建的<code>mysshd</code>文件的所有者确实是<code>sshd</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  sudo -u vbird1 sh -c &quot;mkdir ~vbird1/www; cd ~vbird1/www; \</span></span><br><span class="line">&gt;  <span class="built_in">echo</span> <span class="string">&#x27;This is index.html file&#x27;</span> &gt; index.html<span class="string">&quot;</span></span><br><span class="line"><span class="string">[root@localhost ~]#  ll -a ~vbird1/www</span></span><br><span class="line"><span class="string">drwxr-xr-x 2 vbird1 vbird1 4096 Feb 28 17:51 .</span></span><br><span class="line"><span class="string">drwx------ 5 vbird1 vbird1 4096 Feb 28 17:51 ..</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 vbird1 vbird1   24 Feb 28 17:51 index.html</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，使用<code>sudo</code>命令切换至<code>vbird1</code>身份，并运行<code>sh -c</code>的方式来运行一连串的命令。</p>
<p>默认情况下<code>sudo</code>命令只有<code>root</code>身份可以使用，那么，如何让普通用户也能使用它呢？</p>
<p>解决这个问题之前，先给大家分析一下<code>sudo</code>命令的执行过程。<code>sudo</code>命令的运行，需经历如下几步：</p>
<ul>
<li>当用户运行<code>sudo</code>命令时，系统会先通过<code>/etc/sudoers</code>文件，验证该用户是否有运行<code>sudo</code>的权限；</li>
<li>确定用户具有使用<code>sudo</code>命令的权限后，还要让用户输入自己的密码进行确认。出于对系统安全性的考虑，如果用户在默认时间内（默认是 5 分钟）不使用<code>sudo</code>命令，此后使用时需要再次输入密码；</li>
<li>密码输入成功后，才会执行<code>sudo</code>命令后接的命令。</li>
</ul>
<p>显然，能否使用<code>sudo</code>命令，取决于对<code>/etc/sudoers</code>文件的配置（默认情况下，此文件中只配置有<code>root</code>用户）。</p>
<h2 id="sudo命令的配置文件-x2F-etc-x2F-sudoers"><a href="#sudo命令的配置文件-x2F-etc-x2F-sudoers" class="headerlink" title="sudo命令的配置文件&#x2F;etc&#x2F;sudoers"></a>sudo命令的配置文件&#x2F;etc&#x2F;sudoers</h2><p>修改<code>/etc/sudoers</code>，不建议直接使用<code>vim</code>，而是使用<code>visudo</code>。因为修改<code>/etc/sudoers</code>文件需遵循一定的语法规则，使用<code>visudo</code>的好处就在于，当修改完毕<code>/etc/sudoers</code>文件，离开修改页面时，系统会自行检验<code>/etc/sudoers</code>文件的语法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># visudo</span></span><br><span class="line">…省略部分输出…</span><br><span class="line">root ALL=(ALL) ALL  &lt;--大约 76 行的位置</span><br><span class="line"><span class="comment"># %wheel ALL=(ALL) ALL   &lt;--大约84行的位置</span></span><br><span class="line"><span class="comment">#这两行是系统为我们提供的模板，我们参照它写自己的就可以了</span></span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
<p>通过<code>visudo</code>命令，我们就打开了<code>/etc/sudoers</code>文件，可以看到如上显示的 2 行信息，这是系统给我们提供的 2 个模板，分别用于添加用户和群组，使其能够使用<code>sudo</code>命令。</p>
<p>这两行模板的含义分为是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL) ALL</span><br><span class="line">#用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span><br><span class="line">#%wheel ALL=(ALL) ALL</span><br><span class="line">#%组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span><br></pre></td></tr></table></figure>
<p><code>/etc/sudoers</code>用户和群组模板的含义：</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户名或群组名</td>
<td align="center">表示系统中的那个用户或群组，可以使用 sudo 这个命令。</td>
</tr>
<tr>
<td align="center">被管理主机的地址</td>
<td align="center">用户可以管理指定 IP 地址的服务器。这里如果写 ALL，则代表用户可以管理任何主机；如果写固定 IP，则代表用户可以管理指定的服务器。如果我们在这里写本机的 IP 地址，不代表只允许本机的用户使用指定命令，而是代表指定的用户可以从任何 IP 地址来管理当前服务器。</td>
</tr>
<tr>
<td align="center">可使用的身份</td>
<td align="center">就是把来源用户切换成什么身份使用，（ALL）代表可以切换成任意身份。这个字段可以省略。</td>
</tr>
<tr>
<td align="center">授权命令</td>
<td align="center">表示 root 把什么命令命令授权给用户，换句话说，可以用切换的身份执行什么命令。需要注意的是，此命令必须使用绝对路径写。默认值是 ALL，表示可以执行任何命令。</td>
</tr>
</tbody></table>
<p>授权用户<code>lamp</code>可以重启服务器，由<code>root</code>用户添加，可以在<code>/etc/sudoers</code>模板下添加如下语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># visudo</span></span><br><span class="line">lamp ALL=/sbin/shutdown -r now</span><br></pre></td></tr></table></figure>
<p>注意，这里也可以写多个授权命令，之间用逗号分隔。用户<code>lamp</code>可以使用<code>sudo -l</code>查看授权的命令列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># su - lamp</span></span><br><span class="line"><span class="comment">#切换成lamp用户</span></span><br><span class="line">[lamp@localhost ~]$ sudo -l</span><br><span class="line">[sudo] password <span class="keyword">for</span> lamp:</span><br><span class="line"><span class="comment">#需要输入lamp用户的密码</span></span><br><span class="line">User lamp may run the following commands on this host:</span><br><span class="line">(root) /sbin/shutdown -r now</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>lamp</code>用户拥有了<code>shutdown -r now</code>的权限。这时，<code>lamp</code>用户就可以使用<code>sudo</code>执行如下命令重启服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lamp@localhost ~]$ sudo /sbin/shutdown -r now</span><br></pre></td></tr></table></figure>
<p>再次强调，授权命令要使用绝对路径（或者把<code>/sbin</code>路径导入普通用户<code>PATH</code>路径中，不推荐使用此方式），否则无法执行。</p>
<p>假设现在有<code>pro1，pro2，pro3</code>这 3 个用户，还有一个<code>group</code>群组，我们可以通过在<code>/etc/sudoers</code>文件配置<code>wheel</code>群组信息，令这 3 个用户同时拥有管理系统的权限。</p>
<p>首先，向<code>/etc/sudoers</code>文件中添加群组配置信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># visudo</span></span><br><span class="line">....(前面省略)....</span><br><span class="line">%group     ALL=(ALL)    ALL</span><br><span class="line"><span class="comment">#在 84 行#wheel这一行后面写入</span></span><br></pre></td></tr></table></figure>
<p>此配置信息表示，<code>group</code>这个群组中的所有用户都能够使用<code>sudo</code>切换任何身份，执行任何命令。接下来，我们使用<code>usermod</code>命令将<code>pro1</code>加入<code>group</code> 群组，看看有什么效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># usermod -a -G group pro1</span></span><br><span class="line">[pro1@localhost ~]<span class="comment"># sudo tail -n 1 /etc/shadow &lt;==注意身份是 pro1</span></span><br><span class="line">....(前面省略)....</span><br><span class="line">Password:  &lt;==输入 pro1 的口令喔！</span><br><span class="line">pro3:$1$GfinyJgZ<span class="variable">$9J8IdrBXXMwZIauANg7tW0</span>:14302:0:99999:7:::</span><br><span class="line">[pro2@localhost ~]<span class="comment"># sudo tail -n 1 /etc/shadow &lt;==注意身份是 pro2</span></span><br><span class="line">Password:</span><br><span class="line">pro2 is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br><span class="line"><span class="comment">#此错误信息表示 pro2 不在 /etc/sudoers 的配置中。</span></span><br></pre></td></tr></table></figure>
<p>可以看到，由于<code>pro1</code>加入到了<code>group</code>群组，因此<code>pro1</code>就可以使用<code>sudo</code>命令，而<code>pro2</code>不行。同样的道理，如果我们想让<code>pro3</code>也可以使用<code>sudo</code>命令，不用再修改<code>/etc/sudoers</code>文件，只需要将<code>pro3</code>加入<code>group</code>群组即可。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/01/24/Linux/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Linux系统服务管理
          
        </div>
      </a>
    
    
      <a href="/2022/01/20/Linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Linux用户和用户组管理</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>