<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>运输层——TCP的传输连接管理 |  学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-计算机网络/运输层——TCP的传输连接管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  运输层——TCP的传输连接管理
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2020-10-17T03:51:33.000Z" itemprop="datePublished">2020-10-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">29 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>TCP 连接有三个阶段：连接建立、数据传送、连接释放。</p>
<p>TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。</p>
<p>TCP 连接建立过程中要解决的三个问题：</p>
<ol>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li>
<li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ol>
<p>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户，被动等待建立连接的应用进程叫服务器。</p>
<h1 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h1><p>TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/img1.png" class="" title="用三次握手建立TCP连接的各状态">

<p>假定主机 A 运行的是 TCP 客户程序，B 运行 TCP 服务器程序。最初两端的 TCP 进程都处于<code>CLOSED</code>（关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。注意，A 主动打开连接，B 被动打开连接。</p>
<p>B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于<code>LISTEN</code>（收听）状态，等待客户的连接请求。</p>
<p>A 的 TCP 客户进程也是首先创建传输控制块 TCB，然后向 B 发出连接请求报文段，这时，首部中的同部位<code>SYN = 1</code>，同时选择一个初始序号<code>seq = x</code>。TCP 规定<code>SYN</code>报文段（即<code>SYN = 1</code>的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入<code>SYN-SENT</code>（同步已发送）状态。</p>
<p>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中，<code>SYN = 1, ACK = 1</code>，确认号是<code>ack = x + 1</code>，同时也为自己选择一个初始序号<code>seq = y</code>。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，TCP 服务器进程进入<code>SYN-RCVD</code>（同步收到）状态。</p>
<p>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。<code>ACK = 1, ack = y + 1</code>，而自己的序号<code>seq = x + 1</code>。TCP 规定，<code>ACK</code>报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是<code>seq = x + 1</code>。这时 TCP 连接已经建立，A 进入<code>ESTABLISHED</code>（已建立连接）状态。</p>
<p>当 B 收到 A 的确认后，也进入<code>ESTABLISHED</code>状态。</p>
<p>从上⾯的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</p>
<p>⼀旦完成三次握手，双方都处于<code>ESTABLISHED</code>态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h2 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h2><p>三次握手的原因：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<h3 id="原因⼀：避免历史连接"><a href="#原因⼀：避免历史连接" class="headerlink" title="原因⼀：避免历史连接"></a>原因⼀：避免历史连接</h3><p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p>我们考虑一个场景，客户端先发送了<code>SYN(seq = 90)</code>报文，然后客户端宕机了，而且这个<code>SYN</code>报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了<code>SYN(seq = 100)</code>报文（注意！不是重传<code>SYN</code>，重传的<code>SYN</code>的序列号是一样的）。</p>
<p>看看三次握手是如何阻止历史连接的：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/10.jpg" class="">

<p>客户端连续发送多次<code>SYN</code>建立连接的报文，在网络拥堵情况下：</p>
<ul>
<li>一个「旧<code>SYN</code>报文」比「最新的<code>SYN</code>」 报文早到达了服务端，那么此时服务端就会回一个<code>SYN + ACK</code>报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回<code>RST</code>报文。</li>
<li>服务端收到<code>RST</code>报文后，就会释放连接。</li>
<li>后续最新的<code>SYN</code>抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>如果服务端在收到<code>RST</code>报文之前，先收到了「新<code>SYN</code>报文」，也就是服务端收到客户端报文的顺序是：「旧<code>SYN</code>报文」-&gt;「新<code>SYN</code>报文」，此时会发生什么?</p>
<p>当服务端第一次收到<code>SYN</code>报文，也就是收到 「旧<code>SYN</code>报文」时，就会回复<code>SYN + ACK</code>报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新<code>SYN</code>报文」时，就会回<code>Challenge Ack</code>报文给客户端，这个<code>ack</code>报文并不是确认收到「新<code>SYN</code>报文」的，而是上一次的<code>ack</code>确认号，也就是 91（90+1）。所以客户端收到此<code>ACK</code>报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回<code>RST</code>报文。</p>
<p>如果是两次握手连接，就无法阻止历史连接，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p>
<p>主要是因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。</p>
<p>在两次握手的情况下，服务端在收到<code>SYN</code>报文后，就进入<code>ESTABLISHED</code>状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入<code>ESTABLISHED</code>状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回<code>RST</code>报文来断开连接，而服务端在第一次握手的时候就进入<code>ESTABLISHED</code>状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到<code>RST</code>报文后，才会断开连接。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/9.png" class="">

<p>可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p>
<p>因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。</p>
<p>所以，TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</p>
<h3 id="原因二：同步双方初始序列号"><a href="#原因二：同步双方初始序列号" class="headerlink" title="原因二：同步双方初始序列号"></a>原因二：同步双方初始序列号</h3><p>TCP 协议的通信双方， 都必须维护⼀个序列号， 序列号是可靠传输的⼀个关键因素，它的作用： </p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
<p>可⻅，序列号在 TCP 连接中占据着⾮常重要的作用，所以当客户端发送携带「初始序列号」的<code>SYN</code>报文的时候，需要服务端回⼀个<code>ACK</code>应答报文，表示客户端的<code>SYN</code>报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样⼀来⼀回，才能确保双方的初始序列号能被可靠的同步。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/12.jpg" class="">

<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成⼀步，所以就成了三次握手。</p>
<p>而两次握手只保证了⼀方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h3 id="原因三：避免资源浪费"><a href="#原因三：避免资源浪费" class="headerlink" title="原因三：避免资源浪费"></a>原因三：避免资源浪费</h3><p>如果只有两次握手，当客户端的<code>SYN</code>请求连接在网络中阻塞，客户端没有接收到<code>ACK</code>报文，就会重新发送<code>SYN</code>，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的<code>ACK</code>确认信号，所以每收到⼀个<code>SYN</code>就只能先主动建立⼀个连接，这会造成什么情况呢？</p>
<p>如果客户端的<code>SYN</code>阻塞了，重复发送多次<code>SYN</code>报文，那么服务器在收到请求后就会建立多个冗余的⽆效链接，造成不必要的资源浪费。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/13.jpg" class="">

<p>即两次握手会造成消息滞留情况下，服务器重复接受⽆用的连接请求<code>SYN</code>报文，而造成重复分配资源。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用两次握手和四次握手的原因：</p>
<ul>
<li>两次握手：⽆法防止历史连接的建立，会造成双方资源的浪费，也⽆法可靠的同步双方序列号；</li>
<li>四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h2 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h2><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是<code>SYN</code>报文，然后进入到<code>SYN_SENT</code>状态。</p>
<p>在这之后，如果客户端迟迟收不到服务端的<code>SYN-ACK</code>报文（第二次握手），就会触发「超时重传」机制，重传<code>SYN</code>报文，而且重传的<code>SYN</code>报文的序列号都是一样的。</p>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
<p>当客户端在 1 秒后没收到服务端的<code>SYN-ACK</code>报文后，客户端就会重发<code>SYN</code>报文，那到底重发几次呢？</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由<code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应<code>ACK</code>，客户端就不再发送<code>SYN</code>包，然后断开 TCP 连接。</p>
<p>所以，总耗时是<code>1+2+4+8+16+32=63</code>秒，大约 1 分钟左右。</p>
<p>举个例子，假设<code>tcp_syn_retries</code>参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/14.png" class="">

<p>具体过程：<br>当客户端超时重传 3 次 SYN 报文后，由于<code>tcp_syn_retries</code>为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（<code>SYN-ACK</code>报文），那么客户端就会断开连接。</p>
<h2 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h2><p>当服务端收到客户端的第一次握手后，就会回<code>SYN-ACK</code>报文给客户端，这个就是第二次握手，此时服务端会进入<code>SYN_RCVD</code>状态。</p>
<p>第二次握手的<code>SYN-ACK</code>报文其实有两个目的：</p>
<ul>
<li>第二次握手里的<code>ACK</code>，是对第一次握手的确认报文；</li>
<li>第二次握手里的<code>SYN</code>，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p>
<p>因为第二次握手报文里是包含对客户端的第一次握手的<code>ACK</code>确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的<code>SYN</code>报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传<code>SYN</code>报文。</p>
<p>然后，因为第二次握手中包含服务端的<code>SYN</code>报文，所以当客户端收到后，需要给服务端发送<code>ACK</code>确认报文（第三次握手），服务端才会认为该<code>SYN</code>报文被客户端收到了。</p>
<p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传<code>SYN-ACK</code>报文。</p>
<p>在 Linux 下，<code>SYN-ACK</code>报文的最大重传次数由<code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/net/ipv4/tcp_synack_retries</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传<code>SYN</code>报文，也就是第一次握手，最大重传次数由<code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传<code>SYN-ACK</code>报文，也就是第二次握手，最大重传次数由<code>tcp_synack_retries</code>内核参数决定。</li>
</ul>
<p>举个例子，假设<code>tcp_syn_retries</code>参数值为 1，<code>tcp_synack_retries</code>参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/15.png" class="">

<p>具体过程：</p>
<ul>
<li>当客户端超时重传 1 次<code>SYN</code>报文后，由于<code>tcp_syn_retries</code>为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（<code>SYN-ACK</code>报文），那么客户端就会断开连接。</li>
<li>当服务端超时重传 2 次<code>SYN-ACK</code>报文后，由于<code>tcp_synack_retries</code>为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（<code>ACK</code>报文），那么服务端就会断开连接。</li>
</ul>
<h2 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h2><p>客户端收到服务端的<code>SYN-ACK</code>报文后，就会给服务端回一个<code>ACK</code>报文，也就是第三次握手，此时客户端状态进入到<code>ESTABLISH</code>状态。</p>
<p>因为这个第三次握手的<code>ACK</code>是对第二次握手的<code>SYN</code>的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传<code>SYN-ACK</code>报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<code>ACK</code>报文是不会有重传的，当<code>ACK</code>丢失了，就由对方重传对应的报文。</p>
<p>举个例子，假设<code>tcp_synack_retries</code>参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/16.png" class="">

<p>具体过程：<br>当服务端超时重传 2 次<code>SYN-ACK</code>报文后，由于<code>tcp_synack_retries</code>为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（<code>ACK</code>报文），那么服务端就会断开连接。</p>
<h2 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h2><p>起始 ISN 是基于时钟的，每 4 毫秒<code>+1</code>，转⼀圈要 4.55 个小时。</p>
<p>RFC1948 中提出了⼀个较好的初始化序列号 ISN 随机生成算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISN = M + F(localhost, localport, remotehost, remoteport)</span><br></pre></td></tr></table></figure>
<p>M 是⼀个计时器，这个计时器每隔 4 毫秒加 1。 F 是⼀个 Hash 算法，根据源 IP、⽬的 IP、源端口、⽬的端口生成⼀个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是⼀个比较好的选择。</p>
<h1 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h1><p>TCP 连接释放过程是通过四次挥手方式。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/img2.png" class="">

<p>数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于<code>ESTABLISHED</code>状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的<code>FIN</code>置1，其序号<code>seq = u</code>，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入<code>FIN-WAIT-1</code>（终止等待1）状态，等待 B 的确认。TCP 规定，<code>FIN</code>报文段即使不携带数据也消耗掉一个序号。</p>
<p>B 收到连接释放报文段后立即发出确认，确认号是<code>ack = u + 1</code>，而这个报文段自己的序号是<code>v</code>，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 进入<code>CLOSE-WAIT</code>（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭。这个状态可能会持续一些时间。</p>
<p>A 收到来自 B 的确认后，就进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待 B 发出的连接释放报文段。</p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使<code>FIN = 1</code>。现假定 B 的序号为<code>w</code>（半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号<code>ack = u + 1</code>。这时 B 就进入<code>LAST-ACK</code>（最后确认）状态，等待 A 的确认。</p>
<p>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中，<code>ACK = 1, ack = w + 1</code>，而自己的序号是<code>seq = u + 1</code>。然后进入到<code>TIME-WAIT</code>（时间等待）状态。现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL 后，A 才进入到<code>CLOSED</code>状态。时间 MSL 叫最长报文段寿命(<code>Maximum Segment Lifetime</code>)。当 A 撤销相应的传输控制块 TCB 后，就结束了这次 TCP 连接。</p>
<p>B 只要收到了 A 的确认，就进入<code>CLOSED</code>状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早。</p>
<p>可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。</p>
<p>需要注意是：主动关闭连接的，才有<code>TIME_WAIT</code>状态。</p>
<h2 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h2><p>关闭连接时，客户端向服务端发送<code>FIN</code>时，仅仅表示客户端不再发送数据了但是还能接收数据。</p>
<p>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</p>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p>
<h2 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h2><p>当客户端（主动关闭方）调用<code>close</code>函数后，就会向服务端发送<code>FIN</code>报文，试图与服务端断开连接，此时客户端的连接进入到<code>FIN_WAIT_1</code>状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的<code>ACK</code>，则会很快变为<code>FIN_WAIT2</code>状态。</p>
<p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的<code>ACK</code>的话，也就会触发超时重传机制，重传<code>FIN</code>报文，重发次数由<code>tcp_orphan_retries</code>参数控制。</p>
<p>当客户端重传<code>FIN</code>报文的次数超过<code>tcp_orphan_retries</code>后，就不再发送<code>FIN</code>报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到<code>close</code>状态。</p>
<p>举个例子，假设<code>tcp_orphan_retries</code>参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/17.png" class="">

<p>具体过程：<br>当客户端超时重传 3 次<code>FIN</code>报文后，由于<code>tcp_orphan_retries</code>为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（<code>ACK</code>报文），那么客户端就会断开连接。</p>
<h2 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h2><p>当服务端收到客户端的第一次挥手后，就会先回一个<code>ACK</code>确认报文，此时服务端的连接进入到<code>CLOSE_WAIT</code>状态。</p>
<p><code>ACK</code>报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传<code>FIN</code>报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<p>举个例子，假设<code>tcp_orphan_retries</code>参数值为 2，当第二次挥手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/18.png" class="">

<p>具体过程：<br>当客户端超时重传 2 次<code>FIN</code>报文后，由于<code>tcp_orphan_retries</code>为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（<code>ACK</code>报文），那么客户端就会断开连接。</p>
<p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的<code>ACK</code>报文后，客户端就会处于<code>FIN_WAIT2</code>状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的<code>FIN</code>报文。</p>
<p>对于<code>close</code>函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code>状态不可以持续太久，而<code>tcp_fin_timeout</code>控制了这个状态下连接的持续时长，默认值是 60 秒。</p>
<p>这意味着对于调用<code>close</code>关闭的连接，如果在 60 秒后还没有收到<code>FIN</code>报文，客户端（主动关闭方）的连接就会直接关闭，如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/19.png" class="">

<p>但是注意，如果主动关闭方使用<code>shutdown</code>函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p>
<p>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于<code>FIN_WAIT2</code>状态（<code>tcp_fin_timeout</code>无法控制<code>shutdown</code>关闭的连接）。如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/20.png" class="">

<h2 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h2><p>当服务端（被动关闭方）收到客户端（主动关闭方）的<code>FIN</code>报文后，内核会自动回复<code>ACK</code>，同时连接处于<code>CLOSE_WAIT</code>状态，顾名思义，它表示等待应用进程调用<code>close</code>函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用<code>close</code>函数来触发服务端发送<code>FIN</code>报文。</p>
<p>服务端处于<code>CLOSE_WAIT</code>状态时，调用了<code>close</code>函数，内核就会发出<code>FIN</code>报文，同时连接进入<code>LAST_ACK</code>状态，等待客户端返回<code>ACK</code>来确认连接关闭。</p>
<p>如果迟迟收不到这个<code>ACK</code>，服务端就会重发<code>FIN</code>报文，重发次数仍然由<code>tcp_orphan_retries</code>参数控制，这与客户端重发<code>FIN</code>报文的重传次数控制方式是一样的。</p>
<p>举个例子，假设<code>tcp_orphan_retries = 3</code>，当第三次挥手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/21.png" class="">

<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于<code>tcp_orphan_retries</code>为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（<code>ACK</code>报文），那么服务端就会断开连接。</li>
<li>客户端因为是通过<code>close</code>函数关闭连接的，处于<code>FIN_WAIT_2</code>状态是有时长限制的，如果<code>tcp_fin_timeout</code>时间内还是没能收到服务端的第三次挥手（<code>FIN</code>报文），那么客户端就会断开连接。</li>
</ul>
<h2 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h2><p>当客户端收到服务端的第三次挥手的<code>FIN</code>报文后，就会回<code>ACK</code>报文，也就是第四次挥手，此时客户端连接进入<code>TIME_WAIT</code>状态。</p>
<p>在 Linux 系统，<code>TIME_WAIT</code>状态会持续 2MSL 后才会进入关闭状态。</p>
<p>然后，服务端（被动关闭方）没有收到<code>ACK</code>报文前，还是处于<code>LAST_ACK</code>状态。</p>
<p>如果第四次挥手的<code>ACK</code>报文没有到达服务端，服务端就会重发<code>FIN</code>报文，重发次数仍然由<code>tcp_orphan_retries</code>参数控制。</p>
<p>举个例子，假设<code>tcp_orphan_retries</code>为 2，当第四次挥手一直丢失时，发生的过程如下：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/22.png" class="">

<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文达到 2 时，由于<code>tcp_orphan_retries</code>为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（<code>ACK</code>报文），那么服务端就会断开连接。</li>
<li>客户端在收到第三次挥手后，就会进入<code>TIME_WAIT</code>状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（<code>FIN</code>报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li>
</ul>
<h2 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h2><p>MSL 是<code>Maximum Segment Lifetime</code>，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。</p>
<p><code>TIME_WAIT</code>等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p>
<p>比如如果被动关闭方没有收到断开连接的最后的<code>ACK</code>报文，就会触发超时重发<code>FIN</code>报文，另一方接收到<code>FIN</code>后，会重发<code>ACK</code>给被动关闭方，一来一去正好 2 个 MSL。</p>
<p>2MSL 的时间是从客户端接收到<code>FIN</code>后发送<code>ACK</code>开始计时的。如果在<code>TIME-WAIT</code>时间内，因为客户端的<code>ACK</code>没有传输到服务端，客户端又接收到了服务端重发的<code>FIN</code>报文，那么 2MSL 时间将重新计时。</p>
<p>在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。Linux 系统停留在<code>TIME_WAIT</code>的时间为固定的 60 秒。</p>
<p>其定义在 Linux 内核代码里的名称为<code>TCP_TIMEWAIT_LEN</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT </span><br><span class="line">                                    state, about 60 seconds  */</span><br></pre></td></tr></table></figure>
<p>如果要修改<code>TIME_WAIT</code>的时间长度，只能修改 Linux 内核代码里<code>TCP_TIMEWAIT_LEN</code>的值，并重新编译 Linux 内核。</p>
<h2 id="A-必须等待-2MSL-的时间"><a href="#A-必须等待-2MSL-的时间" class="headerlink" title="A 必须等待 2MSL 的时间"></a>A 必须等待 2MSL 的时间</h2><p>第一，为了保证 A 发送的最后一个<code>ACK</code>报文段能够到达 B。这个<code>ACK</code>报文段有可能丢失，因而使处在<code>LAST-ACK</code>状态的 B 收不到对已发送的<code>FIN + ACK</code>报文段的确认。B 会超时重传这个<code>FIN + ACK</code>报文段，而 A 就能在 2MSL 时间内收到这个重传的<code>FIN + ACK</code>报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到<code>CLOSED</code>状态。如果 A 在<code>TIME_WAIT</code>状态不等待一段时间，而是在发送完<code>ACK</code>报文段后立即释放连接，那么就无法收到 B 重传的<code>FIN + ACK</code>报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入<code>CLOSED</code>状态。</p>
<p>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个<code>ACK</code>报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<p>B 只要收到了 A 发岀的确认，就进入<code>CLOSED</code>状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早一些。</p>
<h2 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h2><p>主动发起关闭连接的一方，才会有<code>TIME-WAIT</code>状态。</p>
<p>需要<code>TIME-WAIT</code>状态，主要是两个原因：</p>
<ul>
<li>防止具有相同「四元组」的旧数据包被收到；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的<code>ACK</code>能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
<h3 id="原因一：防止旧连接的数据包"><a href="#原因一：防止旧连接的数据包" class="headerlink" title="原因一：防止旧连接的数据包"></a>原因一：防止旧连接的数据包</h3><p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/23.jpg" class="">

<ul>
<li>如上图黄色框框服务端在关闭连接之前发送的<code>SEQ = 301</code>报文，被网络延迟了。</li>
<li>这时有相同端口的 TCP 连接被复用后，被延迟的<code>SEQ = 301</code>抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li>
</ul>
<p>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</p>
<h3 id="原因二：保证连接正确关闭"><a href="#原因二：保证连接正确关闭" class="headerlink" title="原因二：保证连接正确关闭"></a>原因二：保证连接正确关闭</h3><p><code>TIME-WAIT</code>另一个重要的作用是等待足够的时间以确保最后的<code>ACK</code>能让被动关闭方接收，从而帮助其正常关闭。</p>
<p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/24.jpg" class="">

<ul>
<li>如上图红色框框客户端四次挥手的最后一个<code>ACK</code>报文如果在网络中被丢失了，此时如果客户端<code>TIME-WAIT</code>过短或没有，则就直接进入了<code>CLOSED</code>状态了，那么服务端则会一直处在<code>LASE_ACK</code>状态。</li>
<li>当客户端发起建立连接的<code>SYN</code>请求报文后，服务端会发送<code>RST</code>报文给客户端，连接建立的过程就会被终止。</li>
</ul>
<p>如果<code>TIME-WAIT</code>等待足够长的情况就会遇到两种情况：</p>
<ul>
<li>服务端正常收到四次挥手的最后一个<code>ACK</code>报文，则服务端正常关闭连接。</li>
<li>服务端没有收到四次挥手的最后一个<code>ACK</code>报文时，则会重发<code>FIN</code>关闭连接报文并等待新的<code>ACK</code>报文。</li>
</ul>
<p>所以客户端在<code>TIME-WAIT</code>状态等待 2MSL 时间后，就可以保证双方的连接都可以正常的关闭。</p>
<h2 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h2><p>除时间等待计时器外，TCP还设有一个保活计时器(<code>keepalive timer</code>)，用来防止在 TCP 连接出现长时期的空闲。</p>
<p>设想有这样的情况：客户己主动与服务器建立了 TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器。</p>
<p>保活计时器通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 </p>
<h1 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h1><img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/img3.png" class="" title="TCP 的有限状态机">

<p>图中每一个方框都是 TCP 可能具有的状态。</p>
<p>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。</p>
<p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p>
<p>图中有三种不同的箭头：</p>
<ul>
<li>粗实线箭头表示对客户进程的正常变迁。</li>
<li>粗虚线箭头表示对服务器进程的正常变迁。</li>
<li>另一种细线箭头表示异常变迁。</li>
</ul>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            DNS详解
          
        </div>
      </a>
    
    
      <a href="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">运输层——TCP的流量控制</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>