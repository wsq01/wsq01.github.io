<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Java 类和对象 |  学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-java/基础/Java类和对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Java 类和对象
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/13/java/%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2020-09-13T08:22:16.000Z" itemprop="datePublished">2020-09-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">10.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">40 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h1><p>Java 是面向对象的编程语言，对象就是面向对象程序设计的核心。所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：</p>
<ul>
<li>对象具有属性和行为。</li>
<li>对象具有变化的状态。</li>
<li>对象具有唯一性。</li>
<li>对象都是某个类别的实例。</li>
<li>一切皆为对象，真实世界中的所有事物都可以视为对象。</li>
</ul>
<p>例如，在真实世界的学校里，会有学生和老师等实体，学生有学号、姓名、所在班级等属性（数据），学生还有学习、提问、吃饭和走路等操作。学生只是抽象的描述，这个抽象的描述称为“类”。在学校里活动的是学生个体，即张同学、李同学等，这些具体的个体称为“对象”，“对象”也称为“实例”。</p>
<h1 id="面向对象的三大核心特性"><a href="#面向对象的三大核心特性" class="headerlink" title="面向对象的三大核心特性"></a>面向对象的三大核心特性</h1><p>面向对象程序设计有以下优点。</p>
<ul>
<li>可重用性：代码重复使用，减少代码量，提高开发效率。大核心特性（继承、封装和多态）都围绕这个核心。</li>
<li>可扩展性：指新的功能可以很容易地加入到系统中来，便于软件的修改。</li>
<li>可管理性：能够将功能与数据结合，方便管理。</li>
</ul>
<p>该开发模式之所以使程序设计更加完善和强大，主要是因为面向对象具有继承、封装和多态 3 个核心特性。</p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承。</p>
<p>使用这种层次形的分类方式，是为了将多个类的通用属性和方法提取出来，放在它们的父类中，然后只需要在子类中各自定义自己独有的属性和方法，并以继承的形式在父类中获取它们的通用属性和方法即可。</p>
<p>Java 语言是单继承的，即只能有一个父类，但 Java 可以实现多个接口，可以防止多继承所引起的冲突问题。</p>
<h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><p>封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下。</p>
<ul>
<li>保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。</li>
<li>隐藏细节信息，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。</li>
<li>有助于建立各个系统之间的松耦合关系，提高系统的独立性。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。</li>
<li>提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。</li>
</ul>
<p>Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。</p>
<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p>定义一个类，需要使用<code>class</code>关键字、一个自定义的类名和一对表示程序体的大括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>][<span class="keyword">abstract</span>|<span class="keyword">final</span>]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;</span><br><span class="line">    <span class="comment">// 定义属性部分</span></span><br><span class="line">    &lt;property_type&gt;&lt;property1&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property2&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property3&gt;;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 定义方法部分</span></span><br><span class="line">    function1();</span><br><span class="line">    function2();</span><br><span class="line">    function3();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>》 提示：上述语法中，中括号<code>[]</code>中的部分表示可以省略，竖线<code>|</code>表示“或关系”，但是两个关键字不能同时出现。</p>
<p>上述语法中各关键字的描述如下。</p>
<ul>
<li><code>public</code>：表示“共有”的意思。如果使用<code>public</code>修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是<code>public</code>类，作为公共工具供其他类和程序使用的类应定义为<code>public</code>类。</li>
<li><code>abstract</code>：如果类被<code>abstract</code>修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用<code>abstract</code>修饰的方法）和具体方法（没有使用<code>abstract</code>修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。</li>
<li><code>final</code>：如果类被<code>final</code>修饰，则不允许被继承。</li>
<li><code>class</code>：声明类的关键字。</li>
<li><code>class_name</code>：类的名称。</li>
<li><code>extends</code>：表示继承其他类。</li>
<li><code>implements</code>：表示实现某些接口。</li>
<li><code>property_type</code>：表示成员变量的类型。</li>
<li><code>property</code>：表示成员变量名称。</li>
<li><code>function()</code>：表示成员方法名称。</li>
</ul>
<p>Java 类名的命名规则：</p>
<ul>
<li>类名应该以下划线（<code>_</code>）或字母开头，最好以字母开头。</li>
<li>第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。</li>
<li>类名不能为 Java 中的关键字，例如<code>boolean、this、int</code>等。</li>
<li>类名不能包含任何嵌入的空格或点号以及除了下划线（<code>_</code>）和美元符号（<code>$</code>）字符之外的特殊字符。</li>
</ul>
<p>创建一个新的类，就是创建一个新的数据类型。实例化一个类，就是得到类的一个对象。因此，对象就是一组变量和相关方法的集合，其中变量表明对象的状态和属性，方法表明对象所具有的行为。定义一个类的步骤如下所述。</p>
<ol>
<li>声明类。编写类的最外层框架，声明一个名称为<code>Person</code>的类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 类的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写类的属性。类中的数据和方法统称为类成员。其中，类的属性就是类的数据成员。通过在类的主体中定义变量来描述类所具有的特征（属性），这里声明的变量称为类的成员变量。</li>
<li>编写类的方法。类的方法描述了类所具有的行为，是类的方法成员。可以简单地把方法理解为独立完成某个功能的单元模块。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="comment">// 定义说话的方法</span></span><br><span class="line">    System.out.println(name+<span class="string">&quot;今年&quot;</span>+age+<span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h1><p>在 Java 中类的成员变量定义了类的属性。声明成员变量的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[public|protected|private][static][final] &lt;type&gt; &lt;variable_name&gt;</span><br></pre></td></tr></table></figure>
<p>各参数的含义如下。</p>
<ul>
<li><code>public、protected、private</code>：用于表示成员变量的访问权限。</li>
<li><code>static</code>：表示该成员变量为类变量，也称为静态变量。</li>
<li><code>final</code>：表示将该成员变量声明为常量，其值无法更改。</li>
<li><code>type</code>：表示变量的类型。</li>
<li><code>variable_name</code>：表示变量名称。</li>
</ul>
<p>可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。</p>
<p>初始化的默认值如下：</p>
<ul>
<li>整数型（<code>byte、short、int</code>和<code>long</code>）的基本类型变量的默认值为 0。</li>
<li>单精度浮点型（<code>float</code>）的基本类型变量的默认值为<code>0.0f</code>。</li>
<li>双精度浮点型（<code>double</code>）的基本类型变量的默认值为<code>0.0d</code>。</li>
<li>字符型（<code>char</code>）的基本类型变量的默认值为<code>\u0000</code>。</li>
<li>布尔型的基本类型变量的默认值为<code>false</code>。</li>
<li>数组引用类型的变量的默认值为<code>null</code>。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。</li>
</ul>
<p>定义类的成员变量的示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 性别：0表示女孩，1表示男孩</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><p>声明成员方法可以定义类的行为，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。类的各种功能操作都是用方法来实现的，属性只不过提供了相应的数据。一个完整的方法通常包括方法名称、方法主体、方法参数和方法返回值类型。</p>
<p>成员方法一旦被定义，便可以在程序中多次调用。声明成员方法的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  [<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>][<span class="keyword">static</span>] &lt;<span class="keyword">void</span>|return_type&gt; &lt;method_name&gt; ([paramList]) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中<code>return_type</code>是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。</p>
<p>除了这些，一个方法还可以没有返回值，即返回类型为<code>void</code>，像<code>main()</code>方法。<code>method_name</code>表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。</p>
<p><code>paramList</code>表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。</p>
<ul>
<li><code>public、private、protected</code>：表示成员方法的访问权限。</li>
<li><code>static</code>：表示限定该成员方法为静态方法。</li>
<li><code>final</code>：表示限定该成员方法不能被重写或重载。</li>
<li><code>abstract</code>：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> StringBuffer <span class="title function_">printInfo</span><span class="params">(Student st)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(<span class="string">&quot;学生姓名：&quot;</span>+st.Name+<span class="string">&quot;\n 学生年龄：&quot;</span>+st.Age+<span class="string">&quot;\n 学生性别：&quot;</span>+st.isSex());</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个名称为<code>printInfo</code>的方法，其返回值类型为<code>StringBuffer</code>（引用数据类型）。该方法需要传递一个<code>Student</code>类型的参数，最后需要将一个<code>StringBuffer</code>类型的数据返回。</p>
<h3 id="1-成员方法的返回值"><a href="#1-成员方法的返回值" class="headerlink" title="1. 成员方法的返回值"></a>1. 成员方法的返回值</h3><p>若方法有返回值，则在方法体中用<code>return</code>语句指明要返回的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return 表达式</span><br><span class="line">// 或者</span><br><span class="line">return (表达式)</span><br></pre></td></tr></table></figure>
<p>其中，表达式可以是常量、变量、对象等。表达式的数据类型必须与声明成员方法时给出的返回值类型一致。</p>
<h3 id="2-形参、实参及成员方法的调用"><a href="#2-形参、实参及成员方法的调用" class="headerlink" title="2. 形参、实参及成员方法的调用"></a>2. 形参、实参及成员方法的调用</h3><p>可以通过以下方式来调用成员方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodName(&#123;paramList&#125;)</span><br></pre></td></tr></table></figure>
<p>关于方法的参数，经常会提到形参与实参，形参是定义方法时参数列表中出现的参数，实参是调用方法时为方法传递的参数。</p>
<p>下面<code>retumMin()</code>方法中的<code>m</code>和<code>n</code>是形参，调用<code>retumMin()</code>方法时的<code>x</code>和<code>y</code>是实参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">returnMin</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Math.min(m,n);    <span class="comment">// m和n是形参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t.returnMin(x,y);    <span class="comment">// x和y是实参</span></span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的形参和实参具有以下特点：</p>
<ul>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在方法内部有效，方法调用结束返回主调方法后则不能再使用该形参变量。</li>
<li>实参可以是常量、变量、表达式、方法等，无论实参是何种类型的量，在进行方法调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值、输入等办法使实参获得确定值。</li>
<li>实参和形参在数量、类型和顺序上应严格一致，否则会发生“类型不匹配” 的错误。</li>
<li>方法调用中发生的数据传送是单向的，即只能把实参的值传送绐形参，而不能把形参的值反向地传送给实参。因此在方法调用过程中，形参的值发生改变，而实参中的值不会变化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  x += <span class="number">30</span>;</span><br><span class="line">  System.out.println(<span class="string">&quot;形参 x 的值：&quot;</span>+x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用 add() 方法之前 x 的值：&quot;</span>+x);</span><br><span class="line">  <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t.add(x);</span><br><span class="line">  System.out.println(<span class="string">&quot;实参 x 的值：&quot;</span>+x);</span><br><span class="line">  System.out.println(<span class="string">&quot;调用 add() 方法的返回值：&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用 add() 方法之前 x 的值：150</span><br><span class="line">形参 x 的值：180</span><br><span class="line">实参 x 的值：150</span><br><span class="line">调用 add() 方法的返回值：180</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出，形参<code>x</code>值的改变，并没有影响实参<code>x</code>。</p>
<p>在调用成员方法时应注意以下 4 点：</p>
<ul>
<li>对无参成员方法来说，是没有实际参数列表的（即没有<code>paramList</code>），但方法名后的括号不能省略。</li>
<li>对带参数的成员方法来说，实参的个数、顺序以及它们的数据类型必须与形式参数的个数、顺序以及它们的数据类型保持一致，各个实参间用逗号分隔。实参名与形参名可以相同，也可以不同。</li>
<li>实参也可以是表达式，此时一定要注意使表达式的数据类型与形参的数据类型相同，或者使表达式的类型按 Java 类型转换规则达到形参指明的数据类型。</li>
<li>实参变量对形参变量的数据传递是“值传递”，即只能由实参传递给形参，而不能由形参传递给实参。程序中执行到调用成员方法时，Java 把实参值复制到一个临时的存储区（栈）中，形参的任何修改都在栈中进行，当退出该成员方法时，Java 自动清除栈中的内容。</li>
</ul>
<h3 id="3-方法体中的局部变量"><a href="#3-方法体中的局部变量" class="headerlink" title="3. 方法体中的局部变量"></a>3. 方法体中的局部变量</h3><p>在方法体内可以定义本方法所使用的变量，这种变量是局部变量。它的生存期与作用域是在本方法内，也就是说，局部变量只能在本方法内有效或可见，离开本方法则这些变量将被自动释放。</p>
<p>在方法体内定义变量时，变量前不能加修饰符。局部变量在使用前必须明确赋值，否则编译时会出错。另外，在一个方法内部，可以在复合语句（把多个语句用括号{}括起来组成的一个语句称复合语句）中定义变量，这些变量只在复合语句中有效。</p>
<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p><code>this</code>关键字可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。</p>
<h2 id="this-属性名"><a href="#this-属性名" class="headerlink" title="this.属性名"></a>this.属性名</h2><p>大部分时候，普通方法访问其他方法、成员变量时无须使用<code>this</code>前缀，但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用<code>this</code>前缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;    <span class="comment">// 教师名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> salary;    <span class="comment">// 工资</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中<code>name、salary</code>和<code>age</code>的作用域是<code>private</code>，因此在类外部无法对它们的值进行设置。为了解决这个问题，可以为<code>Teacher</code>类添加一个构造方法，然后在构造方法中传递参数进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建构造方法，为上面的3个属性赋初始值</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name,<span class="type">double</span> salary,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;    <span class="comment">// 设置教师名称</span></span><br><span class="line">  <span class="built_in">this</span>.salary = salary;    <span class="comment">// 设置教师工资</span></span><br><span class="line">  <span class="built_in">this</span>.age = age;    <span class="comment">// 设置教师年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Teacher</code>类的构造方法中使用了<code>this</code>关键字对属性<code>name、salary</code>和<code>age</code>赋值，<code>this</code>表示当前对象。<code>this.name=name</code>语句表示一个赋值语句，等号左边的<code>this.name</code>是指当前对象具有的变量<code>name</code>，等号右边的<code>name</code>表示参数传递过来的数值。</p>
<p>创建一个<code>main()</code>方法对<code>Teacher</code>类进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;王刚&quot;</span>,<span class="number">5000.0</span>,<span class="number">45</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;教师信息如下：&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;教师名称：&quot;</span>+teacher.name+<span class="string">&quot;\n教师工资：&quot;</span>+teacher.salary+<span class="string">&quot;\n教师年龄：&quot;</span>+teacher.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">教师信息如下：</span><br><span class="line">教师名称：王刚</span><br><span class="line">教师工资：5000.0</span><br><span class="line">教师年龄：45</span><br></pre></td></tr></table></figure>
<p>提示：当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。</p>
<h2 id="this-方法名"><a href="#this-方法名" class="headerlink" title="this.方法名"></a>this.方法名</h2><p><code>this</code>关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p>
<p>假设定义了一个<code>Dog</code>类，这个<code>Dog</code>对象的<code>run()</code>方法需要调用它的<code>jump()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一种定义Dog类方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个jump()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;正在执行jump方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义一个run()方法，run()方法需要借助jump()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    d.jump();</span><br><span class="line">    System.out.println(<span class="string">&quot;正在执行 run 方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式来定义这个<code>Dog</code>类，确实可以实现在<code>run()</code>方法中调用<code>jump()</code>方法。下面再提供一个程序来创建<code>Dog</code>对象，并调用该对象的<code>run()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Dog对象</span></span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="comment">// 调用Dog对象的run()方法</span></span><br><span class="line">    dog.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，一共产生了两个<code>Dog</code>对象，在<code>Dog</code>类的<code>run()</code>方法中，程序创建了一个<code>Dog</code>对象，并使用名为<code>d</code>的引用变量来指向该<code>Dog</code>对象。在<code>DogTest</code>的<code>main()</code>方法中，程序再次创建了一个<code>Dog</code>对象，并使用名为<code>dog</code>的引用变量来指向该<code>Dog</code>对象。</p>
<p>下面我们思考两个问题。</p>
<ol>
<li>在<code>run()</code>方法中调用<code>jump()</code>方法时是否一定需要一个<code>Dog</code>对象？<br>答案是肯定的，因为没有使用<code>static</code>修饰的成员变量和方法都必须使用对象来调用。</li>
<li>是否一定需要重新创建一个<code>Dog</code>对象？<br>不一定，因为当程序调用<code>run()</code>方法时，一定会提供一个<code>Dog</code>对象，这样就可以直接使用这个已经存在的<code>Dog</code>对象，而无须重新创建新的<code>Dog</code>对象了。因此需要在<code>run()</code>方法中获得调用该方法的对象，通过<code>this</code>关键字就可以满足这个要求。</li>
</ol>
<p><code>this</code>可以代表任何对象，当<code>this</code>出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的只能是当前类的实例。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，<code>this</code>就代表谁。</p>
<p>将前面的<code>Dog</code>类的<code>run()</code>方法改为如下形式会更加合适。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二种定义Dog类方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 定义一个run()方法，run()方法需要借助jump()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 使用this引用调用run()方法的对象</span></span><br><span class="line">  <span class="built_in">this</span>.jump();</span><br><span class="line">  System.out.println(<span class="string">&quot;正在执行run方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 允许对象的一个成员直接调用另一个成员，可以省略<code>this</code>前缀。也就是说，将上面的<code>run()</code>方法改为如下形式也完全正确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  jump();</span><br><span class="line">  System.out.println(<span class="string">&quot;正在执行run方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分时候，一个方法访问该类中定义的其他方法、成员变量时加不加<code>this</code>前缀的效果是完全一样的。</p>
<p>注意：对于<code>static</code>修饰的方法而言，可以使用类来直接调用该方法，如果在<code>static</code>修饰的方法中使用<code>this</code>关键字，则这个关键字就无法指向合适的对象。所以，<code>static</code>修饰的方法中不能使用<code>this</code>引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。</p>
<p>省略<code>this</code>前缀只是一种假象，虽然程序员省略了调用<code>jump()</code>方法之前的<code>this</code>，但实际上这个<code>this</code>依然是存在的。</p>
<h2 id="this-访问构造方法"><a href="#this-访问构造方法" class="headerlink" title="this()访问构造方法"></a>this()访问构造方法</h2><p><code>this()</code>用来访问本类的构造方法（构造方法是类的一种特殊方法，方法名称和类名相同，没有返回值）括号中可以有参数，如果有参数就是调用指定的有参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="comment">// 无参构造方法（没有参数的构造方法）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有参构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输出name和age</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    stu.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="comment">// 姓名：张三</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>this()</code>不能在普通方法中使用，只能写在构造方法中。在构造方法中使用时，必须是第一条语句。</p>
</blockquote>
<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>对象是对类的实例化。对象具有状态和行为，变量用来表明对象的状态，方法表明对象所具有的行为。Java 对象的生命周期包括创建、使用和清除，创建对象分显式创建与隐含创建两种情况。</p>
<h2 id="显式创建对象"><a href="#显式创建对象" class="headerlink" title="显式创建对象"></a>显式创建对象</h2><p>对象的显式创建方式有 4 种。</p>
<ol>
<li>使用<code>new</code>关键字创建对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = new 类名();</span><br></pre></td></tr></table></figure></li>
<li>调用<code>java.lang.Class</code>或者<code>java.lang.reflect.Constuctor</code>类的<code>newlnstance()</code>实例方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class Class 类对象名称 = java.lang.Class.forName(要实例化的类全称);</span><br><span class="line">类名 对象名 = (类名)Class类对象名称.newInstance();</span><br></pre></td></tr></table></figure>
调用<code>java.lang.Class</code>类中的<code>forName()</code>方法时，需要将要实例化的类的全称（比如<code>com.mxl.package.Student</code>）作为参数传递过去，然后再调用<code>java.lang.Class</code>类对象的<code>newInstance()</code>方法创建对象。</li>
<li>调用对象的<code>clone()</code>方法<br>该方法不常用，使用该方法创建对象时，要实例化的类必须继承<code>java.lang.Cloneable</code>接口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名对象名 = (类名)已创建好的类对象名.clone();</span><br></pre></td></tr></table></figure></li>
<li>调用<code>java.io.ObjectlnputStream</code>对象的<code>readObject()</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;   </span><br><span class="line">  <span class="comment">// 实现 Cloneable 接口</span></span><br><span class="line">  <span class="keyword">private</span> String Name;    <span class="comment">// 学生名字</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 学生年龄</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.Name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.Name = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;学生名字：&quot;</span>+Name+<span class="string">&quot;，年龄：&quot;</span>+age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用 new 关键字创建对象---------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用new关键字创建对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小刘&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------调用 java.lang.Class 的 newInstance() 方法创建对象-----------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 java.lang.Class 的 newInstance() 方法创建对象</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student)c1.newInstance();</span><br><span class="line">    System.out.println(student2);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------调用对象的 clone() 方法创建对象----------&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用对象的 clone() 方法创建对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student3</span> <span class="operator">=</span> (Student)student2.clone();</span><br><span class="line">    System.out.println(student3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上述示例的说明如下：</p>
<ul>
<li>使用<code>new</code>关键字或<code>Class</code>对象的<code>newInstance()</code>方法创建对象时，都会调用类的构造方法。</li>
<li>使用<code>Class</code>类的<code>newInstance()</code>方法创建对象时，会调用类的默认构造方法，即无参构造方法。</li>
<li>使用<code>Object</code>类的<code>clone()</code>方法创建对象时，不会调用类的构造方法，它会创建一个复制的对象，这个对象和原来的对象具有不同的内存地址，但它们的属性值相同。</li>
<li>如果类没有实现<code>Cloneable</code>接口，则<code>clone</code>。方法会抛出<code>java.lang.CloneNotSupportedException</code>异常，所以应该让类实现<code>Cloneable</code>接口。</li>
</ul>
<p>程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------使用 new 关键字创建对象---------</span><br><span class="line">学生名字：小刘，年龄：22</span><br><span class="line">-----------调用 java.lang.Class 的 newInstance() 方法创建对象-----------</span><br><span class="line">学生名字：name，年龄：0</span><br><span class="line">-------------------调用对象的done()方法创建对象----------</span><br><span class="line">学生名字：name，年龄：0</span><br></pre></td></tr></table></figure>
<h2 id="隐含创建对象"><a href="#隐含创建对象" class="headerlink" title="隐含创建对象"></a>隐含创建对象</h2><p>除了显式创建对象以外，在 Java 程序中还可以隐含地创建对象，例如下面几种情况。</p>
<ol>
<li><code>String strName = &quot;strValue&quot;</code>，其中的<code>strValue</code>就是一个<code>String</code>对象，由 Java 虚拟机隐含地创建。</li>
<li>字符串的“+”运算符运算的结果为一个新的<code>String</code>对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1+str2;  <span class="comment">// str3引用一个新的String对象</span></span><br></pre></td></tr></table></figure></li>
<li>当 Java 虚拟机加载一个类时，会隐含地创建描述这个类的<code>Class</code>实例。</li>
</ol>
<p>提示：类的加载是指把类的<code>.class</code>文件中的二进制数据读入内存中，把它存放在运行时数据区的方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。</p>
<p>无论釆用哪种方式创建对象，Java 虚拟机在创建一个对象时都包含以下步骤：</p>
<ul>
<li>给对象分配内存。</li>
<li>将对象的实例变量自动初始化为其变量类型的默认值。</li>
<li>初始化对象，给实例变量赋予正确的初始值。</li>
</ul>
<blockquote>
<p>注意：每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理。</p>
</blockquote>
<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p>每次<code>new</code>都相当于开辟了一个新的对象，并开辟了一个新的物理内存空间。如果一个对象只需要使用唯一的一次，就可以使用匿名对象，匿名对象还可以作为实际参数传递。</p>
<p>匿名对象就是没有明确的给出名字的对象，是对象的一种简写形式。一般匿名对象只使用一次，而且匿名对象只在堆内存中开辟空间，而不存在栈内存的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">  <span class="comment">// 定义构造方法，为属性初始化</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取信息的方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>).tell(); <span class="comment">// 匿名对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序运行结果为：</span></span><br><span class="line"><span class="comment">// 姓名：张三，年龄：30</span></span><br></pre></td></tr></table></figure>
<p>在以上程序的主方法中可以发现，直接使用了<code>new Person(&quot;张三&quot;,30)</code>语句，这实际上就是一个匿名对象，与之前声明的对象不同，此处没有任何栈内存引用它，所以此对象使用一次之后就等待被 GC（垃圾收集机制）回收。</p>
<p>匿名对象实际上就是个堆内存空间，对象不管是匿名的还是非匿名的，都必须在开辟堆空间之后才可以使用。</p>
<h1 id="访问对象的属性和行为"><a href="#访问对象的属性和行为" class="headerlink" title="访问对象的属性和行为"></a>访问对象的属性和行为</h1><p>每个对象都有自己的属性和行为，这些属性和行为在类中体现为成员变量和成员方法，其中成员变量对应对象的属性，成员方法对应对象的行为。</p>
<p>在 Java 中，要引用对象的属性和行为，需要使用点（.）操作符来访问。对象名在圆点左边，而成员变量或成员方法的名称在圆点的右边。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.属性(成员变量)    // 访问对象的属性</span><br><span class="line">对象名.成员方法名()    // 访问对象的方法</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();    <span class="comment">// 创建 Student 类的对象 stu</span></span><br><span class="line">stu.Name = <span class="string">&quot;李子文&quot;</span>;    <span class="comment">// 调用stu对象的Name属性并赋值</span></span><br><span class="line">stu.Sex = <span class="literal">true</span>;    <span class="comment">// 调用stu对象的Sex属性并赋值</span></span><br><span class="line">stu.Age = <span class="number">15</span>;    <span class="comment">// 调用stu对象的Age属性并赋值</span></span><br></pre></td></tr></table></figure>
<p>如果一个对象要被使用，则对象必须被实例化，如果一个对象没有被实例化而直接调用了对象中的属性或方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">stu.Name = <span class="string">&quot;李子文&quot;</span>;</span><br><span class="line">stu.Sex = <span class="literal">true</span>;</span><br><span class="line">stu.Age = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>则程序运行时会出现以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure>
<p>此异常是使用了未实例化的对象则肯定会出现此异常。</p>
<h1 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h1><p>对象使用完之后需要对其进行清除。对象的清除是指释放对象占用的内存。在创建对象时，用户必须使用<code>new</code>操作符为对象分配内存。不过，在清除对象时，由系统自动进行内存回收，不需要用户额外处理。</p>
<p>Java 语言的内存自动回收称为垃圾回收机制，简称 GC。垃圾回收机制是指 JVM 用于释放那些不再使用的对象所占用的内存。</p>
<p>Java 语言并不要求 JVM 有 GC，也没有规定 GC 如何工作。不过常用的 JVM 都有 GC，而且大多数 GC 都使用类似的算法管理内存和执行回收操作。</p>
<p>如果回收内存的任务由程序负责，也就是说必须在程序中显式地进行内存回收，这无疑会增加程序员的负担，而且存在很多弊端。Java 语言对象是由垃圾回收器收集然后释放，程序员不用关系释放的细节。</p>
<p>一个对象被当作垃圾回收的情况主要如下两种。</p>
<ol>
<li>对象的引用超过其作用范围。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="comment">// 对象o的作用范围，超过这个范围对象将被视为垃圾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对象被赋值为<code>null</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  o = <span class="literal">null</span>;    <span class="comment">// 对象被赋值为null将被视为垃圾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 Java 的<code>Object</code>类中还提供了一个<code>protected</code>类型的<code>finalize()</code>方法，因此任何 Java 类都可以覆盖这个方法，在这个方法中进行释放对象所占有的相关资源的操作。</li>
</ol>
<p>在 Java 虚拟机的堆区，每个对象都可能处于以下三种状态之一。</p>
<ol>
<li>可触及状态：当一个对象被创建后，只要程序中还有引用变量引用它，那么它就始终处于可触及状态。</li>
<li>可复活状态：当程序不再有任何引用变量引用该对象时，该对象就进入可复活状态。在这个状态下，垃圾回收器会准备释放它所占用的内存，在释放之前，会调用它及其他处于可复活状态的对象的<code>finalize()</code>方法，这些<code>finalize()</code>方法有可能使该对象重新转到可触及状态。</li>
<li>不可触及状态：当 Java 虚拟机执行完所有可复活对象的<code>finalize()</code>方法后，如果这些方法都没有使该对象转到可触及状态，垃圾回收器才会真正回收它占用的内存。</li>
</ol>
<p>注意：调用<code>System.gc()</code>或者<code>Runtime.gc()</code>方法也不能保证回收操作一定执行，它只是提高了 Java 垃圾回收器尽快回收垃圾的可能性。</p>
<h1 id="main-方法"><a href="#main-方法" class="headerlink" title="main()方法"></a>main()方法</h1><p><code>main()</code>方法是 Java 应用程序的入口方法，程序在运行的时候，第一个执行的方法就是<code>main()</code>方法。<code>main()</code>方法和其他的方法有很大的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>main()</code>方法时应该注意如下几点：</p>
<ul>
<li>访问控制权限是公有的（<code>public</code>）。</li>
<li><code>main()</code>方法是静态的。如果要在<code>main()</code>方法中调用本类中的其他方法，则该方法也必须是静态的，否则需要先创建本类的实例对象，然后再通过对象调用成员方法。</li>
<li><code>main()</code>方法没有返回值，只能使用<code>void</code>。</li>
<li><code>main()</code>方法具有一个字符串数组参数，用来接收执行 Java 程序的命令行参数。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。</li>
<li>字符串中数组的名字（代码中的<code>args</code>）可以任意设置，但是根据习惯，这个字符串数组的名字一般和 Java 规范范例中<code>main()</code>参数名保持一致，命名为<code>args</code>，而方法中的其他内容都是固定不变的。</li>
<li><code>main()</code>方法定义必须是<code>public static void main(String[] 字符串数组参数名)</code>。</li>
<li>一个类只能有一个<code>main()</code>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Speak1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你好!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Speak2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Java!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Speak1();    // 错误调用</span></span><br><span class="line">    Speak2();    <span class="comment">// 可以直接调用静态方法Speak2()</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    t.Speak1();    <span class="comment">// 调用非静态方法，需要通过类的对象来调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面代码可以看出，在<code>main()</code>方法中只能直接调用静态方法，如果想调用非静态方法，需要将当前类实例化，然后通过类的对象来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> args.length;    <span class="comment">// 获取参数数量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;一共有 &quot;</span>+n+<span class="string">&quot; 个参数&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">      <span class="comment">// 判断参数个数是否大于0</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        System.out.println(args[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javac TestMain.java</span><br><span class="line">java TestMain</span><br><span class="line">一共有 0 个参数</span><br><span class="line"></span><br><span class="line">java TestMain apple banana</span><br><span class="line">一共有 2 个参数</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line"></span><br><span class="line">java TestMain one two three four five six</span><br><span class="line">一共有 6 个参数</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br></pre></td></tr></table></figure>
<p>由此可见，<code>main()</code>方法可以以字符串的形式接收命令行参数，然后在方法体内进行处理。</p>
<h1 id="方法的可变参数"><a href="#方法的可变参数" class="headerlink" title="方法的可变参数"></a>方法的可变参数</h1><p>在具体实际开发过程中，有时方法中参数的个数是不确定的。为了解决这个问题，引入了可变参数的概念。声明可变参数的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodName(&#123;paramList&#125;,paramType…paramName)</span><br></pre></td></tr></table></figure>
<p>其中，<code>methodName</code>表示方法名称；<code>paramList</code>表示方法的固定参数列表；<code>paramType</code>表示可变参数的类型；<code>…</code>是声明可变参数的标识；<code>paramName</code>表示可变参数名称。</p>
<p>注意：可变参数必须定义在参数列表的最后。<br>例 1<br>每次参加考试的人数是不固定的，但是每次考试完之后都需要打印出本次考试的总人数以及参加考试的学生名单。下面编写程序，使用方法的可变参数实现该功能，具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTestMethod</span> &#123;</span><br><span class="line">    <span class="comment">// 定义输出考试学生的人数及姓名的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String ...names)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> names.length;    <span class="comment">// 获取总个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;本次参加考试的有&quot;</span>+count+<span class="string">&quot;人，名单如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; names.length;i++) &#123;</span><br><span class="line">            System.out.println(names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">StudentTestMethod</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentTestMethod</span>();</span><br><span class="line">        student.print(<span class="string">&quot;张强&quot;</span>,<span class="string">&quot;李成&quot;</span>,<span class="string">&quot;王勇&quot;</span>);    <span class="comment">// 传入3个值</span></span><br><span class="line">        student.print(<span class="string">&quot;马丽&quot;</span>,<span class="string">&quot;陈玲&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法是类的一种特殊方法，用来初始化类的一个新的对象，在创建对象（<code>new</code>运算符）之后自动调用。Java 中的每个类都有一个默认的构造方法，并且可以有一个以上的构造方法。</p>
<p>Java 构造方法有以下特点：</p>
<ul>
<li>方法名必须与类名相同</li>
<li>可以有 0 个、1 个或多个参数</li>
<li>没有任何返回值，包括<code>void</code></li>
<li>默认返回类型就是对象类型本身</li>
<li>只能与<code>new</code>运算符结合使用</li>
</ul>
<p>值得注意的是，如果为构造方法定义了返回值类型或使用 void 声明构造方法没有返回值，编译时不会出错，但 Java 会把这个所谓的构造方法当成普通方法来处理。</p>
<p>构造方法不是没有返回值吗？为什么不能用 void 声明呢？</p>
<p>简单的说，这是 Java 的语法规定。实际上，类的构造方法是有返回值的，当使用 new 关键字来调用构造方法时，构造方法返回该类的实例，可以把这个类的实例当成构造器的返回值，因此构造器的返回值类型总是当前类，无须定义返回值类型。但必须注意不要在构造方法里使用<code>return</code>来返回当前类的对象，因为构造方法的返回值是隐式的。</p>
<p>注意：构造方法不能被<code>static、final、synchronized、abstract</code>和<code>native</code>（类似于<code>abstract</code>）修饰。构造方法用于初始化一个新对象，所以用<code>static</code>修饰没有意义。构造方法不能被子类继承，所以用<code>final</code>和<code>abstract</code>修饰没有意义。多个线程不会同时创建内存地址相同的同一个对象，所以用<code>synchronized</code>修饰没有必要。</p>
<p>构造方法的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">class_name</span><span class="params">()</span>&#123;&#125;    <span class="comment">// 默认无参构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ciass_name</span><span class="params">([paramList])</span>&#123;&#125;    <span class="comment">// 定义构造方法</span></span><br><span class="line">  …</span><br><span class="line">  <span class="comment">// 类主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个类中，与类名相同的方法就是构造方法。每个类可以具有多个构造方法，但要求它们各自包含不同的方法参数。</p>
<p>构造方法主要有无参构造方法和有参构造方法两种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> m;  <span class="comment">// 定义私有变量</span></span><br><span class="line">  MyClass() &#123;</span><br><span class="line">    <span class="comment">// 定义无参的构造方法</span></span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  MyClass(<span class="type">int</span> m) &#123;</span><br><span class="line">    <span class="comment">// 定义有参的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.m = m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个类中定义多个具有不同参数的同名方法，这就是方法的重载。这两个构造方法的名称都与类名相同，均为<code>MyClass</code>。在实例化该类时可以调用不同的构造方法进行初始化。</p>
<p>注意：类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。</p>
<blockquote>
<p>提示：无参数的构造方法也被称为<code>Nullary</code>构造方法。只有编译程序自动加入的构造方法，才称为默认构造函数。如果自行编写无参数、没有内容的构造函数，就不称为默认构造函数了（只是<code>Nullary</code>构造函数）。虽然只是名词定义，不过认证考试时要区别一下两者的不同。</p>
</blockquote>
<p>要在不同的条件下使用不同的初始化行为创建类的对象，这时候就需要在一个类中创建多个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">  <span class="comment">// 定义带有一个参数的构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义带有两个参数的构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;大家好！我是新来的员工，我叫&quot;</span>+name+<span class="string">&quot;，今年&quot;</span>+age+<span class="string">&quot;岁。&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWorker</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------带有一个参数的构造方法-----------&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用带有一个参数的构造方法</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">    System.out.println(worker1);</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------带有两个参数的构造方法------------&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用带有两个参数的构造方法</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;李丽&quot;</span>,<span class="number">25</span>);</span><br><span class="line">    System.out.println(worker2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 Java 对象都是在堆中构造的，构造器总是伴随着<code>new</code>操作符一起使用。</p>
<p>输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-----------带有一个参数的构造方法-----------</span><br><span class="line">大家好！我是新来的员工，我叫张强，今年0岁。</span><br><span class="line">-----------带有两个参数的构造方法------------</span><br><span class="line">大家好！我是新来的员工，我叫李丽，今年25岁。</span><br></pre></td></tr></table></figure>
<p>通过调用带参数的构造方法，在创建对象时，一并完成了对象成员的初始化工作，简化了对象初始化的代码。</p>
<h1 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h1><p>析构方法与构造方法相反，当对象脱离其作用域时（例如对象所在的方法已调用完毕），系统自动执行析构方法。析构方法往往用来做清理垃圾碎片的工作，例如在建立对象时用<code>new</code>开辟了一片内存空间，应退出前在析构方法中将其释放。</p>
<p>在 Java 的<code>Object</code>类中还提供了一个<code>protected</code>类型的<code>finalize()</code>方法，因此任何 Java 类都可以覆盖这个方法，在这个方法中进行释放对象所占有的相关资源的操作。</p>
<p>对象的<code>finalize()</code>方法具有如下特点：</p>
<ul>
<li>垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。</li>
<li><code>finalize()</code>方法有可能使用对象复活，使对象恢复到可触及状态。</li>
<li>垃圾回收器在执行<code>finalize()</code>方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 对象的清理工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面通过一个例子来讲解析构方法的使用。该例子计算从类中实例化对象的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 计数器变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.count++;    <span class="comment">// 创建实例时增加值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取计数器的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 析构方法</span></span><br><span class="line">    <span class="built_in">this</span>.count--;    <span class="comment">// 实例销毁时减少值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象销毁&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCounter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Counter</span> <span class="variable">cnt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();    <span class="comment">// 建立第一个实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数量：&quot;</span>+ cnt1.getCount());    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="type">Counter</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();    <span class="comment">// 建立第二个实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数量：&quot;</span>+ cnt2.getCount());    <span class="comment">// 输出2</span></span><br><span class="line">    cnt2 = <span class="literal">null</span>;    <span class="comment">// 销毁实例2</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.gc();    <span class="comment">// 清理内存</span></span><br><span class="line">      Thread.currentThread().sleep(<span class="number">1000</span>);    <span class="comment">// 延时1000毫秒</span></span><br><span class="line">      System.out.println(<span class="string">&quot;数量：&quot;</span>+cnt1.getCount());    <span class="comment">// 输出1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数量：1</span><br><span class="line">数量：2</span><br><span class="line">对象销毁</span><br><span class="line">数量：1</span><br></pre></td></tr></table></figure>
<p>技巧：由于<code>finalize()</code>方法的不确定性，所以在程序中可以调用<code>System.gc()</code>或者<code>Runtime.gc()</code>方法提示垃圾回收器尽快执行垃圾回收操作。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2020/09/13/java/%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/09/17/java/%E5%9F%BA%E7%A1%80/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Java 修饰符和关键字
          
        </div>
      </a>
    
    
      <a href="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">数据链路层——使用广播信道</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>