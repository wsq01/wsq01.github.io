<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Java 输入输出流 |  学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-java/基础/Java输入输出流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Java 输入输出流
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" class="article-date">
  <time datetime="2020-11-14T08:31:41.000Z" itemprop="datePublished">2020-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">12.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">49 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><p>Java 程序通过流来完成输入&#x2F;输出，所有的输入&#x2F;输出以流的形式处理。</p>
<p>输入就是将数据从各种输入设备（包括文件、键盘等）中读取到内存中，输出则正好相反，是将数据写入到各种输出设备（比如文件、显示器、磁盘等）。</p>
<p>数据流是 Java 进行 I&#x2F;O 操作的对象，它按照不同的标准可以分为不同的类别。</p>
<ul>
<li>按照流的方向主要分为输入流和输出流两大类。</li>
<li>数据流按照数据单位的不同分为字节流和字符流。</li>
<li>按照功能可以划分为节点流和处理流。</li>
</ul>
<p>数据流的处理只能按照数据序列的顺序来进行，即前一个数据处理完之后才能处理后一个数据。数据流以输入流的形式被程序获取，再以输出流的形式将数据输出到其它设备。</p>
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/1.png" class="" title="输入流模式">
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/2.png" class="" title="输出流模式">

<h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p>Java 流相关的类都封装在<code>java.io</code>包中，而且每个数据流都是一个对象。所有输入流类都是<code>InputStream</code>抽象类（字节输入流）和<code>Reader</code>抽象类（字符输入流）的子类。</p>
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/3.png" class="" title="InputStream类的层次结构图">

<p><code>InputStream</code>类中所有方法遇到错误时都会引发<code>IOException</code>异常。如下是该类中包含的常用方法。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流读入一个 8 字节的数据，将它转换成一个 0~ 255 的整数，返回一个整数，如果遇到输入流的结尾返回 -1</td>
</tr>
<tr>
<td align="center">int read(byte[] b)</td>
<td align="center">从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，返回的字节数表示读取的字节数，如果遇到输入流的结尾返回 -1</td>
</tr>
<tr>
<td align="center">int read(byte[] b,int off,int len)</td>
<td align="center">从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，其中 off 是指在数组中开始保存数据位置的起始下标，len 是指读取字节的位数。返回的是实际读取的字节数，如果遇到输入流的结尾则返回 -1</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭数据流，当完成对数据流的操作之后需要关闭数据流</td>
</tr>
<tr>
<td align="center">int available()</td>
<td align="center">返回可以从数据源读取的数据流的位数。</td>
</tr>
<tr>
<td align="center">skip(long n)</td>
<td align="center">从输入流跳过参数 n 指定的字节数目</td>
</tr>
<tr>
<td align="center">boolean markSupported()</td>
<td align="center">判断输入流是否可以重复读取，如果可以就返回 true</td>
</tr>
<tr>
<td align="center">void mark(int readLimit)</td>
<td align="center">如果输入流可以被重复读取，从流的当前位置开始设置标记，readLimit 指定可以设置标记的字节数</td>
</tr>
<tr>
<td align="center">void reset()</td>
<td align="center">使输入流重新定位到刚才被标记的位置，这样可以重新读取标记过的数据</td>
</tr>
</tbody></table>
<p>上述最后 3 个方法一般会结合在一起使用，首先使用<code>markSupported()</code>判断，如果可以重复读取，则使用<code>mark(int readLimit)</code>方法进行标记，标记完成之后可以使用<code>read()</code>方法读取标记范围内的字节数，最后使用<code>reset()</code>方法使输入流重新定位到标记的位置，继而完成重复读取操作。</p>
<p>Java 中的字符是 Unicode 编码，即双字节的，而<code>InputerStream</code>是用来处理单字节的，在处理字符文本时不是很方便。这时可以使用文本输入流<code>Reader</code>类，该类是字符输入流的抽象类，即所有字符输入流的实现都是它的子类，该类的方法与<code>InputerSteam</code>类的方法类似。</p>
<h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>所有输出流类都是<code>OutputStream</code>抽象类（字节输出流）和<code>Writer</code>抽象类（字符输出流）的子类。其中<code>OutputStream</code>类是字节输出流的抽象类，是所有字节输出流的父类。</p>
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/4.png" class="" title="OutputStream类的层次结构图">

<p><code>OutputStream</code>类用于以二进制的形式将数据写入目标设备，该类是抽象类，不能被实例化。<code>OutputStream</code>类提供了一系列跟数据输出有关的方法。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int write(b)</td>
<td align="center">将指定字节的数据写入到输出流</td>
</tr>
<tr>
<td align="center">int write (byte[] b)</td>
<td align="center">将指定字节数组的内容写入输出流</td>
</tr>
<tr>
<td align="center">int write (byte[] b,int off,int len)</td>
<td align="center">将指定字节数组从 off 位置开始的 len 字节的内容写入输出流</td>
</tr>
<tr>
<td align="center">close()</td>
<td align="center">关闭数据流，当完成对数据流的操作之后需要关闭数据流</td>
</tr>
<tr>
<td align="center">flush()</td>
<td align="center">刷新输出流，强行将缓冲区的内容写入输出流</td>
</tr>
</tbody></table>
<h1 id="系统流"><a href="#系统流" class="headerlink" title="系统流"></a>系统流</h1><p>每个 Java 程序运行时都带有一个系统流，系统流对应的类为<code>java.lang.System</code>。<code>Sytem</code>类封装了 Java 程序运行时的 3 个系统流，分别通过<code>in、out</code>和<code>err</code>变量来引用。</p>
<ul>
<li><code>System.in</code>：标准输入流，默认设备是键盘。</li>
<li><code>System.out</code>：标准输出流，默认设备是控制台。</li>
<li><code>System.err</code>：标准错误流，默认设备是控制台。</li>
</ul>
<p>以上变量的作用域为<code>public</code>和<code>static</code>，因此在程序的任何部分都不需引用<code>System</code>对象就可以使用它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] byteData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>]; <span class="comment">// 声明一个字节数组</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入英文：&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.in.read(byteData);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;您输入的内容如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; byteData.length; i++) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) byteData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>System.in</code>是<code>InputStream</code>类的一个对象，因此上述代码的<code>System.in.read()</code>方法实际是访问<code>InputStream</code>类定义的<code>read()</code>方法。该方法可以从键盘读取一个或多个字符。对于<code>System.out</code>输出流主要用于将指定内容输出到控制台。</p>
<p><code>System.out</code>和<code>System.error</code>是<code>PrintStream</code>类的对象。因为<code>PrintStream</code>是一个从<code>OutputStream</code>派生的输出流，所以它还执行低级别的<code>write()</code>方法。因此，除了<code>print()</code>和<code>println()</code>方法可以完成控制台输出以外，<code>System.out</code>还可以调用<code>write()</code>方法实现控制台输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void write(int byteval) throws IOException</span><br></pre></td></tr></table></figure>
<p>该方法通过<code>byteval</code>参数向文件写入指定的字节。在实际操作中，<code>print()</code>方法和<code>println()</code>方法比<code>write()</code>方法更常用。</p>
<p>注意：尽管它们通常用于对控制台进行读取和写入字符，但是这些都是字节流。因为预定义流是没有引入字符流的 Java 原始规范的一部分，所以它们不是字符流而是字节流，但是在 Java 中可以将它们打包到基于字符的流中使用。</p>
<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>计算机中，任何的文字都是以指定的编码方式存在的，最常见的是 ISO8859-1、GBK&#x2F;GB2312、Unicode、 UTF 编码。</p>
<ul>
<li>ISO8859-1：属于单字节编码，最多只能表示 0~255 的字符范围。</li>
<li>GBK&#x2F;GB2312：中文的国标编码，用来表示汉字，属于双字节编码。GBK 可以表示简体中文和繁体中文，而 GB2312 只能表示简体中文。GBK 兼容 GB2312。</li>
<li>Unicode：是一种编码规范，是为解决全球字符通用编码而设计的。UTF-8 和 UTF-16 是这种规范的一种实现，此编码不兼容 ISO8859-1 编码。Java 内部采用此编码。</li>
<li>UTF：UTF 编码兼容了 ISO8859-1 编码，同时也可以用来表示所有的语言字符，不过 UTF 编码是不定长编码，每一个字符的长度为 1~6 个字节不等。一般在中文网页中使用此编码，可以节省空间。</li>
</ul>
<p>在程序中如果处理不好字符编码，就有可能出现乱码问题。例如现在本机的默认编码是 GBK，但在程序中使用了 ISO8859-1 编码，则就会出现字符的乱码问题。为了避免产生乱码，程序编码应与本地的默认编码保持一致。</p>
<p>本地的默认编码可以使用<code>System</code>类查看。Java 中 System 类可以取得与系统有关的信息，所以直接使用此类可以找到系统的默认编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title function_">getProperty</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>使用上述方法可以查看 JVM 的默认编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前系统编码</span></span><br><span class="line">  System.out.println(<span class="string">&quot;系统默认编码：&quot;</span> + System.getProperty(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果如下：</span></span><br><span class="line"><span class="comment">// 系统默认编码：GBK</span></span><br></pre></td></tr></table></figure>
<p>现在本地的默认编码是 GBK，下面通过 ISO8859-1 编码对文字进行编码转换。如果要实现编码的转换可以使用<code>String</code>类中的<code>getBytes(String charset)</code>方法，此方法可以设置指定的编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charset);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 实例化输出流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">    <span class="comment">// 指定ISO8859-1编码</span></span><br><span class="line">    <span class="type">byte</span> b[] = <span class="string">&quot;hello！&quot;</span>.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>);</span><br><span class="line">    <span class="comment">// 保存转码之后的数据</span></span><br><span class="line">    out.write(b);</span><br><span class="line">    <span class="comment">// 关闭输出流</span></span><br><span class="line">    out.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后可以发现，因为编码不一致，所以在保存时出现了乱码。在 Java 的开发中，乱码是一个比较常见的问题，乱码的产生就有一个原因，即输出内容的编码与接收内容的编码不一致。</p>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p><code>File</code>类是<code>java.io</code>包中唯一代表磁盘文件本身的对象，也就是说，如果希望在程序中操作文件和目录，则都可以通过<code>File</code>类来完成。<code>File</code>类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等。</p>
<p><code>File</code>类不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</p>
<p><code>File</code>类提供了如下三种形式构造方法。</p>
<ul>
<li><code>File(String path)</code>：如果<code>path</code>是实际存在的路径，则该<code>File</code>对象表示的是目录；如果<code>path</code>是文件名，则该<code>File</code>对象表示的是文件。</li>
<li><code>File(String path, String name)</code>：<code>path</code>是路径名，<code>name</code>是文件名。</li>
<li><code>File(File dir, String name)</code>：<code>dir</code>是路径对象，<code>name</code>是文件名。</li>
</ul>
<p><code>File</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean canRead()</td>
<td align="center">测试应用程序是否能从指定的文件中进行读取</td>
</tr>
<tr>
<td align="center">boolean canWrite()</td>
<td align="center">测试应用程序是否能写当前文件</td>
</tr>
<tr>
<td align="center">boolean delete()</td>
<td align="center">删除当前对象指定的文件</td>
</tr>
<tr>
<td align="center">boolean exists()</td>
<td align="center">测试当前 File 是否存在</td>
</tr>
<tr>
<td align="center">String getAbsolutePath()</td>
<td align="center">返回由该对象表示的文件的绝对路径名</td>
</tr>
<tr>
<td align="center">String getName()</td>
<td align="center">返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</td>
</tr>
<tr>
<td align="center">String getParent()</td>
<td align="center">返回当前 File 对象所对应目录（最后一级子目录）的父目录名</td>
</tr>
<tr>
<td align="center">boolean isAbsolute()</td>
<td align="center">测试当前 File 对象表示的文件是否为一个绝对路径名。该方法消除了不同平台的差异，可以直接判断 file 对象是否为绝对路径。在 UNIX&#x2F;Linux&#x2F;BSD 等系统上，如果路径名开头是一条斜线&#x2F;，则表明该 File 对象对应一个绝对路径；在 Windows 等系统上，如果路径开头是盘符，则说明它是一个绝对路径。</td>
</tr>
<tr>
<td align="center">boolean isDirectory()</td>
<td align="center">测试当前 File 对象表示的文件是否为一个路径</td>
</tr>
<tr>
<td align="center">boolean isFile()</td>
<td align="center">测试当前 File 对象表示的文件是否为一个“普通”文件</td>
</tr>
<tr>
<td align="center">long lastModified()</td>
<td align="center">返回当前 File 对象表示的文件最后修改的时间</td>
</tr>
<tr>
<td align="center">long length()</td>
<td align="center">返回当前 File 对象表示的文件长度</td>
</tr>
<tr>
<td align="center">String[] list()</td>
<td align="center">返回当前 File 对象指定的路径文件列表</td>
</tr>
<tr>
<td align="center">String[] list(FilenameFilter)</td>
<td align="center">返回当前 File 对象指定的目录中满足指定过滤器的文件列表</td>
</tr>
<tr>
<td align="center">boolean mkdir()</td>
<td align="center">创建一个目录，它的路径名由当前 File 对象指定</td>
</tr>
<tr>
<td align="center">boolean mkdirs()</td>
<td align="center">创建一个目录，它的路径名由当前 File 对象指定</td>
</tr>
<tr>
<td align="center">boolean renameTo(File)</td>
<td align="center">将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</td>
</tr>
</tbody></table>
<p><code>File</code>类中有以下两个常用常量：</p>
<ul>
<li><code>public static final String pathSeparator</code>：指的是分隔连续多个路径字符串的分隔符，Windows 下指<code>;</code>。例如<code>java -cp test.jar;abc.jar HelloWorld</code>。</li>
<li><code>public static final String separator</code>：用来分隔同一个路径字符串中的目录的，Windows 下指<code>/</code>。例如<code>C:/Program Files/Common Files</code>。</li>
</ul>
<p>注意：可以看到<code>File</code>类的常量定义的命名规则不符合标准命名规则，常量名没有全部大写，这是因为 Java 的发展经过了一段相当长的时间，而命名规范也是逐步形成的，<code>File</code>类出现较早，所以当时并没有对命名规范有严格的要求，这些都属于 Java 的历史遗留问题。</p>
<p>Windows 的路径分隔符使用反斜线“\”，而 Java 程序中的反斜线表示转义字符，所以如果需要在 Windows 的路径下包括反斜线，则应该使用两条反斜线或直接使用斜线“&#x2F;”也可以。Java 程序支持将斜线当成平台无关的路径分隔符。</p>
<p>假设在 Windows 操作系统中有一文件<code>D:\javaspace\hello.java</code>，在 Java 中使用的时候，其路径的写法应该为<code>D:/javaspace/hello.java</code>或者<code>D:\\javaspace\\hello.java</code>。</p>
<h2 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h2><p>获取文件属性信息的第一步是先创建一个<code>File</code>类对象并指向一个已存在的文件， 然后调用<code>File</code>的方法进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:/windows/&quot;</span>; <span class="comment">// 指定文件所在的目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path, <span class="string">&quot;notepad.exe&quot;</span>); <span class="comment">// 建立File变量,并设定由f变量引用</span></span><br><span class="line">    System.out.println(<span class="string">&quot;C:\\windows\\notepad.exe文件信息如下：&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;文件长度：&quot;</span> + f.length() + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;文件或者目录：&quot;</span> + (f.isFile() ? <span class="string">&quot;是文件&quot;</span> : <span class="string">&quot;不是文件&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;文件或者目录：&quot;</span> + (f.isDirectory() ? <span class="string">&quot;是目录&quot;</span> : <span class="string">&quot;不是目录&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;是否可读：&quot;</span> + (f.canRead() ? <span class="string">&quot;可读取&quot;</span> : <span class="string">&quot;不可读取&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;是否可写：&quot;</span> + (f.canWrite() ? <span class="string">&quot;可写入&quot;</span> : <span class="string">&quot;不可写入&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;是否隐藏：&quot;</span> + (f.isHidden() ? <span class="string">&quot;是隐藏文件&quot;</span> : <span class="string">&quot;不是隐藏文件&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;最后修改日期：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(f.lastModified()));</span><br><span class="line">    System.out.println(<span class="string">&quot;文件名称：&quot;</span> + f.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件路径：&quot;</span> + f.getPath());</span><br><span class="line">    System.out.println(<span class="string">&quot;绝对路径：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终运行效果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\windows\notepad.exe文件信息如下：</span><br><span class="line">============================================</span><br><span class="line">文件长度：193536字节</span><br><span class="line">文件或者目录：是文件</span><br><span class="line">文件或者目录：不是目录</span><br><span class="line">是否可读：可读取</span><br><span class="line">是否可写：可写入</span><br><span class="line">是否隐藏：不是隐藏文件</span><br><span class="line">最后修改日期：Mon Dec 28 02:55:19 CST 2016</span><br><span class="line">文件名称：notepad.exe</span><br><span class="line">文件路径：C:\windows\notepad.exe</span><br><span class="line">绝对路径：C:\windows\notepad.exe</span><br></pre></td></tr></table></figure>
<h2 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h2><p><code>File</code>类不仅可以获取已知文件的属性信息，还可以在指定路径创建文件，以及删除一个文件。创建文件需要调用<code>createNewFile()</code>方法，删除文件需要调用<code>delete()</code>方法。无论是创建还是删除文件通常都先调用<code>exists()</code>方法判断文件是否存在。</p>
<p>假设要在 C 盘上创建一个<code>test.txt</code>文件，程序启动时会检测该文件是否存在，如果不存在则创建；如果存在则删除它再创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\test.txt&quot;</span>); <span class="comment">// 创建指向文件的File对象</span></span><br><span class="line">    <span class="keyword">if</span> (f.exists()) <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">      f.delete(); <span class="comment">// 存在则先删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.createNewFile(); <span class="comment">// 再创建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序之后可以发现，在 C 盘中已经创建好了<code>test.txt</code>文件。但是如果在不同的操作系统中，路径的分隔符是不一样的，例如：</p>
<ul>
<li>Windows 中使用反斜杠<code>\</code>表示目录的分隔符。</li>
<li>Linux 中使用正斜杠<code>/</code>表示目录的分隔符。</li>
</ul>
<p>那么既然 Java 程序本身具有可移植性的特点，则在编写路径时最好可以根据程序所在的操作系统自动使用符合本地操作系统要求的分隔符，这样才能达到可移植性的目的。要实现这样的功能，则就需要使用<code>File</code>类中提供的两个常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>; <span class="comment">// 拼凑出可以适应操作系统的路径</span></span><br><span class="line">  <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">  <span class="keyword">if</span> (f.exists()) <span class="comment">// 判断文件是否存在</span></span><br><span class="line">  &#123;</span><br><span class="line">    f.delete(); <span class="comment">// 存在则先删除</span></span><br><span class="line">  &#125;</span><br><span class="line">  f.createNewFile(); <span class="comment">// 再创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果和前面程序一样，但是此时的程序可以在任意的操作系统中使用。</p>
<p>注意：在操作文件时一定要使用<code>File.separator</code>表示分隔符。在程序的开发中，往往会使用 Windows 开发环境，因为在 Windows 操作系统中支持的开发工具较多，使用方便，而在程序发布时往往是直接在 Linux 或其它操作系统上部署，所以这时如果不使用<code>File.separator</code>，则程序运行就有可能存在问题。</p>
<h2 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h2><p><code>File</code>类除了对文件的创建和删除外，还可以创建和删除目录。创建目录需要调用<code>mkdir()</code>方法，删除目录需要调用<code>delete()</code>方法。无论是创建还是删除目录都可以调用<code>exists()</code>方法判断目录是否存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:/config/&quot;</span>; <span class="comment">// 指定目录位置</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path); <span class="comment">// 创建File对象</span></span><br><span class="line">    <span class="keyword">if</span> (f.exists()) &#123;</span><br><span class="line">      f.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    f.mkdir(); <span class="comment">// 创建目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><p>通过遍历目录可以在指定的目录中查找文件，或者显示所有的文件列表。<code>File</code>类的<code>list()</code>方法提供了遍历目录功能，该方法有如下两种重载形式。</p>
<ol>
<li><code>String[] list()</code><br>该方法表示返回由<code>File</code>对象表示目录中所有文件和子目录名称组成的字符串数组，如果调用的<code>File</code>对象不是目录，则返回<code>null</code>。<br>提示：<code>list()</code>方法返回的数组中仅包含文件名称，而不包含路径。但不保证所得数组中的相同字符串将以特定顺序出现，特别是不保证它们按字母顺序出现。</li>
<li><code>String[] list(FilenameFilter filter)</code><br>该方法的作用与<code>list()</code>方法相同，不同的是返回数组中仅包含符合<code>filter</code>过滤器的文件和目录，如果<code>filter</code>为<code>null</code>，则接受所有名称。</li>
</ol>
<p>假设要遍历 C 盘根目录下的所有文件和目录，并显示文件或目录名称、类型及大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/&quot;</span>); <span class="comment">// 建立File变量,并设定由f变量变数引用</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件名称\t\t文件类型\t\t文件大小&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;===================================================&quot;</span>);</span><br><span class="line">    String fileList[] = f.list(); <span class="comment">// 调用不带参数的list()方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fileList.length; i++) &#123; <span class="comment">// 遍历返回的字符数组</span></span><br><span class="line">      System.out.print(fileList[i] + <span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">      System.out.print((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/&quot;</span>, fileList[i])).isFile() ? <span class="string">&quot;文件&quot;</span> + <span class="string">&quot;\t\t&quot;</span> : <span class="string">&quot;文件夹&quot;</span> + <span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">      System.out.println((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/&quot;</span>, fileList[i])).length() + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>list()</code>方法返回的字符数组中仅包含文件名称，因此为了获取文件类型和大小，必须先转换为<code>File</code>对象再调用其方法。如下所示的是实例的运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">文件名称  文件类型  文件大小</span><br><span class="line">===================================================</span><br><span class="line">$Recycle.Bin  文件夹  4096字节</span><br><span class="line">Documents and Settings  文件夹  0字节</span><br><span class="line">Download  文件夹  0字节</span><br><span class="line">DRIVERS  文件夹  0字节</span><br><span class="line">FibocomLog  文件夹  0字节</span><br><span class="line">Gateface  文件夹  0字节</span><br><span class="line">GFPageCache  文件夹  0字节</span><br><span class="line">hiberfil.sys  文件  3375026176字节</span><br><span class="line">Intel  文件夹  0字节</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>假设希望只列出目录下的某些文件，这就需要调用带过滤器参数的<code>list()</code>方法。首先需要创建文件过滤器，该过滤器必须实现<code>java.io.FilenameFilter</code>接口，并在<code>accept()</code>方法中指定允许的文件类型。</p>
<p>如下所示为允许 SYS、TXT 和 BAK 格式文件的过滤器实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageFilter</span> <span class="keyword">implements</span> <span class="title class_">FilenameFilter</span> &#123;</span><br><span class="line">  <span class="comment">// 实现 FilenameFilter 接口</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定允许的文件类型</span></span><br><span class="line">    <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.sys&quot;</span>) || name.endsWith(<span class="string">&quot;.txt&quot;</span>) || name.endsWith(<span class="string">&quot;.bak&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建的过滤器名称为<code>ImageFilter</code>，接下来只需要将该名称传递给<code>list()</code>方法即可实现筛选文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fileList[] = f.list(<span class="keyword">new</span> <span class="title class_">ImageFilter</span>());</span><br></pre></td></tr></table></figure>
<p>再次运行程序，遍历结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件名称        文件类型        文件大小</span><br><span class="line">===================================================</span><br><span class="line">offline_FtnInfo.txt        文件        296字节</span><br><span class="line">pagefile.sys        文件        8436592640字节</span><br></pre></td></tr></table></figure>
<h1 id="字节流的使用"><a href="#字节流的使用" class="headerlink" title="字节流的使用"></a>字节流的使用</h1><h2 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h2><p><code>InputStream</code>类及其子类的对象表示字节输入流，<code>InputStream</code>类的常用子类：</p>
<ul>
<li><code>ByteArrayInputStream</code>类：将字节数组转换为字节输入流，从中读取字节。</li>
<li><code>FileInputStream</code>类：从文件中读取数据。</li>
<li><code>PipedInputStream</code>类：连接到一个<code>PipedOutputStream</code>（管道输出流）。</li>
<li><code>SequenceInputStream</code>类：将多个字节输入流串联成一个字节输入流。</li>
<li><code>ObjectInputStream</code>类：将对象反序列化。</li>
</ul>
<p>使用<code>InputStream</code>类的方法可以从流中读取一个或一批字节。<code>InputStream</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流中读取一个 8 位的字节，并把它转换为 0~255 的整数，最后返回整数。<br>如果返回 -1，则表示已经到了输入流的末尾。<br>为了提高 I&#x2F;O 操作的效率，建议尽量使用 read() 方法的另外两种形式</td>
</tr>
<tr>
<td align="center">int read(byte[] b)</td>
<td align="center">从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。<br>该方法返回读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="center">int read(byte[] b, int off, int len)</td>
<td align="center">从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。<br>其中，off 指定在字节数组中开始保存数据的起始下标；len 指定读取的字节数。<br>该方法返回实际读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输入流。在读操作完成后，应该关闭输入流，系统将会释放与这个输入流相关的资源。<br>注意，InputStream 类本身的 close() 方法不执行任何操作，但是它的许多子类重写了 close() 方法</td>
</tr>
<tr>
<td align="center">int available()</td>
<td align="center">返回可以从输入流中读取的字节数</td>
</tr>
<tr>
<td align="center">long skip(long n)</td>
<td align="center">从输入流中跳过参数 n 指定数目的字节。该方法返回跳过的字节数</td>
</tr>
<tr>
<td align="center">void mark(int readLimit)</td>
<td align="center">在输入流的当前位置开始设置标记，参数 readLimit 则指定了最多被设置标记的字节数</td>
</tr>
<tr>
<td align="center">boolean markSupported()</td>
<td align="center">判断当前输入流是否允许设置标记，是则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">void reset()</td>
<td align="center">将输入流的指针返回到设置标记的起始处</td>
</tr>
</tbody></table>
<p>注意：在使用<code>mark()</code>方法和<code>reset()</code>方法之前，需要判断该文件系统是否支持这两个方法，以避免对程序造成影响。</p>
<h2 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h2><p><code>OutputStream</code>类及其子类的对象表示一个字节输出流。<code>OutputStream</code>类的常用子类如下。</p>
<ul>
<li><code>ByteArrayOutputStream</code>类：向内存缓冲区的字节数组中写数据。</li>
<li><code>FileOutputStream</code>类：向文件中写数据。</li>
<li><code>PipedOutputStream</code>类：连接到一个<code>PipedlntputStream</code>（管道输入流）。</li>
<li><code>ObjectOutputStream</code>类：将对象序列化。</li>
</ul>
<p>利用<code>OutputStream</code>类的方法可以从流中写入一个或一批字节。<code>OutputStream</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int b)</td>
<td align="center">向输出流写入一个字节。<br>这里的参数是 int 类型，但是它允许使用表达式，<br>而不用强制转换成 byte 类型。<br>为了提高 I&#x2F;O 操作的效率，建议尽量使用 write() 方法的另外两种形式</td>
</tr>
<tr>
<td align="center">void write(byte[] b)</td>
<td align="center">把参数 b 指定的字节数组中的所有字节写到输出流中</td>
</tr>
<tr>
<td align="center">void write(byte[] b,int off,int len)</td>
<td align="center">把参数 b 指定的字节数组中的若干字节写到输出流中。<br>其中，off 指定字节数组中的起始下标，len 表示元素个数</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输出流。写操作完成后，应该关闭输出流。<br>系统将会释放与这个输出流相关的资源。<br>注意，OutputStream 类本身的 close() 方法不执行任何操作，但是它的许多子类重写了 close() 方法</td>
</tr>
<tr>
<td align="center">void flush()</td>
<td align="center">为了提高效率，在向输出流中写入数据时，数据一般会先保存到内存缓冲区中，只有当缓冲区中的数据达到一定程度时，缓冲区中的数据才会被写入输出流中。<br>使用 flush() 方法则可以强制将缓冲区中的数据写入输出流，并清空缓冲区</td>
</tr>
</tbody></table>
<h2 id="字节数组输入流"><a href="#字节数组输入流" class="headerlink" title="字节数组输入流"></a>字节数组输入流</h2><p><code>ByteArrayInputStream</code>类可以从内存的字节数组中读取数据，该类有如下两种构造方法重载形式。</p>
<ul>
<li><code>ByteArrayInputStream(byte[] buf)</code>：创建一个字节数组输入流，字节数组类型的数据源由参数 buf 指定。</li>
<li><code>ByteArrayInputStream(byte[] buf,int offse,int length)</code>：创建一个字节数组输入流，其中，参数 buf 指定字节数组类型的数据源，offset 指定在数组中开始读取数据的起始下标位置，length 指定读取的元素个数。</li>
</ul>
<p>使用<code>ByteArrayInputStream</code>类实现从一个字节数组中读取数据，再转换为<code>int</code>型进行输出。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test08</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">25</span>, -<span class="number">22</span>, -<span class="number">5</span>, <span class="number">23</span> &#125;; <span class="comment">// 创建数组</span></span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// 创建字节数组输入流</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bais.read(); <span class="comment">// 从输入流中读取下一个字节，并转换成int型数据</span></span><br><span class="line">    <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123; <span class="comment">// 如果不返回-1，则表示没有到输入流的末尾</span></span><br><span class="line">      System.out.println(<span class="string">&quot;原值=&quot;</span> + (<span class="type">byte</span>) i + <span class="string">&quot;\t\t\t转换为int类型=&quot;</span> + i);</span><br><span class="line">      i = bais.read(); <span class="comment">// 读取下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，字节输入流<code>bais</code>从字节数组<code>b</code>的第一个元素开始读取 4 字节元素，并将这 4 字节转换为<code>int</code>类型数据，最后返回。</p>
<p>提示：上述示例中除了打印<code>i</code>的值外，还打印出了<code>(byte) i</code>的值，由于<code>i</code>的值是从<code>byte</code>类型的数据转换过来的，所以使用<code>(byte) i</code>可以获取原来的<code>byte</code>数据。</p>
<p>该程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原值=1   转换为int类型=1</span><br><span class="line">原值=-1   转换为int类型=255</span><br><span class="line">原值=25   转换为int类型=25</span><br><span class="line">原值=-22   转换为int类型=234</span><br><span class="line">原值=-5   转换为int类型=251</span><br><span class="line">原值=23   转换为int类型=23</span><br></pre></td></tr></table></figure>
<p>从上述的运行结果可以看出，字节类型的数据 -1 和 -22 转换成<code>int</code>类型的数据后变成了 255 和 234，对这种结果的解释如下：</p>
<ul>
<li>字节类型的 1，二进制形式为<code>00000001</code>，转换为<code>int</code>类型后的二进制形式为<code>00000000 00000000 0000000000000001</code>，对应的十进制数为 1。</li>
<li>字节类型的 -1，二进制形式为<code>11111111</code>，转换为<code>int</code>类型后的二进制形式为<code>00000000 00000000 0000000011111111</code>，对应的十进制数为 255。</li>
</ul>
<p>可见，从字节类型的数转换成<code>int</code>类型的数时，如果是正数，则数值不变；如果是负数，则由于转换后，二进制形式前面直接补了 24 个 0，这样就改变了原来表示负数的二进制补码形式，所以数值发生了变化，即变成了正数。</p>
<p>提示：负数的二进制形式以补码形式存在，例如 -1，其二进制形式是这样得来的：首先获取 1 的原码<code>00000001</code>，然后进行反码操作，1 变成 0，0 变成 1，这样就得到<code>11111110</code>，最后进行补码操作，就是在反码的末尾位加 1，这样就变成了<code>11111111</code>。</p>
<h2 id="字节数组输出流"><a href="#字节数组输出流" class="headerlink" title="字节数组输出流"></a>字节数组输出流</h2><p><code>ByteArrayOutputStream</code>类可以向内存的字节数组中写入数据，该类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>ByteArrayOutputStream()</code>：创建一个字节数组输出流，输出流缓冲区的初始容量大小为 32 字节。</li>
<li><code>ByteArrayOutputStream(int size)</code>：创建一个字节数组输出流，输出流缓冲区的初始容量大小由参数<code>size</code>指定。</li>
</ul>
<p><code>ByteArrayOutputStream</code>类中除了有前面介绍的字节输出流中的常用方法以外，还有如下两个方法。</p>
<ul>
<li><code>intsize()</code>：返回缓冲区中的当前字节数。</li>
<li><code>byte[] toByteArray()</code>：以字节数组的形式返回输出流中的当前内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">25</span>, -<span class="number">22</span>, -<span class="number">5</span>, <span class="number">23</span> &#125;; <span class="comment">// 创建数组</span></span><br><span class="line">    baos.write(b, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// 将字节数组b中的前4个字节元素写到输出流中</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数组中一共包含：&quot;</span> + baos.size() + <span class="string">&quot;字节&quot;</span>); <span class="comment">// 输出缓冲区中的字节数</span></span><br><span class="line">    <span class="type">byte</span>[] newByteArray = baos.toByteArray(); <span class="comment">// 将输出流中的当前内容转换成字节数组</span></span><br><span class="line">    System.out.println(Arrays.toString(newByteArray)); <span class="comment">// 输出数组中的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组中一共包含：6字节</span><br><span class="line">[1, -1, 25, -22, -5, 23]</span><br></pre></td></tr></table></figure>
<h2 id="文件输入流"><a href="#文件输入流" class="headerlink" title="文件输入流"></a>文件输入流</h2><p><code>FileInputStream</code>表示从文件系统的某个文件中获取输入字节。通过使用<code>FileInputStream</code>可以访问文件中的一个字节、一批字节或整个文件。</p>
<p>在创建<code>FileInputStream</code>类的对象时，如果找不到指定的文件将拋出<code>FileNotFoundException</code>异常，该异常必须捕获或声明拋出。</p>
<p><code>FileInputStream</code>常用的构造方法主要有如下两种重载形式。</p>
<ul>
<li><code>FileInputStream(File file)</code>：通过打开一个到实际文件的连接来创建一个<code>FileInputStream</code>，该文件通过文件系统中的<code>File</code>对象<code>file</code>指定。</li>
<li><code>FileInputStream(String name)</code>：通过打开一个到实际文件的链接来创建一个<code>FileInputStream</code>，该文件通过文件系统中的路径名<code>name</code>指定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 以File对象作为参数创建FileInputStream对象</span></span><br><span class="line">  <span class="type">FileInputStream</span> <span class="variable">fis1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:/mxl.txt&quot;</span>));</span><br><span class="line">  <span class="comment">// 以字符串值作为参数创建FilelnputStream对象</span></span><br><span class="line">  <span class="type">FileInputStream</span> <span class="variable">fis2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;F:/mxl.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;指定的文件找不到!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个 D:\myJava\HelloJava.java 文件，下面使用 FileInputStream 类读取并输出该文件的内容。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/myJava/HelloJava.java&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 因为File没有读写的能力,所以需要有个InputStream</span></span><br><span class="line">      fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">      <span class="comment">// 定义一个字节数组</span></span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 得到实际读取到的字节数</span></span><br><span class="line">      System.out.println(<span class="string">&quot;D:\\myJava\\HelloJava.java文件内容如下：&quot;</span>);</span><br><span class="line">      <span class="comment">// 循环读取</span></span><br><span class="line">      <span class="keyword">while</span> ((n = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, n); <span class="comment">// 将数组中从下标0到n的内容给s</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>FileInputStream</code>类重写了父类<code>InputStream</code>中的<code>read()</code>方法、<code>skip()</code>方法、<code>available()</code>方法和<code>close()</code>方法，不支持<code>mark()</code>方法和<code>reset()</code>方法。</p>
</blockquote>
<h2 id="文件输出流"><a href="#文件输出流" class="headerlink" title="文件输出流"></a>文件输出流</h2><p><code>FileOutputStream</code>类继承自<code>OutputStream</code>类，重写和实现了父类中的所有方法。<code>FileOutputStream</code>类的对象表示一个文件字节输出流，可以向流中写入一个字节或一批字节。在创建<code>FileOutputStream</code>类的对象时，如果指定的文件不存在，则创建一个新文件；如果文件已存在，则清除原文件的内容重新写入。</p>
<p><code>FileOutputStream</code>类的构造方法主要有如下 4 种重载形式。</p>
<ul>
<li><code>FileOutputStream(File file)</code>：创建一个文件输出流，参数<code>file</code>指定目标文件。</li>
<li><code>FileOutputStream(File file,boolean append)</code>：创建一个文件输出流，参数<code>file</code>指定目标文件，<code>append</code>指定是否将数据添加到目标文件的内容末尾，如果为<code>true</code>，则在末尾添加；如果为<code>false</code>，则覆盖原有内容；其默认值为<code>false</code>。</li>
<li><code>FileOutputStream(String name)</code>：创建一个文件输出流，参数<code>name</code>指定目标文件的文件路径信息。</li>
<li><code>FileOutputStream(String name,boolean append)</code>：创建一个文件输出流，参数<code>name</code>和<code>append</code>的含义同上。</li>
</ul>
<p>注意：使用构造方法<code>FileOutputStream(String name,boolean append)</code>创建一个文件输出流对象，它将数据附加在现有文件的末尾。该字符串<code>name</code>指明了原文件，如果只是为了附加数据而不是重写任何已有的数据，布尔类型参数<code>append</code>的值应为<code>true</code>。</p>
<p>对文件输出流有如下四点说明：<br>在<code>FileOutputStream</code>类的构造方法中指定目标文件时，目标文件可以不存在。<br>目标文件的名称可以是任意的，例如<code>D:\\abc、D:\\abc.de 和 D:\\abc.de.fg</code>等都可以，可以使用记事本等工具打开并浏览这些文件中的内容。<br>目标文件所在目录必须存在，否则会拋出<code>java.io.FileNotFoundException</code>异常。<br>目标文件的名称不能是已存在的目录。例如 D 盘下已存在 Java 文件夹，那么就不能使用 Java 作为文件名，即不能使用<code>D:\\Java</code>，否则抛出<code>java.io.FileNotFoundException</code>异常。</p>
<p>读取<code>D:\myJava\HelloJava.java</code>文件的内容，在这里使用<code>FileInputStream</code>类实现，然后再将内容写入新的文件<code>D:\myJava\HelloJava.txt</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明FileInputStream对象fis</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明FileOutputStream对象fos</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/myJava/HelloJava.java&quot;</span>);</span><br><span class="line">      fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile); <span class="comment">// 实例化FileInputStream对象</span></span><br><span class="line">      <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/myJava/HelloJava.txt&quot;</span>); <span class="comment">// 创建目标文件对象，该文件不存在</span></span><br><span class="line">      fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile); <span class="comment">// 实例化FileOutputStream对象</span></span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 每次读取1024字节</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fis.read(bytes);</span><br><span class="line">      <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(bytes, <span class="number">0</span>, i); <span class="comment">// 向D:\HelloJava.txt文件中写入内容</span></span><br><span class="line">        i = fis.read(bytes);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;写入结束！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close(); <span class="comment">// 关闭FileInputStream对象</span></span><br><span class="line">        fos.close(); <span class="comment">// 关闭FileOutputStream对象</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，将<code>D:\myJava\HelloJava.java</code>文件中的内容通过文件输入&#x2F;输出流写入到了<code>D:\myJava\HelloJava.txt</code>文件中。由于<code>HelloJava.txt</code>文件并不存在，所以在执行程序时将新建此文件，并写入相应内容。</p>
<p>运行程序，成功后会在控制台输出“写入结束！”。此时，打开<code>D:\myJava\HelloJava.txt</code>文件会发现，其内容与<code>HelloJava.java</code>文件的内容相同。</p>
<p>技巧：在创建<code>FileOutputStream</code>对象时，如果将<code>append</code>参数设置为<code>true</code>，则可以在目标文件的内容末尾添加数据，此时目标文件仍然可以暂不存在。</p>
<h1 id="字符流的使用"><a href="#字符流的使用" class="headerlink" title="字符流的使用"></a>字符流的使用</h1><p>尽管 Java 中字节流的功能十分强大，几乎可以直接或间接地处理任何类型的输入&#x2F;输出操作，但利用它却不能直接操作 16 位的 Unicode 字符。这就要用到字符流。</p>
<h2 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h2><p><code>Reader</code>类是所有字符流输入类的父类，该类定义了许多方法，这些方法对所有子类都是有效的。</p>
<p><code>Reader</code>类的常用子类如下。</p>
<ul>
<li><code>CharArrayReader</code>类：将字符数组转换为字符输入流，从中读取字符。</li>
<li><code>StringReader</code>类：将字符串转换为字符输入流，从中读取字符。</li>
<li><code>BufferedReader</code>类：为其他字符输入流提供读缓冲区。</li>
<li><code>PipedReader</code>类：连接到一个<code>PipedWriter</code>。</li>
<li><code>InputStreamReader</code>类：将字节输入流转换为字符输入流，可以指定字符编码。</li>
</ul>
<p>与<code>InputStream</code>类相同，在<code>Reader</code>类中也包含<code>close()、mark()、skip()</code>和<code>reset()</code>等方法，这些方法可以参考<code>InputStream</code>类的方法。<code>Reader</code>类中的<code>read()</code>方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流中读取一个字符，并把它转换为 0~65535 的整数。如果返回 -1， 则表示已经到了输入流的末尾。为了提高 I&#x2F;O 操作的效率，建议尽量使用下面两种 read() 方法</td>
</tr>
<tr>
<td align="center">int read(char[] cbuf)</td>
<td align="center">从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。 该方法返回读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="center">int read(char[] cbuf,int off,int len)</td>
<td align="center">从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。其中，off 指定在字符数组中开始保存数据的起始下标，len 指定读取的字符数。该方法返回实际读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
</tbody></table>
<h2 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h2><p>与<code>Reader</code>类相反，<code>Writer</code>类是所有字符输出流的父类，该类中有许多方法，这些方法对继承该类的所有子类都是有效的。</p>
<p><code>Writer</code>类的常用子类如下。</p>
<ul>
<li><code>CharArrayWriter</code>类：向内存缓冲区的字符数组写数据。</li>
<li><code>StringWriter</code>类：向内存缓冲区的字符串（<code>StringBuffer</code>）写数据。</li>
<li><code>BufferedWriter</code>类：为其他字符输出流提供写缓冲区。</li>
<li><code>PipedWriter</code>类：连接到一个<code>PipedReader</code>。</li>
<li><code>OutputStreamReader</code>类：将字节输出流转换为字符输出流，可以指定字符编码。</li>
</ul>
<p>与<code>OutputStream</code>类相同，<code>Writer</code>类也包含<code>close()、flush()</code>等方法，这些方法可以参考<code>OutputStream</code>类的方法。<code>Writer</code>类中的<code>write()</code>方法和<code>append()</code>方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int c)</td>
<td align="center">向输出流中写入一个字符</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf)</td>
<td align="center">把参数 cbuf 指定的字符数组中的所有字符写到输出流中</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf,int off,int len)</td>
<td align="center">把参数 cbuf 指定的字符数组中的若干字符写到输出流中。其中，off 指定字符数组中的起始下标，len 表示元素个数</td>
</tr>
<tr>
<td align="center">void write(String str)</td>
<td align="center">向输出流中写入一个字符串</td>
</tr>
<tr>
<td align="center">void write(String str, int off,int len)</td>
<td align="center">向输出流中写入一个字符串中的部分字符。其中，off 指定字符串中的起始偏移量，len 表示字符个数</td>
</tr>
<tr>
<td align="center">append(char c)</td>
<td align="center">将参数 c 指定的字符添加到输出流中</td>
</tr>
<tr>
<td align="center">append(charSequence esq)</td>
<td align="center">将参数 esq 指定的字符序列添加到输出流中</td>
</tr>
<tr>
<td align="center">append(charSequence esq,int start,int end)</td>
<td align="center">将参数 esq 指定的字符序列的子序列添加到输出流中。其中，start 指定子序列的第一个字符的索引，end 指定子序列中最后一个字符后面的字符的索引，也就是说子序列的内容包含 start 索引处的字符，但不包括 end索引处的字符</td>
</tr>
</tbody></table>
<p>注意：<code>Writer</code>类所有的方法在出错的情况下都会引发<code>IOException</code>异常。关闭一个流后，再对其进行任何操作都会产生错误。</p>
<h2 id="字符文件输入流"><a href="#字符文件输入流" class="headerlink" title="字符文件输入流"></a>字符文件输入流</h2><p>为了读取方便，Java 提供了用来读取字符文件的便捷类——<code>FileReader</code>。该类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>FileReader(File file)</code>：在给定要读取数据的文件的情况下创建一个新的<code>FileReader</code>对象。其中，<code>file</code>表示要从中读取数据的文件。</li>
<li><code>FileReader(String fileName)</code>：在给定从中读取数据的文件名的情况下创建一个新<code>FileReader</code>对象。其中，<code>fileName</code>表示要从中读取数据的文件的名称，表示的是一个文件的完整路径。</li>
</ul>
<p>在用该类的构造方法创建<code>FileReader</code>读取对象时，默认的字符编码及字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在<code>FilelnputStream</code>上构造一个<code>InputStreamReader</code>。</p>
<p>注意：在创建<code>FileReader</code>对象时可能会引发一个<code>FileNotFoundException</code>异常，因此需要使用<code>try catch</code>语句捕获该异常。</p>
<p>字符流和字节流的操作步骤相同，都是首先创建输入流或输出流对象，即建立连接管道，建立完成后进行读或写操作，最后关闭输入&#x2F;输出流通道。</p>
<p>要将<code>D:\myJava\HelloJava.java</code>文件中的内容读取并输出到控制台，使用<code>FileReader</code>类的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test12</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/myJava/HelloJava.java&quot;</span>); <span class="comment">// 创建FileReader对象</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;D:\\myJava\\HelloJava.java文件内容如下：&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> ((i = fr.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 循环读取</span></span><br><span class="line">        System.out.print((<span class="type">char</span>) i); <span class="comment">// 将读取的内容强制转换为char类型</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.print(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close(); <span class="comment">// 关闭对象</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先创建了<code>FileReader</code>字符输入流对象<code>fr</code>，该对象指向<code>D:\myJava\HelloJava.java</code>文件，然后定义变量<code>i</code>来接收调用<code>read()</code>方法的返回值，即读取的字符。在<code>while</code>循环中，每次读取一个字符赋给整型变量<code>i</code>，直到读取到文件末尾时退出循环（当输入流读取到文件末尾时，会返回值 -1）。</p>
<h2 id="字符文件输出流"><a href="#字符文件输出流" class="headerlink" title="字符文件输出流"></a>字符文件输出流</h2><p>Java 提供了写入字符文件的便捷类——<code>FileWriter</code>，该类的构造方法有如下 4 种重载形式。</p>
<ul>
<li><code>FileWriter(File file)</code>：在指定<code>File</code>对象的情况下构造一个<code>FileWriter</code>对象。其中，<code>file</code>表示要写入数据的<code>File</code>对象。</li>
<li><code>FileWriter(File file,boolean append)</code>：在指定<code>File</code>对象的情况下构造一个<code>FileWriter</code>对象，如果<code>append</code>的值为<code>true</code>，则将字节写入文件末尾，而不是写入文件开始处。</li>
<li><code>FileWriter(String fileName)</code>：在指定文件名的情况下构造一个<code>FileWriter</code>对象。其中，<code>fileName</code>表示要写入字符的文件名，表示的是完整路径。</li>
<li><code>FileWriter(String fileName,boolean append)</code>：在指定文件名以及要写入文件的位置的情况下构造<code>FileWriter</code>对象。其中，<code>append</code>是一个<code>boolean</code>值，如果为<code>true</code>，则将数据写入文件末尾，而不是文件开始处。</li>
</ul>
<p>在创建<code>FileWriter</code>对象时，默认字符编码和默认字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在<code>FileOutputStream</code>上构造一个<code>OutputStreamWriter</code>对象。</p>
<p><code>FileWriter</code>类的创建不依赖于文件存在与否，如果关联文件不存在，则会自动生成一个新的文件。在创建文件之前，<code>FileWriter</code>将在创建对象时打开它作为输出。如果试图打开一个只读文件，将引发一个<code>IOException</code>异常。</p>
<p>注意：在创建<code>FileWriter</code>对象时可能会引发<code>IOException</code>或<code>SecurityException</code>异常，因此需要使用<code>try catch</code>语句捕获该异常。</p>
<p>编写一个程序，将用户输入的 4 个字符串保存到<code>D:\myJava\book.txt</code>文件中。在这里使用<code>FileWriter</code>类中的<code>write()</code>方法循环向指定文件中写入数据，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\myJava\\book.txt&quot;</span>); <span class="comment">// 创建FileWriter对象</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next(); <span class="comment">// 读取输入的名称</span></span><br><span class="line">        fw.write(name + <span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 循环写入文件</span></span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;录入完成！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fw.close(); <span class="comment">// 关闭对象</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先创建了一个指向<code>D:\myJava\book.txt</code>文件的字符文件输出流对象<code>fw</code>，然后使用<code>for</code>循环录入 4 个字符串，并调用<code>write()</code>方法将字符串写入到指定的文件中。最后在<code>finally</code>语句中关闭字符文件输出流。</p>
<h2 id="字符缓冲区输入流"><a href="#字符缓冲区输入流" class="headerlink" title="字符缓冲区输入流"></a>字符缓冲区输入流</h2><p><code>BufferedReader</code>类主要用于辅助其他字符输入流，它带有缓冲区，可以先将一批数据读到内存缓冲区。接下来的读操作就可以直接从缓冲区中获取数据，而不需要每次都从数据源读取数据并进行字符编码转换，这样就可以提高数据的读取效率。</p>
<p><code>BufferedReader</code>类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>BufferedReader(Reader in)</code>：创建一个<code>BufferedReader</code>来修饰参数<code>in</code>指定的字符输入流。</li>
<li><code>BufferedReader(Reader in,int size)</code>：创建一个<code>BufferedReader</code>来修饰参数<code>in</code>指定的字符输入流，参数<code>size</code>则用于指定缓冲区的大小，单位为字符。</li>
</ul>
<p>除了可以为字符输入流提供缓冲区以外，<code>BufferedReader</code>还提供了<code>readLine()</code>方法，该方法返回包含该行内容的字符串，但该字符串中不包含任何终止符，如果已到达流末尾，则返回<code>null</code>。<code>readLine()</code>方法表示每次读取一行文本内容，当遇到换行（<code>\n</code>）、回车（<code>\r</code>）或回车后直接跟着换行标记符即可认为某行已终止。</p>
<p>使用<code>BufferedReader</code>类中的<code>readLine()</code>方法逐行读取<code>D:\myJava\Book.txt</code>文件中的内容，并将读取的内容在控制台中打印输出，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\myJava\\book.txt&quot;</span>); <span class="comment">// 创建 FileReader 对象</span></span><br><span class="line">      br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr); <span class="comment">// 创建 BufferedReader 对象</span></span><br><span class="line">      System.out.println(<span class="string">&quot;D:\\myJava\\book.txt 文件中的内容如下：&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">strLine</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> ((strLine = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 循环读取每行数据</span></span><br><span class="line">        System.out.println(strLine);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e1) &#123;</span><br><span class="line">      e1.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close(); <span class="comment">// 关闭 FileReader 对象</span></span><br><span class="line">        br.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先分别创建了名称为<code>fr</code>的<code>FileReader</code>对象和名称为<code>br</code>的<code>BufferedReader</code>对象，然后调用<code>BufferedReader</code>对象的<code>readLine()</code>方法逐行读取文件中的内容。如果读取的文件内容为<code>Null</code>，即表明已经读取到文件尾部，此时退出循环不再进行读取操作。最后将字符文件输入流和带缓冲的字符输入流关闭。</p>
<p>运行该程序，输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\myJava\book.txt 文件中的内容如下：</span><br><span class="line">热点要闻</span><br><span class="line">个性推荐</span><br><span class="line">热搜新闻词</span><br><span class="line">本地看点</span><br></pre></td></tr></table></figure>
<h2 id="字符缓冲区输出流"><a href="#字符缓冲区输出流" class="headerlink" title="字符缓冲区输出流"></a>字符缓冲区输出流</h2><p><code>BufferedWriter</code>类主要用于辅助其他字符输出流，它同样带有缓冲区，可以先将一批数据写入缓冲区，当缓冲区满了以后，再将缓冲区的数据一次性写到字符输出流，其目的是为了提高数据的写效率。</p>
<p><code>BufferedWriter</code>类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>*ufferedWriter(Writer out)</code>：创建一个<code>BufferedWriter</code>来修饰参数<code>out</code>指定的字符输出流。</li>
<li><code>*ufferedWriter(Writer out,int size)</code>：创建一个<code>BufferedWriter</code>来修饰参数<code>out</code>指定的字符输出流，参数<code>size</code>则用于指定缓冲区的大小，单位为字符。</li>
</ul>
<p>该类除了可以给字符输出流提供缓冲区之外，还提供了一个新的方法<code>newLine()</code>，该方法用于写入一个行分隔符。行分隔符字符串由系统属性<code>line.separator</code>定义，并且不一定是单个新行（\n）符。</p>
<p>提示：<code>BufferedWriter</code>类的使用与<code>FileWriter</code>类相同，这里不再重述。</p>
<h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><p>正常情况下，字节流可以对所有的数据进行操作，但是有些时候在处理一些文本时我们要用到字符流，比如，查看文本的中文时就是需要采用字符流更为方便。所以 Java IO 流中提供了两种用于将字节流转换为字符流的转换流。</p>
<p><code>InputStreamReader</code>用于将字节输入流转换为字符输入流，其中<code>OutputStreamWriter</code>用于将字节输出流转换为字符输出流。使用转换流可以在一定程度上避免乱码，还可以指定输入输出所使用的字符集。</p>
<p>在<code>java.txt</code>中输出你好，将<code>java.txt</code>保存为“UTF-8”的格式，然后通过字节流的方式读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://java.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为 C??????????，我们发现都是乱码。下面用字节数组，并通过字符串设定编码格式来显式内容，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://java.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span> b[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当存储的文字较多时，会出现解码不正确的问题，且字节长度无法根据解码内容自动设定，此时就需要转换流来完成。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://java.txt&quot;</span>);</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) b); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面以获取键盘输入为例来介绍转换流的用法。Java 使用<code>System.in</code>代表标准输出，即键盘输入，但这个标准输入流是<code>InputStream</code>类的实例，使用不太方便，而且键盘输入内容都是文本内容，所以可以使用<code>InputStreamReader</code>将其转换成字符输入流，普通的<code>Reader</code>读取输入内容时依然不太方便，可以将普通的<code>Reader</code>再次包装成<code>BufferedReader</code>，利用<code>BufferedReader</code>的<code>readLine()</code>方法可以一次读取一行内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将 System.in 对象转换成 Reader 对象</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">    <span class="comment">// 将普通的Reader 包装成 BufferedReader</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 利用循环方式来逐行的读取</span></span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果读取的字符串为“exit”，则程序退出</span></span><br><span class="line">      <span class="keyword">if</span> (line.equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 打印读取的内容</span></span><br><span class="line">      System.out.println(<span class="string">&quot;输入内容为：&quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码第 4 行和第 6 行将<code>System.in</code>包装成<code>BufferedReader</code>，<code>BufferReader</code>流具有缓冲功能，它可以一次读取一行文本，以换行符为标志，如果它没有读到换行符，则程序堵塞，等到读到换行符为止。运行上面程序可以发现这个特征，在控制台执行输入时，只有按下回车键，程序才会打印出刚刚输入的内容。</p>
<p>由于<code>BufferedReader</code>具有一个<code>readLine()</code>方法，可以非常方便地进行一次读入一行内容，所以经常把读入文本内容地输入流包装成<code>BufferedReader</code>，用来方便地读取输入流的文本内容。</p>
<p>既然有字节流转字符流的转换流，那么为什么没有字符流转字节流的转换流呢？</p>
<p>这个问题一语指出了 Java 设计的遗漏之处，想一想字符流和字节流的差别。字节流比字符流的使用范围要更广，但字符流比字节流操作方便。如果有一个流已经是字符流了，也就是说，是一个用起来更方便的流，为什么要转换成字节流呢？反之，如果现在有一个字节流，但可以确定这个字节流的内容都是文本内容，那么把它转换成字符流来处理就会更方便一些，所以 Java 只提供了将字节流转换成字符流的转换流，没有提供将字符流转换成字节流的转换流。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/11/15/java/%E5%9F%BA%E7%A1%80/Java%20%E6%B3%A8%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Java 注解
          
        </div>
      </a>
    
    
      <a href="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">网络安全——互联网使用的安全协议</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>