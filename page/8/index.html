<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-java/设计模式/面向对象设计原则"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="article-date">
  <time datetime="2022-10-29T09:05:54.868Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>开闭原则（<code>Open Closed Principle，OCP</code>）的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p>
<ol>
<li>对软件测试的影响<br>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</li>
<li>可以提高代码的可复用性<br>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</li>
<li>可以提高软件的可维护性<br>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。<br>开闭原则的实现方法<br>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</li>
</ol>
<p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>里氏替换原则（<code>Liskov Substitution Principle，LSP</code>）主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p>
<h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><ul>
<li>里氏替换原则的主要作用如下。</li>
<li>里氏替换原则是实现开闭原则的重要方式之一。</li>
<li>它克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
<li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li>
</ul>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<p>根据上述理解，对里氏替换原则的定义可以总结如下：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类中可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li>
<li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li>
</ul>
<p>通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p>
<p>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p>
<p>关于里氏替换原则的例子，最有名的是“正方形不是长方形”。当然，生活中也有很多类似的例子，例如，企鹅、鸵鸟和几维鸟从生物学的角度来划分，它们属于鸟类；但从类的继承关系来看，由于它们不能继承“鸟”会飞的功能，所以它们不能定义成“鸟”的子类。同样，由于“气球鱼”不会游泳，所以不能定义成“鱼”的子类；“玩具炮”炸不了敌人，所以不能定义成“炮”的子类等。</p>
<p>下面以“几维鸟不是鸟”为例来说明里氏替换原则。</p>
<p>【例1】里氏替换原则在“几维鸟不是鸟”实例中的应用。</p>
<p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时 120 千米。但是新西兰的几维鸟由于翅膀退化无法飞行。假如要设计一个实例，计算这两种鸟飞行 300 千米要花费的时间。显然，拿燕子来测试这段代码，结果正确，能计算出所需要的时间；但拿几维鸟来测试，结果会发生“除零异常”或是“无穷大”，明显不符合预期，其类图如图 1 所示。</p>
<p>“几维鸟不是鸟”实例的类图<br>图1 “几维鸟不是鸟”实例的类图</p>
<p>程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> principle;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LSPtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrownKiwi</span>();</span><br><span class="line">        bird1.setSpeed(<span class="number">120</span>);</span><br><span class="line">        bird2.setSpeed(<span class="number">120</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;燕子将飞行&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;几维鸟将飞行&quot;</span> + bird2.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception err) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//鸟类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="type">double</span> flySpeed;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSpeed</span><span class="params">(<span class="type">double</span> speed)</span> &#123;</span><br><span class="line">        flySpeed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (distance / flySpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//燕子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Swallow</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//几维鸟类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrownKiwi</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSpeed</span><span class="params">(<span class="type">double</span> speed)</span> &#123;</span><br><span class="line">        flySpeed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果飞行300公里：</span><br><span class="line">燕子将飞行2.5小时.</span><br><span class="line">几维鸟将飞行Infinity小时。</span><br></pre></td></tr></table></figure>
<p>程序运行错误的原因是：几维鸟类重写了鸟类的 setSpeed(double speed) 方法，这违背了里氏替换原则。正确的做法是：取消几维鸟原来的继承关系，定义鸟和几维鸟的更一般的父类，如动物类，它们都有奔跑的能力。几维鸟的飞行速度虽然为 0，但奔跑速度不为 0，可以计算出其奔跑 300 千米所要花费的时间。其类图如图 2 所示。</p>
<p>“几维鸟是动物”实例的类图<br>图2 “几维鸟是动物”实例的类图</p>
<h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>依赖倒置原则（<code>Dependence Inversion Principle，DIP</code>）的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。</p>
<p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p>
<p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p>
<p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p>
<h2 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h2><p>依赖倒置原则的主要作用如下。</p>
<ul>
<li>依赖倒置原则可以降低类间的耦合性。</li>
<li>依赖倒置原则可以提高系统的稳定性。</li>
<li>依赖倒置原则可以减少并行开发引起的风险。</li>
<li>依赖倒置原则可以提高代码的可读性和可维护性。</li>
</ul>
<h2 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h2><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p>
<ol>
<li>每个类尽量提供接口或抽象类，或者两者都具备。</li>
<li>变量的声明类型尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>使用继承时尽量遵循里氏替换原则。</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>依赖倒置原则在“顾客购物程序”中的应用。</p>
<p>分析：本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Customer &#123;</span><br><span class="line">    public void shopping(ShaoguanShop shop) &#123;</span><br><span class="line">        //购物</span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Customer &#123;</span><br><span class="line">    public void shopping(WuyuanShop shop) &#123;</span><br><span class="line">        //购物</span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。解决方法是：定义“婺源网店”和“韶关网店”的共同接口 Shop，顾客类面向该接口编程，其代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，不管顾客类 Customer 访问什么商店，或者增加新的商店，都不需要修改原有代码了，其类图如图 1 所示。</p>
<p>顾客购物程序的类图<br>图1 顾客购物程序的类图</p>
<p>程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> principle;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DIPtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">wang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;顾客购买以下商品：&quot;</span>);</span><br><span class="line">        wang.shopping(<span class="keyword">new</span> <span class="title class_">ShaoguanShop</span>());</span><br><span class="line">        wang.shopping(<span class="keyword">new</span> <span class="title class_">WuyuanShop</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//商店</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span>; <span class="comment">//卖</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//韶关网店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShaoguanShop</span> <span class="keyword">implements</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;韶关土特产：香菇、木耳……&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//婺源网店</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WuyuanShop</span> <span class="keyword">implements</span> <span class="title class_">Shop</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;婺源土特产：绿茶、酒糟鱼……&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顾客</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="comment">//购物</span></span><br><span class="line">        System.out.println(shop.sell());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">顾客购买以下商品：</span><br><span class="line">韶关土特产：香菇、木耳……</span><br><span class="line">婺源土特产：绿茶、酒糟鱼……</span><br></pre></td></tr></table></figure>
<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><h2 id="x-96-定义"><a href="#x-96-定义" class="headerlink" title="x&#96;定义"></a>x&#96;定义</h2><p>单一职责原则（<code>Single Responsibility Principle，SRP</code>）又称单一功能原则。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。</p>
<p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p>
<ul>
<li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li>
<li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p>
<ul>
<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li>
<li>提高类的可读性。复杂性降低，自然其可读性会提高。</li>
<li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li>
<li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h2 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h2><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>大学学生工作管理程序。</p>
<p>分析：大学学生工作主要包括学生生活辅导和学生学业指导两个方面的工作，其中生活辅导主要包括班委建设、出勤统计、心理辅导、费用催缴、班级管理等工作，学业指导主要包括专业引导、学习辅导、科研指导、学习总结等工作。如果将这些工作交给一位老师负责显然不合理，正确的做 法是生活辅导由辅导员负责，学业指导由学业导师负责，其类图如图 1 所示。</p>
<p>大学学生工作管理程序的类图<br>图1 大学学生工作管理程序的类图</p>
<p>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p>
<h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>定义<br>接口隔离原则（<code>Interface Segregation Principle，ISP</code>）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p>
<p>2002 年罗伯特·C.马丁给“接口隔离原则”的定义是：客户端不应该被迫依赖于它不使用的方法。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>
<p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p>
<ul>
<li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li>
<li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li>
</ul>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</p>
<ol>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li>
</ol>
<h2 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h2><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。<br>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。<br>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。<br>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。<br>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>学生成绩管理程序。</p>
<p>分析：学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均分、打印成绩信息、査询成绩信息等功能，如果将这些功能全部放到一个接口中显然不太合理，正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中，其类图如图 1 所示。<br>学生成绩管理程序的类图<br>图1 学生成绩管理程序的类图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> principle;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ISPtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputModule</span> <span class="variable">input</span> <span class="operator">=</span> StuScoreList.getInputModule();</span><br><span class="line">        <span class="type">CountModule</span> <span class="variable">count</span> <span class="operator">=</span> StuScoreList.getCountModule();</span><br><span class="line">        <span class="type">PrintModule</span> <span class="variable">print</span> <span class="operator">=</span> StuScoreList.getPrintModule();</span><br><span class="line">        input.insert();</span><br><span class="line">        count.countTotalScore();</span><br><span class="line">        print.printStuInfo();</span><br><span class="line">        <span class="comment">//print.delete();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入模块接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InputModule</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计模块接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CountModule</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">countTotalScore</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">countAverage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印模块接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PrintModule</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printStuInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">queryStuInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StuScoreList</span> <span class="keyword">implements</span> <span class="title class_">InputModule</span>, CountModule, PrintModule &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StuScoreList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InputModule <span class="title function_">getInputModule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (InputModule) <span class="keyword">new</span> <span class="title class_">StuScoreList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CountModule <span class="title function_">getCountModule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (CountModule) <span class="keyword">new</span> <span class="title class_">StuScoreList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrintModule <span class="title function_">getPrintModule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (PrintModule) <span class="keyword">new</span> <span class="title class_">StuScoreList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入模块的insert()方法被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入模块的delete()方法被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入模块的modify()方法被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countTotalScore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;统计模块的countTotalScore()方法被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countAverage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;统计模块的countAverage()方法被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStuInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印模块的printStuInfo()方法被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryStuInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印模块的queryStuInfo()方法被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入模块的insert()方法被调用！</span><br><span class="line">统计模块的countTotalScore()方法被调用！</span><br><span class="line">打印模块的printStuInfo()方法被调用！</span><br></pre></td></tr></table></figure>
<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>迪米特法则（<code>Law of Demeter，LoD</code>）又叫作最少知识原则（<code>Least Knowledge Principle，LKP</code>)。</p>
<p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p>
<ul>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li>
</ul>
<p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p>
<h2 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h2><p>从迪米特法则的定义和特点可知，它强调以下两点：</p>
<ul>
<li>从依赖者的角度来说，只依赖应该依赖的对象。</li>
<li>从被依赖者的角度说，只暴露应该暴露的方法。</li>
</ul>
<p>所以，在运用迪米特法则时要注意以下 6 点。</p>
<ul>
<li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设置成不变类。</li>
<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>
<li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li>
<li>谨慎使用序列化（Serializable）功能。</li>
</ul>
<p>【例1】明星与经纪人的关系实例。</p>
<p>分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则，其类图如图 1 所示。</p>
<p>明星与经纪人的关系图<br>图1 明星与经纪人的关系图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> principle;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoDtest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">        agent.setStar(<span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&quot;林心如&quot;</span>));</span><br><span class="line">        agent.setFans(<span class="keyword">new</span> <span class="title class_">Fans</span>(<span class="string">&quot;粉丝韩丞&quot;</span>));</span><br><span class="line">        agent.setCompany(<span class="keyword">new</span> <span class="title class_">Company</span>(<span class="string">&quot;中国传媒有限公司&quot;</span>));</span><br><span class="line">        agent.meeting();</span><br><span class="line">        agent.business();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//经纪人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Star myStar;</span><br><span class="line">    <span class="keyword">private</span> Fans myFans;</span><br><span class="line">    <span class="keyword">private</span> Company myCompany;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStar</span><span class="params">(Star myStar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myStar = myStar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFans</span><span class="params">(Fans myFans)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myFans = myFans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(Company myCompany)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myCompany = myCompany;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(myFans.getName() + <span class="string">&quot;与明星&quot;</span> + myStar.getName() + <span class="string">&quot;见面了。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(myCompany.getName() + <span class="string">&quot;与明星&quot;</span> + myStar.getName() + <span class="string">&quot;洽淡业务。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//明星</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Star(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//粉丝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fans</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Fans(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//媒体公司</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    Company(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">粉丝韩丞与明星林心如见面了。</span><br><span class="line">中国传媒有限公司与明星林心如洽淡业务。</span><br></pre></td></tr></table></figure>
<h1 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>合成复用原则（<code>Composite Reuse Principle，CRP</code>）又叫组合&#x2F;聚合复用原则（<code>Composition/Aggregate Reuse Principle，CARP</code>）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p>
<h2 id="合成复用原则的重要性"><a href="#合成复用原则的重要性" class="headerlink" title="合成复用原则的重要性"></a>合成复用原则的重要性</h2><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。<br>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</p>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。<br>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p>
<h2 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h2><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>
<p>下面以汽车分类管理程序为例来介绍合成复用原则的应用。</p>
<p>【例1】汽车分类管理程序。</p>
<p>分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继承关系实现的汽车分类的类图。</p>
<p>用继承关系实现的汽车分类的类图<br>图1 用继承关系实现的汽车分类的类图</p>
<p>从图 1 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。</p>
<p>用组合关系实现的汽车分类的类图<br>图2 用组合关系实现的汽车分类的类图</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，是设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，而是要综合考虑人力、时间、成本、质量，不刻意追求完美，要在适当的场景遵循设计原则。这体现的是一种平衡取舍，可以帮助我们设计出更加优雅的代码结构。</p>
<p>各种原则要求的侧重点不同，下面我们分别用一句话归纳总结软件设计模式的七大原则，如下表所示。</p>
<p>设计原则	一句话归纳	目的<br>开闭原则	对扩展开放，对修改关闭	降低维护带来的新风险<br>依赖倒置原则	高层不应该依赖低层，要面向接口编程	更利于代码结构的升级扩展<br>单一职责原则	一个类只干一件事，实现类要单一	便于理解，提高代码的可读性<br>接口隔离原则	一个接口只干一件事，接口要精简单一	功能解耦，高聚合、低耦合<br>迪米特法则	不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度	只和朋友交流，不和陌生人说话，减少代码臃肿<br>里氏替换原则	不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义	防止继承泛滥<br>合成复用原则	尽量使用组合或者聚合关系实现代码复用，少使用继承	降低代码耦合<br>实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。<br>记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p>
<p>在程序设计时，我们应该将程序功能最小化，每个类只干一件事。若有类似功能基础之上添加新功能，则要合理使用继承。对于多方法的调用，要会运用接口，同时合理设置接口功能与数量。最后类与类之间做到低耦合高内聚。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/设计模式/创建型模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2022-10-29T09:05:54.867Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="创建型模式的特点和分类"><a href="#创建型模式的特点和分类" class="headerlink" title="创建型模式的特点和分类"></a>创建型模式的特点和分类</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</p>
<p>创建型模式分为以下几种。</p>
<ul>
<li>单例（<code>Singleton</code>）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（<code>Prototype</code>）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（<code>FactoryMethod</code>）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（<code>AbstractFactory</code>）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（<code>Builder</code>）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p>
<h2 id="单例模式的定义与特点"><a href="#单例模式的定义与特点" class="headerlink" title="单例模式的定义与特点"></a>单例模式的定义与特点</h2><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p>
<p>J2EE 标准中的<code>ServletContext</code>和<code>ServletContextConfig</code>、Spring 框架应用中的<code>ApplicationContext</code>、数据库中的连接池等也都是单例模式。</p>
<p>单例模式有 3 个特点：</p>
<ul>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点。</li>
</ul>
<h2 id="单例模式的优点和缺点"><a href="#单例模式的优点和缺点" class="headerlink" title="单例模式的优点和缺点"></a>单例模式的优点和缺点</h2><p>单例模式的优点：</p>
<ul>
<li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li>
<li>可以避免对资源的多重占用。</li>
<li>单例模式设置全局访问点，可以优化和共享资源的访问。</li>
</ul>
<p>单例模式的缺点：</p>
<ul>
<li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li>
<li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li>
<li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
</ul>
<h2 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h2><p>对于 Java 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。</p>
<ul>
<li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。</li>
<li>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li>
<li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。</li>
<li>某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>
<li>频繁访问数据库或文件的对象。</li>
<li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li>
</ul>
<h2 id="单例模式的结构与实现"><a href="#单例模式的结构与实现" class="headerlink" title="单例模式的结构与实现"></a>单例模式的结构与实现</h2><p>通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p>
<h3 id="1-单例模式的结构"><a href="#1-单例模式的结构" class="headerlink" title="1. 单例模式的结构"></a>1. 单例模式的结构</h3><p>单例模式的主要角色如下。<br>单例类：包含一个实例且能自行创建这个实例的类。<br>访问类：使用单例的类。</p>
<p>其结构如图 1 所示。<br>单例模式的结构图<br>图1 单例模式的结构图</p>
<h3 id="2-单例模式的实现"><a href="#2-单例模式的实现" class="headerlink" title="2. 单例模式的实现"></a>2. 单例模式的实现</h3><p>Singleton 模式通常有两种实现形式。<br>第 1 种：懒汉式单例<br>该模式的特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。<br>第 2 种：饿汉式单例<br>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式单例在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以是线程安全的，可以直接用于多线程而不会出现问题。<br>单例模式的应用实例<br>【例1】用懒汉式单例模式模拟产生美国当今总统对象。</p>
<p>分析：在每一届任期内，美国的总统只有一人，所以本实例适合用单例模式实现，图 2 所示是用懒汉式单例实现的结构图。</p>
<p>美国总统生成器的结构图<br>图2 美国总统生成器的结构图</p>
<p>程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">President</span> <span class="variable">zt1</span> <span class="operator">=</span> President.getInstance();</span><br><span class="line">        zt1.getName();    <span class="comment">//输出总统的名字</span></span><br><span class="line">        <span class="type">President</span> <span class="variable">zt2</span> <span class="operator">=</span> President.getInstance();</span><br><span class="line">        zt2.getName();    <span class="comment">//输出总统的名字</span></span><br><span class="line">        <span class="keyword">if</span> (zt1 == zt2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;他们是同一人！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;他们不是同一人！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">President</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">President</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//保证instance在所有线程中同步</span></span><br><span class="line">    <span class="comment">//private避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">President</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;产生一个总统！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> President <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//在getInstance方法上加同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">President</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经有一个总统，不能产生新总统！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是美国总统：特朗普。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果如下：<br>产生一个总统！<br>我是美国总统：特朗普。<br>已经有一个总统，不能产生新总统！<br>我是美国总统：特朗普。<br>他们是同一人！</p>
<p>【例2】用饿汉式单例模式模拟产生猪八戒对象。</p>
<p>分析：同上例类似，猪八戒也只有一个，所以本实例同样适合用单例模式实现。本实例由于要显示猪八戒的图像（点此下载该程序所要显示的猪八戒图片），所以用到了框架窗体 JFrame 组件，这里的猪八戒类是单例类，可以将其定义成面板 JPanel 的子类，里面包含了标签，用于保存猪八戒的图像，客户窗体可以获得猪八戒对象，并显示它。图 3 所示是用饿汉式单例实现的结构图。</p>
<p>猪八戒生成器的结构图<br>图3 猪八戒生成器的结构图</p>
<p>程序代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonEager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">jf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;饿汉单例模式测试&quot;</span>);</span><br><span class="line">        jf.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="type">Container</span> <span class="variable">contentPane</span> <span class="operator">=</span> jf.getContentPane();</span><br><span class="line">        <span class="type">Bajie</span> <span class="variable">obj1</span> <span class="operator">=</span> Bajie.getInstance();</span><br><span class="line">        contentPane.add(obj1);</span><br><span class="line">        <span class="type">Bajie</span> <span class="variable">obj2</span> <span class="operator">=</span> Bajie.getInstance();</span><br><span class="line">        contentPane.add(obj2);</span><br><span class="line">        <span class="keyword">if</span> (obj1 == obj2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;他们是同一人！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;他们不是同一人！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jf.pack();</span><br><span class="line">        jf.setVisible(<span class="literal">true</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bajie</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bajie</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bajie</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bajie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="keyword">new</span> <span class="title class_">ImageIcon</span>(<span class="string">&quot;src/Bajie.jpg&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.add(l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bajie <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果如图 4 所示。</p>
<p>猪八戒生成器的运行结果<br>图4 猪八戒生成器的运行结果<br>单例模式的扩展<br>单例模式可扩展为有限的多例（Multitcm）模式，这种模式可生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，其结构图如图 5 所示。</p>
<p>有限的多例模式的结构图<br>图5 有限的多例模式的结构图</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java数组操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/%E5%9F%BA%E7%A1%80/Java%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2022-10-29T09:05:54.859Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="比较两个数组是否相等"><a href="#比较两个数组是否相等" class="headerlink" title="比较两个数组是否相等"></a>比较两个数组是否相等</h1><p>数组相等的条件不仅要求数组元素的个数必须相等，而且要求对应位置的元素也相等。<code>Arrays</code>类提供了<code>equals()</code>方法比较整个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.equals(arrayA, arrayB);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">double</span>[] score1 = &#123; <span class="number">99</span>, <span class="number">100</span>, <span class="number">98.5</span>, <span class="number">96.5</span>, <span class="number">72</span> &#125;;</span><br><span class="line">  <span class="type">double</span>[] score2 = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>];</span><br><span class="line">  score2[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">  score2[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">  score2[<span class="number">2</span>] = <span class="number">98.5</span>;</span><br><span class="line">  score2[<span class="number">3</span>] = <span class="number">96.5</span>;</span><br><span class="line">  score2[<span class="number">4</span>] = <span class="number">72</span>;</span><br><span class="line">  <span class="type">double</span>[] score3 = &#123; <span class="number">99</span>, <span class="number">96.5</span>, <span class="number">98.5</span>, <span class="number">100</span>, <span class="number">72</span> &#125;;</span><br><span class="line">  <span class="keyword">if</span> (Arrays.equals(score1, score2)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;score1 数组和 score2 数组相等&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;score1 数组和 score2 数组不等&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Arrays.equals(score1, score3)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;score1 数组和 score3 数组相等&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;score1 数组和 score3 数组不等&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中定义 3 个数组，分别为<code>score1、score2</code>和<code>score3</code>。第一个数组直接给出了数组的值；第二个数组先定义数组的长度，然后为每个元素赋值；第三个数组中的元素和第一个数组中的元素相同，但是顺序不同。分别将<code>score1</code>数组与<code>score2</code>和<code>score3</code>数组进行比较，并输出比较的结果。</p>
<p>运行上述代码，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score1 数组和 score2 数组相等</span><br><span class="line">score1 数组和 score3 数组不等</span><br></pre></td></tr></table></figure>
<h1 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h1><p><code>Arrays</code>类提供了一个<code>fill()</code>方法，可以在指定位置进行数值填充。<code>fill()</code>方法虽然可以填充数组，但是它的功能有限制，只能使用同一个数值进行填充。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(array,value);</span><br></pre></td></tr></table></figure>
<p>其中，<code>array</code>表示数组，<code>value</code>表示填充的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] number = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">  System.out.println(<span class="string">&quot;number —共有 &quot;</span> + number.length + <span class="string">&quot; 个元素，它们分别是：&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line">    Arrays.fill(number, i);</span><br><span class="line">    System.out.println(<span class="string">&quot;number[&quot;</span> + i + <span class="string">&quot;]=&quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number 一共有 5 个元素，它们分别是：</span><br><span class="line">number[0]=0</span><br><span class="line">number[1]=1</span><br><span class="line">number[2]=2</span><br><span class="line">number[3]=3</span><br><span class="line">number[4]=4</span><br></pre></td></tr></table></figure>
<h1 id="数组查找指定元素"><a href="#数组查找指定元素" class="headerlink" title="数组查找指定元素"></a>数组查找指定元素</h1><p>查找数组是指从数组中查询指定位置的元素，或者查询某元素在指定数组中的位置。使用 Arrays 类的 binarySearch() 方法可以实现数组的查找，该方法可使用二分搜索法来搜索指定数组，以获得指定对象，该方法返回要搜索元素的索引值。</p>
<p>binarySearch() 方法有多种重载形式来满足不同类型数组的查找需要，常用的重载形式有两种。</p>
<p>(1) 第一种形式如下：<br>binarySearch(Object[] a,Object key);<br>其中，a 表示要搜索的数组，key 表示要搜索的值。如果 key 包含在数组中，则返回搜索值的索引；否则返回 -1 或“-插入点”。插入点指搜索键将要插入数组的位置，即第一个大于此键的元素索引。</p>
<p>在进行数组查询之前，必须对数组进行排序（可以使用 sort() 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法确认找到的是哪一个。<br>例 1<br>声明 double 类型的 score 数组，接着调用 Arrays 类的 sort() 方法对 score 数组排序，排序后分别查找数组中值为 100 和 60 的元素，分别将结果保存到 index1 和 index2 变量中，最后输出变量的值。代码如下：<br>public static void main(String[] args) {<br>    double[] score &#x3D; { 99.5, 100, 98, 97.5, 100, 95, 85.5, 100 };<br>    Arrays.sort(score);<br>    int index1 &#x3D; Arrays.binarySearch(score, 100);<br>    int index2 &#x3D; Arrays.binarySearch(score, 60);<br>    System.out.println(“查找到 100 的位置是：” + index1);<br>    System.out.println(“查找到 60 的位置是：” + index2);<br>}<br>执行上述代码，输出结果如下：<br>查找到 100 的位置是：5<br>查找到 60 的位置是：-1</p>
<p>(2) 除了上述形式外，binarySearch() 还有另一种常用的形式，这种形式用于在指定的范围内查找某一元素。语法如下：<br>binarySearch(Object[] a,int fromIndex,int toIndex,Object key);<br>其中，a 表示要进行查找的数组，fromIndex 指定范围的开始处索引（包含开始处），toIndex 指定范围的结束处索引（不包含结束处），key 表示要搜索的元素。</p>
<p>在使用 binarySearch() 方法的上述重载形式时，也需要对数组进行排序，以便获取准确的索引值。如果要查找的元素 key 在指定的范围内，则返回搜索键的索引；否则返回 -1 或 “-插入点”。插入点指要将键插入数组的位置，即范围内第一个大于此键的元素索引。<br>例 2<br>对例 1 中创建的 score 数组进行查找元素，指定开始位置为 2，结束位置为 6。代码如下:<br>public static void main(String[] args) {<br>    double[] score &#x3D; {99.5,100,98,97.5,100,95,85.5,100};<br>    Arrays.sort(score);<br>    int index1 &#x3D; Arrays.binarySearch(score,2,6,100);<br>    int index2 &#x3D; Arrays.binarySearch(score,2,6,60);<br>    System.out.println(“查找到 100 的位置是：”+index1);<br>    System.out.println(“查找到 60 的位置是：”+ index2);<br>}<br>执行上述代码，输出结果如下：<br>查找到 100 的位置是：5<br>查找到 60 的位置是：-3</p>
<h1 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h1><p>所谓复制数组，是指将一个数组中的元素在另一个数组中进行复制。本文主要介绍关于 Java 里面的数组复制（拷贝）的几种方式和用法。</p>
<p>在 Java 中实现数组复制分别有以下 4 种方法：<br>Arrays 类的 copyOf() 方法<br>Arrays 类的 copyOfRange() 方法<br>System 类的 arraycopy() 方法<br>Object 类的 clone() 方法</p>
<p>下面来详细介绍这 4 种方法的使用。<br>使用 copyOf() 方法和 copyOfRange() 方法<br>Arrays 类的 copyOf() 方法与 copyOfRange() 方法都可实现对数组的复制。copyOf() 方法是复制数组至指定长度，copyOfRange() 方法则将指定数组的指定长度复制到一个新数组中。</p>
<ol>
<li>使用 copyOf() 方法对数组进行复制<br>Arrays 类的 copyOf() 方法的语法格式如下：<br>Arrays.copyOf(dataType[] srcArray,int length);<br>其中，srcArray 表示要进行复制的数组，length 表示复制后的新数组的长度。</li>
</ol>
<p>使用这种方法复制数组时，默认从原数组的第一个元素（索引值为 0）开始复制，目标数组的长度将为 length。如果 length 大于 srcArray.length，则目标数组中采用默认值填充；如果 length 小于 srcArray.length，则复制到第 length 个元素（索引值为 length-1）即止。</p>
<p>注意：目标数组如果已经存在，将会被重构。<br>例 1<br>假设有一个数组中保存了 5 个成绩，现在需要在一个新数组中保存这 5 个成绩，同时留 3 个空余的元素供后期开发使用。</p>
<p>使用 Arrays 类的 CopyOf() 方法完成数组复制的代码如下：<br>import java.util.Arrays;<br>public class Test19{<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F; 定义长度为 5 的数组<br>        int scores[] &#x3D; new int[]{57,81,68,75,91};<br>        &#x2F;&#x2F; 输出原数组<br>        System.out.println(“原数组内容如下：”);<br>        &#x2F;&#x2F; 循环遍历原数组<br>        for(int i&#x3D;0;i&lt;scores.length;i++) {<br>            &#x2F;&#x2F; 将数组元素输出<br>            System.out.print(scores[i]+”\t”);<br>        }<br>        &#x2F;&#x2F; 定义一个新的数组，将 scores 数组中的 5 个元素复制过来<br>        &#x2F;&#x2F; 同时留 3 个内存空间供以后开发使用<br>        int[] newScores &#x3D; (int[])Arrays.copyOf(scores,8);<br>        System.out.println(“\n复制的新数组内容如下：”);<br>        &#x2F;&#x2F; 循环遍历复制后的新数组<br>        for(int j&#x3D;0;j&lt;newScores.length;j++) {<br>            &#x2F;&#x2F; 将新数组的元素输出<br>            System.out.print(newScores[j]+”\t”);<br>        }<br>    }<br>}<br>在上述代码中，由于原数组 scores 的长度为 5，而要复制的新数组 newScores 的长度为 8，因此在将原数组中的 5 个元素复制完之后，会采用默认值填充剩余 3 个元素的内容。</p>
<p>因为原数组 scores 的数据类型为 int，而使用 Arrays.copyOf(scores,8) 方法复制数组之后返回的是 Object[] 类型，因此需要将 Object[] 数据类型强制转换为 int[] 类型。同时，也正因为 scores 的数据类型为 int，因此默认值为 0。</p>
<p>运行的结果如下所示。<br>原数组内容如下：<br>57    81    68    75    91<br>复制的新数组内容如下：<br>57    81    68    75    91    0    0    0<br>2. 使用 CopyOfRange() 方法对数组进行复制<br>Arrays 类的 CopyOfRange() 方法是另一种复制数组的方法，其语法形式如下：<br>Arrays.copyOfRange(dataType[] srcArray,int startIndex,int endIndex)<br>其中：<br>srcArray 表示原数组。<br>startIndex 表示开始复制的起始索引，目标数组中将包含起始索引对应的元素，另外，startIndex 必须在 0 到 srcArray.length 之间。<br>endIndex 表示终止索引，目标数组中将不包含终止索引对应的元素，endIndex 必须大于等于 startIndex，可以大于 srcArray.length，如果大于 srcArray.length，则目标数组中使用默认值填充。</p>
<p>注意：目标数组如果已经存在，将会被重构。<br>例 2<br>假设有一个名称为 scores 的数组其元素为 8 个，现在需要定义一个名称为 newScores 的新数组。新数组的元素为 scores 数组的前 5 个元素，并且顺序不变。</p>
<p>使用 Arrays 类 copyOfRange() 方法完成数组复制的代码如下：<br>public class Test20 {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F; 定义长度为8的数组<br>        int scores[] &#x3D; new int[] { 57, 81, 68, 75, 91, 66, 75, 84 };<br>        System.out.println(“原数组内容如下：”);<br>        &#x2F;&#x2F; 循环遍历原数组<br>        for (int i &#x3D; 0; i &lt; scores.length; i++) {<br>            System.out.print(scores[i] + “\t”);<br>        }<br>        &#x2F;&#x2F; 复制原数组的前5个元素到newScores数组中<br>        int newScores[] &#x3D; (int[]) Arrays.copyOfRange(scores, 0, 5);<br>        System.out.println(“\n复制的新数组内容如下：”);<br>        &#x2F;&#x2F; 循环遍历目标数组，即复制后的新数组<br>        for (int j &#x3D; 0; j &lt; newScores.length; j++) {<br>            System.out.print(newScores[j] + “\t”);<br>        }<br>    }<br>}<br>在上述代码中，原数组 scores 中包含有 8 个元素，使用 Arrays.copyOfRange() 方法可以将该数组复制到长度为 5 的 newScores 数组中，截取 scores 数组的前 5 个元素即可。</p>
<p>该程序运行结果如下所示。<br>原数组内容如下：<br>57    81    68    75    91    66    75    84<br>复制的新数组内容如下：<br>57    81    68    75    91<br>使用 arraycopy() 方法<br>arraycopy() 方法位于 java.lang.System 类中，其语法形式如下：<br>System.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length)<br>其中，srcArray 表示原数组；srcIndex 表示原数组中的起始索引；destArray 表示目标数组；destIndex 表示目标数组中的起始索引；length 表示要复制的数组长度。</p>
<p>使用此方法复制数组时，length+srcIndex 必须小于等于 srcArray.length，同时 length+destIndex 必须小于等于 destArray.length。</p>
<p>注意：目标数组必须已经存在，且不会被重构，相当于替换目标数组中的部分元素。<br>例 3<br>假设在 scores 数组中保存了 8 名学生的成绩信息，现在需要复制该数组从第二个元素开始到结尾的所有元素到一个名称为 newScores 的数组中，长度为 12。scores 数组中的元素在 newScores 数组中从第三个元素开始排列。</p>
<p>使用 System.arraycopy() 方法来完成替换数组元素功能的代码如下：<br>public class Test21 {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F; 定义原数组，长度为8<br>        int scores[] &#x3D; new int[] { 100, 81, 68, 75, 91, 66, 75, 100 };<br>        &#x2F;&#x2F; 定义目标数组<br>        int newScores[] &#x3D; new int[] { 80, 82, 71, 92, 68, 71, 87, 88, 81, 79, 90, 77 };<br>        System.out.println(“原数组中的内容如下：”);<br>        &#x2F;&#x2F; 遍历原数组<br>        for (int i &#x3D; 0; i &lt; scores.length; i++) {<br>            System.out.print(scores[i] + “\t”);<br>        }<br>        System.out.println(“\n目标数组中的内容如下：”);<br>        &#x2F;&#x2F; 遍历目标数组<br>        for (int j &#x3D; 0; j &lt; newScores.length; j++) {<br>            System.out.print(newScores[j] + “\t”);<br>        }<br>        System.arraycopy(scores, 0, newScores, 2, 8);<br>        &#x2F;&#x2F; 复制原数组中的一部分到目标数组中<br>        System.out.println(“\n替换元素后的目标数组内容如下：”);<br>        &#x2F;&#x2F; 循环遍历替换后的数组<br>        for (int k &#x3D; 0; k &lt; newScores.length; k++) {<br>            System.out.print(newScores[k] + “\t”);<br>        }<br>    }<br>}<br>在该程序中，首先定义了一个包含有 8 个元素的 scores 数组，接着又定义了一个包含有 12 个元素的 newScores 数组，然后使用 for 循环分别遍历这两个数组，输出数组中的元素。最后使用 System.arraycopy() 方法将 newScores 数组中从第三个元素开始往后的 8 个元素替换为 scores 数组中的 8 个元素值。</p>
<p>该程序运行的结果如下所示。<br>原数组中的内容如下：<br>100    81    68    75    91    66    75    100<br>目标数组中的内容如下：<br>80    82    71    92    68    71    87    88    81    79    90    77<br>替换元素后的目标数组内容如下：<br>80    82    100    81    68    75    91    66    75    100    90    77   </p>
<p>注意：在使用 arraycopy() 方法时要注意，此方法的命名违背了 Java 的命名惯例。即第二个单词 copy 的首字母没有大写，但按惯例写法应该为 arrayCopy。请读者在使用此方法时注意方法名的书写。<br>使用 clone() 方法<br>clone() 方法也可以实现复制数组。该方法是类 Object 中的方法，可以创建一个有单独内存空间的对象。因为数组也是一个 Object 类，因此也可以使用数组对象的 clone() 方法来复制数组。</p>
<p>clone() 方法的返回值是 Object 类型，要使用强制类型转换为适当的类型。其语法形式比较简单：<br>array_name.clone()</p>
<p>示例语句如下：<br>int[] targetArray&#x3D;(int[])sourceArray.clone();</p>
<p>注意：目标数组如果已经存在，将会被重构。<br>例 4<br>有一个长度为 8 的 scores 数组，因为程序需要，现在要定义一个名称为 newScores 的数组来容纳 scores 数组中的所有元素，可以使用 clone() 方法来将 scores 数组中的元素全部复制到 newScores 数组中。代码如下：<br>public class Test22 {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F; 定义原数组，长度为8<br>        int scores[] &#x3D; new int[] { 100, 81, 68, 75, 91, 66, 75, 100 };<br>        System.out.println(“原数组中的内容如下：”);<br>        &#x2F;&#x2F; 遍历原数组<br>        for (int i &#x3D; 0; i &lt; scores.length; i++) {<br>            System.out.print(scores[i] + “\t”);<br>        }<br>        &#x2F;&#x2F; 复制数组，将Object类型强制转换为int[]类型<br>        int newScores[] &#x3D; (int[]) scores.clone();<br>        System.out.println(“\n目标数组内容如下：”);<br>        &#x2F;&#x2F; 循环遍历目标数组<br>        for (int k &#x3D; 0; k &lt; newScores.length; k++) {<br>            System.out.print(newScores[k] + “\t”);<br>        }<br>    }<br>}<br>在该程序中，首先定义了一个长度为 8 的 scores 数组，并循环遍历该数组输出数组中的元素，然后定义了一个名称为 newScores 的新数组，并使用 scores.clone() 方法将 scores 数组中的元素复制给 newScores 数组。最后循环遍历 newScores 数组，输出数组元素。</p>
<p>程序运行结果如下所示。<br>原数组中的内容如下：<br>100    81    68    75    91    66    75    100<br>目标数组内容如下：<br>100    81    68    75    91    66    75    100<br>从运行的结果可以看出，scores 数组的元素与 newScores 数组的元素是相同的。</p>
<p>注意：以上几种方法都是浅拷贝（浅复制）。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。</p>
<h1 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h1><p><code>Arrays</code>类是一个工具类，其中包含了数组操作的很多方法。这个<code>Arrays</code>类里均为<code>static</code>修饰的方法（static 修饰的方法可以直接通过类名调用），可以直接通过<code>Arrays.xxx(xxx)</code>的形式调用方法。<br>1）int binarySearch(type[] a, type key)<br>使用二分法查询 key 元素值在 a 数组中出现的索引，如果 a 数组不包含 key 元素值，则返回负数。调用该方法时要求数组中元素己经按升序排列，这样才能得到正确结果。<br>2）int binarySearch(type[] a, int fromIndex, int toIndex, type key)<br>这个方法与前一个方法类似，但它只搜索 a 数组中 fromIndex 到 toIndex 索引的元素。调用该方法时要求数组中元素己经按升序排列，这样才能得到正确结果。<br>3）type[] copyOf(type[] original, int length)<br>这个方法将会把 original 数组复制成一个新数组，其中 length 是新数组的长度。如果 length 小于 original 数组的长度，则新数组就是原数组的前面 length 个元素，如果 length 大于 original 数组的长度，则新数组的前面元索就是原数组的所有元素，后面补充 0（数值类型）、false（布尔类型）或者 null（引用类型）。<br>4）type[] copyOfRange(type[] original, int from, int to)<br>这个方法与前面方法相似，但这个方法只复制 original 数组的 from 索引到 to 索引的元素。<br>5）boolean equals(type[] a, type[] a2)<br>如果 a 数组和 a2 数组的长度相等，而且 a 数组和 a2 数组的数组元素也一一相同，该方法将返回 true。<br>6）void fill(type[] a, type val)<br>该方法将会把 a 数组的所有元素都赋值为 val。<br>7）void fill(type[] a, int fromIndex, int toIndex, type val)<br>该方法与前一个方法的作用相同，区别只是该方法仅仅将 a 数组的 fromIndex 到 toIndex 索引的数组元素赋值为 val。<br>8）void sort(type[] a)<br>该方法对 a 数组的数组元素进行排序。<br>9）void sort(type[] a, int fromIndex, int toIndex)<br>该方法与前一个方法相似，区别是该方法仅仅对 fromIndex 到 toIndex 索引的元素进行排序。<br>10）String toString(type[] a)<br>该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在一起，多个数组元素使用英文逗号,和空格隔开。</p>
<p>下面程序示范了 Arrays 类的用法。<br>public class ArraysTest {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F; 定义一个a数组<br>        int[] a &#x3D; new int[] { 3, 4, 5, 6 };<br>        &#x2F;&#x2F; 定义一个a2数组<br>        int[] a2 &#x3D; new int[] { 3, 4, 5, 6 };<br>        &#x2F;&#x2F; a数组和a2数组的长度相等，毎个元素依次相等，将输出true<br>        System.out.println(“a数组和a2数组是否相等：” + Arrays.equals(a, a2));<br>        &#x2F;&#x2F; 通过复制a数组，生成一个新的b数组<br>        int[] b &#x3D; Arrays.copyOf(a, 6);<br>        System.out.println(“a数组和b数组是否相等：” + Arrays.equals(a, b));<br>        &#x2F;&#x2F; 输出b数组的元素，将输出[3, 4, 5, 6, 0, 0]<br>        System.out.println(“b 数组的元素为：” + Arrays.toString(b));<br>        &#x2F;&#x2F; 将b数组的第3个元素（包括）到第5个元素（不包括）賦值为1<br>        Arrays.fill(b, 2, 4, 1);<br>        &#x2F;&#x2F; 输出b数组的元素，将输出[3, 4, 1, 1, 0, 0]<br>        System.out.println(“b 数组的元素为：” + Arrays.toString(b));<br>        &#x2F;&#x2F; 对b数组进行排序<br>        Arrays.sort(b);<br>        &#x2F;&#x2F; 输出b数组的元素.将输出[0,0,1,1,3,4]<br>        System.out.println(“b数组的元素为：” + Arrays.toString(b));<br>    }<br>}<br>Arrays 类处于 java.util 包下，为了在程序中使用 Arrays 类，必须在程序中导入 java.util.Arrays 类。</p>
<p>除此之外，在 System 类里也包含了一个static void arraycopy(Object src, int srePos, Object dest, int dcstPos, int length)方法，该方法可以将 src 数组里的元素值赋给 dest 数组的元素，其中 srcPos 指定从 src 数组的第几个元素开始赋值，length 参数指定将 src 数组的多少个元素值赋给 dest 数组的元素。</p>
<p>Java 8 增强了 Arrays 类的功能，为 Arrays 类增加了一些工具方法，这些工具方法可以充分利用多 CPU 并行的能力来提高设值、排序的性能。下面是 Java 8 为 Arrays 类增加的工具方法。</p>
<p>提示：由于计算机硬件的飞速发展，目前几乎所有家用 PC 都是 4 核、8 核的 CPU，而服务器的 CPU 则具有更好的性能，因此 Java 8 与时俱进地增加了并发支持，并发支持可以充分利用硬件设备来提高程序的运行性能。<br>1）oid parallelPrefix(xxx[] array, XxxBinaryOperator op)<br>该方法使用 op 参数指定的计算公式计算得到的结果作为新的元素。op 计算公式包括 left、right 两个形参，其中 left 代表数组中前一个索引处的元素，right 代表数组中当前索引处的元素，当计算第一个新数组元素时，left 的值默认为 1。<br>2）void parallelPrefix(xxx[] array, int fromIndex, int toIndex, XxxBinaryOperator op)<br>该方法与上一个方法相似，区别是该方法仅重新计算 fromIndex 到 toIndex 索引的元素。<br>3）void setAll(xxx[] array, IntToXxxFunction generator)<br>该方法使用指定的生成器（generator）为所有数组元素设置值，该生成器控制数组元素的值的生成算法。<br>4）void parallelSetAll(xxx[] array, IntToXxxFunction generator)<br>该方法的功能与上一个方法相同，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。<br>5）void parallelSort(xxx[] a)<br>该方法的功能与 Arrays 类以前就有的 sort() 方法相似，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。<br>6）void parallelSort(xxx[] a，int fromIndex, int toIndex)<br>该方法与上一个方法相似，区別是该方法仅对 fromIndex 到 toIndex 索引的元素进行排序。<br>7）Spliterator.OfXxx spliterator(xxx[] array)<br>将该数组的所有元素转换成对应的 Spliterator 对象。<br>8）Spliterator.OfXxx spliterator(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅转换 startInclusive 到 endExclusive 索引的元素。<br>9）XxxStream stream(xxx[] array)<br>该方法将数组转换为 Stream，Stream 是 Java 8 新增的流式编程的 API。<br>10）XxxStream stream(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅将 fromIndex 到 toIndex 索引的元索转换为 Stream。</p>
<p>上面方法列表中，所有以 parallel 开头的方法都表示该方法可利用 CPU 并行的能力来提高性能。上面方法中的 xxx 代表不同的数据类型，比如处理 int[] 型数组时应将 xxx 换成 int，处理 long[] 型数组时应将 XXX 换成 long。</p>
<p>下面程序示范了 Java 8 为 Arrays 类新增的方法。</p>
<p>下面程序用到了接口、匿名内部类的知识，读者阅读起来可能有一定的困难，此处只要大致知道 Arrays 新增的这些新方法就行，暂时并不需要读者立即掌握该程序，可以等到掌握了接口、匿名内部类后再来学习下面程序。<br>public class ArraysTest2 {<br>    public static void main(String[] args) {<br>        int[] arr1 &#x3D; new int[] { 3, 4, 25, 16, 30, 18 };<br>        &#x2F;&#x2F; 对数组arr1进行并发排序<br>        Arrays.parallelSort(arr1);<br>        System.out.println(Arrays.toString(arr1));<br>        int[] arr2 &#x3D; new int[] { 13, -4, 25, 16, 30, 18 };<br>        Arrays.parallelPrefix(arr2, new IntBinaryOperator() {<br>            &#x2F;&#x2F; left 代表数组中前一个索引处的元素，计算第一个元素时，left为1<br>            &#x2F;&#x2F; right代表数组中当前索引处的元素<br>            public int applyAsInt(int left, int right) {<br>                return left * right;<br>            }<br>        });<br>        System.out.println(Arrays.toString(arr2));<br>        int[] arr3 &#x3D; new int[5];<br>        Arrays.parallelSetAll(arr3, new IntUnaryOperator() {<br>            &#x2F;&#x2F; operand代表正在计算的元素索引<br>            public int applyAsInt(int operand) {<br>                return operand * 5;<br>            }<br>        });<br>        System.out.println(Arrays.toString(arr3));<br>    }<br>}<br>上面程序中第一行粗体字代码调用了 parallelSort() 方法对数组执行排序，该方法的功能与传统 sort() 方法大致相似，只是在多 CPU 机器上会有更好的性能。</p>
<p>第二段粗体字代码使用的计算公式为 left * right，其中 left 代表数组中当前一个索引处的元素，right 代表数组中当前索引处的元素。程序使用的数组为：<br>{3, -4 , 25, 16, 30, 18)</p>
<p>计算新的数组元素的方式为：<br>{1<em>3&#x3D;3, 3</em>-4—12, -12<em>25&#x3D;-300, -300</em>16&#x3D;—48000, -48000<em>30&#x3D;—144000, -144000</em>18&#x3D;-2592000}</p>
<p>因此将会得到如下新的数组元素：<br>{3, -12, -300, -4800, -144000, -2592000)</p>
<p>第三段粗体字代码使用 operand * 5 公式来设置数组元素，该公式中 operand 代表正在计算的数组元素的索引。因此第三段粗体字代码计算得到的数组为：<br>{0, 5, 10, 15, 20}</p>
<p>提示：上面两段粗体字代码都可以使用 Lambda 表达式进行简化。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringMVC/Spring MVC文件操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/SpringMVC/Spring%20MVC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2022-10-29T09:05:54.824Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/Sring Boot静态资源映射"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/SpringBoot/Sring%20Boot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84/" class="article-date">
  <time datetime="2022-10-29T09:05:54.819Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在 Web 应用中会涉及到大量的静态资源，例如 JS、CSS 和 HTML 等。Spring MVC 导入静态资源文件时，需要配置静态资源的映射；但在 SpringBoot 中则不再需要进行此项配置，因为 SpringBoot 已经默认完成了这一工作。</p>
<p>Spring Boot 默认为我们提供了 3 种静态资源映射规则：</p>
<ul>
<li>WebJars 映射</li>
<li>默认资源映射</li>
<li>静态首页（欢迎页）映射</li>
</ul>
<h1 id="WebJars-映射"><a href="#WebJars-映射" class="headerlink" title="WebJars 映射"></a>WebJars 映射</h1><p>为了让页面更加美观，让用户有更多更好的体验，Web 应用中通常会使用大量的 JS 和 CSS，例如 jQuery，Backbone.js 和 Bootstrap 等等。通常我们会将这些 Web 前端资源拷贝到 Java Web 项目的 webapp 相应目录下进行管理。但是 Spring Boot 项目是以 JAR 包的形式进行部署的，不存在 webapp 目录，那么 Web 前端资源该如何引入到 Spring Boot 项目中呢？</p>
<p>WebJars 可以完美的解决上面的问题，它可以 Jar 形式为 Web 项目提供资源文件。</p>
<p>WebJars 可以将 Web 前端资源（JS，CSS 等）打成一个个的 Jar 包，然后将这些 Jar 包部署到 Maven 中央仓库中进行统一管理，当 Spring Boot 项目中需要引入 Web 前端资源时，只需要访问 WebJars 官网，找到所需资源的 pom 依赖，将其导入到项目中即可。</p>
<p>所有通过 WebJars 引入的前端资源都存放在当前项目类路径（classpath）下的“&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;” 目录中。</p>
<p>下图展示如何通过 WebJars 查找 JQuery 的 pom 依赖的过程。</p>
<p>图1：WebJars 查找 JQuery 的 POM 依赖</p>
<p>Spring Boot 通过 MVC 的自动配置类  WebMvcAutoConfiguration 为这些 WebJars 前端资源提供了默认映射规则，部分源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//WebJars 映射规则</span></span><br><span class="line">    <span class="built_in">this</span>.addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.addResourceHandler(registry, <span class="built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">      registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ServletContextResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        registration.addResourceLocations(<span class="keyword">new</span> <span class="title class_">Resource</span>[]&#123;resource&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上源码可知，WebJars 的映射路径为“&#x2F;webjars&#x2F;**”，即所有访问“&#x2F;webjars&#x2F;**”的请求，都会去“classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;”查找 WebJars 前端资源。<br>示例 1</p>
<ol>
<li>在 Spring Boot 项目 spring-boot-springmvc-demo1 的 pom.xml 中添加以下依赖，将 jquery 引入到该项目中。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.webjars&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jquery&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>Spring Boot 项目中引入的 jquery 的 Jar 包结构如下图。</li>
</ol>
<p>WebJars JQUERY<br>图2：WebJars jquery Jar 包结构</p>
<ol start="3">
<li>启动 Spring Boot，浏览器访问“<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.6.0/jquery.js%E2%80%9D%E8%AE%BF%E9%97%AE">http://localhost:8080/webjars/jquery/3.6.0/jquery.js”访问</a> jquery.js，结果如下图。</li>
</ol>
<p>图3：WebJars jquery 访问结果<br>默认静态资源映射<br>当访问项目中的任意资源（即“&#x2F;**”）时，Spring Boot 会默认从以下路径中查找资源文件（优先级依次降低）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classpath:/META-INF/resources/</span><br><span class="line">classpath:/resources/</span><br><span class="line">classpath:/static/</span><br><span class="line">classpath:/public/</span><br></pre></td></tr></table></figure>
<p>这些路径又被称为静态资源文件夹，它们的优先级顺序为：classpath:&#x2F;META-INF&#x2F;resources&#x2F; &gt; classpath:&#x2F;resources&#x2F; &gt; classpath:&#x2F;static&#x2F; &gt; classpath:&#x2F;public&#x2F; 。</p>
<p>当我们请求某个静态资源（即以“.html”结尾的请求）时，Spring Boot 会先查找优先级高的文件夹，再查找优先级低的文件夹，直到找到指定的静态资源为止。<br>示例 2</p>
<ol>
<li>在 spring-boot-springmvc-demo1 的 src&#x2F;main&#x2F;resources 下的 static 目录中创建一个 hello.html，代码如下。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;欢迎您来到编程帮（www.biancheng.net）&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li>启动 Spring Boot，浏览器访问 “<a target="_blank" rel="noopener" href="http://localhost:8080/hello.html%E2%80%9D%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%82">http://localhost:8080/hello.html”，结果如下图。</a></li>
</ol>
<p>默认资源映射<br>图4：默认资源映射<br>静态首页（欢迎页）映射<br>静态资源文件夹下的所有 index.html 被称为静态首页或者欢迎页，它们会被被 &#x2F;** 映射，换句话说就是，当我们访问“&#x2F;”或者“&#x2F;index.html”时，都会跳转到静态首页（欢迎页）。<br>注意，访问静态首页或欢迎页时，其查找顺序也遵循默认静态资源的查找顺序，即先查找优先级高的目录，在查找优先级低的目录，直到找到 index.html 为止。</p>
<p>示例 3</p>
<ol>
<li>在 spring-boot-springmvc-demo1 的 src&#x2F;main&#x2F;resources 下的 public 目录中创建一个 index.html，代码如下。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li>启动 Spring Boot，使用浏览器访问“<a target="_blank" rel="noopener" href="http://localhost:8080/%E2%80%9D%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%82">http://localhost:8080/”，结果如下图。</a></li>
</ol>
<p>Spring Boot 欢迎页映射<br>图5：Spring Boot 欢迎页</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/SpringApplication执行流程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/SpringBoot/SpringApplication%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/" class="article-date">
  <time datetime="2022-10-29T09:05:54.759Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>SpringApplication</code>的<code>run</code>方法的主要流程大体可以归纳如下：</p>
<ol>
<li>如果我们使用的是<code>SpringApplication</code>的静态<code>run</code>方法，那么，这个方法里面首先需要创建一个<code>SpringApplication</code>对象实例，然后调用这个创建好的<code>SpringApplication</code>的实例<code>run</code>方法。在<code>SpringApplication</code>实例初始化的时候，它会提前做几件事情：</li>
</ol>
<ul>
<li>根据<code>classpath</code>里面是否存在某个特征类（<code>org.springframework.web.context.ConfigurableWebApplicationContext</code>）来决定是否应该创建一个为 Web 应用使用的<code>ApplicationContext</code>类型，还是应该创建一个标准<code>Standalone</code>应用使用的<code>ApplicationContext</code>类型。</li>
<li>使用<code>SpringFactoriesLoader</code>在应用的<code>classpath</code>中查找并加载所有可用的<code>ApplicationContextInitializer</code>。</li>
<li>使用<code>SpringFactoriesLoader</code>在应用的<code>classpath</code>中查找并加载所有可用的<code>ApplicationListener</code>。</li>
<li>推断并设置<code>main</code>方法的定义类。</li>
</ul>
<ol start="2">
<li><code>SpringApplication</code>实例初始化完成并且完成设置后，就开始执行 run 方法的逻辑了，方法执行伊始，首先遍历执行所有通过 SpringFactoriesLoader 可以查找到并加载的 SpringApplicationRunListener，调用它们的 started() 方法，告诉这些 SpringApplicationRunListener，“嘿，SpringBoot 应用要开始执行咯！”。</li>
<li>创建并配置当前 SpringBoot 应用将要使用的 Environment（包括配置要使用的 PropertySource 以及 Profile）。</li>
<li>遍历调用所有 SpringApplicationRunListener 的 environmentPrepared（）的方法，告诉它们：“当前 SpringBoot 应用使用的 Environment 准备好咯！”。</li>
<li>如果 SpringApplication的showBanner 属性被设置为 true，则打印 banner（SpringBoot 1.3.x版本，这里应该是基于 Banner.Mode 决定 banner 的打印行为）。</li>
<li>根据用户是否明确设置了applicationContextClass 类型以及初始化阶段的推断结果，决定该为当前 SpringBoot 应用创建什么类型的 ApplicationContext 并创建完成，然后根据条件决定是否添加 ShutdownHook，决定是否使用自定义的 BeanNameGenerator，决定是否使用自定义的 ResourceLoader，当然，最重要的，将之前准备好的 Environment 设置给创建好的 ApplicationContext 使用。</li>
<li><code>ApplicationContext</code>创建好之后，SpringApplication 会再次借助 Spring-FactoriesLoader，查找并加载 classpath 中所有可用的 ApplicationContext-Initializer，然后遍历调用这些 ApplicationContextInitializer 的 initialize（applicationContext）方法来对已经创建好的 ApplicationContext 进行进一步的处理。</li>
<li>遍历调用所有 SpringApplicationRunListener 的 contextPrepared（）方法，通知它们：“SpringBoot 应用使用的 ApplicationContext 准备好啦！”</li>
<li>最核心的一步，将之前通过 @EnableAutoConfiguration 获取的所有配置以及其他形式的 IoC 容器配置加载到已经准备完毕的 ApplicationContext。</li>
<li>遍历调用所有 SpringApplicationRunListener 的 contextLoaded() 方法，告知所有 SpringApplicationRunListener，ApplicationContext “装填完毕”！</li>
<li>调用 ApplicationContext 的 refresh() 方法，完成 IoC 容器可用的最后一道工序。</li>
<li>查找当前 ApplicationContext 中是否注册有 CommandLineRunner，如果有，则遍历执行它们。</li>
<li>正常情况下，遍历执行 SpringApplicationRunListener 的 finished() 方法，告知它们：“搞定！”。（如果整个过程出现异常，则依然调用所有 SpringApplicationRunListener 的 finished() 方法，只不过这种情况下会将异常信息一并传入处理）。</li>
</ol>
<p>至此，一个完整的 SpringBoot 应用启动完毕！</p>
<p>整个过程看起来冗长无比，但其实很多都是一些事件通知的扩展点，如果我们将这些逻辑暂时忽略，那么，其实整个 SpringBoot 应用启动的逻辑就可以压缩到极其精简的几步，如图 1 所示。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/SpringBoot入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/SpringBoot/SpringBoot%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-10-29T09:05:54.759Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Spring-Boot-的特点"><a href="#Spring-Boot-的特点" class="headerlink" title="Spring Boot 的特点"></a>Spring Boot 的特点</h1><p>Spring Boot 具有以下特点：</p>
<ol>
<li>独立运行的 Spring 项目<br>Spring Boot 可以以 jar 包的形式独立运行，Spring Boot 项目只需通过命令<code>java–jar xx.jar</code>即可运行。</li>
<li>内嵌 Servlet 容器<br>Spring Boot 使用嵌入式的 Servlet 容器（例如 Tomcat、Jetty等），应用无需打成 WAR 包。</li>
<li>提供 starter 简化 Maven 配置<br>Spring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。</li>
<li>提供了大量的自动配置<br>Spring Boot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。</li>
<li>自带应用监控<br>Spring Boot 可以对正在运行的项目提供监控。</li>
<li>无代码生成和 xml 配置<br>Spring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。</li>
</ol>
<h1 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h1><p><code>@SpringBootApplication</code>是一个“三体”结构，实际上它是一个复合<code>Annotation</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScanpublic</span><br><span class="line">@interface</span><br><span class="line">SpringBootApplication&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>虽然它的定义使用了多个<code>Annotation</code>进行元信息标注，但实际上对于 SpringBoot 应用来说，重要的只有三个<code>Annotation</code>，而“三体”结构实际上指的就是这三个<code>Annotation</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan</span><br></pre></td></tr></table></figure>
<p>所以，如果我们使用如下的 SpringBoot 启动类，整个 SpringBoot 应用依然可以与之前的启动类功能对等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScanpublic</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但每次都写三个<code>Annotation</code>显然过于繁琐，所以写一个<code>@SpringBootApplication</code>这样的一站式复合<code>Annotation</code>显然更方便些。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>这里的<code>@Configuration</code>是 JavaConfig 形式的 Spring IoC 容器的配置类使用的那个<code>@Configuration</code>，既然 SpringBoot 应用就是一个 Spring 应用，那么，自然也需要加载某个 IoC 容器的配置，而 SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，很明显，这里的启动类标注了<code>@Configuration</code>之后，本身其实也是一个 IoC 容器的配置类！</p>
<p>如果我们将上面的 SpringBoot 启动类拆分为两个独立的 Java 类，整个形势就明朗了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfiguration</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Controller <span class="title function_">controller</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Controller</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoConfiguration.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，启动类<code>DemoApplication</code>其实就是一个标准的<code>Standalone</code>类型 Java 程序的<code>main</code>函数启动类，没有什么特殊的。而<code>@Configuration</code>标注的<code>DemoConfiguration</code>定义其实也是一个普通的 JavaConfig 形式的 IoC 容器配置类。</p>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p><code>@EnableAutoConfiguration</code>借助<code>@Import</code>，将所有符合自动配置条件的<code>bean</code>定义加载到 IoC 容器。</p>
<p><code>@EnableAutoConfiguration</code>作为一个复合<code>Annotation</code>，其自身定义关键信息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>其中，最关键的要属<code>@Import（EnableAutoConfigurationImportSelector.class）</code>，借助<code>EnableAutoConfigurationImportSelector</code>，<code>@EnableAutoConfiguration</code>可以帮助 SpringBoot 应用将所有符合条件的<code>@Configuration</code>配置都加载到当前 SpringBoot 创建并使用的 IoC 容器。</p>
<img src="/2022/10/29/java/SpringBoot/SpringBoot%E5%85%A5%E9%97%A8/1.png" class="">

<p>借助于 Spring 框架原有的一个工具类：<code>SpringFactoriesLoader</code>的支持，<code>@EnableAutoConfiguration</code>可以“智能”地自动配置功效才得以大功告成！</p>
<h2 id="SpringFactoriesLoader"><a href="#SpringFactoriesLoader" class="headerlink" title="SpringFactoriesLoader"></a>SpringFactoriesLoader</h2><p><code>SpringFactoriesLoader</code>属于 Spring 框架私有的一种扩展方案（类似于 Java 的 SPI 方案<code>java.util.ServiceLoader</code>），其主要功能就是从指定的配置文件<code>META-INF/spring.factories</code>加载配置，<code>spring.factories</code>是一个典型的 java <code>properties</code>文件，配置的格式为<code>Key=Value</code>形式，只不过<code>Key</code>和<code>Value</code>都是 Java 类型的完整类名，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">example.MyService=example.MyServiceImpl1,example.MyServiceImpl2 然后框架就可以根据某个类型作为 Key 来查找对应的类型名称列表了：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SpringFactoriesLoader</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>@EnableAutoConfiguration</code>来说，<code>SpringFactoriesLoader</code>的用途稍微不同一些，其本意是为了提供 SPI 扩展的场景，而在<code>@EnableAutoConfiguration</code>的场景中，它更多是提供了一种配置查找的功能支持，即根据<code>@EnableAutoConfiguration</code>的完整类名<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>作为查找的<code>Key</code>，获取对应的一组<code>@Configuration</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=</span><br><span class="line">\org.springframework.boot.autoconfigure.admin.SpringApplicationAdmin- JmxAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.PropertyPlaceholderAuto- Configuration,</span><br><span class="line">\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.cassandra.CassandraAuto-Configuration,</span><br><span class="line">\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.context.ConfigurationProperties-AutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.dao.PersistenceException-TranslationAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.data.cassandra.Cassandra-DataAutoConfiguration,</span><br><span class="line">\org.springframework.boot.autoconfigure.data.cassandra.Cassandra-RepositoriesAutoConfiguration,</span><br><span class="line">\...</span><br></pre></td></tr></table></figure>
<p>以上是从 SpringBoot 的<code>autoconfigure</code>依赖包中的<code>META-INF/spring.factories</code>配置文件中摘录的一段内容，可以很好地说明问题。</p>
<p>所以，<code>@EnableAutoConfiguration</code>自动配置的魔法其实就变成了：从<code>classpath</code>中搜寻所有<code>META-INF/spring.factories</code>配置文件，并将其中<code>org.spring-framework.boot.autoconfigure.EnableAutoConfiguration</code>对应的配置项通过反射实例化为对应的标注了<code>@Configuration</code>的<code>JavaConfig</code>形式的 IoC 容器配置类，然后汇总为一个并加载到 IoC 容器。</p>
<h2 id="可有可无的-ComponentScan"><a href="#可有可无的-ComponentScan" class="headerlink" title="可有可无的@ComponentScan"></a>可有可无的@ComponentScan</h2><p>为啥说<code>@ComponentScan</code>是可有可无的？</p>
<p>因为原则上来说，<code>@ComponentScan</code>的功能其实就是自动扫描并加载符合条件的组件或<code>bean</code>定义，最终将这些<code>bean</code>定义加载到容器中。加载<code>bean</code>定义到 Spring 的 IoC 容器，我们可以手工单个注册，不一定非要通过批量的自动扫描完成，所以说<code>@ComponentScan</code>是可有可无的。</p>
<p>对于 SpringBoot 应用来说，同样如此。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScanpublic</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们当前应用没有任何<code>bean</code>定义需要通过<code>@ComponentScan</code>加载到当前 SpringBoot 应用对应使用的 IoC 容器，那么，除去<code>@ComponentScan</code>的声明，当前 SpringBoot 应用依然可以照常运行，功能对等。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/Spring-Boot-Starter常用依赖模块"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/SpringBoot/Spring-Boot-Starter%E5%B8%B8%E7%94%A8%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97/" class="article-date">
  <time datetime="2022-10-29T09:05:54.758Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>SpringBoot 提供的依赖模块都约定以<code>spring-boot-starter-</code>作为命名的前缀，并且皆位于<code>org.springframework.boot</code>包或者命名空间下。</p>
<p>所有的<code>spring-boot-starter</code>都有约定俗成的默认配置，但允许我们调整这些配置以改变默认的配置行为，即“约定优先于配置”。</p>
<h1 id="应用日志和spring-boot-starter-logging"><a href="#应用日志和spring-boot-starter-logging" class="headerlink" title="应用日志和spring-boot-starter-logging"></a>应用日志和spring-boot-starter-logging</h1><p>Java 的日志系统多种多样，从<code>java.util</code>默认提供的日志支持，到<code>log4j，log4j2，commons logging</code>等，复杂繁多，所以，应用日志系统的配置就会比较特殊，从而<code>spring-boot-starter-logging</code>也比较特殊一些。</p>
<p>假如 maven 依赖中添加了<code>spring-boot-starter-logging</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-logging <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，我们的 SpringBoot 应用将自动使用 logback 作为应用日志框架，SpringBoot 启动的时候，由 org.springframework.boot.logging.Logging-Application-Listener 根据情况初始化并使用。</p>
<p>SpringBoot 为我们提供了很多默认的日志配置，所以，只要将 spring-boot-starter-logging 作为依赖加入到当前应用的 classpath，则“开箱即用”，不需要做任何多余的配置，但假设我们要对默认 SpringBoot 提供的应用日志设定做调整，则可以通过几种方式进行配置调整：<br>遵循 logback 的约定，在 classpath 中使用自己定制的 logback.xml 配置文件。<br>在文件系统中任何一个位置提供自己的 logback.xml 配置文件，然后通过 logging.config 配置项指向这个配置文件来启用它，比如在 application.properties 中指定如下的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.config=/&#123;some.path.you.defined&#125;/any-logfile-name-I-like.log</span><br></pre></td></tr></table></figure>
<p>SpringBoot 默认允许我们通过在配置文件或者命令行等方式使用 logging.file 和 logging.path 来自定义日志文件的名称和存放路径，不过，这只是允许我们在 SpringBoot 框架预先定义的默认日志系统设定的基础上做有限的设置，如果我们希望更灵活的配置，最好通过框架特定的配置方式提供相应的配置文件，然后通过 logging.config 来启用。</p>
<p>如果大家更习惯使用 log4j 或者 log4j2，那么也可以采用类似的方式将它们对应的<code>spring-boot-starter</code>依赖模块加到 Maven 依赖中即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-log4j <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.springframework.boot <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> spring-boot-starter-log4j2 <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但一定不要将这些完成同一目的的 spring-boot-starter 都加到依赖中。</p>
<h1 id="快速-Web-应用开发与-spring-boot-starter-web"><a href="#快速-Web-应用开发与-spring-boot-starter-web" class="headerlink" title="快速 Web 应用开发与 spring-boot-starter-web"></a>快速 Web 应用开发与 spring-boot-starter-web</h1><p>为了帮我们简化快速搭建并开发一个 Web 项目，SpringBoot 提供了<code>spring-boot-starter-web</code>自动配置模块。</p>
<p>只要将<code>spring-boot-starter-web</code>加入项目的 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们就得到了一个直接可执行的 Web 应用，当前项目下运行<code>mvn spring-boot：run</code>就可以直接启动一个使用了嵌入式 tomcat 服务请求的 Web 应用，只不过，我们还没有提供任何服务 Web 请求的<code>Controller</code>，所以，访问任何路径都会返回一个 SpringBoot 默认提供的错误页面（一般称其为 whitelabel error page），我们可以在当前项目下新建一个服务根路径 Web 请求的 Controller 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, there&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行 mvn spring-boot：run 并访问<code>http://localhost：8080</code>，错误页面将被我们的<code>Controller</code>返回的消息所替代，一个简单的 Web 应用就这样完成了。</p>
<h2 id="项目结构层面的约定"><a href="#项目结构层面的约定" class="headerlink" title="项目结构层面的约定"></a>项目结构层面的约定</h2><p>项目结构层面与传统打包为 war 的 Java Web 应用的差异在于，静态文件和页面模板的存放位置变了，原来是放在<code>src/main/webapp </code>目录下的一系列资源，现在都统一放在<code>src/main/resources</code>相应子目录下，比如：</p>
<ul>
<li><code>src/main/resources/static</code>用于存放各类静态资源，比如<code>css，js</code>等。</li>
<li><code>src/main/resources/templates</code>用于存放模板文件，比如<code>*.vm</code>。</li>
</ul>
<p>当然，如果还是希望以 war 包的形式，而不是 SpringBoot 推荐使用的独立 jar 包形式发布 Web 应用，也可以继续原来 Java Web 应用的项目结构约定。</p>
<h2 id="SpringMVC-框架层面的约定和定制"><a href="#SpringMVC-框架层面的约定和定制" class="headerlink" title="SpringMVC 框架层面的约定和定制"></a>SpringMVC 框架层面的约定和定制</h2><p><code>spring-boot-starter-web</code>默认将为我们自动配置如下一些 SpringMVC 必要组件：</p>
<ul>
<li>必要的<code>ViewResolver</code>，比如<code>ContentNegotiatingViewResolver</code>和<code>Bean-NameViewResolver</code>。</li>
<li>将必要的<code>Converter、GenericConverter</code>和<code>Formatter</code>等<code>bean</code>注册到 IoC 容器。</li>
<li>添加一系列的<code>HttpMessageConverter</code>以便支持对 Web 请求和相应的类型转换。</li>
<li>自动配置和注册<code>MessageCodesResolver</code>。</li>
<li>其他。</li>
</ul>
<p>任何时候，如果我们对默认提供的 SpringMVC 组件设定不满意，都可以在 IoC 容器中注册新的同类型的<code>bean</code>定义来替换，或者直接提供一个基于<code>WebMvcConfigurerAdapter</code>类型的<code>bean</code>定义来定制，甚至直接提供一个标注了<code>@EnableWebMvc</code>的<code>@Configuration</code>配置类完全接管所有 SpringMVC 的相关配置，自己完全重新配置。</p>
<h1 id="spring-boot-starter-jdbc与数据访问"><a href="#spring-boot-starter-jdbc与数据访问" class="headerlink" title="spring-boot-starter-jdbc与数据访问"></a>spring-boot-starter-jdbc与数据访问</h1><p>若想 SpringBoot 为我们自动配置数据访问的基础设施，那么，我们需要直接或者间接地依赖 spring-jdbc，一旦 spring-jdbc 位于我们 SpringBoot 应用的 classpath，即会触发数据访问相关的自动配置行为，最简单的做法就是把 spring-boot-starter-jdbc 加为应用的依赖。</p>
<p>默认情况下，如果我们没有配置任何 DataSource，那么，SpringBoot 会为我们自动配置一个基于嵌入式数据库的 DataSource，这种自动配置行为其实很适合于测试场景，但对实际的开发帮助不大，基本上我们会自己配置一个 DataSource 实例，或者通过自动配置模块提供的配置参数对 DataSource 实例进行自定义的配置。</p>
<p>假设我们的 SpringBoot 应用只依赖一个数据库，那么，使用<code>DataSource</code>自动配置模块提供的配置参数是最方便的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://&#123;database host&#125;:3306/&#123;databaseName&#125;</span><br><span class="line">spring.datasource.username=&#123;database username&#125;</span><br><span class="line">spring.datasource.password=&#123;database password&#125;</span><br></pre></td></tr></table></figure>
<p>当然，自己配置一个 DataSource 也是可以的，SpringBoot 也会智能地选择我们自己配置的这个 DataSource 实例（只不过必要性真不大）。</p>
<p>除了 DataSource 会自动配置，SpringBoot 还会自动配置相应的 JdbcTemplate、DataSourceTransactionManager 等关联“设施”，可谓服务周到，我们只要在使用的地方注入就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeDao</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  JdbcTemplate jdbcTemplate;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">queryForList</span><span class="params">(String sql)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，spring-boot-starter-jdbc 以及与其相关的自动配置也不总是带来便利，在某些场景下，我们可能会在一个应用中需要依赖和访问多个数据库，这个时候就会出现问题了。</p>
<p>假设我们在 ApplicationContext 中配置了多个 DataSource 实例指向多个数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource1</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">  dataSource.setUrl(...);</span><br><span class="line">  dataSource.setUsername(...);</span><br><span class="line">  dataSource.setPassword(...);</span><br><span class="line">  <span class="comment">// TODO other settings if necessary in the future.</span></span><br><span class="line">  <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource2</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">  dataSource.setUrl(...);</span><br><span class="line">  dataSource.setUsername(...);</span><br><span class="line">  dataSource.setPassword(...);</span><br><span class="line">  <span class="comment">// TODO other settings if necessary in the future.</span></span><br><span class="line">  <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，启动 SpringBoot 应用的时候会抛出类似如下的异常（Exception）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception）：No qualifying bean of type [javax.sql.DataSource] is defined: expected single matching bean but found 2 </span><br></pre></td></tr></table></figure>
<p>为了避免这种情况的发生，我们需要在 SpringBoot 的启动类上做点儿“手脚”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">    DataSourceTransactionManagerAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnveilSpringChapter3Application</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(UnveilSpringChapter3Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，我们需要在这种场景下排除掉对 SpringBoot 默认提供的<code>DataSource</code>相关的自动配置。但如果我们还是想要享受 SpringBoot 提供的自动配置<code>DataSource</code>的机能，也可以通过为其中一个<code>DataSource</code>配置添加<code>org.springframework.context.annotation.Primary</code>这个<code>Annotation</code>的方式以实现两全其美：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource1</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">  dataSource.setUrl(...);</span><br><span class="line">  dataSource.setUsername(...);</span><br><span class="line">  dataSource.setPassword(...);</span><br><span class="line">  <span class="comment">// TODO other settings if necessary in the future.</span></span><br><span class="line">  <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource2</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">  dataSource.setUrl(...);</span><br><span class="line">  dataSource.setUsername(...);</span><br><span class="line">  dataSource.setPassword(...);</span><br><span class="line">  <span class="comment">// TODO other settings if necessary in the future.</span></span><br><span class="line">  <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，SpringBoot 还提供了很多其他数据访问相关的自动配置模块，比如<code>spring-boot-starter-data-jpa、spring-boot-starter-data-mongodb</code>等。</p>
<p>如果选择了<code>spring-boot-starter-data-jpa</code>等关系数据库相关的数据访问自动配置模块，并且还需要同时依赖访问多个数据库，那么，也需要相应的在 SpringBoot 启动类中排除掉这些自动配置模块中的<code>AutoConfiguration</code>实现类（对应<code>spring-boot-starter-data-jpa</code>是<code>JpaRepositoriesAutoConfiguration</code>），或者标注某个<code>DataSource</code>为<code>@Primary</code>。</p>
<h1 id="spring-boot-starter-aop"><a href="#spring-boot-starter-aop" class="headerlink" title="spring-boot-starter-aop"></a>spring-boot-starter-aop</h1><p>现在 Spring 框架提供的 AOP 方案倡导了一种各取所长的方案，即使用 SpringAOP 的面向对象的方式来编写和组织织入逻辑，并使用 AspectJ 的 Pointcut 描述语言配合 Annotation 来标注和指明织入点（Jointpoint）。</p>
<p>SpringBoot 为我们提供了一个<code>spring-boot-starter-aop</code>自动配置模块。</p>
<p>spring-boot-starter-aop 自动配置行为由两部分内容组成：<br>位于 spring-boot-autoconfigure的org.springframework.boot.autoconfigure.aop.AopAutoConfiguration 提供 @Configuration 配置类和相应的配置项。<br>spring-boot-starter-aop 模块自身提供了针对 spring-aop、aspectjrt 和 aspectjweaver 的依赖。</p>
<p>一般情况下，只要项目依赖中加入了 spring-boot-starter-aop，其实就会自动触发 AOP 的关联行为，包括构建相应的 AutoProxyCreator，将横切关注点织入（Weave）相应的目标对象等，不过 AopAutoConfiguration 依然为我们提供了可怜的两个配置项，用来有限地干预 AOP 相关配置：<br>spring.aop.auto&#x3D;true<br>spring.aop.proxy-target-class&#x3D;false</p>
<p>对我们来说，这两个配置项的最大意义在于：允许我们投反对票，比如可以选择关闭自动的 aop 配置（spring.aop.auto&#x3D;false），或者启用针对 class 而不是 interface 级别的 aop 代理（aop proxy）。</p>
<p>AOP 的应用场景很多，我们不妨以当下最热门的 APM（Application Performance Monitoring）为实例场景，尝试使用 spring-boot-starter-aop 的支持打造一个应用性能监控的工具原型。<br>spring-boot-starter-aop 在构建 spring-boot-starter-metrics 自定义模块中的应用<br>对于应用性能监控来说，架构逻辑上其实很简单，基本上就是三步走（如图 1 所示）。</p>
<p>本节暂时只构建一个 spring-boot-starter-metrics 自定义的自动配置模块用来解决“应用性能数据采集”的问题。<br>应用性能监控关键环节示意图<br>图 1  应用性能监控关键环节示意图</p>
<p>在此之前，有几个原则我们需要先说明一下：</p>
<p>虽然说采集应用性能数据可以帮助我们更好地分析和改进应用的性能指标，但这不意味着可以借着 APM 的名义对应用的核心职能形成侵害，加上应用性能数据采集功能一定会对应用的性能本身带来拖累，你拿到的所谓性能数据是分摊了你的数据采集方案带来的负担，所以，一般情况下，最好把应用性能数据采集模块的性能损耗控制在 10% 以内甚至更小。</p>
<p>SpringAOP 其实提供了多种横切逻辑织入机制（Weaving），性能损耗上也是各有差别，从运行期间的动态代理和字节码增强 Weavng，到类加载期间的 Weaving，甚至高冷的 AspectJ 二次静态编译 Weaving，大家可以根据情况灵活把握。</p>
<p>针对应用性能数据的采集，最好对应用开发者是透明的，通过配置外部化的形式，可以最大限度地剥离这部分对应用开发者来说非核心的关注点，只在部署和运行之前确定采集点并配置上线即可。</p>
<p>虽然本节实例采用基于 @Annotation 的方式来标注性能采集点，但不意味着这是最优的方式，更多是基于技术方案（SpringAOP）的现状给出的一种实践方式。</p>
<p>下面我们正式着手构建 spring-boot-starter-metrics 自定义的自动配置模块的设计和实现方案。</p>
<p>笔者一向是只在有必要的时候才重新“造轮子”，绝不会为了炫技而去“造轮子”，所以，本次的主角我们选择 Java 中的 Dropwizard Metrics 这个类库作为打造我们 APM 原型的起点。</p>
<p>Dropwizard Metrics 为我们提供了多种不同类型的应用数据度量方案，且通过相应的数据处理算法在性能和批量状态的管理上做了很优秀的工作，只不过，如果我们直接用它的 API 来对自己的应用代码进行度量的话，那写起来代码太多，而且这些性能代码混杂在应用的核心逻辑执行路径上，一个是界面不友好，另外一个就是不容易维护：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  MetricRegistry metricRegistry;</span><br><span class="line">  <span class="keyword">private</span> Timer timer;</span><br><span class="line">  <span class="keyword">private</span> Counter counter;</span><br><span class="line">  <span class="comment">// define more other metrics...</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span> &#123;</span><br><span class="line">    counter.inc();</span><br><span class="line">    Timer.<span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> timer.time();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;just do something.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    timer = metricRegistry.timer(<span class="string">&quot;timerToProfilingDoSthMethod&quot;</span>);</span><br><span class="line">    counter = metricRegistry.counter(<span class="string">&quot;counterForDoSthMethod&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，对于这些非功能性的性能度量代码，我们可以使用 AOP 的方式剥离到相应的 Aspect 中单独维护，而为了能够将这些性能度量的 Aspect 挂接到指定的待度量代码上，基于现有的方案选型。</p>
<p>可以使用 metrics-annotation 提供的一系列 Annotation 来标注织入位置，这样，开发者只要在需要度量的代码位置上标注相应的 Annotation，我们提供的 spring-boot-starter-metrics 自定义的自动配置模块就会自动地收集这些位置上指定的性能度量数据。</p>
<p>首先，我们通过 <a target="_blank" rel="noopener" href="http://start.spring.io/">http://start.spring.io/</a> 构建一个 SpringBoot 的脚手架项目，选择以 Maven 编译（选择用 Gradle 的同学自行甄别后面的配置如何具体进行），然后在创建好的 SpringBoot 脚手架项目的 pom.xml 中添加如下必要配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">      http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.keevol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-metrics<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-boot-starter-metrics<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>auto configuration module for dropwizard metrics<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">metrics.version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">metrics.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--其他配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dropwizard.metrics<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>metrics-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span></span><br><span class="line">        $&#123;metrics.version&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.dropwizard.metrics<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>metrics-annotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;metrics.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>pom.xml 中有几个关键配置需要关注：<br>继承了 spring-boot-starter-parent，用于加入 springboot 的相关依赖。<br>添加了 spring-boot-starter-aop 依赖。<br>添加了 io.dropwizard.metrics 下相应的依赖，用来引入 dropwizard metrics 类库和必要的 Annotations。<br>添加了 spring-boot-starter-actuator，这个自动配置模块教程后面会跟大家进一步介绍，在这里我们主要是引入它对 dropwizard metrics 和 JMX 的一部分自动配置逻辑，比如针对 MetricRegistry 和 MBeanServer 的自动配置，这样我们就可以直接 @Autowired 来注入使用 MetricRegistry 和 MBeanServer。</p>
<p>至于 aspectjrt，是使用了最新的版本，原则上spring-boot-starter-aop已经有依赖，这里可以不用明确添加配置。</p>
<p>如果单单是一个提供必要依赖的自动配置模块，那么到这里其实就可以结束了，但我们的 spring-boot-starter-metrics 需要使用 AOP 提供相应的横切关注点逻辑。</p>
<p>所以，还需要编写并提供一些必要的代码组件，因此，最少我们先要提供一个 @Configuration 配置类，用于将我们即将提供的这些 AOP 逻辑暴露给使用者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123; &quot;com.keevol.springboot.metrics.lifecycle&quot;,</span></span><br><span class="line"><span class="meta">    &quot;com.keevol.springboot.metrics.aop&quot; &#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(AopAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DropwizardMetricsMBeansAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="meta">@Value(&quot;$&#123;metrics.mbeans.domain.name:com.keevol.metrics&#125;&quot;)</span></span><br><span class="line">  String metricsMBeansDomainName;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  MBeanServer mbeanServer;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  MetricRegistry metricRegistry;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> JmxReporter <span class="title function_">jmxReporter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">JmxReporter</span> <span class="variable">reporter</span> <span class="operator">=</span> JmxReporte.forRegistry(metricRegistry)</span><br><span class="line">        .inDomain(metricsMBeansDomainName).registerWith(mbeanServer)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">return</span> reporter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是将这个配置类添加到 META-INF&#x2F;spring.factories：</p>
<p>org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\com.keevol.springboot.metrics.autocfg.DropwizardMetricsMBeansAuto-ConfigurationOK，<br>不要认为将 spring-boot-starter-metrics 打包作为类库发布出去就可以了，AOP 相关的代码还没写。</p>
<p>我们回头来看 DropwizardMetricsMBeansAutoConfiguration 配置类，这个配置类的实现很简单，注入了 MBeanServer 和 MetricRegistry 的实例，并开放了一个 metrics.mbeans.domain.name 配置属性（默认值 com.keevol.metrics）便于使用者指定自定义的 MBean 暴露和访问的命名空间。</p>
<p>当然，以上给这些其实都不是重点，因为它们都只是为了将我们要采集的性能数据指标以 JMX 的形式暴露出去而服务的，重点在于 DropwizardMetricsMBeansAutoConfiguration 头顶上的那几顶“帽子”：<br>@Configuration 自然不必说了，这是一个 JavaConfig 配置类。<br>@ComponentScan（{“com.keevol.springboot.metrics.lifecycle”，”com.keevol.springboot.metrics.aop”}），为了简便，让 @ComponentScan 把这两个 java package 下的所有组件都加载到 IoC 容器中，这些组件就包括我们要提供的一系列与 AOP 和 Dropwizard Metrics 相关的实现逻辑。<br>@AutoConfigureAfter（AopAutoConfiguration.class）告诉 SpringBoot：“我希望 DropwizardMetricsMBeansAutoConfiguration 在 AopAutoConfiguration 完成之后进行配置”。</p>
<p>现在，最后的秘密就隐藏在 @ComponentScan 背后的两个 java package 之下了。</p>
<p>首先是 com.keevol.springboot.metrics.aop，在这个 java package 下面，我们只提供了一个 AutoMetricsAspect，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspectpublic</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoMetricsAspect</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> ConcurrentMap&lt;String, Meter&gt; meters = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> ConcurrentMap&lt;String, Meter&gt; exceptionMeters = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> ConcurrentMap&lt;String, Timer&gt; timers = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> ConcurrentMap&lt;String, Counter&gt; counters = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  MetricRegistry metricRegistry;</span><br><span class="line">  <span class="meta">@Pointcut(value = &quot;execution(public * *(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethods</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Before(&quot;publicMethods() &amp;&amp; @annotation(countedAnnotation)&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instrumentCounted</span><span class="params">(JoinPoint jp, Counted countedAnnotation)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> name(jp.getTarget().getClass(), StringUtils.hasLength(countedAnnotation.name()) ? countedAnnotation.name() : jp.getSignature().getName(), <span class="string">&quot;counter&quot;</span>);</span><br><span class="line">      <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> counters.computeIfAbsent(name, key -&gt; metricRegistry.counter(key));</span><br><span class="line">      counter.inc();</span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Before(&quot;publicMethods() &amp;&amp; @annotation(meteredAnnotation)&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instrumentMetered</span><span class="params">(JoinPoint jp, Metered meteredAnnotation)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> name(jp.getTarget().getClass(), StringUtils.hasLength(meteredAnnotation.name()) ? meteredAnnotation.name() : jp.getSignature().getName(), <span class="string">&quot;meter&quot;</span>);</span><br><span class="line">      <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> meters.computeIfAbsent(name, key -&gt; metricRegistry.meter(key));</span><br><span class="line">      meter.mark();</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="meta">@AfterThrowing(pointcut = &quot;publicMethods() &amp;&amp; @annotation(exMe-teredAnnotation)&quot;, throwing = &quot;ex&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instrumentExceptionMetered</span><span class="params">(JoinPoint jp, Throwable ex, ExceptionMetered exMeteredAnnotation)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> name(jp.getTarget().getClass(), StringUtils.hasLength(exMeteredAnnotation.name()) ? exMeteredAnnotation.name() : jp.getSignature().getName(), <span class="string">&quot;meter&quot;</span>, <span class="string">&quot;exception&quot;</span>);</span><br><span class="line">      <span class="type">Meter</span> <span class="variable">meter</span> <span class="operator">=</span> exceptionMeters.computeIfAbsent(name, meterName -&gt; metricRegistry.meter(meterName));</span><br><span class="line">      meter.mark();</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="meta">@Around(&quot;publicMethods() &amp;&amp; @annotation(timedAnnotation)&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">instrumentTimed</span><span class="params">(ProceedingJoinPoint pjp, Timed timedAnnotation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> name(pjp.getTarget().getClass(), StringUtils.hasLength(timedAnnotation.name()) ? timedAnnotation.name() : pjp.getSignature().getName(), <span class="string">&quot;timer&quot;</span>);</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> timers.computeIfAbsent(name, inputName -&gt; metricRegistry.timer(inputName));</span><br><span class="line">    Timer.<span class="type">Context</span> <span class="variable">tc</span> <span class="operator">=</span> timer.time();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      tc.stop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Aspect+@Component 的目的在于告诉 Spring 框架：“我是一个 AOP 的 Aspect 实现类并且你可以通过 @ComponentScan 把我加入 IoC 容器之中。”当然，这不是重点。</p>
<p>io.dropwizard.metrics：metrics-annotation 这个依赖包为我们提供了几个有趣的 Annotation：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Timed</span><br><span class="line">Gauge</span><br><span class="line">Counted</span><br><span class="line">Metered</span><br><span class="line">ExceptionMetered</span><br></pre></td></tr></table></figure>
<p>这些语义良好的 Annotation 定义可以用来标注相应的 AOP 逻辑扩展点，比如，针对同一个 MockService，我们可以将性能数据的度量和采集简化为只标注一两个 Annotation 就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> &#123;</span><br><span class="line">  <span class="meta">@Timed</span></span><br><span class="line">  <span class="meta">@Counted</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;just do something.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，Annotation 注定只是 Annotation，它们只是一些标记信息，要让它们发挥作用，需要有“伯乐”的眷顾，所以，AutoMetricsAspect 在这里就是这些 Dropwizard Metrics Annotation 的“伯乐”。</p>
<p>通过拦截每一个 public 方法并检查方法上是否存在某个 metrics annotation，我们就可以根据具体的 metrics annotation 的类型，为匹配的方法注入相应性能数据采集代码逻辑，从而完成整个基于 AOP 和 dropwizard metrics 的应用性能数据采集方案的实现。</p>
<p>受限于 SpringAOP 自身的一些限制，并不是所有 AOP 的 Joinpoint 类型都支持，而且，以上原型代码方向也不见得是性能最优的方案，大家需要结合自己的目标和手上可用的技术手段，根据自己的具体应用场景具体分析和权衡。</p>
<h1 id="spring-boot-starter-security与应用安全"><a href="#spring-boot-starter-security与应用安全" class="headerlink" title="spring-boot-starter-security与应用安全"></a>spring-boot-starter-security与应用安全</h1><p>spring-boot-starter-security 主要面向 Web 应用安全，配合 spring-boot-starter-web。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.keevol.unveilspring.chapter3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>web-security-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>web-security-demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>web security demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!--其他依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在当前项目中只要添加需要的 Controller 实现，一个添加了基本安全防护的 Web 应用就诞生了。spring-boot-starter-security 默认会提供一个基于 HTTP Basic 认证的安全防护策略，默认用户名为 user，访问密码则在当前 Web 应用启动的时候，打印到控制台，类似于：<br>2017-01-01 13:57:00.596 INFO 17966 — [ost-startStop-1] b.a.s.Au-thenticationManagerConfiguration : Using default security password: 560ff91b-0ae7-492c-ad16-603e1adec54c </p>
<p>如果我们希望对 HTTP Basic 认证的用户名和密码进行定制，可以通过如下配置项进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security.user.name=&#123;个人希望设置的用户名&#125;</span><br><span class="line">security.user.password=&#123;个人希望使用的访问密码&#125; </span><br></pre></td></tr></table></figure>
<p>除此之外，spring-boot-starter-security 还会默认启用一些必要的 Web 安全防护，比如针对 XSS、CSRF 等常见针对 Web 应用的攻击，同时，也会将一些常见的静态资源路径排除在安全防护之外。</p>
<p>但是，说实话，spring-boot-starter-security 提供的默认安全策略相对于真正的生产环境来说，还是太弱了。但也没办法，既要安全，又要便利，spring-boot-starter-security 默认情况下已经尽量做到够好了。</p>
<p>不过好在 SpringSecurity 扩展性不错，要在其上构建一套真正严谨有效的 Web 应用安全防护体系也并非难事，只不过，需要我们先能够从其架构设计上理解并把握它，然后再在 SpringSecurity 和 SpringBoot 的基础上构建一套符合自身需要的 Web 应用安全方案。</p>
<h2 id="了解-SpringSecurity-基本设计"><a href="#了解-SpringSecurity-基本设计" class="headerlink" title="了解 SpringSecurity 基本设计"></a>了解 SpringSecurity 基本设计</h2><p>SpringSecurity 框架不但囊括了基本的认证和授权功能，而且还提供了加密解密、统一登录等一系列相关支持。</p>
<p>我们可以将 Spring Security 的几个核心概念按照图 1 所示勾勒在一起：<br>SpringSecurity核心概念示意图<br>图 1  SpringSecurity 核心概念示意图</p>
<p>访问者（Accessor）需要访问某个资源（Resources）是这个场景中最原始的需求，但并不是谁都可以访问资源，也不是任何资源都允许任何人来访问，所以，中间我们要加入一些检查和防护。</p>
<p>在访问资源的所经之路上，可能需要上山、过桥、下海行船，不管怎么样，这些所经之路对于我们要防护的资源来说都是比较好的设置关卡点，对应上图就是 FilterInvocation（对应 Web 应用场景）、MethodInvocation 以及 Joinpoint，这些在 Spring Security 框架中统称 Secured Object（s）。</p>
<p>我们知道了在哪里设置关卡最合适，下一步就是设置关卡，对应不同的所经之路，我们分别设置类似 FilterSecurityInterceptor、Method-SecurityInterceptor 以及 AspectJSecurityInterceptor 这样的关卡来负责拦截非法资源访问的闯入者们。</p>
<p>而在 Spring Security 框架的设计中，关卡的概念统一抽象为 AbstractSecurityInterceptor，而 FilterSecurity-Interceptor、MethodSecurityInterceptor 以及 AspectJSecurityInterceptor 都是它的具体实现类。</p>
<p>现在把门儿的倒是有了，可是他们不知道该拦谁，不该拦谁，所以，我们需要有类似神盾局（S.H.I.E.L.D）这样的机构，由这个机构来决定谁可以放行，谁必须阻截，而在 SpringSecurity 框架中 AccessDecisionManager 就是这个控制机构，AccessDecisionManager 将决定谁可以访问哪些资源。</p>
<p>现在剩下最后一个问题，这个谁怎么定义？我们总得知道当前这个访问者是谁才能告知 AccessDecisionManager 阻截还是放行，所以，SpringSecurity 框架中的 AuthenticationManager 将解决的是访问者身份认证的问题，只有确定你在册了，才可以给你授权访问（除非匿名访问某些公共资源）。</p>
<p>AuthenticationManager、AccessDecisionManager 和 AbstractSecurityInterceptor 属于 Spring Security 框架的基础铁三角。AuthenticationManager 和 Access-DecisionManager 负责制定规则，AbstractSecurityInterceptor 负责执行。</p>
<p>所有针对不同应用场景的安全方案，基本上都是在这个基础核心的基础上衍生出来的，比如，Web 安全。</p>
<p>Spring Security 的 Web 安全方案基于 Java 的 Servlet API 规范进行构建，所以，像 Play Framework 这种脱离 Servlet 规范的 Web 框架，则无法享受到 SpringSecurity 提供的默认的 Web 安全方案（当然，依然可以基于基本模型实现扩展方案）。</p>
<p>既然是基于 Servlet API 规范，那么，要实现关卡的“特效”，则非 javax.servlet.Filter 莫属了。在使用 Spring 框架开发 Filter 的时候，为了让 Filter 可以享受到依赖注入的好处，我们一般是实现 GenericFilterBean 并注册到 IoC 容器。</p>
<p>为了能够启用这些注册到 IoC 容器的 Filter，我们一般要在 web.xml 或者相应的 JavaConfig 的配置中声明一个 org.springframework.web.filter.DelegatingFilterProxy，使其 filter-name 与 IoC 容器中我们希望启用的 Filter 对应“挂钩”，SpringSecurity 的 Web 安全方案的启用也是这个原理。</p>
<p>SpringSecurity 默认会需要声明一个默认名称为“springSecurityFilterChain”的 org.springframework.web.filter.DelegatingFilterProxy（web.xml 方式或者 JavaConfig 方式），然后指向 IoC 容器中注册的一个 org.springframework.security.web.FilterChainProxy 实例。</p>
<p>FilterChainProxy 通过扩展 GenericFilterBean 间接实现了 Filter 接口，同时持有一组 SecurityFilterChain，使它可以针对不同的 Web 资源进行特定的防护，这些“角儿”之间的关系大体上如图 2 所示。<br>FilterChainProxy相关组件关系示意图<br>图 2  FilterChainProxy 相关组件关系示意图</p>
<p>当然，这些还只是“骨架”，真正执行防护任务的其实是一个个 org.springframework.security.web.SecurityFilterChain 中定义的一系列 Filter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface SecurityFilterChain &#123;</span><br><span class="line">    boolean matches(HttpServletRequest request);</span><br><span class="line">    List&lt;Filter&gt; getFilters();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们经常看到如下的 xml schema 形式的配置格式的时候：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">http</span> <span class="attr">auto-config</span>=<span class="string">&#x27;true&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">&quot;/login.jsp*&quot;</span> <span class="attr">access</span>=<span class="string">&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intercept-url</span> <span class="attr">pattern</span>=<span class="string">&quot;/**&quot;</span> <span class="attr">access</span>=<span class="string">&quot;ROLE_USER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form-login</span> <span class="attr">login-page</span>=<span class="string">&#x27;/login.jsp&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其实一个个 http 元素背后对应的就是一个个 SecurityFilterChain 实例，而 http 元素的那些子元素，比如 intercept-url，则对应的就是一个个 Filter。</p>
<p>默认情况下，Spring Security 为 SecurityFilterChain 中的 Filter 序列设定了一个注册框架，以 100 为间隔步长，按照一个合理的顺序来规划和排布常用的 Filter 实现（代码参考FilterComparator）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">int order = 100;</span><br><span class="line">put(ChannelProcessingFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(ConcurrentSessionFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(WebAsyncManagerIntegrationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(SecurityContextPersistenceFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(HeaderWriterFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(CsrfFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(LogoutFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(X509AuthenticationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(AbstractPreAuthenticatedProcessingFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">filterToOrder.put(&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(UsernamePasswordAuthenticationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(ConcurrentSessionFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">filterToOrder.put(&quot;org.springframework.security.openid.OpenIDAuthenticationFilter&quot;, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(DefaultLoginPageGeneratingFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(ConcurrentSessionFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(DigestAuthenticationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(BasicAuthenticationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(RequestCacheAwareFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(SecurityContextHolderAwareRequestFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(JaasApiIntegrationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(RememberMeAuthenticationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(AnonymousAuthenticationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(SessionManagementFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(ExceptionTranslationFilter.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(FilterSecurityInterceptor.class, order);</span><br><span class="line">order += STEP;</span><br><span class="line">put(SwitchUserFilter.class, order); </span><br></pre></td></tr></table></figure>
<p>这些 Filter 虽然很多，但可以简单划分为几类，除个别 Filter 在每个 SecurityFilterChain 都需要，其他可以根据需要选用并添加：<br>可以认为是信道与状态管理，比如 ChannelProcessingFilter 用于处理 http 或者 https 之间的切换，而 SecurityContextPersistenceFilter 用于重建或者销毁必要的 SecurityContext 状态。<br>是常见 Web 安全防护类，比如 CsrfFilter。<br>是认证和授权，比如 BasicAuthenticationFilter、CasAuthen-ticationFilter 等。</p>
<p>最需要重点关注的是 FilterSecurityInterceptor，还记得我们前面说到的 secured object 吧。FilterSecurityInterceptor 就属于放在 Web 访问路径上的那道“关卡”，现在，它的真实位置和效能终于浮出水面了。</p>
<p>ExceptionTranslationFilter 属于另一个需要关注的核心类，它负责接待或者送客，如果访客来访，对方没有报上名来，那么，它会让访客去登记认证（去找 AuthenticationManager 做认证），如果对方报上名了，但认证失败，那么不好意思，请重新认证或者走人。当然，它拒绝访客的方式是抛出相应的 Exception，所以名字叫 ExceptionTranslationFilter。</p>
<p>最后，这个 Filter 序列因为间隔了 100 的步长，所以，我们可以在其中穿插自己的 Filter 实现类，为定制和扩展 SpringSecurity 的防护体系提供了机会。</p>
<h2 id="进一步定制spring-boot-starter-security"><a href="#进一步定制spring-boot-starter-security" class="headerlink" title="进一步定制spring-boot-starter-security"></a>进一步定制spring-boot-starter-security</h2><p>除了使用 SecurityProperties 暴露的配置项（以 security.* 开头）对 spring-boot-starter-security 进行简单的配置，我们还可以通过给出一个继承了 WebSecurityConfigurerAdapter 的 JavaConfig 配置类对 spring-boot-starter-security 的行为进行更深一级的定制。</p>
<p>使用 WebSecurityConfigurerAdapter 的好处在于，我们依然可以使用 spring-boot-starter-security 默认约定的一些行为，只需要对必要的行为进行调整，比如：<br>使用其他的 AuthenticationManager 实例。<br>对默认 HttpSecurity 定义的资源访问的规则进行重新定义。<br>对默认提供的 WebSecurity 行为进行调整。</p>
<p>为了能够让这些调整生效，我们定义的 WebSecurityConfigurerAdapter 实现类一般在顺序上需要先于 spring-boot-starter-security 默认提供的配置，故此，一般配合@Order（SecurityProperties.ACCESS_OVERRIDE_ORDER）进行标注，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebSecurity</span>-ConfigurerAdapter &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">DemoSecurityConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="literal">true</span>); <span class="comment">// 取消默认提供的安全相关Filters配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过Override其他方法实现对web安全的定制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebSecurityConfigurerAdapter 其实是为我们预先设定了一个框架，并开放了有限的一些扩展点允许我们对 Web 安全相关的设定进行定制，某些场景下还是会感觉“掣肘”，或者，某些有“洁癖”的开发者，往往不想使用在某些场景下显得并非必要的默认设定。</p>
<p>这个时候，我们可以直接实现并注册一个标注了 @EnableWebSecurity 的 JavaConfig 配置类到 IoC 容器，从而实现一种“颠覆性”的定制，即跟 spring-boot-starter-security 默认提供的 Web 安全相关配置一刀两断，完全自建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverhaulSecurityConfiguration</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> AccessDecisionManager <span class="title function_">accessDecisionManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> SecurityFilterChain <span class="title function_">mySecurityFilterChain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他web安全相关组件和依赖配置&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="spring-boot-starter-actuator与应用监控"><a href="#spring-boot-starter-actuator与应用监控" class="headerlink" title="spring-boot-starter-actuator与应用监控"></a>spring-boot-starter-actuator与应用监控</h1><p>所有的应用开发完成之后，其最终目的都是为了上线运行，SpringBoot 应用也不例外，而在应用运行的漫长生命周期内，为了保障其可以持续稳定的服务，我们通常需要对其进行监控，从而可以了解应用的运行状态，并根据情况决定是否需要对其运行状态进行调整。</p>
<p>顺应需求，SpringBoot 框架提供了<code>spring-boot-starter-actuator</code>自动配置模块用于支持 SpringBoot 应用的监控。</p>
<p>为了能够感知应用的运行状态，我们通常会设置一些监控指标并采集分析，这些监控指标的采集需要在应用内部设置相应的监控点，这类监控点一般只是读取状态数据，我们通常称它们为<code>Sensor</code>，即中文一般称为“传感器”的东西。</p>
<p>应用的运行状态数据通过<code>Sensors</code>采集上来之后，我们通常会有专门的系统对这些数据进行分析和判断，一旦某个指标数据超出了预定的阈值，这往往意味着应用的运行状态在这个指标上出现了“不健康”的现象，我们希望对这个指标进行调整，而为了能够执行调整，我们需要预先在应用内部设置对应的执行调整逻辑的控制器。</p>
<p>比如，直接关闭的开关，或者可以执行微调甚至像刹车一样直接快速拉低某个指标值的装置，这些控制器就称为<code>Actuator</code>。虽然我们日常天天在说“监控，监控”，但实际上“监”跟“控”是两个概念，<code>Sensor</code>更多服务于“监”的场景，而<code>Actuator</code>则服务于“控”的场景。</p>
<p><code>spring-boot-starter-actuator</code>自动配置模块默认提供了很多<code>endpoint</code>，虽然自动配置模块名为<code>spring-boot-starter-actuator</code>，但实际上这些<code>endpoint</code>可以按照“监”和“控”划分为两类：</p>
<ol>
<li><p><code>Sensor</code>类<code>endpoints</code></p>
</li>
<li><p><code>Actuator</code>类<code>endpoints</code></p>
</li>
</ol>
<ul>
<li><code>shutdown</code>：用于关闭当前 SpringBoot 应用的<code>endpoint</code>。</li>
<li><code>dump</code>：用于执行线程的<code>dump</code>操作。</li>
</ul>
<p>默认情况下，除了<code>shutdown</code>这个<code>endpoint</code>（因为比较危险，如果没有安全防护，谁都可以访问它，然后关闭应用），其他<code>endpoints</code>都是默认启用的。</p>
<p>生产环境下，如果没有启用安全防护（比如没有依赖<code>spring-boot-starter-security</code>），那么，建议遵循<code>Deny By Default</code>原则，将所有的<code>endpoints</code>都关掉，然后根据具体情况单独启用某些 <code>endpoint</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">endpoints.enabled=falseendpoints.info.enabled=trueendpoints.health.enabled=true...</span><br></pre></td></tr></table></figure>
<p>所有配置项以<code>endpoints.</code>为前缀，然后根据<code>endpoint</code>名称划分具体配置项。大部分<code>endpoints</code>都是开箱即用，但依然有些<code>endpoint</code>提供给我们进一步扩展的权利，比如健康状态检查相关的<code>endpoint（health endpoint）</code>。</p>
<h2 id="自定义应用的健康状态检查"><a href="#自定义应用的健康状态检查" class="headerlink" title="自定义应用的健康状态检查"></a>自定义应用的健康状态检查</h2><p>应用的健康状态检查是很普遍的监控需求，SpringBoot 也预先通过<code>org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration</code>为我们提供了一些常见服务的监控检查支持，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataSourceHealthIndicator</span><br><span class="line">DiskSpaceHealthIndicator</span><br><span class="line">RedisHealthIndicator</span><br><span class="line">SolrHealthIndicator</span><br><span class="line">MongoHealthIndicator</span><br></pre></td></tr></table></figure>
<p>如果这些默认提供的健康检查支持依然无法满足我们的需要，SpringBoot 还允许我们提供更多的<code>HealthIndicator</code>实现，只要将这些<code>HealthIndicator</code>实现类注册到 IoC 容器，SpringBoot 会自动发现并使用它们。</p>
<p>假设需要检查依赖的 dubbo 服务是否处于健康状态，我们可以实现一个<code>DubboHealthIndicator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.ReferenceBean;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.service.EchoService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.AbstractHealthIndicator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.health.Health;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboHealthIndicator</span> <span class="keyword">extends</span> <span class="title class_">AbstractHealthIndicator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReferenceBean bean;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DubboHealthIndicator</span><span class="params">(ReferenceBean bean)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.bean = bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doHealthCheck</span><span class="params">(Health.Builder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    builder.withDetail(<span class="string">&quot;interface&quot;</span>, bean.getObjectType());</span><br><span class="line">    <span class="keyword">final</span> <span class="type">EchoService</span> <span class="variable">service</span> <span class="operator">=</span> (EchoService) bean.getObject();</span><br><span class="line">    service.$echo(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    builder.up();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现一个自定义的<code>HealthIndicator</code>，一般我们不会直接实现（<code>Implements</code>）<code>HealthIndicator</code>接口，而是继承<code>AbstractHealthIndicator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHealthIndicator</span> <span class="keyword">implements</span> <span class="title class_">HealthIndicator</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Health <span class="title function_">health</span><span class="params">()</span> &#123;</span><br><span class="line">    Health.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Health</span>.Builder();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doHealthCheck(builder);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      builder.down(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHealthCheck</span><span class="params">(Health.Builder builder)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好处就是，我们只需实现<code>doHealthCheck</code>，在其中实现我们面向的具体服务的健康检查逻辑就可以了，因此，在<code>DubboHealthIndicator</code>实现类中，我们通过 dubbo 框架提供的<code>EchoService</code>直接检查相应的 dubbo 服务健康状态即可，只要没有任何异常抛出，我们就认为检查的 dubbo 服务是状态健康的，所以，最后会通过 Health.Builder 的 up() 方法标记服务状态为正常运行。</p>
<p>为了完成对 dubbo 服务的健康检查，只实现一个 DubboHealthIndicator 是不够的，我们还需要将其注册到 IoC 容器中，但是一个一个单独注册太费劲了，而且还要自己提供针对某个 dubbo 服务的 ReferenceBean 依赖实例。</p>
<p>所以，为了一劳永逸，也为了其他人能够同样方便地使用针对 dubbo 服务的健康检查支持，我们可以在 DubboHealthIndicator 的基础上实现一个 spring-boot-starter-dubbo-health-indicator 自动配置模块，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &#123; &quot;com.alibaba.dubbo.rpc.Exporter&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboHealthIndicatorConfiguration</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  HealthAggregator healthAggregator;</span><br><span class="line">  <span class="meta">@Autowired(required = false)</span></span><br><span class="line">  Map&lt;String, ReferenceBean&gt; references;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> HealthIndicator <span class="title function_">dubboHealthIndicator</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, HealthIndicator&gt; indicators = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String key : references.keySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReferenceBean</span> <span class="variable">bean</span> <span class="operator">=</span> references.get(key);</span><br><span class="line">        indicators.put(key.startsWith(<span class="string">&quot;&amp;&quot;</span>) ? key.replaceFirst(<span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                : key, <span class="keyword">new</span> <span class="title class_">DubboHealthIndicator</span>(bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompositeHealthIndicator</span>(healthAggregator, indicators);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在 spring-boot-starter-dubbo-health-indicator 的 META-INF&#x2F;spring.factories 文件中添加如下配置：<br>org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\com.keevol…DubboHealthIndicatorConfiguration </p>
<p>现在，发布 spring-boot-starter-dubbo-health-indicator 并依赖它就可以自动享受到针对当前应用引用的所有 dubbo 服务进行健康检查的服务。</p>
<p>那么针对 Map&lt;String，ReferenceBean&gt;references 的依赖注入是从哪里来的？</p>
<p>其实 Spring 框架支持依赖注入 Key 的类型为 String 的 Map，遇到这种类型的 Map 声明（Map），Spring 框架将扫描容器中所有类型为 T 的 bean，然后以该 bean 的 name 作为 Map 的 Key，以 bean 实例作为对应的 Value，从而构建一个 Map 并注入到依赖处。<br>开放的 endpoints 才真正“有用”<br>不管是 spring-boot-starter-actuator 默认提供的 endpoint 实现，还是我们自己给出的 endpoint 实现，如果只是实现了放在 SpringBoot 应用的“身体内部”，那么它们不会发挥任何作用，只有将它们采集的信息暴露开放给外部监控者，或者允许外部监控者访问它们，这些 endpoints 才会真正发挥出它们的最大“功效”。</p>
<p>首先，spring-boot-starter-actuator 会通过 org.springframework.boot.actuate.autoconfigure.EndpointMBeanExportAutoConfiguration 将所有的 org.springframework.boot.actuate.endpoint.Endpoint 实例以 JMX MBean 的形式开放给外部监控者使用。</p>
<p>默认情况下，这些 Endpoint 对应的 JMX MBean 会放在 org.springframework.boot 命名空间下面，不过可以通过 endpoints.jmx.domain 配置项进行更改，比如 endpoints.jmx.domain&#x3D;com.keevol.management。</p>
<p>EndpointMBeanExportAutoConfiguration 为我们提供了一条很好的应用监控实践之路，既然它会把所有的 org.springframework.boot.actuate.endpoint.Endpoint 实例都作为 JMX Mbean 开放出去，那么，我们就可以提供一批用于某些场景下的自定义 Endpoint 实现类，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractEndpoint</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HelloEndpoint</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(id, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, SpringBoot&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，将像 HelloEndpoint 这样的实现类注册到 SpringBoot 应用的 IoC 容器，就可以扩展 SpringBoot 的 endpoints 功能了。</p>
<p>Endpoint 其实更适合简单的 Sensor 场景（即用于读取或者提供信息），或者简单功能的 actuator 场景（不需要行为参数），如果需要对 SpringBoot 进行更细粒度的监控，可以考虑直接使用 Spring 框架的 JMX 支持。</p>
<p>除了可以使用 JMX 将 spring-boot-starter-actuator 提供的（或者我们自己提供的）endpoints 开放访问，如果当前 SpringBoot 应用恰好又是一个 Web 应用。那么，这些 endpoints 还会通过 HTTP 协议开放给外部访问，与一般的 Web 请求处理一样，使用的也是 Web 应用使用的 HTTP 服务器和地址端口。</p>
<p>因为每个 Endpoint 都有一个 id 作为唯一标识，所以，这些 endpoints 的默认访问路径其实就是它们的 id，比如 info 这个 endpoint 的 HTTP 访问路径就是 &#x2F;info，而 beans 这个 endpoint 的 HTTP 访问路径则是 &#x2F;beans，以此类推。</p>
<p>SpringBoot 允许我们通过 management. 为前缀的配置项对 endpoints 的 HTTP 开放行为进行调整：<br>使用 management.context-path&#x3D;设置自定义的 endpoints 访问上下文路径，默认直接根路径，即 &#x2F;info，&#x2F;beans 等形式。<br>使用 management.address&#x3D; 配置单独的 HTTP 服务监听地址，比如只允许本地访问。</p>
<p>management.address&#x3D;127.0.0.1 使用 management.port&#x3D;设置单独的监听端口，默认与 web 应用的对外服务端口相同。</p>
<p>我们可以通过 management.port&#x3D;8888 将管理接口的 HTTP 对外监听端口设置为 8888，但如果 management.port&#x3D;-1，则意味着我们将关闭管理接口的 HTTP 对外服务。</p>
<p>JMX 和 HTTP 是 endpoints 对外开放访问最常用的方式，鉴于 Java 的序列化漏洞以及 JMX 的远程访问防火墙问题，建议用 HTTP 并配合安全防护将 SpringBoot 应用的 endpoints 开放给外部监控者使用。<br>用还是不用，这是个问题<br>endpoints 属于 spring-boot-starter-actuator 提供的主要功能之一，除此之外，spring-boot-starter-actuator 还提供了更多针对应用监控的支持和实现方案。</p>
<ol>
<li>CrshAutoConfiguration 与 spring-boot-starter-remote-shell<br>spring-boot-starter-actuator 提供了基于 CRaSH（<a target="_blank" rel="noopener" href="http://www.crashub.org/%EF%BC%89%E7%9A%84%E8%BF%9C%E7%A8%8B">http://www.crashub.org/）的远程</a> Shell（Remote Shell）支持，从笔者角度来看，这是一把双刃剑，不建议在生产环境使用，因为提供给自己便利的同时，也为黑客朋友们提供了便利。如果实在要用，请加强安全认证和防护。</li>
</ol>
<p>不过，这里我们还是会为大家分析一下 spring-boot-starter-actuator 是如何提供针对 CRaSH 的支持的。</p>
<p>spring-boot-starter-actuator 提供了 org.springframework.boot.actuate.autoconfigure.CrshAutoConfiguration 自动配置类，该类会在 org.crsh.plugin.PluginLifeCycle 出现在 classpath 中的时候生效。</p>
<p>所以，只要将 CRaSH 作为依赖加入应用的 classpath 依赖就可以了，最简单直接的做法是让需要启用 CRaSH 的 SpringBoot 应用依赖 spring-boot-starter-remote-shell 自动配置模块，spring-boot-starter-remote-shell 的主要功效就是提供了针对 CRaSH 的各项依赖。<br>2. SpringBoot 的 Metrics 与 Dropwizard 的 Metrics<br>SpringBoot 提供了一套自己的针对系统指标的度量框架，这个框架的核心设计如图 2 所示。<br>SpringBoot框架的Metrics核心类设计示意图<br>图 2  SpringBoot 框架的 Metrics 核心类设计示意图</p>
<p>基本上，我们只需关注 org.springframework.boot.actuate.endpoint.PublicMetrics 即可，它可以理解为提供一组 Metric 的集合，我们既可以通过 PublicMetrics 来汇总和管理 Metric，也可以通过 MetricRepository 来存储和管理 Metric。</p>
<p>一旦使用了 spring-boot-starter-actuator，只要当前 SpringBoot 应用的 ApplicationContext 中存在任何 PublicMetrics 实例，EndpointAutoConfiguration 就会将这些 PublicMetrics 采集汇总到一起，然后通过 MetricsEndpoint 将它们开放出去。</p>
<p>spring-boot-starter-actuator 提供的 org.springframework.boot.actuate.autoconfigure.PublicMetricsAutoConfiguration 默认会把一个 SystemPublicMetrics 开放出来，用于提供系统各项指标的度量和状态采集，另外一个就是会把当前 SpringBoot 应用的 ApplicationContext 的 org.springframework.boot.actuate.metrics.repository.MetricRepository 实例中的所有 Metric 汇总并开放出去。</p>
<p>默认如果用户没有给出任何自定义的 MetricRepository，spring-boot-starter-actuator 会提供一个 InMemoryMetricRepository 实现，如果我们将 Dropwizard 的 Metrics 类库作为依赖加入 classpath，那么，Dropwizard Metrics 的 MetricRegistry 中所有的度量指标项也会通过 PublicMetrics 的形式开发暴露出来。</p>
<p>虽然 SpringBoot 提供的 metrics 框架也能帮助我们完成系统和应用指标的度量，但笔者更倾向于使用 Dropwizard 这种特定场景下比较完善的方案，从 metrics 的类型，到外围系统的集成，Dropwizard metrics 都更加成熟和完备。<br>3. Auditing 与 Trace<br>SpringBoot 的 Auditing 和 Trace 支持都遵循数据&#x2F;事件+Repository 的设计（如图 3 所示）。<br>SpringBoot框架Audit和Trace功能支持核心类示意图<br>图 3  SpringBoot 框架 Audit 和 Trace 功能支持核心类示意图</p>
<p>我们可能只是通过打印日志时候的 Logger 名称来区分并记录 Audit 事件，然后通过日志采集通道汇总分析就可以了，而不用非要实现一个 LogFileBasedAuditEventRepository 或者 ElasticSearchBasedAuditEventRepository 之类的实现，否则看起来难免有些“学究”气。对于 Trace 来说也是同样道理，我们可能直接使用完备的 APM 方案而不是单一或者少量 Trace 事件的记录。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/Spring Boot配置文件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2022-10-29T09:05:54.749Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="导入Spring配置"><a href="#导入Spring配置" class="headerlink" title="导入Spring配置"></a>导入Spring配置</h1><p>默认情况下，Spring Boot 中是不包含任何的 Spring 配置文件的，即使我们手动添加 Spring 配置文件到项目中，也不会被识别。我们可以通过以下 2 种方式来导入 Spring 配置：</p>
<ul>
<li>使用<code>@ImportResource</code>注解加载 Spring 配置文件</li>
<li>使用全注解方式加载 Spring 配置</li>
</ul>
<h2 id="ImportResource-导入-Spring-配置文件"><a href="#ImportResource-导入-Spring-配置文件" class="headerlink" title="@ImportResource 导入 Spring 配置文件"></a>@ImportResource 导入 Spring 配置文件</h2><p>在主启动类上使用<code>@ImportResource</code>注解可以导入一个或多个 Spring 配置文件，并使其中的内容生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.service;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.Person;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Person <span class="title function_">getPersonInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.service.impl;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.Person;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.service.PersonService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Person person;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Person <span class="title function_">getPersonInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该项目的<code>resources</code>下添加一个名为<code>beans.xml</code>的 Spring 配置文件，配置代码如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;persionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.biancheng.www.service.impl.PersonServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改该项目的单元测试类<code>HelloworldApplicationTests</code>，校验 IOC 容器是否已经<code>personService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloworldApplicationTests</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  Person person;</span><br><span class="line">  <span class="comment">//IOC 容器</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  ApplicationContext ioc;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//校验 IOC 容器中是否包含组件 personService</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> ioc.containsBean(<span class="string">&quot;personService&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;personService 已经添加到 IOC 容器中&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;personService 没添加到 IOC 容器中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主启动程序类上使用<code>@ImportResource</code>注解，将 Spring 配置文件<code>beans.xml</code>加载到项目中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</span><br><span class="line"><span class="comment">//将 beans.xml 加载到项目中</span></span><br><span class="line"><span class="meta">@ImportResource(locations = &#123;&quot;classpath:/beans.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloworldApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(HelloworldApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>执行测试代码，结果如下图。</li>
</ol>
<img src="/2022/10/29/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/4.png" class="" title="使用 @ImportResource 注解加载 Spring 配置文件结果">

<h2 id="全注解方式加载-Spring-配置"><a href="#全注解方式加载-Spring-配置" class="headerlink" title="全注解方式加载 Spring 配置"></a>全注解方式加载 Spring 配置</h2><p>全注解的方式加载 Spring 配置实现方式如下：</p>
<ul>
<li>使用<code>@Configuration</code>注解定义配置类，替换 Spring 的配置文件；</li>
<li>配置类内部可以包含有一个或多个被<code>@Bean</code>注解的方法，这些方法会被<code>AnnotationConfigApplicationContext</code>或<code>AnnotationConfigWebApplicationContext</code>类扫描，构建<code>bean</code>定义（相当于 Spring 配置文件中的<code>&lt;bean&gt;&lt;/bean&gt;</code>标签），方法的返回值会以组件的形式添加到容器中，组件的<code>id</code>就是方法名。</li>
</ul>
<p>删除主启动类的<code>@ImportResource</code>注解，在<code>net.biancheng.www.config</code>包下添加一个名为<code>MyAppConfig</code>的配置类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.config;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.service.PersonService;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.service.impl.PersonServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Configuration</span> 注解用于定义一个配置类，相当于 Spring 的配置文件</span></span><br><span class="line"><span class="comment">* 配置类中包含一个或多个被 <span class="doctag">@Bean</span> 注解的方法，该方法相当于 Spring 配置文件中的 &lt;bean&gt; 标签定义的组件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 与 &lt;bean id=&quot;personService&quot; class=&quot;PersonServiceImpl&quot;&gt;&lt;/bean&gt; 等价</span></span><br><span class="line"><span class="comment">    * 该方法返回值以组件的形式添加到容器中</span></span><br><span class="line"><span class="comment">    * 方法名是组件 id（相当于 &lt;bean&gt; 标签的属性 id)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> PersonService <span class="title function_">personService</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;在容器中添加了一个组件:peronService&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PersonServiceImpl</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行测试代码，执行结果如下图。</p>
<img src="/2022/10/29/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/5.png" class="" title="全注解方式添加 Spring 配置">

<h1 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h1><p>通常情况下，Spring Boot 在启动时会将<code>resources</code>目录下的<code>application.properties</code>或<code>apllication.yml</code>作为其默认配置文件，我们可以在该配置文件中对项目进行配置。</p>
<p>Spring Boot 项目中可以存在多个<code>application.properties</code>或<code>apllication.yml</code>。</p>
<p>Spring Boot 启动时会扫描以下 5 个位置的<code>application.properties</code>或<code>apllication.yml</code>文件，并将它们作为 Spring boot 的默认配置文件。</p>
<ul>
<li><code>file:./config/</code></li>
<li><code>file:./config/*/</code></li>
<li><code>file:./</code></li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ul>
<blockquote>
<p>注：<code>file</code>: 指当前项目根目录；<code>classpath</code>: 指当前项目的类路径，即<code>resources</code>目录。</p>
</blockquote>
<p>以上所有位置的配置文件都会被加载，且它们优先级依次降低，序号越小优先级越高。其次，位于相同位置的<code>application.properties</code>的优先级高于<code>application.yml</code>。</p>
<p>所有位置的文件都会被加载，高优先级配置会覆盖低优先级配置，形成互补配置，即：</p>
<ul>
<li>存在相同的配置内容时，高优先级的内容会覆盖低优先级的内容；</li>
<li>存在不同的配置内容时，高优先级和低优先级的配置内容取并集。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建一个名为<code>springbootdemo</code>的 Spring Boot 项目，并在当前项目根目录下、类路径下的<code>config</code>目录下、以及类路径下分别创建一个配置文件<code>application.yml</code>，该项目结构如下图。</p>
<img src="/2022/10/29/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/1.png" class="" title="Spring Boot 项目配置文件位置">

<p>项目根路径下配置文件<code>application.yml</code>配置如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#项目更目录下</span><br><span class="line">#上下文路径为 /abc</span><br><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /abc</span><br></pre></td></tr></table></figure>
<p>项目类路径下<code>config</code>目录下配置文件<code>application.yml</code>配置如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#类路径下的 config 目录下</span><br><span class="line">#端口号为8084</span><br><span class="line">#上下文路径为 /helloWorld</span><br><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /helloworld</span><br></pre></td></tr></table></figure>
<p>项目类路径下的<code>application.yml</code>配置如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#默认配置</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br></pre></td></tr></table></figure>
<p>创建一个名为<code>MyController</code>的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello Spring Boot!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 Spring Boot，查看控制台输出。</p>
<img src="/2022/10/29/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2.png" class="" title="Spring Boot 项目启动控制台输出">

<p>根据 Spring Boot 默认配置文件优先级进行分析：</p>
<ul>
<li>该项目中存在多个默认配置文件，其中根目录下<code>/config</code>目录下的配置文件优先级最高，因此项目的上下文路径为<code>/abc</code>；</li>
<li>类路径（<code>classpath</code>）下<code>config</code>目录下的配置文件优先级高于类路径下的配置文件，因此该项目的端口号为<code>8084</code>；</li>
<li>以上所有配置项形成互补，所以访问路径为<code>http://localhost:8084/abc</code>。</li>
</ul>
<h1 id="外部配置文件"><a href="#外部配置文件" class="headerlink" title="外部配置文件"></a>外部配置文件</h1><p>除了默认配置文件，Spring Boot 还可以加载一些位于项目外部的配置文件。我们可以通过如下 2 个参数，指定外部配置文件的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.config.location </span><br><span class="line">spring.config.additional-location </span><br></pre></td></tr></table></figure>
<h2 id="spring-config-location"><a href="#spring-config-location" class="headerlink" title="spring.config.location"></a>spring.config.location</h2><p>我们可以先将 Spring Boot 项目打包成 JAR 文件，然后在命令行启动命令中，使用命令行参数 –spring.config.location，指定外部配置文件的路径。<br>java -jar {JAR}  –spring.config.location&#x3D;{外部配置文件全路径}</p>
<p>需要注意的是，使用该参数指定配置文件后，会使项目默认配置文件（application.properties 或 application.yml ）失效，Spring Boot 将只加载指定的外部配置文件。<br>示例 1</p>
<ol>
<li>在本地目录 D:\myConfig 下，创建一个配置文件 my-application.yml，配置如下。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#指定配置文件</span><br><span class="line">server:</span><br><span class="line">  port: 8088</span><br></pre></td></tr></table></figure></li>
<li>执行以下 mvn 命令，将 springbootdemo 项目打包成 JAR。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
命令执行结果如下图。</li>
</ol>
<p>Spring Boot  打包结果<br>图1：打包结果</p>
<ol start="3">
<li>打开命令行窗口，跳转到 JAR 文件所在目录，执行以下命令，其中 –spring.config.location 用于指定配置文件的新位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springbootdemo-0.0.1-SNAPSHOT.jar  --spring.config.location=D:\myConfig\my-application.yml</span><br></pre></td></tr></table></figure>
项目运行结果如下图。</li>
</ol>
<p>Spring Boot –spring.config.location 指定外部配置文件<br>图2：使用外部配置运行项目控制台输出</p>
<p>从控制台输出可以看出：<br>服务器端口号从“8084”被修改为“8088”，表示外部配置文件已生效；<br>上下文路径则从“&#x2F;abc”被修改为默认值（‘ ’），表示项目内部的默认配置文件已失效。</p>
<ol start="4">
<li>使用浏览器访问 “<a target="_blank" rel="noopener" href="http://localhost:8088/test%E2%80%9D,%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%82">http://localhost:8088/test”,结果如下图。</a></li>
</ol>
<p>Spring Boot 指定外部配置文件访问结果<br>图3：spring.config.location 指定外部配置文件访问结果<br>spring.config.additional-location<br>我们还可以在 Spring Boot 启动时，使用命令行参数 –spring.config.additional-location 来加载外部配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar &#123;JAR&#125;  --spring.config.additional-location=&#123;外部配置文件全路径&#125;</span><br></pre></td></tr></table></figure>
<p>但与 –spring.config.location 不同，–spring.config.additional-location 不会使项目默认的配置文件失效，使用该命令行参数添加的外部配置文件会与项目默认的配置文件共同生效，形成互补配置，且其优先级是最高的，比所有默认配置文件的优先级都高。<br>示例 2</p>
<ol>
<li>将 springbootdemo 打包为 JAR 文件，打开命令行窗口，跳转到该项目 JAR 所在目录下，执行以下命令启动该项目。<br>java -jar springbootdemo-0.0.1-SNAPSHOT.jar  –spring.config.additional-location&#x3D;D:\myConfig\my-application.yml</li>
</ol>
<p>结果如下图。</p>
<p>图4：Spring Boot  spring.config.additional-location 指定外部配置文件项目启动结果</p>
<p>注意：Maven 对项目进行打包时，位于项目根目录下的配置文件是无法被打包进项目的 JAR 包的，因此位于根目录下的默认配置文件无法在 JAR 中生效，即该项目将只加载指定的外部配置文件和项目类路径（classpath）下的默认配置文件，它们的加载优先级顺序为：</p>
<p>spring.config.additional-location 指定的外部配置文件 my-application.yml<br>classpath:&#x2F;config&#x2F;application.yml<br>classpath:&#x2F;application.yml</p>
<p>根据配置文件优先级分析可知：<br>以上三个配置文件中 my-application.yml 的优先级最高，因此该项目的服务器端口号为 “8088”；<br>只有 classpath:&#x2F;config&#x2F;application.yml 中配置了上下文路径（context-path），因此该项目的上下文路径为 “&#x2F;helloworld”；<br>基于以上配置分析，得出该项目访问路径为“<a target="_blank" rel="noopener" href="http://localhost:8088/helloWorld%E2%80%9D%E3%80%82">http://localhost:8088/helloWorld”。</a></p>
<h1 id="配置加载顺序"><a href="#配置加载顺序" class="headerlink" title="配置加载顺序"></a>配置加载顺序</h1><p>Spring Boot 不仅可以通过配置文件进行配置，还可以通过环境变量、命令行参数等多种形式进行配置。这些配置都可以让开发人员在不修改任何代码的前提下，直接将一套 Spring Boot  应用程序在不同的环境中运行。</p>
<h2 id="Spring-Boot-配置优先级"><a href="#Spring-Boot-配置优先级" class="headerlink" title="Spring Boot 配置优先级"></a>Spring Boot 配置优先级</h2><p>以下是常用的 Spring Boot 配置形式及其加载顺序（优先级由高到低）：</p>
<ul>
<li>命令行参数</li>
<li>来自<code>java:comp/env</code>的 JNDI 属性</li>
<li>Java 系统属性（<code>System.getProperties()</code>）</li>
<li>操作系统环境变量</li>
<li><code>RandomValuePropertySource</code>配置的<code>random.*</code>属性值</li>
<li>配置文件（<code>YAML</code>文件、<code>Properties</code>文件）</li>
<li><code>@Configuration</code>注解类上的<code>@PropertySource</code>指定的配置文件</li>
<li>通过<code>SpringApplication.setDefaultProperties</code>指定的默认属性</li>
</ul>
<p>以上所有形式的配置都会被加载，当存在相同配置内容时，高优先级的配置会覆盖低优先级的配置；存在不同的配置内容时，高优先级和低优先级的配置内容取并集，共同生效，形成互补配置。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>Spring Boot 中的所有配置，都可以通过命令行参数进行指定，其配置形式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar &#123;Jar文件名&#125; --&#123;参数1&#125;=&#123;参数值1&#125; --&#123;参数2&#125;=&#123;参数值2&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在 springbootdemo  项目启动时，使用以下命令。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springbootdemo-0.0.1-SNAPSHOT.jar --server.port=8081 --server.servlet.context-path=/bcb</span><br></pre></td></tr></table></figure>
命令行参数说明如下：</li>
</ol>
<ul>
<li><code>--server.port</code>：指定服务器端口号；</li>
<li><code>--server.servlet.context-path</code>：指定上下文路径（项目的访问路径）。</li>
</ul>
<p>执行结果如下图。</p>
<p>Spring Boot 指定命令行参数<br>图1：Spring Boot 指定命令行参数</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Spring Boot 启动时，会自动加载 JAR 包内部及 JAR 包所在目录指定位置的配置文件（Properties 文件、YAML 文件），下图中展示了 Spring Boot 自动加载的配置文件的位置及其加载顺序，同一位置下，Properties 文件优先级高于 YAML 文件。</p>
<p>Spring Boot 配置文件加载顺序</p>
<p>图2：Spring Boot 配置文件加载位置及优先级</p>
<p>图 2 说明如下：<br>&#x2F;myBoot：表示 JAR 包所在目录，目录名称自定义；<br>&#x2F;childDir：表示 JAR 包所在目录下 config 目录的子目录，目录名自定义；<br>JAR：表示 Spring Boot 项目打包生成的 JAR；<br>其余带有“&#x2F;”标识的目录的目录名称均不能修改。<br>红色数字：表示该配置文件的优先级，数字越小优先级越高。</p>
<p>这些配置文件得优先级顺序，遵循以下规则：</p>
<ul>
<li>先加载 JAR 包外的配置文件，再加载 JAR 包内的配置文件；</li>
<li>先加载<code>config</code>目录内的配置文件，再加载 config 目录外的配置文件；</li>
<li>先加载<code>config</code>子目录下的配置文件，再加载 config 目录下的配置文件；</li>
<li>先加载<code>appliction-&#123;profile&#125;.properties/yml</code>，再加载<code>application.properties/yml</code>；</li>
<li>先加载<code>.properties</code>文件，再加载<code>.yml</code>文件。</li>
</ul>
<ol>
<li>创建一个名为 mybootdemo 的 Spring Boot 项目，并在 src&#x2F;main&#x2F;resoources 下创建以下 4 个配置文件。</li>
</ol>
<ul>
<li>applcation.yml：默认配置</li>
<li>application-dev.yml：开发环境配置</li>
<li>application-test.yml：测试环境配置</li>
<li>application-prod.yml：生产环境配置</li>
</ul>
<p>1）在 applcation.yml 文件中，指定默认服务端口号（port）为 “8080”，上下文路径（context-path）为“&#x2F;mybootdemo”，并激活开发环境（dev）的 profile。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080 #端口号</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /mybootdemo #上下文路径或项目访问路径</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev #激活开发环境配置</span><br></pre></td></tr></table></figure>
<p>2）在 application-dev.yml 中，指定开发环境端口号为 “8081”，上下文路径为“&#x2F;in-dev”，配置如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081 #开发环境端口号 8081</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /in-dev #开发环境上下文路径为 in-dev</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: dev #开发环境</span><br></pre></td></tr></table></figure>
<p>3）在 application-test.yml 中，指定测试环境端口号为 “8082”，上下文路径为“&#x2F;in-test”，配置如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#测试环境配置</span><br><span class="line">server:</span><br><span class="line">  port: 8082 #测试环境端口 8082</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /in-test #测试环境上下文路径 /in-test</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: test</span><br></pre></td></tr></table></figure>
<p>4）在 application-prod.yml 中，指定生产环境端口号为 “8083”，上下文路径为“&#x2F;in-prod”，配置如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#生产环境配置</span><br><span class="line">server:</span><br><span class="line">  port: 8083 #端口号</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /in-prod #上下文路径</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: prod</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>执行以下 mvn 命令，将 mybootdemo 打包成 JAR，并将该 JAR 包移动到本次磁盘的某个目录下（例如 mySpringBoot 目录）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 JAR 包所在目录下创建 application.yml ，并设置上下文路径为“&#x2F;out-default”，并激活生产环境（prod）Profile。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#JAR 包外默认配置</span><br><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /out-default</span><br><span class="line">#切换配置</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod #激活开发环境配置</span><br></pre></td></tr></table></figure></li>
<li><p>打开命令行窗口，跳转到 mySpringBoot 目录下，执行以下命令启动 Spring Boot。<br>java -jar mybootdemo-0.0.1-SNAPSHOT.jar<br>启动结果如下图。</p>
</li>
</ol>
<p>图3：Spring Boot 使用 JAR 包外配置启动<br>示例分析：</p>
<p>Spring Boot 在启动时会加载全部的 5 个配置文件，其中位于 JAR 包外的 application.yml 优先级最高；<br>在 JAR 包外的 application.yml 中，配置激活了生产环境（prod）Profile，即 JAR 包内部的 application-prod.yml 生效。此时，该项目中的配置文件优先级顺序为：JAR 包外 application.yml &gt; JAR 包内 application-prod.yml &gt;JAR 包内其他配置文件;<br>application-prod.yml 的配置内容会覆盖 JAR 包内所有其他配置文件的配置内容，即端口号（port）为“8083”，上下文路径（context-path）为“&#x2F;in-prod”;<br>JAR 包内的 application-prod.yml 中的上下文路径会被 JAR 包外的 application.yml 覆盖为“&#x2F;out-default”;<br>JAR 包内的 application-prod.yml 与 JAR 包外的 application.yml，形成互补配置，即，端口号为“8083”，上下文路径为“&#x2F;out-default”。</p>
<h1 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/Spring Boot拦截器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/java/SpringBoot/Spring%20Boot%E6%8B%A6%E6%88%AA%E5%99%A8/" class="article-date">
  <time datetime="2022-10-29T09:05:54.747Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>拦截器可以根据 URL 对请求进行拦截，主要应用于登陆校验、权限验证、乱码解决、性能监控和异常处理等功能上。</p>
<p>在 Spring Boot 项目中，使用拦截器功能通常需要以下 3 步：</p>
<ol>
<li>定义拦截器；</li>
<li>注册拦截器；</li>
<li>指定拦截规则（如果是拦截所有，静态资源也会被拦截）。</li>
</ol>
<h1 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h1><p>在 Spring Boot 中定义拦截器只需要创建一个拦截器类，并实现<code>HandlerInterceptor</code>接口即可。</p>
<p><code>HandlerInterceptor</code>接口中定义以下 3 个方法。</p>
<table>
<thead>
<tr>
<th align="center">返回值类型</th>
<th align="center">方法声明</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean</td>
<td align="center">preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</td>
<td align="center">该方法在控制器处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</td>
<td align="center">该方法在控制器处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改。</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</td>
<td align="center">该方法在视图渲染结束后执行，可以通过此方法实现资源清理、记录日志信息等工作。</td>
</tr>
</tbody></table>
<p>在<code>net.biancheng.www.interceptor</code>中创建一个名为<code>LoginInterceptor</code>的拦截器类，对登陆进行拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.interceptor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 目标方法执行前</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (loginUser == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//未登录，返回登陆页</span></span><br><span class="line">      request.setAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;您没有权限进行此操作，请先登陆！&quot;</span>);</span><br><span class="line">      request.getRequestDispatcher(<span class="string">&quot;/index.html&quot;</span>).forward(request, response);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//放行</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 目标方法执行后</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.info(<span class="string">&quot;postHandle执行&#123;&#125;&quot;</span>, modelAndView);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 页面渲染后</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.info(<span class="string">&quot;afterCompletion执行异常&#123;&#125;&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h1><p>创建一个实现了<code>WebMvcConfigurer</code>接口的配置类（使用了<code>@Configuration</code>注解的类），重写<code>addInterceptors()</code>方法，并在该方法中调用<code>registry.addInterceptor()</code>方法将自定义的拦截器注册到容器中。</p>
<p>在配置类<code>MyMvcConfig</code>中，添加以下方法注册拦截器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指定拦截规则"><a href="#指定拦截规则" class="headerlink" title="指定拦截规则"></a>指定拦截规则</h1><p>在使用<code>registry.addInterceptor()</code>方法将拦截器注册到容器中后，我们便可以继续指定拦截器的拦截规则了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;注册拦截器&quot;</span>);</span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>) <span class="comment">//拦截所有请求，包括静态资源文件</span></span><br><span class="line">            .excludePathPatterns(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/index.html&quot;</span>, <span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/images/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/fonts/**&quot;</span>); <span class="comment">//放行登录页，登陆操作，静态资源</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在指定拦截器拦截规则时，调用了两个方法，这两个方法的说明如下：</p>
<ul>
<li><code>addPathPatterns</code>：该方法用于指定拦截路径，例如拦截路径为<code>/**</code>，表示拦截所有请求，包括对静态资源的请求。</li>
<li><code>excludePathPatterns</code>：该方法用于排除拦截路径，即指定不需要被拦截器拦截的请求。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/9/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>