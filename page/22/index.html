<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-微服务/初识微服务"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/"
    >初识微服务</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/08/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2020-08-14T03:25:51.000Z" itemprop="datePublished">2020-08-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>微服务是由单一应用程序构成的小服务，拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时，服务会使用最小规模的集中管理 （例如 Docker）技术，服务可以用不同的编程语言与数据库等。</p>
<h1 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h1><p>早些年，各大互联网公司的应用技术栈大致可分为 LAMP（Linux + Apache + MySQL + PHP）和 MVC（Spring + iBatis&#x2F;Hibernate + Tomcat）两大流派。无论是 LAMP 还是 MVC，都是为单体应用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。</p>
<p>以 MVC 架构为例，业务通常是通过部署一个 WAR 包到 Tomcat 中，然后启动 Tomcat，监听某个端口即可对外提供服务。</p>
<p>然而随着业务规模的不断扩大，单体应用架构就会开始出现问题。大概会有以下几个方面的问题。</p>
<ul>
<li>部署效率低下。当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试一次，甚至需要 10 分钟以上。</li>
<li>团队协作开发成本高。一旦团队人员扩张，超过 5 人修改代码，然后一起打包部署，测试阶段只要有一块功能有问题，就得重新编译打包部署，然后重新预览测试，所有相关的开发人员又都得参与其中，效率低下，开发成本极高。</li>
<li>系统高可用性差。因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。</li>
<li>线上发布变慢。特别是对于 Java 应用来说，一旦代码膨胀，服务启动的时间就会变长。因此，急需一种方法能够将应用的不同模块的解耦，降低开发和部署成本。</li>
</ul>
<p>想要解决上面这些问题，服务化的思想也就应运而生。</p>
<h1 id="什么是服务化"><a href="#什么是服务化" class="headerlink" title="什么是服务化"></a>什么是服务化</h1><p>用通俗的话来讲，服务化就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。一般在编写业务代码时，对于一些通用的业务逻辑，尽力把它抽象并独立成为专门的模块，因为这对于代码复用和业务理解都大有裨益。</p>
<p>以微博系统为例，微博既包含了内容模块，也包含了消息模块和用户模块等。其中消息模块依赖内容模块，消息模块和内容模块又都依赖用户模块。当这三个模块的代码耦合在一起，应用启动时，需要同时去加载每个模块的代码并连接对应的资源。一旦任何模块的代码出现 bug，或者依赖的资源出现问题，整个单体应用都会受到影响。</p>
<p>为此，首先可以把用户模块从单体应用中拆分出来，独立成一个服务部署，以 RPC 接口的形式对外提供服务。微博和消息模块调用用户接口，就从进程内的调用变成远程 RPC 调用。这样，用户模块就可以独立开发、测试、上线和运维，可以交由专门的团队来做，与主模块不耦合。进一步的可以再把消息模块也拆分出来作为独立的模块，交由专门的团队来开发和维护。</p>
<p>可见通过服务化，可以解决单体应用膨胀、团队开发耦合度高、协作效率低下的问题。</p>
<h1 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h1><p>以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演化，演变为微服务。</p>
<p>微服务相比于服务化的不同可以总结为以下四点：</p>
<ul>
<li>服务拆分粒度更细。微服务可以说是更细维度的服务化，小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务。</li>
<li>服务独立部署。每个微服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个 Docker 实例，每个 Docker 实例可以部署一个微服务的代码。</li>
<li>服务独立维护。每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。</li>
<li>服务治理能力要求高。因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。</li>
</ul>
<p>由此可见，微服务化给服务的发布和部署，以及服务的保障带来了诸多好处。</p>
<h1 id="什么时候进行服务化拆分"><a href="#什么时候进行服务化拆分" class="headerlink" title="什么时候进行服务化拆分"></a>什么时候进行服务化拆分</h1><p>项目第一阶段的主要目标是快速开发和验证想法，证明产品思路是否可行。这个阶段功能设计一般不会太复杂，开发采取快速迭代的方式，架构也不适合过度设计。所以将所有功能打包部署在一起，集中地进行开发、测试和运维，对于项目起步阶段，是最高效也是最节省成本的方式。当可行性验证通过，功能进一步迭代，就可以加入越来越多的新特性。</p>
<p>比如做一个社交 App，初期为了快速上线，验证可行性，可以只开发首页信息流、评论等基本功能。产品上线后，经过一段时间的运营，用户开始逐步增多，可行性验证通过，下一阶段就需要进一步增加更多的新特性来吸引更多的目标用户，比如再给这个社交 App 添加个人主页显示、消息通知等功能。</p>
<p>一般情况下，这个时候就需要大规模地扩张开发人员，以支撑多个功能的开发。如果这个时候继续采用单体应用架构，多个功能模块混杂在一起开发、测试和部署的话，就会导致不同功能之间相互影响，一次打包部署需要所有的功能都测试 OK 才能上线。</p>
<p>不仅如此，多个功能模块混部在一起，对线上服务的稳定性也是个巨大的挑战。比如 A 开发的一个功能由于代码编写考虑不够全面，上线后产生了内存泄漏，运行一段时间后进程异常退出，那么部署在这个服务池中的所有功能都不可访问。</p>
<p>这个时候就该考虑进行服务化拆分了。</p>
<h1 id="服务化拆分的两种姿势"><a href="#服务化拆分的两种姿势" class="headerlink" title="服务化拆分的两种姿势"></a>服务化拆分的两种姿势</h1><p>那么服务化拆分具体该如何实施呢？一个最有效的手段就是将不同的功能模块服务化，独立部署和运维。以社交 App 为例，可以认为首页信息流是一个服务，评论是一个服务，消息通知是一个服务，个人主页也是一个服务。</p>
<p>这种服务化拆分方式是纵向拆分，是从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</p>
<p>还有一种服务化拆分方式是横向拆分，是从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</p>
<p>以前面提到的社交 App 举例，无论是首页信息流、评论、消息箱还是个人主页，都需要显示用户的昵称。假如用户的昵称功能有产品需求的变更，你需要上线几乎所有的服务，这个成本就有点高了。显而易见，如果我把用户的昵称功能单独部署成一个独立的服务，那么有什么变更我只需要上线这个服务即可，其他服务不受影响，开发和上线成本就大大降低了。</p>
<h1 id="服务化拆分的前置条件"><a href="#服务化拆分的前置条件" class="headerlink" title="服务化拆分的前置条件"></a>服务化拆分的前置条件</h1><p>下面几个问题，是从单体应用迁移到微服务架构时必将面临也必须解决的。</p>
<ul>
<li>服务如何定义。对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。对于微服务来说，每个服务都运行在各自的进程之中，服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值。</li>
<li>服务如何发布和订阅。单体应用由于部署在同一个 WAR 包里，接口之间的调用属于进程内的调用。而拆分为微服务独立部署后，服务提供者该如何对外暴露自己的地址，服务调用者该如何查询所需要调用的服务的地址呢？这个时候你就需要一个类似登记处的地方，能够记录每个服务提供者的地址以供服务调用者查询，在微服务架构里，这个地方就是注册中心。</li>
<li>服务如何监控。通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。</li>
<li>服务如何治理。可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。</li>
<li>故障如何定位。在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。</li>
</ul>
<h1 id="微服务架构组成部分"><a href="#微服务架构组成部分" class="headerlink" title="微服务架构组成部分"></a>微服务架构组成部分</h1><p>一次正常的服务调用的流程:</p>
<img src="/2020/08/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/img1.png" class="" title="一次正常的服务调用的流程">

<p>首先服务提供者（就是提供服务的一方）按照一定格式的服务描述，向注册中心注册服务，声明自己能够提供哪些服务以及服务的地址是什么，完成服务发布。</p>
<p>接下来服务消费者（就是调用服务的一方）请求注册中心，查询所需要调用服务的地址，然后以约定的通信协议向服务提供者发起请求，得到请求结果后再按照约定的协议解析结果。</p>
<p>而且在服务的调用过程中，服务的请求耗时、调用量以及成功率等指标都会被记录下来用作监控，调用经过的链路信息会被记录下来，用于故障定位和问题追踪。在这期间，如果调用失败，可以通过重试等服务治理手段来保证成功率。</p>
<p>总结一下，微服务架构下，服务调用主要依赖下面几个基本组件：</p>
<ul>
<li>服务描述</li>
<li>注册中心</li>
<li>服务框架</li>
<li>服务监控</li>
<li>服务追踪</li>
<li>服务治理</li>
</ul>
<h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><p>服务调用首先要解决的问题就是服务如何对外描述。比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题。</p>
<p>常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。</p>
<p>其中，RESTful API 方式通常用于 HTTP 协议的服务描述，并且常用 Wiki 或者Swagger来进行管理。</p>
<p>XML 配置方式多用作 RPC 协议的服务描述，通过 *.xml 配置文件来定义接口名、参数以及返回值类型等。</p>
<p>IDL 文件方式通常用作 Thrift 和 gRPC 这类跨语言服务调用框架中，比如 gRPC 就是通过 Protobuf 文件来定义服务的接口名、参数以及返回值的数据结构。</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。</p>
<p>一般来讲，注册中心的工作流程是：</p>
<ul>
<li>服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。</li>
<li>服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li>
<li>注册中心返回服务提供者地址列表给服务消费者。</li>
<li>当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。</li>
</ul>
<img src="/2020/08/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/img2.png" class="">

<h2 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h2><p>通过注册中心，服务消费者就可以获取到服务提供者的地址，有了地址后就可以发起调用。但在发起调用之前你还需要解决以下几个问题。</p>
<ul>
<li>服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信。</li>
<li>数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。</li>
<li>数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的 JSON 序列化、Java 对象序列化以及 Protobuf 序列化等。</li>
</ul>
<h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>一旦服务消费者与服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程。</p>
<ul>
<li>指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。</li>
<li>数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。</li>
<li>数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。</li>
</ul>
<h2 id="服务追踪"><a href="#服务追踪" class="headerlink" title="服务追踪"></a>服务追踪</h2><p>除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。</p>
<p>服务追踪的工作原理大致如下：</p>
<p>服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。</p>
<p>服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递。</p>
<p>以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的。</p>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就得靠服务治理了。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。</p>
<p>在生产环境中，你应该经常会遇到下面几种状况。</p>
<ul>
<li>单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。</li>
<li>单 IDC 故障。你应该经常听说某某 App，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障 IDC 的流量到其他正常 IDC，可以避免因为单 IDC 故障引起的大批量业务受影响。</li>
<li>依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。</li>
</ul>
<p>上面是三种最常见的需要引入服务治理的场景，当然还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微服务是由单体应用进化到服务化拆分部署，后期随着移动互联网规模的不断扩大，敏捷开发、持续交付、DevOps 理论的发展和实践，以及基于 Docker 容器化技术的成熟，微服务架构开始流行，逐渐成为应用架构的未来演进方向。</p>
<p>微服务架构是将复杂臃肿的单体应用进行细粒度的服务化拆分，每个拆分出来的服务各自独立打包部署，并交由小团队进行开发和运维，从而极大地提高了应用交付的效率，并被各大互联网公司所普遍采用。</p>
<p>无论是纵向拆分还是横向拆分，都是将单体应用庞杂的功能进行拆分，抽离成单独的服务部署。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL日志"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/05/MySQL/MySQL%E6%97%A5%E5%BF%97/"
    >MySQL 日志</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/06/05/MySQL/MySQL%E6%97%A5%E5%BF%97/" class="article-date">
  <time datetime="2020-06-05T10:25:14.000Z" itemprop="datePublished">2020-06-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="日志及分类"><a href="#日志及分类" class="headerlink" title="日志及分类"></a>日志及分类</h1><p>日志是数据库的重要组成部分，主要用来记录数据库的运行情况、日常操作和错误信息。</p>
<p>MySQL 中的日志可以分为二进制日志、错误日志、通用查询日志和慢查询日志。分析这些日志，可以帮助我们了解 MySQL 数据库的运行情况、日常操作、错误信息和哪些地方需要进行优化。</p>
<p>MySQL 中 4 种日志文件的作用：</p>
<ul>
<li>二进制日志：该日志文件会以二进制的形式记录数据库的各种操作，但不记录查询语句。</li>
<li>错误日志：该日志文件会记录 MySQL 服务器的启动、关闭和运行错误等信息。</li>
<li>通用查询日志：该日志记录 MySQL 服务器的启动和关闭信息、客户端的连接信息、更新、查询数据记录的 SQL 语句等。</li>
<li>慢查询日志：记录执行事件超过指定时间的操作，通过工具分析慢查询日志可以定位 MySQL 服务器性能瓶颈所在。</li>
</ul>
<p>为了维护 MySQL 数据库，经常需要在 MySQL 中进行日志操作，包含日志文件的启动、查看、停止和删除等，这些操作都是数据库管理中最基本、最重要的操作。</p>
<p>例如，当用户<code>root</code>登录到 MySQL 服务器后，就会在日志文件里记录该用户的登录事件、执行操作等信息。当 MySQL 服务器运行时出错，出错信息就会被记录到日志文件里。</p>
<p>日志操作是数据库维护中最重要的手段之一。如果 MySQL 数据库系统意外停止服务，我们可以通过错误日志查看出现错误的原因。还可以通过二进制日志文件来查看用户分别执行了哪些操作、对数据库文件做了哪些修改。然后，还可以根据二进制日志中的记录来修复数据库。</p>
<p>在 MySQL 所支持的日志文件里，除了二进制日志文件外，其它日志文件都是文本文件。默认情况下，MySQL 只会启动错误日志文件，而其它日志则需要手动启动。</p>
<p>使用日志有优点也有缺点。启动日志后，虽然可以对 MySQL 服务器性能进行维护，但是会降低 MySQL 的执行速度。例如，一个查询操作比较频繁的 MySQL 中，记录通用查询日志和慢查询日志要花费很多的时间。</p>
<p>日志文件还会占用大量的硬盘空间。对于用户量非常大、操作非常频繁的数据库，日志文件需要的存储空间甚至比数据库文件需要的存储空间还要大。因此，是否启动日志，启动什么类型的日志要根据具体的应用来决定。</p>
<h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><p>错误日志主要记录 MySQL 服务器启动和停止过程中的信息、服务器在运行过程中发生的故障和异常情况等。</p>
<h2 id="启动和设置错误日志"><a href="#启动和设置错误日志" class="headerlink" title="启动和设置错误日志"></a>启动和设置错误日志</h2><p>在 MySQL 数据库中，默认开启错误日志功能。一般情况下，错误日志存储在 MySQL 数据库的数据文件夹下，通常名称为<code>hostname.err</code>。其中，<code>hostname</code>表示 MySQL 服务器的主机名。</p>
<p>在 MySQL 配置文件中，错误日志所记录的信息可以通过<code>log-error</code>和<code>log-warnings</code>来定义，其中，<code>log-err</code>定义是否启用错误日志功能和错误日志的存储位置，<code>log-warnings</code>定义是否将警告信息也记录到错误日志中。</p>
<p>将<code>log_error</code>选项加入到 MySQL 配置文件的 <code>[mysqld]</code>组中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-error=dir/&#123;filename&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>dir</code>参数指定错误日志的存储路径；<code>filename</code>参数指定错误日志的文件名；省略参数时文件名默认为主机名，存放在<code>Data</code>目录中。</p>
<p>重启 MySQL 服务后，参数开始生效，可以在指定路径下看到<code>filename.err</code>的文件，如果没有指定<code>filename</code>，那么错误日志将直接默认为<code>hostname.err</code>。</p>
<p>注意：错误日志中记录的并非全是错误信息，例如 MySQL 如何启动 InnoDB 的表空间文件、如何初始化自己的存储引擎等，这些也记录在错误日志文件中。</p>
<h2 id="查看错误日志"><a href="#查看错误日志" class="headerlink" title="查看错误日志"></a>查看错误日志</h2><p>在 MySQL 中，通过<code>SHOW</code>命令可以查看错误日志文件所在的目录及文件名信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_error&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_error     <span class="operator">|</span> C:\ProgramData\MySQL\MySQL Server <span class="number">5.7</span>\Data\LAPTOP<span class="operator">-</span>UHQ6V8KP.err <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+----------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>错误日志以文本文件的形式存储，直接使用普通文本工具就可以查看。</p>
<h3 id="删除错误日志"><a href="#删除错误日志" class="headerlink" title="删除错误日志"></a>删除错误日志</h3><p>在 MySQL 中，可以使用<code>mysqladmin</code>命令来开启新的错误日志。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure>
<p>执行该命令后，MySQL 服务器首先会自动创建一个新的错误日志，然后将旧的错误日志更名为<code>filename.err-old</code>。</p>
<p>MySQL 服务器发生异常时，可以在错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。对于很久之前的错误日志，查看的可能性不大，可以直接将这些错误日志删除。</p>
<h1 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h1><p>二进制日志也可叫作变更日志。主要用于记录数据库的变化情况，即 SQL 语句的 DDL 和 DML 语句，不包含数据记录查询操作。</p>
<p>如果 MySQL 数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</p>
<p>默认情况下，二进制日志功能是关闭的。可以通过以下命令查看二进制日志是否开启：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_bin&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_bin       <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>
<h2 id="启动和设置二进制日志"><a href="#启动和设置二进制日志" class="headerlink" title="启动和设置二进制日志"></a>启动和设置二进制日志</h2><p>在 MySQL 中，可以通过在配置文件中添加<code>log-bin</code>选项来开启二进制日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=dir/[filename]</span><br></pre></td></tr></table></figure>
<p>其中，<code>dir</code>参数指定二进制文件的存储路径；<code>filename</code>参数指定二进制文件的文件名，其形式为<code>filename.number</code>，<code>number</code>的形式为 000001、000002 等。</p>
<p>每次重启 MySQL 服务后，都会生成一个新的二进制日志文件，这些日志文件的文件名中<code>filename</code>部分不会改变，<code>number</code>会不断递增。</p>
<p>如果没有<code>dir</code>和<code>filename</code>参数，二进制日志将默认存储在数据库的数据目录下，默认的文件名为<code>hostname-bin.number</code>，其中<code>hostname</code>表示主机名。</p>
<p>下面在<code>my.ini</code>文件的<code>[mysqld]</code>组中添加以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log-bin</span><br></pre></td></tr></table></figure>
<p>重启 MySQL 服务器后，可以在 MySQL 数据库的数据目录下看到<code>LAPTOP-UHQ6V8KP-bin.000001</code>这个文件，同时还生成了<code>LAPTOP-UHQ6V8KP-bin.index</code>文件。此处，MySQL 服务器的主机名为<code>LAPTOP-UHQ6V8KP</code>。</p>
<p>还可以在<code>my.ini</code>文件的<code>[mysqld]</code>组中进行如下修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log-bin=C:log\mylog</span><br></pre></td></tr></table></figure>
<p>重启 MySQL 服务后，可以在<code>C:log</code>文件夹下看到<code>mylog.000001</code>文件和<code>mylog.index</code>文件。</p>
<h2 id="查看二进制日志"><a href="#查看二进制日志" class="headerlink" title="查看二进制日志"></a>查看二进制日志</h2><h3 id="1-查看二进制日志文件列表"><a href="#1-查看二进制日志文件列表" class="headerlink" title="1. 查看二进制日志文件列表"></a>1. 查看二进制日志文件列表</h3><p>可以使用如下命令查看 MySQL 中有哪些二进制日志文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="type">binary</span> logs;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name                   <span class="operator">|</span> File_size <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> LAPTOP<span class="operator">-</span>UHQ6V8KP<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span>       <span class="number">177</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> LAPTOP<span class="operator">-</span>UHQ6V8KP<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>       <span class="number">154</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+-----------+</span></span><br></pre></td></tr></table></figure>
<h3 id="2-查看当前正在写入的二进制日志文件"><a href="#2-查看当前正在写入的二进制日志文件" class="headerlink" title="2. 查看当前正在写入的二进制日志文件"></a>2. 查看当前正在写入的二进制日志文件</h3><p>可以使用以下命令查看当前 MySQL 中正在写入的二进制日志文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> master status;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> File                       <span class="operator">|</span> Position <span class="operator">|</span> Binlog_Do_DB <span class="operator">|</span> Binlog_Ignore_DB <span class="operator">|</span> Executed_Gtid_Set <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="operator">|</span> LAPTOP<span class="operator">-</span>UHQ6V8KP<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span>      <span class="number">154</span> <span class="operator">|</span>              <span class="operator">|</span>                  <span class="operator">|</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------+--------------+------------------+-------------------+</span></span><br></pre></td></tr></table></figure>
<h3 id="3-查看二进制日志文件内容"><a href="#3-查看二进制日志文件内容" class="headerlink" title="3. 查看二进制日志文件内容"></a>3. 查看二进制日志文件内容</h3><p>二进制日志使用二进制格式存储，不能直接打开查看。如果需要查看二进制日志，必须使用<code>mysqlbinlog</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog filename.number</span><br></pre></td></tr></table></figure>
<p><code>mysqlbinlog</code>命令只在当前文件夹下查找指定的二进制日志，因此需要在二进制日志所在的目录下运行该命令，否则将会找不到指定的二进制日志文件。</p>
<p>下面使用<code>mysqlbinlog</code>命令，来查看<code>C:\log</code>目录下的<code>mylog.000001</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\11645&gt;cd C:\log</span><br><span class="line">C:\log&gt;mysqlbinlog mylog.000001</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/;</span><br><span class="line">/*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/;</span><br><span class="line">DELIMITER /*!*/;</span><br><span class="line"># at 4</span><br><span class="line">#200527  9:33:37 server id 1  end_log_pos 123 CRC32 0x69738cfd  Start: binlog v 4, server v 5.7.29-log created 200527  9:33:37 at startup</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>使用<code>mysqlbinlog</code>命令时，可以指定二进制文件的存储路径。这样可以确保<code>mysqlbinlog</code>命令可以找到二进制文件。上面例子中的命令可以变为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog C:\log\mylog.000001</span><br></pre></td></tr></table></figure>
<p>这样，<code>mysqlbinlog</code>命令就会到<code>C:\log</code>目录下去查找<code>mylog.000001</code>文件。如果不指定路径，<code>mysqlbinlog</code>命令将在当前目录下查找<code>mylog.000001</code>文件。</p>
<p>除了<code>filename.number</code>文件，MySQL 还会生成一个名为<code>filename.index</code>的文件，这个文件存储着所有二进制日志文件的列表，可以用记事本打开该文件。</p>
<p>小技巧：实际工作中，二进制日志文件与数据库的数据文件不放在同一块硬盘上，这样即使数据文件所在的硬盘被破坏，也可以使用另一块硬盘上的二进制日志来恢复数据库文件。两块硬盘同时坏了的可能性要小得多，这样可以保证数据库中数据的安全。</p>
<h2 id="删除二进制日志"><a href="#删除二进制日志" class="headerlink" title="删除二进制日志"></a>删除二进制日志</h2><p>二进制日志中记录着大量的信息，如果很长时间不清理二进制日志，将会浪费很多的磁盘空间。</p>
<h3 id="1-删除所有二进制日志"><a href="#1-删除所有二进制日志" class="headerlink" title="1. 删除所有二进制日志"></a>1. 删除所有二进制日志</h3><p>使用<code>RESET MASTER</code>语句可以删除的所有二进制日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RESET MASTER;</span><br></pre></td></tr></table></figure>
<p>登录 MySQL 数据库后，可以执行该语句来删除所有二进制日志。删除所有二进制日志后，MySQL 将会重新创建新的二进制日志，新二进制日志的编号从 000001 开始。</p>
<h3 id="2-根据编号删除二进制日志"><a href="#2-根据编号删除二进制日志" class="headerlink" title="2. 根据编号删除二进制日志"></a>2. 根据编号删除二进制日志</h3><p>每个二进制日志文件后面有一个 6 位数的编号，如 000001。使用<code>PURGE MASTER LOGS TO</code>语句，可以删除指定二进制日志的编号之前的日志。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS <span class="keyword">TO</span> <span class="string">&#x27;filename.number&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>该语句将删除编号小于<code>filename.number</code>的所有二进制日志。</p>
<h3 id="3-根据创建时间删除二进制日志"><a href="#3-根据创建时间删除二进制日志" class="headerlink" title="3. 根据创建时间删除二进制日志"></a>3. 根据创建时间删除二进制日志</h3><p>使用<code>PURGE MASTER LOGS TO</code>语句，可以删除指定时间之前创建的二进制日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PURGE MASTER LOGS <span class="keyword">TO</span> <span class="string">&#x27;yyyy-mm-dd hh:MM:ss&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="暂时停止二进制日志"><a href="#暂时停止二进制日志" class="headerlink" title="暂时停止二进制日志"></a>暂时停止二进制日志</h2><p>在配置文件中设置了<code>log_bin</code>选项之后，MySQL 服务器将会一直开启二进制日志功能。删除该选项后就可以停止二进制日志功能，如果需要再次启动这个功能，需要重新添加<code>log_bin</code>选项。由于这样比较麻烦，所以 MySQL 提供了暂时停止二进制日志功能的语句。</p>
<p>如果用户不希望自己执行的某些 SQL 语句记录在二进制日志中，可以在执行这些 SQL 语句之前暂停二进制日志功能。</p>
<p>使用<code>SET</code>语句来暂停&#x2F;开启二进制日志功能：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SQL_LOG_BIN<span class="operator">=</span><span class="number">0</span><span class="operator">/</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>0 表示暂停二进制日志功能，1 表示开启二进制功能。</p>
<p><code>my.ini</code>中的<code>[mysqld]</code>组下面有几个设置参数是关于二进制日志的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire_logs_days = 10</span><br><span class="line">max_binlog_size = 1​00M</span><br></pre></td></tr></table></figure>
<p><code>expire_logs_day</code>定义了 MySQL 清除过期日志的时间、二进制日志自动删除的天数。默认值为 0，表示“没有自动删除”。当 MySQL 启动或刷新二进制日志时可能删除。</p>
<p><code>max_binlog_size</code>定义了单个文件的大小限制，如果二进制日志写入的内容大小超出给定值，日志就会发生滚动（关闭当前文件，重新打开一个新的日志文件）。不能将该变量设置为大于 1GB 或小于 4096B（字节），其默认值是 1GB。</p>
<h1 id="使用二进制日志还原数据库"><a href="#使用二进制日志还原数据库" class="headerlink" title="使用二进制日志还原数据库"></a>使用二进制日志还原数据库</h1><p>二进制日志中记录了用户对数据库更改的所有操作，如<code>INSERT</code>语句、<code>UPDATE</code>语句、<code>CREATE</code>语句等。如果数据库因为操作不当或其它原因丢失了数据，可以通过二进制日志来查看在一定时间段内用户的操作，结合数据库备份来还原数据库。</p>
<p>数据库遭到意外损坏时，应该先使用最近的备份文件来还原数据库。另外备份之后，数据库可能进行了一些更新，这时可以使用二进制日志来还原。因为二进制日志中存储了更新数据库的语句，如<code>UPDATE</code>语句、<code>INSERT</code>语句等。</p>
<p>二进制日志还原数据库的命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog filename.number <span class="operator">|</span> mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>
<p>以上命令可以理解成，先使用<code>mysqlbinlog</code>命令来读取<code>filename.number</code>中的内容，再使用<code>mysql</code>命令将这些内容还原到数据库中。</p>
<p>技巧：二进制日志虽然可以用来还原 MySQL 数据库，但是其占用的磁盘空间也是非常大的。因此，在备份 MySQL 数据库之后，应该删除备份之前的二进制日志。如果备份之后发生异常，造成数据库的数据损失，可以通过备份之后的二进制日志进行还原。</p>
<p>使用<code>mysqlbinlog</code>命令进行还原操作时，必须是编号小的先还原。例如，<code>mylog.000001</code>必须在<code>mylog.000002</code>之前还原。</p>
<p>下面使用二进制日志来还原数据库：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mylog<span class="number">.000001</span> <span class="operator">|</span> mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">mysqlbinlog mylog<span class="number">.000002</span> <span class="operator">|</span> mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">mysqlbinlog mylog<span class="number">.000003</span> <span class="operator">|</span> mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">mysqlbinlog mylog<span class="number">.000004</span> <span class="operator">|</span> mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br></pre></td></tr></table></figure>
<h1 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h1><p>通用查询日志用来记录用户的所有操作，包括启动和关闭 MySQL 服务、更新语句和查询语句等。</p>
<p>默认情况下，通用查询日志功能是关闭的。可以通过以下命令查看通用查询日志是否开启：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                                                            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> C:\ProgramData\MySQL\MySQL Server <span class="number">5.7</span>\Data\LAPTOP<span class="operator">-</span>UHQ6V8KP.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，通用查询日志是关闭的，<code>general_log_file</code>变量指定了通用查询日志文件所在的位置。</p>
<h2 id="启动和设置通用查询日志"><a href="#启动和设置通用查询日志" class="headerlink" title="启动和设置通用查询日志"></a>启动和设置通用查询日志</h2><p>在 MySQL 中，可以通过在 MySQL 配置文件添加<code>log</code>选项来开启通用查询日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log=dir/filename</span><br></pre></td></tr></table></figure>
<p>其中，<code>dir</code>参数指定通用查询日志的存储路径；<code>filename</code>参数指定日志的文件名。如果不指定存储路径，通用查询日志将默认存储到 MySQL 数据库的数据文件夹下。如果不指定文件名，默认文件名为<code>hostname.log</code>，其中<code>hostname</code>表示主机名。</p>
<h2 id="查看通用查询日志"><a href="#查看通用查询日志" class="headerlink" title="查看通用查询日志"></a>查看通用查询日志</h2><p>如果希望了解用户最近的操作，可以查看通用查询日志。通用查询日志以文本文件的形式存储，可以使用普通文本文件查看该类型日志内容。</p>
<p>首先我们查看通用查询日志功能是否是开启状态，然后查询<code>tb_student</code>表的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                                                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> <span class="keyword">ON</span>                                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> C:\ProgramData\MySQL\MySQL Server <span class="number">5.7</span>\Data\LAPTOP<span class="operator">-</span>UHQ6V8KP.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+----------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> use test;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Java   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MySQL  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Python <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br></pre></td></tr></table></figure>
<p>执行成功后，打开通用查询日志，这里日志名称为<code>LAPTOP-UHQ6V8KP.log</code>，下面是通用查询日志中的部分内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld.exe, Version: 5.7.29-log (MySQL Community Server (GPL)). started with:</span><br><span class="line">TCP Port: 3306, Named Pipe: MySQL</span><br><span class="line">Time                 Id Command    Argument</span><br><span class="line">2020-05-29T06:43:44.382878Z     7 Quit</span><br><span class="line">2020-05-29T06:44:10.001382Z     8 Connect root@localhost on  using SSL/TLS</span><br><span class="line">2020-05-29T06:44:10.007532Z     8 Query select @@version_comment limit 1</span><br><span class="line">2020-05-29T06:44:11.748179Z     8 Query SHOW VARIABLES LIKE &#x27;%general%&#x27;</span><br><span class="line">2020-05-29T06:44:25.487472Z     8 Query SELECT DATABASE()</span><br><span class="line">2020-05-29T06:44:25.487748Z     8 Init DB test</span><br><span class="line">2020-05-29T06:44:35.390523Z     8 Query SELECT * FROM tb_student</span><br></pre></td></tr></table></figure>
<p>可以看出，该日志非常清晰地记录了客户端的所有行为。</p>
<h2 id="停止通用查询日志"><a href="#停止通用查询日志" class="headerlink" title="停止通用查询日志"></a>停止通用查询日志</h2><p>通用查询日志启动后，可以通过两种方法停止该日志。一种是将 MySQL 配置文件中的相关配置注释掉，然后重启服务器，来停止通用查询日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#log=dir\filename</span><br></pre></td></tr></table></figure>
<p>上述方法需要重启 MySQL 服务器，这在某些场景，比如有业务量访问的情况下是不允许的，这时可以通过另一种方法来动态地控制通用查询日志的开启和关闭。</p>
<p>设置 MySQL 的环境变量<code>general_log</code>为关闭状态可以停止该日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general_log%&#x27;</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Variable_name: general_log</span><br><span class="line">        <span class="keyword">Value</span>: OFF</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Variable_name: general_log_file</span><br><span class="line">        <span class="keyword">Value</span>: C:\ProgramData\MySQL\MySQL Server <span class="number">5.7</span>\Data\LAPTOP<span class="operator">-</span>UHQ6V8KP.log</span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="删除通用查询日志"><a href="#删除通用查询日志" class="headerlink" title="删除通用查询日志"></a>删除通用查询日志</h3><p>在 MySQL 中，可以使用<code>mysqladmin</code>命令来开启新的通用查询日志。新的通用查询日志会直接覆盖旧的查询日志，不需要再手动删除了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果希望备份旧的通用查询日志，必须先将旧的日志文件拷贝出来或者改名。然后，再执行<code>mysqladmin</code>命令。</p>
<p>除了上述方法之外，还可以手工删除通用查询日志。删除之后需要重新启动 MySQL 服务。重启之后就会生成新的通用查询日志。如果希望备份旧的日志文件，可以将旧的日志文件改名，然后重启 MySQL 服务。</p>
<p>由于通用查询日志会记录用户的所有操作，如果数据库的使用非常频繁，通用查询日志将会占用非常大的磁盘空间，对系统性能影响较大。一般情况下，数据管理员可以删除很长时间之前的通用查询日志或关闭此日志，以保证 MySQL 服务器上的硬盘空间。</p>
<h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。</p>
<p>MySQL 慢查询日志是排查问题的 SQL 语句，以及检查当前 MySQL 性能的一个重要功能。如果不是调优需要，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<p>默认情况下，慢查询日志功能是关闭的。可以通过以下命令查看是否开启慢查询日志功能。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;slow_query%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+---------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name       <span class="operator">|</span> <span class="keyword">Value</span>                                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+---------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log      <span class="operator">|</span> OFF                                                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file <span class="operator">|</span> C:\ProgramData\MySQL\MySQL Server <span class="number">5.7</span>\Data\LAPTOP<span class="operator">-</span>UHQ6V8KP<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+---------------------------------------------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> long_query_time <span class="operator">|</span> <span class="number">10.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>slow_query_log</code>：慢查询开启状态</li>
<li><code>slow_query_log_file</code>：慢查询日志存放的位置（一般设置为 MySQL 的数据存放目录）</li>
<li><code>long_query_time</code>：查询超过多少秒才记录</li>
</ul>
<h2 id="启动和设置慢查询日志"><a href="#启动和设置慢查询日志" class="headerlink" title="启动和设置慢查询日志"></a>启动和设置慢查询日志</h2><p>可以通过<code>log-slow-queries</code>选项开启慢查询日志。通过<code>long_query_time</code>选项来设置时间值，时间以秒为单位。如果查询时间超过了这个时间值，这个查询语句将被记录到慢查询日志。</p>
<p>将<code>log_slow_queries</code>选项和<code>long_query_time</code>选项加入到配置文件的<code>[mysqld]</code>组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-slow-queries=dir\filename</span><br><span class="line">long_query_time=n</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>dir</code>参数指定慢查询日志的存储路径，如果不指定存储路径，慢查询日志将默认存储到 MySQL 数据库的数据文件夹下。</li>
<li><code>filename</code>参数指定日志的文件名，生成日志文件的完整名称为<code>filename-slow.log</code>。如果不指定文件名，默认文件名为<code>hostname-slow.log</code>，<code>hostname</code>是 MySQL 服务器的主机名。</li>
<li><code>n</code>参数是设定的时间值，单位是秒。如果不设置<code>long_query_time</code>选项，默认时间为 10 秒。</li>
</ul>
<p>还可以通过以下命令启动慢查询日志、设置指定时间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span><span class="keyword">ON</span><span class="operator">/</span>OFF;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time<span class="operator">=</span>n;</span><br></pre></td></tr></table></figure>
<h2 id="查看慢查询日志"><a href="#查看慢查询日志" class="headerlink" title="查看慢查询日志"></a>查看慢查询日志</h2><p>如果你想查看哪些查询语句的执行效率低，可以从慢查询日志中获得信息。和错误日志、查询日志一样，慢查询日志也是以文本文件的形式存储的，可以使用普通的文本文件查看工具来查看。</p>
<p>开启 MySQL 慢查询日志功能，并设置时间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time<span class="operator">=</span><span class="number">0.001</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>查询<code>tb_student</code>表中的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> USE test;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> Java   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MySQL  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Python <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br></pre></td></tr></table></figure>
<p>慢查询日志的部分内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Time: 2020-06-01T01:59:18.368780Z</span><br><span class="line"># User@Host: root[root] @ localhost [::1]  Id:     3</span><br><span class="line"># Query_time: 0.006281  Lock_time: 0.000755 Rows_sent: 2  Rows_examined: 1034</span><br><span class="line">use test;</span><br><span class="line">SET timestamp=1590976758;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;slow_query%&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="删除慢查询日志"><a href="#删除慢查询日志" class="headerlink" title="删除慢查询日志"></a>删除慢查询日志</h2><p>慢查询日志的删除方法与通用日志的删除方法是一样的。可以使用<code>mysqladmin</code>命令来删除。也可以使用手工方式来删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure>
<p>执行该命令后，命令行会提示输入密码。输入正确密码后，将执行删除操作。新的慢查询日志会直接覆盖旧的查询日志，不需要再手动删除。</p>
<p>也可以手工删除慢查询日志，删除之后需要重新启动 MySQL 服务。</p>
<p>注意：通用查询日志和慢查询日志都是使用这个命令，使用时一定要注意，一旦执行这个命令，通用查询日志和慢查询日志都只存在新的日志文件中。如果需要备份旧的慢查询日志文件，必须先将旧的日志改名，然后重启 MySQL 服务或执行<code>mysqladmin</code>命令。</p>
<h1 id="设置日志输出方式"><a href="#设置日志输出方式" class="headerlink" title="设置日志输出方式"></a>设置日志输出方式</h1><p>MySQL 的查询日志支持写入到文件或写入数据表两种输出形式。启用了普通查询日志或慢查询日志功能后，可以选择让服务器把日志写入到日志文件、<code>mysql</code>数据库中的日志表、或者同时写到这两个地方。</p>
<p>可以通过以下命令查看日志输出类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%log_out%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_output    <span class="operator">|</span> FILE  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>
<p>结果显示，日志输出类型为<code>FILE</code>。</p>
<p>要想在运行时更改日志输出目标，可以在启动服务器时，设置全局系统变量<code>log_output</code>的值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_output<span class="operator">=</span><span class="string">&#x27;value&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>value</code>的值可以是：</p>
<ul>
<li><code>FILE</code>：表示把日志写入到文件。如果未指定<code>log_output</code>的值，默认为<code>FILE</code>。</li>
<li><code>TABLE</code>：表示把日志写入到<code>mysql</code>数据库的<code>slow_log</code>或<code>general_log</code>表中。</li>
<li>MySQL 可以同时支持 2 种日志存储方式，配置的时候以逗号隔开，即<code>log_output=&#39;FILE,TABLE&#39;</code>。</li>
</ul>
<p>需要注意的是，系统变量<code>log_output</code>只确定了日志使用什么输出目标，并不会启用日志功能。</p>
<p>相对于写入到文件，日志写入到数据表中要耗费更多的系统资源。因此，对于需要启用查询日志，又需要获得更高的系统性能，建议优先选择将日志写入到文件。</p>
<p>日志表（<code>slow_log</code>或<code>general_log</code>）中的内容只允许查看，不允许修改，除非服务器自己进行更改。因此，你只能对日志表使用<code>SELECT</code>语句，不能使用<code>INSERT、DELETE</code>或<code>UPDATE</code>语句。不过，可以使用<code>TRUNCATE TABLE</code>语句来清空日志表。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL数据库备份与恢复"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/03/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"
    >MySQL数据库备份与恢复</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/06/03/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" class="article-date">
  <time datetime="2020-06-03T09:11:23.000Z" itemprop="datePublished">2020-06-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="备份类型"><a href="#备份类型" class="headerlink" title="备份类型"></a>备份类型</h1><p>备份是以防万一的一种必要手段，在出现硬件损坏或非人为的因素而导致数据丢失时，可以使用备份恢复数据，以将损失降低到最小程度，因此备份是必须的。备份可以分为以下几个类型。</p>
<p>根据备份的方法（是否需要数据库离线）可以将备份分为：</p>
<ul>
<li>热备（<code>Hot Backup</code>）</li>
<li>冷备（<code>Cold Backup</code>）</li>
<li>温备（<code>Warm Backup</code>）</li>
</ul>
<p>热备份可以在数据库运行中直接备份，对正在运行的数据库操作没有任何的影响，数据库的读写操作可以正常执行。这种方式也称为<code>Online Backup</code>（在线备份）。</p>
<p>冷备份必须在数据库停止的情况下进行备份，数据库的读写操作不能执行。这种备份最为简单，一般只需要复制相关的数据库物理文件即可。这种方式也称为<code>Offline Backup</code>（离线备份）。</p>
<p>温备份同样是在数据库运行中进行的，但是会对当前数据库的操作有所影响，备份时仅支持读操作，不支持写操作。</p>
<p>按照备份后文件的内容，热备份又可以分为：逻辑备份、裸文件备份。</p>
<p>在 MySQL 数据库中，逻辑备份是指备份出的文件内容是可读的，一般是文本内容。内容一般是由一条条 SQL 语句，或者是表内实际数据组成。如<code>mysqldump</code>和<code>SELECT * INTO OUTFILE</code>的方法。这类方法的好处是可以观察导出文件的内容，一般适用于数据库的升级、迁移等工作。但其缺点是恢复的时间较长。</p>
<p>裸文件备份是指复制数据库的物理文件，既可以在数据库运行中进行复制（如 ibbackup、xtrabackup 这类工具），也可以在数据库停止运行时直接复制数据文件。这类备份的恢复时间往往比逻辑备份短很多。</p>
<p>按照备份数据库的内容来分，备份又可以分为：完全备份、部分备份。</p>
<p>完全备份是指对数据库进行一个完整的备份，即备份整个数据库，如果数据较多会占用较大的时间和空间。</p>
<p>部分备份是指备份部分数据库（例如，只备份一个表）。</p>
<p>部分备份又分为：增量备份、差异备份。</p>
<p>增量备份需要使用专业的备份工具。指的是在上次完全备份的基础上，对更改的数据进行备份。也就是说每次备份只会备份自上次备份之后到备份时间之内产生的数据。因此每次备份都比差异备份节约空间，但是恢复数据麻烦。</p>
<p>差异备份指的是自上一次完全备份以来变化的数据。和增量备份相比，浪费空间，但恢复数据比增量备份简单。</p>
<p>MySQL 中进行不同方式的备份还要考虑存储引擎是否支持，如 MyISAM 不支持热备，支持温备和冷备。而 InnoDB 支持热备、温备和冷备。</p>
<p>一般情况下，我们需要备份的数据分为以下几种：</p>
<ul>
<li>表数据</li>
<li>二进制日志、InnoDB 事务日志</li>
<li>代码（存储过程、存储函数、触发器、事件调度器）</li>
<li>服务器配置文件</li>
</ul>
<p>下面是几种常用的备份工具：</p>
<ul>
<li><code>mysqldump</code>：逻辑备份工具，适用于所有的存储引擎，支持温备、完全备份、部分备份、对于 InnoDB 存储引擎支持热备。</li>
<li><code>cp、tar</code>等归档复制工具：物理备份工具，适用于所有的存储引擎、冷备、完全备份、部分备份。</li>
<li><code>lvm2 snapshot</code>：借助文件系统管理工具进行备份。</li>
<li><code>mysqlhotcopy</code>：名不副实的一个工具，仅支持 MyISAM 存储引擎。</li>
<li><code>xtrabackup</code>：一款由 percona 提供的非常强大的 InnoDB&#x2F;XtraDB 热备工具，支持完全备份、增量备份。</li>
</ul>
<h1 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h1><p>冷备份可以称为<code>Offline Backup</code>（离线备份）。这种备份最为简单，一般只需要复制相关的数据库物理文件到另外的位置即可。</p>
<p>由于 MySQL 服务器中的数据文件是基于磁盘的文本文件，所以最简单、最直接的备份操作，就是将数据文件直接复制出来。但是由于 MySQL 服务器的数据文件在运行时期，总是处于打开和使用状态，因此备份文件不一定有效。为了解决该问题，在复制数据文件时，需要先停止 MySQL 服务器。</p>
<p>这样做的好处是可以保证数据库的完整性，备份过程简单且恢复速度相对快一些，但是关闭数据库会影响现有业务的进行。服务器停止运行期间，用户不能再继续访问网站。冷备一般用于不是很重要、非核心的业务上面。</p>
<p>冷备份的优点如下：</p>
<ul>
<li>备份简单、快速，只要复制相关文件即可。</li>
<li>备份文件易于在不同操作系统，不同 MySQL 版本上进行恢复。</li>
<li>恢复相当简单，只需要把文件恢复到指定位置即可。</li>
<li>恢复速度快，不需要执行任何 SQL 语句，也不需要重建索引。</li>
<li>低度维护，高度安全。</li>
</ul>
<p>冷备份的缺点如下：</p>
<ul>
<li>备份过程中，数据库不能做其它的工作，且必须是关闭状态。</li>
<li>InnoDB 存储引擎冷备的文件通常比逻辑文件大很多，因为表空间存放着很多其它的数据，如<code>undo</code>段，插入缓冲等信息。</li>
<li>若磁盘空间有限，只能拷贝到磁带等其它外部存储设备上，速度会很慢。</li>
<li>冷备也不总是可以轻易的跨平台。操作系统、MySQL 的版本、文件大小写敏感和浮点数格式都会成为问题。</li>
</ul>
<p>数据库的物理文件主要由数据库的数据文件、日志文件以及配置文件等组成。MySQL 系统有一些共有的日志文件和系统表的数据文件。每种存储引擎的物理文件也不一样。</p>
<p>冷备的备份与恢复过程也很简单。仅仅需要如下几步：</p>
<ol>
<li>为了保证所备份数据的完整性，在停止 MySQL 数据库服务器之前，需要先执行 FLUSH TABLES 语句将所有数据写入到数据文件的文本文件里。</li>
<li>停掉 MySQL 服务，命令（2种方式）如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>proot shutdown</span><br><span class="line">NET <span class="keyword">START</span> mysql</span><br></pre></td></tr></table></figure></li>
<li>备份过程就是复制整个数据目录到远程备份机或者本地磁盘上，Linux 和 Windows 命令如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scp -r /data/mysql/ root@远程备份机ip:/新的目录</span><br><span class="line">Copy -r /data/mysql/ 本地新目录</span><br></pre></td></tr></table></figure>
备份到本次磁盘也可以手动复制上述相关目录里的数据文件。</li>
<li>恢复过程就更简单了，仅仅需要把已备份的数据目录替换原有的目录就可以了，最后重启 MySQL 服务。</li>
</ol>
<p>需要注意的是，通过复制数据文件这种方式实现数据恢复时，必须保证两个 MySQL 数据库的主版本号一致。只有两个 MySQL 数据库主版本号相同时，才能保证它们的数据文件类型是相同的。</p>
<h1 id="冷备份所需物理文件"><a href="#冷备份所需物理文件" class="headerlink" title="冷备份所需物理文件"></a>冷备份所需物理文件</h1><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>MyISAM 存储引擎的所有数据默认存放在<code>C:/ProgramData/MySQL/MySQL Server 5.7/Data</code>路径下，即配置文件（<code>my.ini</code>或<code>my.cnf</code>）中<code>datadir</code>参数的值。</p>
<p>实际上不管我们使用的是 MyISAM 存储引擎还是其他存储引擎，每一个数据库都会在<code>datadir</code>目录下有一个文件夹（包括系统信息的数据库<code>mysql</code>也是一样）。</p>
<p>在各个数据库中每一个 MyISAM 存储引擎的表都会有 3 个文件存在，即记录表结构元数据的<code>.frm</code>文件，存储表数据的<code>.MYD</code>文件，存储索引数据的<code>.MYI</code>文件。</p>
<p>MyISAM 属于非事务性存储引擎，它没有自己的日志文件。所以 MyISAM 存储引擎的物理备份除了需要备份 MySQL 系统共有的物理文件之外，还需要备份上面的 3 种文件。</p>
<h2 id="Innodb-存储引擎"><a href="#Innodb-存储引擎" class="headerlink" title="Innodb 存储引擎"></a>Innodb 存储引擎</h2><p>Innodb 存储引擎属于事务性存储引擎，存放数据的位置也可能与 MyISAM 存储引擎有所不同，这主要取决于 Innodb 的相关配置。</p>
<p>指定 Innodb 存放数据和日志文件的位置参数为<code>innodb_data_home_dir、innodb_data_file_path</code>和<code>innodb_log_group_home_dir</code>。以及决定 Innodb 的表空间存储方式参数<code>innodb_file_per_table</code>，它决定 Innodb 是以共享表空间存放数据还是以独享表空间方式存储数据。</p>
<p>如果使用的是共享表空间的存储方式，那么需要备份<code>innodb_data_home_dir</code>和<code>innodb_data_file_path</code>参数设定的所有数据文件，以及<code>datadir</code>中相应数据库目录下的所有 Innodb 存储引擎表的 <code>frm</code>文件。</p>
<p>而如果使用的是独享表空间，那么除了需要备份上面共享表空间方式所需要备份的所有文件之外，我们还需要备份<code>datadir</code>中相应数据库目录下的所有<code>.idb</code>文件，该文件中存放的才是独享表空间方式下 Innodb 存储引擎表的数据。</p>
<p>那么既然是使用独享表空间，为什么还要备份共享表空间“才使用到”的数据文件呢？其实这是很多人的一个共性误区，以为使用独享表空间的时候 Innodb 的所有信息就都存放在“datadir”所设定数据库目录下的“.ibd”文件中。实际上并不是这样的，“.ibd”文件中所存放的仅仅只是我们的表数据而已。</p>
<p>大家都很清楚，Innodb 是事务性存储引擎，它需要<code>undo</code>和<code>redo</code>信息，而不管 Innodb 使用的是共享还是独享表空间的方式来存储数据。与事务相关的<code>undo</code>信息以及其他的一些元数据信息，都是存放在<code>innodb_data_home_dir</code>和<code>innodb_data_file_path</code>这两个参数所设定的数据文件中的。所以要想 Innodb 的物理备份有效，就必须备份<code>innodb_data_home_dir</code>和<code>innodb_data_file_path</code>参数所设定的数据文件。</p>
<p>此外，除了上面所说的数据文件之外，Innodb 还有存放自己的<code>redo</code>信息和相关事务信息的日志文件在<code>innodb_log_group_home_dir</code>参数所设定的位置。所以要想 Innodb 物理备份能够有效使用，我们还必须要备份<code>innodb_log_group_home_dir</code>参数所设定的位置的所有日志文件。</p>
<h1 id="热备份及恢复"><a href="#热备份及恢复" class="headerlink" title="热备份及恢复"></a>热备份及恢复</h1><p>与冷备份正好相反，热备份是在数据库处于运行状态时直接备份，不影响现有业务的正常进行。热备份又细分为逻辑备份和裸文件备份。</p>
<h2 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h2><p>逻辑备份的最大优点就是对于各种存储引擎，都可以用同样的方法来备份。而冷备份则不同，不同的存储引擎的备份方法也各不相同。因此，对于不同存储引擎混合的数据库，用逻辑备份会更简单一些。</p>
<p>逻辑备份可以说是最简单，也是目前中小型系统最常用的备份方法。逻辑备份主要有以下几种方法：</p>
<ol>
<li><code>mysqldump</code><br><code>mysqldump</code>是 MySQL 自带的逻辑备份工具。它的备份原理是通过协议连接到 MySQL 数据库，将需要备份的数据查询出来，然后将查询出的数据转换成对应的<code>INSERT</code>语句。当我们需要还原恢复这些数据时，只要执行这些<code>INSERT</code>语句，就能将对应的数据还原。所以有的资料也将这种备份方式称为<code>INSERT</code>备份。</li>
</ol>
<p>恢复数据时可以使用<code>mysql -uroot -p &lt;backup.sql</code>直接调用备份文件执行所有命令，将数据完全恢复到备份时候的状态。如果已经连接上了 MySQL 服务器，那么可以通过<code>source /path/backup.sql</code>来进行恢复。<br>2. <code>SELECT INTO…OUTFILE</code><br><code>SELECT INTO…OUTFILE</code>语句可以把表数据导出到一个文本文件中，且能将数据库中的表数据以特定分隔符进行分隔后记录在文本文件中，以达到逻辑备份的效果。</p>
<p>这种备份方式与<code>mysqldump</code>方法相比，使用的存储空间更小，数据格式更加清晰明确，编辑方便。但是这种方法只能导出或导入数据的内容，不包括表的结构，如果表的结构文件损坏，则必须先恢复原来的表的结构。而且这种方法不能在同一个备份文件中存在多个表的备份数据，增加了文件维护和恢复的成本。</p>
<p>这种备份方法恢复起来会稍微麻烦一点，需要一个表一个表通过相关命令来进行恢复。当然如果是通过脚本来实现自动多表恢复也是比较方便的。恢复方法有 2 个，一个是通过 MySQL 的<code>LOAD DATA INFILE</code>命令来恢复数据，另一种方法就是通过 MySQL 提供的使用工具 mysqlimport 来进行恢复。<br>3. <code>mydumper</code><br><code>mydumper</code>是针对 MySQL 数据库备份的一个轻量级第三方的开源工具，备份方式为逻辑备份。它支持多线程，备份速度远高于原生态的<code>mysqldump</code>以及其它众多优异特性。与其配套的相应恢复数据为<code>myloader</code>工具。</p>
<p>我们可以看出所谓的逻辑备份就是备份 SQL 语句，然后恢复数据时执行备份 SQL，从而实现数据库数据的重现。逻辑备份完成后所形成的文件都可以直接编辑。</p>
<p>逻辑备份的作用如下：</p>
<ul>
<li>通过逻辑备份，我们可以仅仅恢复备份中的部分数据而不需要全部恢复。不会影响不相关的数据；</li>
<li>通过全库的逻辑备份，我们可以在新的 MySQL 环境下完全重建出一个与备份时完全一样的数据库，并且不受平台类型限制；</li>
<li>通过特定条件的逻辑备份，我们可以将某些特定数据轻松迁移（或者同步）到其它的 MySQL 或另外的数据库环境。</li>
</ul>
<h2 id="裸文件备份"><a href="#裸文件备份" class="headerlink" title="裸文件备份"></a>裸文件备份</h2><p>裸文件备份主要在底层复制数据文件，所以备份速度要比逻辑备份更快。</p>
<p>我们利用 Percona 公司发布的一个 XtraBackup 热备份工具来完成裸文件备份，据官方介绍它是世界上唯一一款开源的能够对 InnoDB 和 XtraDB 数据库进行热备的工具。</p>
<p>它的优点就是备份与恢复过程的速度很快，安全可靠，而且在备份过程中不会缩表，不影响现有业务。但它目前还是不能对表结构文件和其它非事务类型的表进行备份。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL用户管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/31/MySQL/MySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"
    >MySQL 用户管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/05/31/MySQL/MySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2020-05-31T03:48:16.000Z" itemprop="datePublished">2020-05-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>MySQL 是一个多用户数据库，具有功能强大的访问控制系统，可以为不同用户指定不同权限。</p>
<h1 id="user权限表"><a href="#user权限表" class="headerlink" title="user权限表"></a>user权限表</h1><p>MySQL 在安装时会自动创建一个名为<code>mysql</code>的数据库，<code>mysql</code>数据库中存储的都是用户权限表。用户登录以后，MySQL 会根据这些权限表的内容为每个用户赋予相应的权限。</p>
<p><code>user</code>表是 MySQL 中最重要的一个权限表，用来记录允许连接到服务器的账号信息。需要注意的是，在<code>user</code>表里启用的所有权限都是全局级的，适用于所有数据库。</p>
<p>user 表中的字段大致可以分为 4 类，分别是用户列、权限列、安全列和资源控制列。</p>
<h2 id="用户列"><a href="#用户列" class="headerlink" title="用户列"></a>用户列</h2><p>用户列存储了用户连接 MySQL 数据库时需要输入的信息。需要注意的是 MySQL 5.7 版本不再使用<code>Password</code>来作为密码的字段，而改成了<code>authentication_string</code>。</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Host</td>
<td align="center">char(60)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">主机名</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">char(32)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">authentication_string</td>
<td align="center">text</td>
<td align="center">YES</td>
<td align="center">无</td>
<td align="center">密码</td>
</tr>
</tbody></table>
<p>用户登录时，如果这 3 个字段同时匹配，MySQL 数据库系统才会允许其登录。创建新用户时，也是设置这 3 个字段的值。修改用户密码时，实际就是修改<code>user</code>表的<code>authentication_string</code>字段的值。因此，这 3 个字段决定了用户能否登录。</p>
<h2 id="权限列"><a href="#权限列" class="headerlink" title="权限列"></a>权限列</h2><p>权限列的字段决定了用户的权限，用来描述在全局范围内允许对数据和数据库进行的操作。</p>
<p>权限大致分为两大类，分别是高级管理权限和普通权限：</p>
<ul>
<li>高级管理权限主要对数据库进行管理，例如关闭服务的权限、超级权限和加载用户等；</li>
<li>普通权限主要操作数据库，例如查询权限、修改权限等。</li>
</ul>
<p><code>user</code>表的权限列包括<code>Select_priv、Insert_ priv</code>等以<code>priv</code>结尾的字段，这些字段值的数据类型为<code>ENUM</code>，可取的值只有<code>Y</code>和<code>N</code>：<code>Y</code>表示该用户有对应的权限，<code>N</code>表示该用户没有对应的权限。从安全角度考虑，这些字段的默认值都为<code>N</code>。</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Select_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以通过SELECT 命令查询数据</td>
</tr>
<tr>
<td align="center">Insert_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以通过 INSERT 命令插入数据</td>
</tr>
<tr>
<td align="center">Update_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以通过UPDATE 命令修改现有数据</td>
</tr>
<tr>
<td align="center">Delete_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以通过DELETE 命令删除现有数据</td>
</tr>
<tr>
<td align="center">Create_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以创建新的数据库和表</td>
</tr>
<tr>
<td align="center">Drop_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以删除现有数据库和表</td>
</tr>
<tr>
<td align="center">Reload_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以执行刷新和重新加载MySQL所用的各种内部缓存的特定命令，包括日志、权限、主机、查询和表</td>
</tr>
<tr>
<td align="center">Shutdown_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以关闭MySQL服务器。将此权限提供给root账户之外的任何用户时，都应当非常谨慎</td>
</tr>
<tr>
<td align="center">Process_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以通过SHOW PROCESSLIST命令查看其他用户的进程</td>
</tr>
<tr>
<td align="center">File_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令</td>
</tr>
<tr>
<td align="center">Grant_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以将自己的权限再授予其他用户</td>
</tr>
<tr>
<td align="center">References_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以创建外键约束</td>
</tr>
<tr>
<td align="center">Index_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以对索引进行增删查</td>
</tr>
<tr>
<td align="center">Alter_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以重命名和修改表结构</td>
</tr>
<tr>
<td align="center">Show_db_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以查看服务器上所有数据库的名字，包括用户拥有足够访问权限的数据库</td>
</tr>
<tr>
<td align="center">Super_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以执行某些强大的管理功能，例如通过KILL命令删除用户进程；使用SET GLOBAL命令修改全局MySQL变量，执行关于复制和日志的各种命令。（超级 权限）</td>
</tr>
<tr>
<td align="center">Create_tmp_table_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以创建临时表</td>
</tr>
<tr>
<td align="center">Lock_tables_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以使用LOCK TABLES命令阻止对表的访问&#x2F;修改</td>
</tr>
<tr>
<td align="center">Execute_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以执行存储过程</td>
</tr>
<tr>
<td align="center">Repl_slave_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以读取用于维护复制数据库环境的二进制日志文件</td>
</tr>
<tr>
<td align="center">Repl_client_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以确定复制从服务器和主服务器的位置</td>
</tr>
<tr>
<td align="center">Create_view_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以创建视图</td>
</tr>
<tr>
<td align="center">Show_view_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以查看视图</td>
</tr>
<tr>
<td align="center">Create_routine_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以更改或放弃存储过程和函数</td>
</tr>
<tr>
<td align="center">Alter_routine_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以修改或删除存储函数及函数</td>
</tr>
<tr>
<td align="center">Create_user_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以执行CREATE USER命令，这个命令用于创建新的MySQL账户</td>
</tr>
<tr>
<td align="center">Event_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以创建、修改和删除事件</td>
</tr>
<tr>
<td align="center">Trigger_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以创建和删除触发器</td>
</tr>
<tr>
<td align="center">Create_tablespace_priv</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">是否可以创建表空间</td>
</tr>
</tbody></table>
<p>如果要修改权限，可以使用<code>GRANT</code>语句为用户赋予一些权限，也可以通过<code>UPDATE</code>语句更新<code>user</code>表的方式来设置权限。</p>
<h2 id="安全列"><a href="#安全列" class="headerlink" title="安全列"></a>安全列</h2><p>安全列主要用来判断用户是否能够登录成功。</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ssl_type</td>
<td align="center">enum(‘’,’ANY’,<br>‘X509’, ‘SPECIFIED’)</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">支持ssl标准加密安全字段</td>
</tr>
<tr>
<td align="center">ssl_cipher</td>
<td align="center">blob</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">支持ssl标准加密安全字段</td>
</tr>
<tr>
<td align="center">x509_issuer</td>
<td align="center">blob</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">支持x509标准字段</td>
</tr>
<tr>
<td align="center">x509_subject</td>
<td align="center">blob</td>
<td align="center">NO</td>
<td align="center"></td>
<td align="center">支持x509标准字段</td>
</tr>
<tr>
<td align="center">plugin</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">mysql_native_<br>password</td>
<td align="center">引入plugins以进行用户连接时的密码验证，plugin创建外部&#x2F;代理用户</td>
</tr>
<tr>
<td align="center">password_expired</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">密码是否过期 (N 未过期，y 已过期)</td>
</tr>
<tr>
<td align="center">password_last_changed</td>
<td align="center">timestamp</td>
<td align="center">YES</td>
<td align="center"></td>
<td align="center">记录密码最近修改的时间</td>
</tr>
<tr>
<td align="center">password_lifetime</td>
<td align="center">smallint(5)</td>
<td align="center">unsigned</td>
<td align="center">YES</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">account_locked</td>
<td align="center">enum(‘N’,’Y’)</td>
<td align="center">NO</td>
<td align="center">N</td>
<td align="center">用户是否被锁定（Y 锁定，N 未锁定）</td>
</tr>
</tbody></table>
<p>注意：即使<code>password_expired</code>为<code>Y</code>，用户也可以使用密码登录 MySQL，但是不允许做任何操作。</p>
<p>通常标准的发行版不支持<code>ssl</code>，可以使用<code>SHOW VARIABLES LIKE &quot;have_openssl&quot;</code>语句来查看是否具有<code>ssl</code>功能。如果<code>have_openssl</code>的值为<code>DISABLED</code>，那么则不支持<code>ssl</code>加密功能。</p>
<h2 id="资源控制列"><a href="#资源控制列" class="headerlink" title="资源控制列"></a>资源控制列</h2><p>资源控制列的字段用来限制用户使用的资源，user 表中的资源控制列：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">max_questions</td>
<td align="center">int(11)</td>
<td align="center">unsigned</td>
<td align="center">NO</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">max_updates</td>
<td align="center">int(11)</td>
<td align="center">unsigned</td>
<td align="center">NO</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">max_connections</td>
<td align="center">int(11)</td>
<td align="center">unsigned</td>
<td align="center">NO</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">max_user_connections</td>
<td align="center">int(11)</td>
<td align="center">unsigned</td>
<td align="center">NO</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>以上字段的默认值为 0，表示没有限制。一个小时内用户查询或者连接数量超过资源控制限制，用户将被锁定，直到下一个小时才可以在此执行对应的操作。可以使用<code>GRANT</code>语句更新这些字段的值。</p>
<h1 id="其它权限表"><a href="#其它权限表" class="headerlink" title="其它权限表"></a>其它权限表</h1><p>在 MySQL 数据库中，权限表除了<code>user</code>表外，还有<code>db</code>表、<code>tables_priv</code>表、<code>columns_priv</code>表和<code>procs_priv</code>表。</p>
<h2 id="db表"><a href="#db表" class="headerlink" title="db表"></a>db表</h2><p><code>db</code>表中存储了用户对某个数据库的操作权限。表中的字段大致可以分为两类，分别是用户列和权限列。</p>
<h3 id="用户列-1"><a href="#用户列-1" class="headerlink" title="用户列"></a>用户列</h3><p><code>db</code>表用户列有 3 个字段，分别是<code>Host、User、Db</code>，标识从某个主机连接某个用户对某个数据库的操作权限，这 3 个字段的组合构成了<code>db</code>表的主键。</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Host</td>
<td align="center">char(60)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">主机名</td>
</tr>
<tr>
<td align="center">Db</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">数据库名</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">char(32)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">用户名</td>
</tr>
</tbody></table>
<h3 id="权限列-1"><a href="#权限列-1" class="headerlink" title="权限列"></a>权限列</h3><p><code>db</code>表中的权限列和<code>user</code>表中的权限列大致相同，只是<code>user</code>表中的权限是针对所有数据库的，而<code>db</code>表中的权限只针对指定的数据库。如果希望用户只对某个数据库有操作权限，可以先将<code>user</code>表中对应的权限设置为<code>N</code>，然后在<code>db</code>表中设置对应数据库的操作权限。</p>
<h2 id="tables-priv表和columns-priv表"><a href="#tables-priv表和columns-priv表" class="headerlink" title="tables_priv表和columns_priv表"></a>tables_priv表和columns_priv表</h2><p><code>tables_priv</code>表用来对单个表进行权限设置，<code>columns_priv</code>表用来对单个数据列进行权限设置。<code>tables_priv</code>表结构如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Host</td>
<td align="center">char(60)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">主机</td>
</tr>
<tr>
<td align="center">Db</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">数据库名</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">char(32)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">Table_name</td>
<td align="center">har(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表名</td>
</tr>
<tr>
<td align="center">Grantor</td>
<td align="center">char(93)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">修改该记录的用户</td>
</tr>
<tr>
<td align="center">Timestamp</td>
<td align="center">timestamp</td>
<td align="center">NO</td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">修改该记录的时间</td>
</tr>
<tr>
<td align="center">Table_priv</td>
<td align="center">set(‘Select’,’Insert’,<br>‘Update’,’Delete’,<br>‘Create’,’Drop’,<br>‘Grant’,’References’,<br>‘Index’,’Alter’,’Create View’,<br>‘Show view’,’Trigger’)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表示对表的操 作权限，包括 Select、Insert、Update、Delete、Create、Drop、Grant、References、Index 和 Alter 等</td>
</tr>
<tr>
<td align="center">Column_priv</td>
<td align="center">set(‘Select’,’Insert’,<br>‘Update’,’References’)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表示对表中的列的操作权限，包括 Select、Insert、Update 和 References</td>
</tr>
</tbody></table>
<p><code>columns_priv</code>表结构如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Host</td>
<td align="center">char(60)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">主机</td>
</tr>
<tr>
<td align="center">Db</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">数据库名</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">char(32)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">Table_name</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表名</td>
</tr>
<tr>
<td align="center">Column_name</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">数据列名称，用来指定对哪些数据列具有操作权限</td>
</tr>
<tr>
<td align="center">Timestamp</td>
<td align="center">timestamp</td>
<td align="center">NO</td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">修改该记录的时间</td>
</tr>
<tr>
<td align="center">Column_priv</td>
<td align="center">set(‘Select’,<br>‘Insert’,<br>‘Update’,<br>‘References’)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表示对表中的列的操作权限，包括 Select、Insert、Update 和 References</td>
</tr>
</tbody></table>
<h2 id="procs-priv表"><a href="#procs-priv表" class="headerlink" title="procs_priv表"></a>procs_priv表</h2><p><code>procs_priv</code>表可以对存储过程和存储函数进行权限设置，<code>procs_priv</code>的表结构如表所示：</p>
<table>
<thead>
<tr>
<th align="center">字段名</th>
<th align="center">字段类型</th>
<th align="center">是否为空</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Host</td>
<td align="center">char(60)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">主机名</td>
</tr>
<tr>
<td align="center">Db</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">数据库名</td>
</tr>
<tr>
<td align="center">User</td>
<td align="center">char(32)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">Routine_name</td>
<td align="center">char(64)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表示存储过程或函数的名称</td>
</tr>
<tr>
<td align="center">Routine_type</td>
<td align="center">enum(<br>‘FUNCTION’,<br>‘PROCEDURE’)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表示存储过程或函数的类型，Routine_type 字段有两个值，分别是 FUNCTION 和 PROCEDURE。FUNCTION 表示这是一个函数；PROCEDURE 表示这是一个存储过程。</td>
</tr>
<tr>
<td align="center">Grantor</td>
<td align="center">char(93)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">插入或修改该记录的用户</td>
</tr>
<tr>
<td align="center">Proc_priv</td>
<td align="center">set(<br>‘Execute’,<br>‘Alter Routine’,<br>‘Grant’)</td>
<td align="center">NO</td>
<td align="center">无</td>
<td align="center">表示拥有的权限，包括 Execute、Alter Routine、Grant 3种</td>
</tr>
<tr>
<td align="center">Timestamp</td>
<td align="center">timestamp</td>
<td align="center">NO</td>
<td align="center">CURRENT_TIMESTAMP</td>
<td align="center">表示记录更新时间</td>
</tr>
</tbody></table>
<h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><p>MySQL 在安装时，会默认创建一个名为<code>root</code>的用户，该用户拥有超级权限，可以控制整个 MySQL 服务器。</p>
<p>在对 MySQL 的日常管理和操作中，为了避免有人恶意使用<code>root</code>用户控制数据库，我们通常创建一些具有适当权限的用户，尽可能地不用或少用<code>root</code>用户登录系统，以此来确保数据的安全访问。</p>
<p>MySQL 提供了以下 3 种方法创建用户：</p>
<ul>
<li>使用<code>CREATE USER</code>语句创建用户</li>
<li>在<code>mysql.user</code>表中添加用户</li>
<li>使用<code>GRANT</code>语句创建用户</li>
</ul>
<h2 id="使用CREATE-USER语句创建用户"><a href="#使用CREATE-USER语句创建用户" class="headerlink" title="使用CREATE USER语句创建用户"></a>使用CREATE USER语句创建用户</h2><p>可以使用<code>CREATE USER</code>语句来创建 MySQL 用户，并设置相应的密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &lt;用户&gt; [ IDENTIFIED BY [ PASSWORD ] &#x27;password&#x27; ] [ ,用户 [ IDENTIFIED BY [ PASSWORD ] &#x27;password&#x27; ]]</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<ol>
<li>用户<br>指定创建用户账号，格式为<code>user_name&#39;@&#39;host_name</code>。这里的<code>user_name</code>是用户名，<code>host_name</code>为主机名，即用户连接 MySQL 时所用主机的名字。如果在创建的过程中，只给出了用户名，而没指定主机名，那么主机名默认为“%”，表示一组主机，即对所有主机开放权限。</li>
<li><code>IDENTIFIED BY</code>子句<br>用于指定用户密码。新用户可以没有初始密码，若该用户不设密码，可省略此子句。</li>
<li><code>PASSWORD &#39;password&#39;</code><br><code>PASSWORD</code>表示使用哈希值设置密码，该参数可选。如果密码是一个普通的字符串，则不需要使用<code>PASSWORD</code>关键字。<code>&#39;password&#39;</code>表示用户登录时使用的密码，需要用单引号括起来。</li>
</ol>
<p>使用<code>CREATE USER</code>语句时应注意以下几点：</p>
<ul>
<li><code>CREATE USER</code>语句可以不指定初始密码。但是从安全的角度来说，不推荐这种做法。</li>
<li>使用<code>CREATE USER</code>语句必须拥有<code>mysql</code>数据库的<code>INSERT</code>权限或全局<code>CREATE USER</code>权限。</li>
<li>使用<code>CREATE USER</code>语句创建一个用户后，MySQL 会在 mysql 数据库的<code>user</code>表中添加一条新记录。</li>
<li><code>CREATE USER</code>语句可以同时创建多个用户，多个用户用逗号隔开。</li>
</ul>
<p>新创建的用户拥有的权限很少，它们只能执行不需要权限的操作。如登录 MySQL、使用 SHOW 语句查询所有存储引擎和字符集的列表等。如果两个用户的用户名相同，但主机名不同，MySQL 会将它们视为两个用户，并允许为这两个用户分配不同的权限集合。</p>
<p>使用<code>CREATE USER</code>创建一个用户，用户名是<code>test1</code>，密码是<code>test1</code>，主机名是<code>localhost</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;test1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在实际应用中，我们应避免明文指定密码，可以通过<code>PASSWORD</code>关键字使用密码的哈希值设置密码。</p>
<p>在 MySQL 中，可以使用<code>password()</code>函数获取密码的哈希值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> password(<span class="string">&#x27;test1&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> password(<span class="string">&#x27;test1&#x27;</span>)                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="operator">*</span><span class="number">06</span>C0BF5B64ECE2F648B5F048A71903906BA08E5C <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p><code>*06C0BF5B64ECE2F648B5F048A71903906BA08E5C</code>就是<code>test1</code>的哈希值。下面创建用户<code>test1</code>，SQL 语句和执行过程如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>IDENTIFIED <span class="keyword">BY</span> PASSWORD <span class="string">&#x27;*06C0BF5B64ECE2F648B5F048A71903906BA08E5C&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>执行成功后就可以使用密码<code>test1</code>登录了。</p>
<h2 id="使用-INSERT-语句新建用户"><a href="#使用-INSERT-语句新建用户" class="headerlink" title="使用 INSERT 语句新建用户"></a>使用 INSERT 语句新建用户</h2><p>可以使用<code>INSERT</code>语句将用户的信息添加到<code>mysql.user</code>表中，但必须拥有对<code>mysql.user</code>表的<code>INSERT</code>权限。通常<code>INSERT</code>语句只添加<code>Host、User</code>和<code>authentication_string</code>这 3 个字段的值。</p>
<p>MySQL 5.7 的<code>user</code>表中的密码字段从<code>Password</code>变成了<code>authentication_string</code>，如果是 MySQL 5.7 之前的版本，将<code>authentication_string</code>字段替换成<code>Password</code>即可。</p>
<p>使用<code>INSERT</code>语句创建用户的代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.user(Host, <span class="keyword">User</span>,  authentication_string, ssl_cipher, x509_issuer, x509_subject) <span class="keyword">VALUES</span> (<span class="string">&#x27;hostname&#x27;</span>, <span class="string">&#x27;username&#x27;</span>, PASSWORD(<span class="string">&#x27;password&#x27;</span>), <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>由于<code>mysql</code>数据库的<code>user</code>表中，<code>ssl_cipher、x509_issuer</code>和<code>x509_subject</code>这 3 个字段没有默认值，所以向<code>user</code>表插入新记录时，一定要设置这 3 个字段的值，否则<code>INSERT</code>语句将不能执行。</p>
<p>下面使用<code>INSERT</code>语句创建名为<code>test2</code>的用户，主机名是<code>localhost</code>，密码也是<code>test2</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.user(Host, <span class="keyword">User</span>, authentication_string, ssl_cipher, x509_issuer, x509_subject)</span><br><span class="line">       <span class="keyword">VALUES</span> (<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;test2&#x27;</span>, PASSWORD(<span class="string">&#x27;test2&#x27;</span>), <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected, <span class="number">1</span> warning (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果显示，新建用户成功。但是这时如果通过该账户登录 MySQL 服务器，不会登录成功，因为<code>test2</code>用户还没有生效。</p>
<p>可以使用<code>FLUSH</code>命令让用户生效：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>使用以上命令可以让 MySQL 刷新系统权限相关表。执行<code>FLUSH</code>命令需要<code>RELOAD</code>权限。</p>
<p>注意：<code>user</code>表中的<code>User</code>和<code>Host</code>字段区分大小写，创建用户时要指定正确的用户名称或主机名。</p>
<h2 id="使用GRANT语句新建用户"><a href="#使用GRANT语句新建用户" class="headerlink" title="使用GRANT语句新建用户"></a>使用GRANT语句新建用户</h2><p>虽然<code>CREATE USER</code>和<code>INSERT INTO</code>语句都可以创建普通用户，但是这两种方式不便授予用户权限。于是 MySQL 提供了<code>GRANT</code>语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> priv_type <span class="keyword">ON</span> database.table <span class="keyword">TO</span> <span class="keyword">user</span> [IDENTIFIED <span class="keyword">BY</span> [PASSWORD] <span class="string">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>priv_type</code>参数表示新用户的权限；</li>
<li><code>database.table</code>参数表示新用户的权限范围，即只能在指定的数据库和表上使用自己的权限；</li>
<li><code>user</code>参数指定新用户的账号，由用户名和主机名构成；</li>
<li><code>IDENTIFIED BY</code>关键字用来设置密码；</li>
<li><code>password</code>参数表示新用户的密码。</li>
</ul>
<p>下面使用<code>GRANT</code>语句创建名为<code>test3</code>的用户，主机名为<code>localhost</code>，密码为<code>test3</code>。该用户对所有数据库的所有表都有<code>SELECT</code>权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span><span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test3&#x27;</span><span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;test3&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中，<code>*.*</code>表示所有数据库下的所有表。结果显示创建用户成功，且<code>test3</code>用户对所有表都有查询（<code>SELECT</code>）权限。</p>
<h1 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h1><p>在 MySQL 中，我们可以使用<code>RENAME USER</code>语句修改一个或多个已经存在的用户账号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME USER &lt;旧用户&gt; TO &lt;新用户&gt;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>&lt;旧用户&gt;：系统中已经存在的 MySQL 用户账号。</li>
<li>&lt;新用户&gt;：新的 MySQL 用户账号。</li>
</ul>
<p>使用<code>RENAME USER</code>语句时应注意以下几点：</p>
<ul>
<li><code>RENAME USER</code>语句用于对原有的 MySQL 用户进行重命名。</li>
<li>若系统中旧账户不存在或者新账户已存在，该语句执行时会出现错误。</li>
<li>使用<code>RENAME USER</code>语句，必须拥有<code>mysql</code>数据库的<code>UPDATE</code>权限或全局<code>CREATE USER</code>权限。</li>
</ul>
<p>使用<code>RENAME USER</code>语句将用户名<code>test1</code>修改为<code>testUser1</code>，主机是<code>localhost</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> RENAME <span class="keyword">USER</span> <span class="string">&#x27;test1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">TO</span> <span class="string">&#x27;testUser1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h1><p>在 MySQL 数据库中，可以使用<code>DROP USER</code>语句删除用户，也可以直接在<code>mysql.user</code>表中删除用户以及相关权限。</p>
<h2 id="1-使用DROP-USER语句删除普通用户"><a href="#1-使用DROP-USER语句删除普通用户" class="headerlink" title="1. 使用DROP USER语句删除普通用户"></a>1. 使用DROP USER语句删除普通用户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &lt;用户1&gt; [ , &lt;用户2&gt; ]…</span><br></pre></td></tr></table></figure>
<p>其中，用户用来指定需要删除的用户账号。</p>
<p>使用<code>DROP USER</code>语句应注意以下几点：</p>
<ul>
<li><code>DROP USER</code>语句可用于删除一个或多个用户，并撤销其权限。</li>
<li>使用<code>DROP USER</code>语句必须拥有<code>mysql</code>数据库的<code>DELETE</code>权限或全局<code>CREATE USER</code>权限。</li>
<li>在<code>DROP USER</code>语句的使用中，若没有明确地给出账户的主机名，则该主机名默认为“%”。</li>
</ul>
<p>注意：用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为 MySQL 并不会记录是谁创建了这些对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;test1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-使用DELETE语句删除普通用户"><a href="#2-使用DELETE语句删除普通用户" class="headerlink" title="2. 使用DELETE语句删除普通用户"></a>2. 使用DELETE语句删除普通用户</h2><p>可以使用<code>DELETE</code>语句直接删除<code>mysql.user</code>表中相应的用户信息，但必须拥有<code>mysql.user</code>表的<code>DELETE</code>权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>Host</code>和<code>User</code>这两个字段都是<code>mysql.user</code>表的主键。因此，需要两个字段的值才能确定一条记录。</p>
<p>下面使用<code>DELETE</code>语句删除用户<code>&#39;test2&#39;@&#39;localhost&#39;</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span><span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;test2&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果显示删除成功。可以使用<code>SELETE</code>语句查询<code>mysql.user</code>表，以确定该用户是否已经成功删除。</p>
<h1 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h1><p>在 MySQL 中，可以通过查看<code>mysql.user</code>表中的数据记录来查看相应的用户权限，也可以使用<code>SHOW GRANTS</code>语句查询用户的权限。</p>
<p><code>mysql</code>数据库下的<code>user</code>表中存储着用户的基本权限，可以使用<code>SELECT</code>语句来查看。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure>
<p>要执行该语句，必须拥有对<code>user</code>表的查询权限。</p>
<p>注意：新创建的用户只有登录 MySQL 服务器的权限，没有任何其它权限，不能查询<code>user</code>表。</p>
<p>除了使用<code>SELECT</code>语句之外，还可以使用<code>SHOW GRANTS FOR</code>语句查看权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>下面创建<code>testuser1</code>用户并查询权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;testuser1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;testuser1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> testuser1<span class="variable">@localhost</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;testuser1&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中，<code>USAGE ON *.*</code>表示该用户对任何数据库和任何表都没有权限。</p>
<p>下面查询<code>root</code>用户的权限，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> root<span class="variable">@localhost</span>                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> PROXY <span class="keyword">ON</span> <span class="string">&#x27;&#x27;</span>@<span class="string">&#x27;&#x27;</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="GRANT：用户授权"><a href="#GRANT：用户授权" class="headerlink" title="GRANT：用户授权"></a>GRANT：用户授权</h1><p>授权就是为某个用户赋予某些权限。例如，可以为新建的用户赋予查询所有数据库和表的权限。MySQL 提供了<code>GRANT</code>语句来为用户设置权限。</p>
<p>在 MySQL 中，拥有<code>GRANT</code>权限的用户才可以执行<code>GRANT 语句</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type [(column_list)] ON database.table</span><br><span class="line">TO user [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;]</span><br><span class="line">[, user[IDENTIFIED BY [PASSWORD] &#x27;password&#x27;]] ...</span><br><span class="line">[WITH with_option [with_option]...]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>priv_type</code>参数表示权限类型；</li>
<li><code>columns_list</code>参数表示权限作用于哪些列上，省略该参数时，表示作用于整个表；</li>
<li><code>database.table</code>用于指定权限的级别；</li>
<li><code>user</code>参数表示用户账户，由用户名和主机名构成，格式是<code>&#39;username&#39;@&#39;hostname&#39;</code>；</li>
<li><code>IDENTIFIED BY</code>参数用来为用户设置密码；</li>
<li><code>password</code>参数是用户的新密码。</li>
</ul>
<p><code>WITH</code>关键字后面带有一个或多个<code>with_option</code>参数。这个参数有 5 个选项：</p>
<ul>
<li><code>GRANT OPTION</code>：被授权的用户可以将这些权限赋予给别的用户；</li>
<li><code>MAX_QUERIES_PER_HOUR count</code>：设置每个小时可以允许执行<code>count</code>次查询；</li>
<li><code>MAX_UPDATES_PER_HOUR count</code>：设置每个小时可以允许执行<code>count</code>次更新；</li>
<li><code>MAX_CONNECTIONS_PER_HOUR count</code>：设置每小时可以建立<code>count</code>个连接;</li>
<li><code>MAX_USER_CONNECTIONS count</code>：设置单个用户可以同时具有的<code>count</code>个连接。</li>
</ul>
<p>MySQL 中可以授予的权限有如下几组：</p>
<ul>
<li>列权限，和表中的一个具体列相关。例如，可以使用<code>UPDATE</code>语句更新表<code>students</code>中 name 列的值的权限。</li>
<li>表权限，和一个具体表中的所有数据相关。例如，可以使用<code>SELECT</code>语句查询表<code>students</code>的所有数据的权限。</li>
<li>数据库权限，和一个具体的数据库中的所有表相关。例如，可以在已有的数据库<code>mytest</code>中创建新表的权限。</li>
<li>用户权限，和 MySQL 中所有的数据库相关。例如，可以删除已有的数据库或者创建一个新的数据库的权限。</li>
</ul>
<p>对应地，在<code>GRANT</code>语句中可用于指定权限级别的值有以下几类格式：</p>
<ul>
<li><code>*</code>：表示当前数据库中的所有表。</li>
<li><code>*.*</code>：表示所有数据库中的所有表。</li>
<li><code>db_name.*</code>：表示某个数据库中的所有表，<code>db_name</code>指定数据库名。</li>
<li><code>db_name.tbl_name</code>：表示某个数据库中的某个表或视图，<code>db_name</code>指定数据库名，<code>tbl_name</code>指定表名或视图名。</li>
<li><code>db_name.routine_name</code>：表示某个数据库中的某个存储过程或函数，<code>routine_name</code>指定存储过程名或函数名。</li>
<li><code>TO</code>子句：如果权限被授予给一个不存在的用户，MySQL 会自动执行一条<code>CREATE USER</code>语句来创建这个用户，但同时必须为该用户设置密码。</li>
</ul>
<h2 id="权限类型说明"><a href="#权限类型说明" class="headerlink" title="权限类型说明"></a>权限类型说明</h2><ol>
<li>授予数据库权限时，&lt;权限类型&gt;可以指定为以下值：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">权限名称</th>
<th align="center">对应user表中的字段</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SELECT</td>
<td align="center">Select_priv</td>
<td align="center">表示授予用户可以使用 SELECT 语句访问特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td align="center">INSERT</td>
<td align="center">Insert_priv</td>
<td align="center">表示授予用户可以使用 INSERT 语句向特定数据库中所有表添加数据行的权限。</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">Delete_priv</td>
<td align="center">表示授予用户可以使用 DELETE 语句删除特定数据库中所有表的数据行的权限。</td>
</tr>
<tr>
<td align="center">UPDATE</td>
<td align="center">Update_priv</td>
<td align="center">表示授予用户可以使用 UPDATE 语句更新特定数据库中所有数据表的值的权限。</td>
</tr>
<tr>
<td align="center">REFERENCES</td>
<td align="center">References_priv</td>
<td align="center">表示授予用户可以创建指向特定的数据库中的表外键的权限。</td>
</tr>
<tr>
<td align="center">CREATE</td>
<td align="center">Create_priv</td>
<td align="center">表示授权用户可以使用 CREATE TABLE 语句在特定数据库中创建新表的权限。</td>
</tr>
<tr>
<td align="center">ALTER</td>
<td align="center">Alter_priv</td>
<td align="center">表示授予用户可以使用 ALTER TABLE 语句修改特定数据库中所有数据表的权限。</td>
</tr>
<tr>
<td align="center">SHOW VIEW</td>
<td align="center">Show_view_priv</td>
<td align="center">表示授予用户可以查看特定数据库中已有视图的视图定义的权限。</td>
</tr>
<tr>
<td align="center">CREATE ROUTINE</td>
<td align="center">Create_routine_priv</td>
<td align="center">表示授予用户可以为特定的数据库创建存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="center">ALTER ROUTINE</td>
<td align="center">Alter_routine_priv</td>
<td align="center">表示授予用户可以更新和删除数据库中已有的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="center">INDEX</td>
<td align="center">Index_priv</td>
<td align="center">表示授予用户可以在特定数据库中的所有数据表上定义和删除索引的权限。</td>
</tr>
<tr>
<td align="center">DROP</td>
<td align="center">Drop_priv</td>
<td align="center">表示授予用户可以删除特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td align="center">CREATE TEMPORARY TABLES</td>
<td align="center">Create_tmp_table_priv</td>
<td align="center">表示授予用户可以在特定数据库中创建临时表的权限。</td>
</tr>
<tr>
<td align="center">CREATE VIEW</td>
<td align="center">Create_view_priv</td>
<td align="center">表示授予用户可以在特定数据库中创建新的视图的权限。</td>
</tr>
<tr>
<td align="center">EXECUTE ROUTINE</td>
<td align="center">Execute_priv</td>
<td align="center">表示授予用户可以调用特定数据库的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="center">LOCK TABLES</td>
<td align="center">Lock_tables_priv</td>
<td align="center">表示授予用户可以锁定特定数据库的已有数据表的权限。</td>
</tr>
<tr>
<td align="center">ALL 或<br>ALL PRIVILEGES<br>或 SUPER</td>
<td align="center">Super_priv</td>
<td align="center">表示以上所有权限&#x2F;超级权限</td>
</tr>
</tbody></table>
<ol start="2">
<li>授予表权限时，&lt;权限类型&gt;可以指定为以下值：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">权限名称</th>
<th align="center">对应user表中的字段</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SELECT</td>
<td align="center">Select_priv</td>
<td align="center">授予用户可以使用 SELECT 语句进行访问特定表的权限</td>
</tr>
<tr>
<td align="center">INSERT</td>
<td align="center">Insert_priv</td>
<td align="center">授予用户可以使用 INSERT 语句向一个特定表中添加数据行的权限</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">Delete_priv</td>
<td align="center">授予用户可以使用 DELETE 语句从一个特定表中删除数据行的权限</td>
</tr>
<tr>
<td align="center">DROP</td>
<td align="center">Drop_priv</td>
<td align="center">授予用户可以删除数据表的权限</td>
</tr>
<tr>
<td align="center">UPDATE</td>
<td align="center">Update_priv</td>
<td align="center">授予用户可以使用 UPDATE 语句更新特定数据表的权限</td>
</tr>
<tr>
<td align="center">ALTER</td>
<td align="center">Alter_priv</td>
<td align="center">授予用户可以使用 ALTER TABLE 语句修改数据表的权限</td>
</tr>
<tr>
<td align="center">REFERENCES</td>
<td align="center">References_priv</td>
<td align="center">授予用户可以创建一个外键来参照特定数据表的权限</td>
</tr>
<tr>
<td align="center">CREATE</td>
<td align="center">Create_priv</td>
<td align="center">授予用户可以使用特定的名字创建一个数据表的权限</td>
</tr>
<tr>
<td align="center">INDEX</td>
<td align="center">Index_priv</td>
<td align="center">授予用户可以在表上定义索引的权限</td>
</tr>
<tr>
<td align="center">ALL 或<br>ALL PRIVILEGES<br>或 SUPER</td>
<td align="center">Super_priv</td>
<td align="center">所有的权限名</td>
</tr>
</tbody></table>
<ol start="3">
<li>授予列权限时，&lt;权限类型&gt;的值只能指定为<code>SELECT、INSERT</code>和<code>UPDATE</code>，同时权限的后面需要加上列名列表<code>column-list</code>。</li>
<li>最有效率的权限是用户权限。<br>授予用户权限时，&lt;权限类型&gt;除了可以指定为授予数据库权限时的所有值之外，还可以是下面这些值：</li>
</ol>
<ul>
<li><code>CREATE USER</code>：表示授予用户可以创建和删除新用户的权限。</li>
<li><code>SHOW DATABASES</code>：表示授予用户可以使用<code>SHOW DATABASES</code>语句查看所有已有的数据库的定义的权限。</li>
</ul>
<p>使用<code>GRANT</code>语句创建一个新的用户<code>testUser</code>，密码为<code>testPwd</code>。用户<code>testUser</code>对所有的数据有查询、插入权限，并授予<code>GRANT</code>权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;testPwd&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure>
<p>使用<code>SHOW GRANTS</code>语句查询用户<code>testUser</code>的权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> testUser<span class="variable">@localhost</span>                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果显示，<code>testUser</code>对所有数据库的所有表有查询、插入权限，并可以将这些权限赋予给别的用户。</p>
<h1 id="REVOKE：删除用户权限"><a href="#REVOKE：删除用户权限" class="headerlink" title="REVOKE：删除用户权限"></a>REVOKE：删除用户权限</h1><p>在 MySQL 中，可以使用<code>REVOKE</code>语句删除某个用户的某些权限（此用户不会被删除），在一定程度上可以保证系统的安全性。</p>
<p>使用<code>REVOKE</code>语句删除权限的语法格式有两种形式：</p>
<h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>删除用户某些特定的权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> priv_type [(column_list)]...</span><br><span class="line"><span class="keyword">ON</span> database.table</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> [, <span class="keyword">user</span>]...</span><br></pre></td></tr></table></figure>
<p><code>REVOKE</code>语句中的参数与<code>GRANT</code>语句的参数意思相同。其中：</p>
<ul>
<li><code>priv_type</code>参数表示权限的类型；</li>
<li><code>column_list</code>参数表示权限作用于哪些列上，没有该参数时作用于整个表上；</li>
<li><code>user</code>参数由用户名和主机名构成，格式为<code>username&#39;@&#39;hostname&#39;</code>。</li>
</ul>
<h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>删除特定用户的所有权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES, <span class="keyword">GRANT</span> OPTION <span class="keyword">FROM</span> <span class="keyword">user</span> [, <span class="keyword">user</span>] ...</span><br></pre></td></tr></table></figure>
<p>删除用户权限需要注意以下几点：</p>
<ul>
<li><code>REVOKE</code>语法和<code>GRANT</code>语句的语法格式相似，但具有相反的效果。</li>
<li>要使用<code>REVOKE</code>语句，必须拥有 MySQL 数据库的全局<code>CREATE USER</code>权限或<code>UPDATE</code>权限。</li>
</ul>
<p>使用<code>REVOKE</code>语句取消用户<code>testUser</code>的插入权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> testUser<span class="variable">@localhost</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;testUser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="登录和退出服务器"><a href="#登录和退出服务器" class="headerlink" title="登录和退出服务器"></a>登录和退出服务器</h1><p>启动 MySQL 服务后，可以使用以下命令来登录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h hostname<span class="operator">|</span>hostlP <span class="operator">-</span>p port <span class="operator">-</span>u username <span class="operator">-</span>p DatabaseName <span class="operator">-</span>e &quot;SQL语句&quot;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>-h</code>：指定连接 MySQL 服务器的地址。可以用两种方式表示，<code>hostname</code>为主机名，<code>hostIP</code>为主机 IP 地址。</li>
<li><code>-p</code>：指定连接 MySQL 服务器的端口号，<code>port</code>为连接的端口号。MySQL 的默认端口号是 3306，因此如果不指定该参数，默认使用 3306 连接 MySQL 服务器。</li>
<li><code>-u</code>：指定连接 MySQL 服务器的用户名，<code>username</code>为用户名。</li>
<li><code>-p</code>：提示输入密码，即提示<code>Enter password</code>。</li>
<li><code>DatabaseName</code>：指定连接到 MySQL 服务器后，登录到哪一个数据库中。如果没有指定，默认为<code>mysql</code>数据库。</li>
<li><code>-e</code>：指定需要执行的 SQL 语句，登录 MySQL 服务器后执行这个 SQL 语句，然后退出 MySQL 服务器。</li>
</ul>
<p>下面使用<code>root</code>用户登录到<code>test</code>数据库中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\11645&gt;mysql -h localhost -u root -p test</span><br><span class="line">Enter password: ****</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.29-log MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br></pre></td></tr></table></figure>
<p>上述命令中，通过值<code>localhost</code>指定 MySQL 服务器的地址，参数<code>-u</code>指定了登录 MySQL 服务器的用户账户，参数<code>-p</code>表示会出现输入密码提示信息，最后值<code>test</code>指定了登录成功后要使用的数据库。</p>
<p>由结果可以看到，输入命令后，会出现“Enter password”提示信息，在这条信息之后输入密码，然后按 Enter 键。密码正确后，就成功登录到 MySQL 服务器了。</p>
<p>下面使用<code>root</code>用户登录到自己计算机的<code>mysql</code>数据库，同时查询<code>student</code>表的表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\11645&gt;mysql -h localhost -u root -p test -e&quot;DESC student&quot;</span><br><span class="line">Enter password: ****</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| age   | int(4)      | YES  |     | NULL    |       |</span><br><span class="line">| stuno | int(11)     | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure>
<p>结果显示，执行命令并输入正确密码后，窗口中就会显示出<code>student</code>表的基本结构。</p>
<p>用户也可以直接在<code>mysql</code>命令的<code>-p</code>后加上登录密码，登录密码与<code>-p</code>之间没有空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\11645&gt;mysql -h localhost -u root -proot</span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 4</span><br><span class="line">Server version: 5.7.29-log MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br></pre></td></tr></table></figure>
<p>上述命令执行后，后面不会提示输入密码。因为<code>-p</code>后面有密码，MySQL 会直接使用这个密码。</p>
<p>退出 MySQL 服务器的方式很简单，只要在命令行输入<code>EXIT</code>或<code>QUIT</code>即可。“\q”是<code>QUIT</code>的缩写，也可以用来退出 MySQL 服务器。退出后就会显示 Bye。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; QUIT;</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>
<h1 id="root修改普通用户密码"><a href="#root修改普通用户密码" class="headerlink" title="root修改普通用户密码"></a>root修改普通用户密码</h1><p>在 MySQL 中，<code>root</code>用户拥有很高的权限，不仅可以修改自己的密码，还可以修改其他用户的密码。</p>
<h2 id="使用SET语句修改普通用户的密码"><a href="#使用SET语句修改普通用户的密码" class="headerlink" title="使用SET语句修改普通用户的密码"></a>使用SET语句修改普通用户的密码</h2><p>在 MySQL 中，只有<code>root</code>用户可以通过更新 MySQL 数据库来更改密码。使用<code>root</code>用户登录到 MySQL 服务器后，可以使用<code>SET</code>语句来修改普通用户密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> <span class="operator">=</span> PASSWORD (<span class="string">&#x27;newpwd&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>其中，<code>username</code>参数是普通用户的用户名，<code>hostname</code>参数是普通用户的主机名，<code>newpwd</code>是要更改的新密码。</p>
<blockquote>
<p>注意：新密码必须使用<code>PASSWORD()</code>函数来加密，如果不使用<code>PASSWORD()</code>加密，也会执行成功，但是用户会无法登录。</p>
</blockquote>
<p>如果是普通用户修改密码，可省略<code>FOR</code>子句来更改自己的密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;newpwd&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>首先创建一个没有密码的<code>testuser</code>用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;testuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.14</span> sec)</span><br></pre></td></tr></table></figure>
<p><code>root</code>用户登录 MySQL 服务器后，再使用<code>SET</code>语句将<code>testuser</code>用户的密码修改为<code>newpwd</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;testuser&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> PASSWORD(&quot;newpwd&quot;);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>下面验证<code>testuser</code>用户密码是否修改成功。退出 MySQL 服务器，使用<code>testuser</code>用户登录，输入密码<code>newpwd</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\leovo&gt;mysql -utestuser -p</span><br><span class="line">Enter password: ******</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 15</span><br><span class="line">Server version: 5.7.29-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br></pre></td></tr></table></figure>
<p>由运行结果可以看出，<code>testuser</code>用户登录成功，修改密码成功。</p>
<p>使用<code>testuser</code>用户登录 MySQL 服务器，再使用<code>SET</code>语句将密码更改为<code>newpwd1</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD = PASSWORD(&#x27;newpwd1&#x27;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>由运行结果可以看出，修改密码成功。</p>
<h2 id="使用UPDATE语句修改普通用户的密码"><a href="#使用UPDATE语句修改普通用户的密码" class="headerlink" title="使用UPDATE语句修改普通用户的密码"></a>使用UPDATE语句修改普通用户的密码</h2><p>使用<code>root</code>用户登录 MySQL 服务器后，可以使用<code>UPDATE</code>语句修改 MySQL 数据库的<code>user</code>表的<code>authentication_string</code>字段，从而修改普通用户的密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> MySQL.user <span class="keyword">SET</span> authentication_string <span class="operator">=</span> PASSWORD(&quot;newpwd&quot;) <span class="keyword">WHERE</span> <span class="keyword">User</span> <span class="operator">=</span> &quot;username&quot; <span class="keyword">AND</span> Host <span class="operator">=</span> &quot;hostname&quot;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>username</code>参数是普通用户的用户名，<code>hostname</code>参数是普通用户的主机名，<code>newpwd</code>是要更改的新密码。</p>
<blockquote>
<p>注意，执行<code>UPDATE</code>语句后，需要执行<code>FLUSH PRIVILEGES</code>语句重新加载用户权限。</p>
</blockquote>
<p>使用<code>root</code>用户登录 MySQL 服务器，再使用<code>UPDATE</code>语句将<code>testuser</code>用户的密码修改为<code>newpwd2</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE MySQL.user SET authentication_string = PASSWORD (&quot;newpwd2&quot;)</span><br><span class="line">    -&gt; WHERE User = &quot;testuser&quot; AND Host = &quot;localhost&quot;;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.07 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>
<p>由运行结果可以看出，密码修改成功。<code>testuser</code>的密码被修改成了<code>newpwd2</code>。使用<code>FLUSH PRIVILEGES</code>重新加载权限后，就可以使用新的密码登录<code>testuser</code>用户了。</p>
<h2 id="使用-GRANT-语句修改普通用户密码"><a href="#使用-GRANT-语句修改普通用户密码" class="headerlink" title="使用 GRANT 语句修改普通用户密码"></a>使用 GRANT 语句修改普通用户密码</h2><p>除了前面介绍的方法，还可以在全局级别使用<code>GRANT USAGE</code>语句指定某个账户的密码而不影响账户当前的权限。需要注意的是，使用<code>GRANT</code>语句修改密码，必须拥有<code>GRANT</code>权限。一般情况下最好使用该方法来指定或修改密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;newpwd&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>username</code>参数是普通用户的用户名，<code>hostname</code>参数是普通用户的主机名，<code>newpwd</code>是要更改的新密码。</p>
<p>使用<code>root</code>用户登录 MySQL 服务器，再使用<code>GRANT</code>语句将<code>testuser</code>用户的密码修改为<code>newpwd3</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT USAGE ON *.* TO &#x27;testuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;newpwd3&#x27;;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.05 sec)</span><br></pre></td></tr></table></figure>
<h1 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h1><p>在 MySQL 中，<code>root</code>用户拥有很高的权限，因此必须保证<code>root</code>用户密码的安全。修改<code>root</code>用户密码的方式有很多种。</p>
<h2 id="使用mysqladmin命令在命令行指定新密码"><a href="#使用mysqladmin命令在命令行指定新密码" class="headerlink" title="使用mysqladmin命令在命令行指定新密码"></a>使用mysqladmin命令在命令行指定新密码</h2><p><code>root</code>用户可以使用<code>mysqladmin</code>命令来修改密码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>u username <span class="operator">-</span>h hostname <span class="operator">-</span>p password &quot;newpwd&quot;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>usermame</code>指需要修改密码的用户名称，在这里指定为<code> root</code>用户；</li>
<li><code>hostname</code>指需要修改密码的用户主机名，该参数可以不写，默认是<code>localhost</code>；</li>
<li><code>password</code>为关键字，而不是指旧密码；</li>
<li><code>newpwd</code>为新设置的密码，必须用双引号括起来。如果使用单引号会引发错误，可能会造成修改后的密码不是你想要的。</li>
</ul>
<p>执行完上面的语句，<code>root</code>用户的密码将被修改为<code>newpwd</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\leovo&gt;mysqladmin -u root -p password &quot;rootpwd&quot;</span><br><span class="line">Enter password: ****</span><br><span class="line">mysqladmin: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.</span><br></pre></td></tr></table></figure>
<p>运行结果中，输入密码后会提示在命令行界面上使用密码可能不安全的警告信息，因为在命令行输入密码时，MySQL 服务器就会提示这些安全警告信息。</p>
<h2 id="修改MySQL数据库的user表"><a href="#修改MySQL数据库的user表" class="headerlink" title="修改MySQL数据库的user表"></a>修改MySQL数据库的user表</h2><p>因为所有账户信息都保存在<code>user</code>表中，因此可以直接通过修改<code>user</code>表来改变<code>root</code>用户的密码。</p>
<p><code>root</code>用户登录到 MySQL 服务器后，可以使用<code>UPDATE</code>语句修改 MySQL 数据库的<code>user</code>表的<code>authentication_string</code>字段，从而修改用户的密码。</p>
<p>使用<code>UPDATA</code>语句修改<code>root</code>用户密码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">set</span> authentication_string <span class="operator">=</span> PASSWORD (&quot;rootpwd) WHERE User = &quot;root&quot; and Host=&quot;localhost&quot;;</span><br></pre></td></tr></table></figure>
<p>新密码必须使用<code>PASSWORD()</code>函数来加密。执行<code>UPDATE</code>语句后，需要执行<code>FLUSH PRIVILEGES</code>语句重新加载用户权限。</p>
<p>下面使用<code>UPDATE</code>语句将<code>root</code>用户的密码修改为<code>rootpwd2</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> mysql.user <span class="keyword">set</span> authentication_string <span class="operator">=</span> password (&quot;rootpwd2&quot;)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="keyword">User</span> <span class="operator">=</span> &quot;root&quot; <span class="keyword">and</span> Host <span class="operator">=</span> &quot;localhost&quot;;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected, <span class="number">0</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings:<span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> FLUSH PRIVILEGES;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure>
<p>退出后就必须使用新密码来登录了。</p>
<h2 id="使用SET语句修改root用户的密码"><a href="#使用SET语句修改root用户的密码" class="headerlink" title="使用SET语句修改root用户的密码"></a>使用SET语句修改root用户的密码</h2><p><code>SET PASSWORD</code>语句可以用来重新设置其他用户的登录密码或者自己使用的账户的密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD (&quot;rootpwd&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL&gt; SET PASSWORD = password (&quot;rootpwd3&quot;);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<h1 id="忘记root密码后如何重置"><a href="#忘记root密码后如何重置" class="headerlink" title="忘记root密码后如何重置"></a>忘记root密码后如何重置</h1><p>在忘记 MySQL 密码的情况下，可以通过<code>--skip-grant-tables</code>关闭服务器的认证，然后重置<code>root</code>的密码，具体操作步骤如下。</p>
<ol>
<li>关闭正在运行的 MySQL 服务。打开 cmd 进入 MySQL 的<code>bin</code>目录。</li>
<li>输入<code>mysqld --console --skip-grant-tables --shared-memory</code>命令。<code>–skip-grant-tables</code>会让 MySQL 服务器跳过验证步骤，允许所有用户以匿名的方式，无需做密码验证就可以直接登录 MySQL 服务器，并且拥有所有的操作权限。</li>
<li>上一个 DOS 窗口不要关闭，打开一个新的 DOS 窗口，此时仅输入 mysql 命令，不需要用户名和密码，即可连接到 MySQL。</li>
<li>输入命令<code>update mysql.user set authentication_string=password(&#39;root&#39;) where user=&#39;root&#39; and Host =&#39;localhost&#39;;</code>设置新密码。<br>注意：MySQL 5.7 版本中的<code>user</code>表里已经去掉了<code>password</code>字段，改为了<code>authentication_string</code>。</li>
<li>刷新权限（必须步骤），输入<code>flush privileges;</code>命令。</li>
<li>因为之前使用<code>--skip-grant-tables</code>启动，所以需要重启 MySQL 服务器去掉<code>--skip-grant-tables</code>。输入无误后输入<code>quit;</code>命令退出 MySQL 服务。</li>
<li>重启 MySQL 服务，使用用户名<code>root</code>和刚才设置的新密码<code>root</code>登录就可以了。</li>
</ol>
<h1 id="修改密码的3种方式"><a href="#修改密码的3种方式" class="headerlink" title="修改密码的3种方式"></a>修改密码的3种方式</h1><p>3 种修改 MySQL 数据库密码的方法。</p>
<h2 id="1-使用-SET-PASSWORD-命令"><a href="#1-使用-SET-PASSWORD-命令" class="headerlink" title="1. 使用 SET PASSWORD 命令"></a>1. 使用 SET PASSWORD 命令</h2><ol>
<li>输入命令<code>mysql -u root -p</code>指定<code>root</code>用户登录 MySQL，输入后按回车键输入密码。如果没有配置环境变量，请在 MySQL 的<code>bin</code>目录下登录操作。</li>
<li>使用<code>SET PASSWORD</code>修改密码命令格式为<code>set password for username @localhost = password(newpwd);</code><br>，其中<code>username</code>为要修改密码的用户名，<code>newpwd</code>为要修改的新密码。</li>
<li>输入<code>quit;</code>命令退出 MySQL 重新登录，输入新密码“root”登录就可以了；</li>
</ol>
<h2 id="2-使用mysqladmin修改密码"><a href="#2-使用mysqladmin修改密码" class="headerlink" title="2. 使用mysqladmin修改密码"></a>2. 使用mysqladmin修改密码</h2><p>使用 mysqladmin 命令修改 MySQL 的<code>root</code>用户密码格式为<code>mysqladmin -u</code>用户名 -p旧密码<code>password</code>新密码。</p>
<p>注意：下图修改密码的命令中<code>-uroot</code>和<code>-proot</code>是整体，不要写成<code>-u root -p root</code>，<code>-u</code>和<code>root</code>间可以加空格，但是会有警告出现，所以就不要加空格了。</p>
<h2 id="3-UPDATE直接编辑user表"><a href="#3-UPDATE直接编辑user表" class="headerlink" title="3. UPDATE直接编辑user表"></a>3. UPDATE直接编辑user表</h2><ol>
<li>输入命令<code>mysql -u root -p</code>指定<code>root</code>用户登录 MySQL，输入后按回车键输入密码。如果没有配置环境变量，请在 MySQL 的<code>bin</code>目录下登录操作。</li>
<li>输入<code>use mysql;</code>命令连接权限数据库。</li>
<li>输入命令<code>update mysql.user set authentication_string=password(&#39;新密码&#39;) where user=&#39;用户名&#39; and Host =&#39;localhost&#39;;</code>设置新密码。</li>
<li>输入<code>flush privileges;</code>命令刷新权限。</li>
<li>输入<code>quit;</code>命令退出 MySQL 重新登录，此时密码已经修改为刚才输入的新密码了。</li>
</ol>
<h1 id="权限控制实现原理"><a href="#权限控制实现原理" class="headerlink" title="权限控制实现原理"></a>权限控制实现原理</h1><p>MySQL 权限表在数据库启动时载入内存，用户通过身份认证后，系统会在内存中进行相应权限的存取。当 MySQL 允许一个用户执行各种操作时，它将首先核实该用户向 MySQL 服务器发送的连接请求，然后确认用户的操作请求是否被允许。</p>
<p>当用户进行连接时，MySQL 实现权限控制主要有以下两个阶段：</p>
<h2 id="1-连接核实阶段"><a href="#1-连接核实阶段" class="headerlink" title="1. 连接核实阶段"></a>1. 连接核实阶段</h2><p>登录 MySQL 服务器时，客户端连接请求中会提供用户名称、主机地址和密码，MySQL 服务器会使用<code>user</code>表中的<code>Host、User</code>和<code>authentication_string</code>字段执行身份检查。</p>
<p>只有客户端请求的主机名和用户名在<code>user</code>表中有匹配的记录，并且密码正确时，MySQL 服务器才会通过身份认证，接受连接，否则拒绝连接。</p>
<p>MySQL 通过 IP 地址和用户名联合进行身份认证。例如 MySQL 安装后默认创建的用户<code>root@localhost</code>，表示用户<code>root</code>只能从本地（<code>localhost</code>）进行连接时才能通过认证。此用户从其它任何主机对数据库进行连接时都将被拒绝。也就是说，用户名相同，IP 地址不同，MySQL 则将其视为不同的用户。</p>
<p>服务器接受连接后进入请求核实阶段等待用户请求。如果连接核实没有通过，服务器则完全拒绝访问。</p>
<h2 id="2-请求核实阶段"><a href="#2-请求核实阶段" class="headerlink" title="2. 请求核实阶段"></a>2. 请求核实阶段</h2><p>建立连接后，服务器进入请求核实阶段，对在此连接上的每个请求，服务器都会检查用户是否有足够的权限来执行它。这正是授权表中的权限列发挥作用的地方。</p>
<p>权限按照以下权限表的顺序得到数据库权限：<code>user→db→tables_priv→columns_priv→procs_priv</code>。在这几个权限表中，权限范围依次递减，全局权限覆盖局部权限。</p>
<p>请求核实的过程如下所示：</p>
<ol>
<li>用户向 MySQL 发出操作请求。</li>
<li>MySQL 首先检查<code>user</code>表，匹配<code>User、Host</code>字段值，查看请求的全局权限在 user 表中是否被授权。授权则允许操作执行，如果指定的权限在 user 表中没有被授权。MySQL 将检查<code>db</code>表。</li>
<li><code>db</code>表是下一安全层级，其中的权限限定于数据库层级，在该层级的<code>SELECT</code>权限允许用户查看指定数据库的所有表中的数据。<br>MySQL 检查<code>db</code>权限表中的权限信息，匹配<code>User、Host</code>字段值，查看请求的数据库级别的权限在<code>db</code>表中是否被授权。授权则允许操作执行，否则 MySQL 继续向下查找。</li>
<li>MySQL 检查<code>tables_priv</code>权限表中的权限信息，匹配<code>User、Host</code>字段值，查看请求的数据表级别的权限在<code>tables_priv</code>表中是否被授权。授权则允许操作执行，否则 MySQL 继续向下查找。</li>
<li>MySQL 检查<code>columns_priv</code>权限表中的权限信息，匹配<code>User、Host</code>字段值，查看请求的列级别的权限在<code>columns_priv</code>表中是否被授权。授权则允许操作执行，否则 MySQL 继续向下查找。</li>
<li>如果所有权限表都检查完毕，还是没有找到允许的权限操作，那么 MySQL 将返回错误信息，即用户请求的操作不能执行，操作失败。</li>
</ol>
<p>提示：上面提到 MySQL 通过向下层级的顺序检查权限表，但并不意味着所有的权限都要执行该过程。例如，一个用户登录到 MySQL 服务器之后只执行对 MySQL 的管理操作，此时只涉及管理权限，因此 MySQL 只检查 user 表。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL锁机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/19/MySQL/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"
    >MySQL 锁机制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/05/19/MySQL/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-05-19T13:09:17.000Z" itemprop="datePublished">2020-05-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>为了保证数据并发访问时的一致性和有效性，任何一个数据库都存在锁机制。锁机制的优劣直接影响到数据库的并发处理能力和系统性能，所以锁机制也就成为了各种数据库的核心技术之一。</p>
<p>锁机制是为了解决数据库的并发控制问题而产生的。如在同一时刻，客户端对同一个表做更新或查询操作，为了保证数据的一致性，必须对并发操作进行控制。同时，锁机制也为实现 MySQL 的各个隔离级别提供了保证。</p>
<p>可以将锁机制理解为使各种资源在被并发访问时变得有序所设计的一种规则。</p>
<p>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>
<p>按锁级别分类，可分为共享锁、排他锁和意向锁。也可以按锁粒度分类，可分为行级锁、表级锁和页级锁。</p>
<p>1.共享锁<br>共享锁的代号是 S，是 Share 的缩写，也可称为读锁。是一种可以查看但无法修改和删除的数据锁。</p>
<p>共享锁的锁粒度是行或者元组（多个行）。一个事务获取了共享锁之后，可以对锁定范围内的数据执行读操作。会阻止其它事务获得相同数据集的排他锁。</p>
<p>2.排他锁<br>排他锁的代号是 X，是 eXclusive 的缩写，也可称为写锁，是基本的锁类型。</p>
<p>排他锁的粒度与共享锁相同，也是行或者元组。一个事务获取了排他锁之后，可以对锁定范围内的数据执行写操作。允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享锁和排他锁。</p>
<p>如有两个事务 A 和 B，如果事务 A 获取了一个元组的共享锁，事务 B 还可以立即获取这个元组的共享锁，但不能立即获取这个元组的排他锁，必须等到事务 A 释放共享锁之后才可以。</p>
<p>如果事务 A 获取了一个元组的排他锁，事务 B 不能立即获取这个元组的共享锁，也不能立即获取这个元组的排他锁，必须等到 A 释放排他锁之后才可以。<br>3.意向锁<br>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁。</p>
<p>意向锁是一种表锁，锁定的粒度是整张表，分为意向共享锁（IS）和意向排他锁（IX）两类。</p>
<p>意向共享锁表示一个事务有意对数据上共享锁或者排他锁。“有意”表示事务想执行操作但还没有真正执行。</p>
<p>锁和锁之间的关系，要么是相容的，要么是互斥的。<br>锁 a 和锁 b 相容是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 还可以获取锁 b；<br>锁 a 和锁 b 互斥是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 在 t1 释放锁 a 之前无法释放锁 b。</p>
<p>锁模式的兼容情况<br>其中共享锁、排他锁、意向共享锁、意向排他锁相互之间的兼容&#x2F;互斥关系如下表所示，其中 Y 表示相容，N 表示互斥。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">X</th>
<th align="center">S</th>
<th align="center">IX</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X（排他锁）</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">S（共享锁）</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">IX（意向排他锁）</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">IS（意向共享锁）</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
</tbody></table>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p>
<p>为了尽可能提高数据库的并发量，需每次锁定的数据范围越小越好，越小的锁其耗费的系统资源越多，系统性能下降。为在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度”的概念。</p>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>要使用全局锁，则要执行这条命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock</span><br></pre></td></tr></table></figure>
<p>执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删改操作，比如<code>insert、delete、update</code>等语句；</li>
<li>对表结构的更改操作，比如<code>alter table、drop table</code>等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>
<p>当然，当会话断开了，全局锁会被自动释放。</p>
<h2 id="全局锁应用场景"><a href="#全局锁应用场景" class="headerlink" title="全局锁应用场景"></a>全局锁应用场景</h2><p>全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<p>在全库逻辑备份期间，假设不加全局锁的场景，看看会出现什么意外的情况。</p>
<p>如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑是会涉及到多张数据库表的更新，比如在用户表更新该用户的余额，然后在商品表更新被购买的商品的库存。</p>
<p>那么，有可能出现这样的顺序：</p>
<ol>
<li>先备份了用户表的数据；</li>
<li>然后有用户发起了购买商品的操作；</li>
<li>接着再备份商品表的数据。</li>
</ol>
<p>也就是在备份用户表和商品表之间，有用户购买了商品。</p>
<p>这种情况下，备份的结果是用户表中该用户的余额并没有扣除，反而商品表中该商品的库存被减少了，如果后面用这个备份文件恢复数据库数据的话，用户钱没少，而库存少了，等于用户白嫖了一件商品。</p>
<p>所以，在全库逻辑备份期间，加上全局锁，就不会出现上面这种情况了。</p>
<h2 id="加全局锁缺点"><a href="#加全局锁缺点" class="headerlink" title="加全局锁缺点"></a>加全局锁缺点</h2><p>加上全局锁，意味着整个数据库都是只读状态。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<p>既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</p>
<p>有的，如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建<code>Read View</code>，然后整个事务执行期间都在用这个<code>Read View</code>，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
<p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的<code>Read View</code>，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>备份数据库的工具是<code>mysqldump</code>，在使用<code>mysqldump</code>时加上<code>–single-transaction</code>参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p>
<p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h1 id="表锁、行锁和页锁"><a href="#表锁、行锁和页锁" class="headerlink" title="表锁、行锁和页锁"></a>表锁、行锁和页锁</h1><p>MySQL 按锁的粒度可以细分为行级锁、页级锁和表级锁。</p>
<p>我们可以将锁粒度理解成锁范围。</p>
<h2 id="表级锁（table-lock）"><a href="#表级锁（table-lock）" class="headerlink" title="表级锁（table lock）"></a>表级锁（table lock）</h2><p>表级锁为表级别的锁定，会锁定整张表，可以很好的避免死锁，是 MySQL 中最大颗粒度的锁定机制。</p>
<p>一个用户在对表进行写操作（插入、删除、更新等）时，需要先获得写锁，这会阻塞其它用户对该表的所有读写操作。没有写锁时，其它读取的用户才能获得读锁，读锁之间是不相互阻塞的。</p>
<p>表级锁最大的特点就是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。当然，锁定颗粒度大带来最大的负面影响就是出现锁定资源争用的概率会很高，致使并发度大打折扣。</p>
<p>不过在某些特定的场景中，表级锁也可以有良好的性能。例如，<code>READ LOCAL</code>表级锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面（写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面）。</p>
<p>使用表级锁的主要是 MyISAM，MEMORY，CSV 等一些非事务性存储引擎。</p>
<p>尽管存储引擎可以管理自己的锁，MySQL 本身还是会使用各种有效的表级锁来实现不同的目的。例如，服务器会为诸如<code>ALTER TABLE</code>之类的语句使用表级锁，而忽略存储引擎的锁机制。</p>
<p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁；</li>
</ul>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>如果我们想对学生表（<code>t_student</code>）加表锁，可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
<p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>
<p>另外，当会话退出后，也会释放所有表锁。</p>
<p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁。</p>
<h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 MDL 读锁；</li>
<li>对一张表做结构变更操作的时候，加的是 MDL 写锁；</li>
</ul>
<p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
<p>当有线程在执行<code>select</code>语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（申请 MDL 写锁），那么将会被阻塞，直到执行完<code>select</code>语句（释放 MDL 读锁）。</p>
<p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（释放 MDL 写锁）。</p>
<p>MDL 不需要显示调用，那它是在什么时候释放的?</p>
<p>MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。</p>
<p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p>
<ol>
<li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条<code>select</code>语句，此时就先对该表加上 MDL 读锁；</li>
<li>然后，线程 B 也执行了同样的<code>select</code>语句，此时并不会阻塞，因为「读读」并不冲突；</li>
<li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li>
</ol>
<p>那么在线程 C 阻塞后，后续有对该表的<code>select</code>语句，就都会被阻塞，如果此时有大量该表的<code>select</code>语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<p>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</p>
<p>这是因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
<p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑<code>kill</code>掉这个长事务，然后再做表结构的变更。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p>
<p>而普通的<code>select</code>是不会加行级锁的，普通的<code>select</code>语句是利用 MVCC 实现一致性读，是无锁的。</p>
<p>不过，<code>select</code>也是可以对记录加共享锁和独占锁的，具体方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">//先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="line">select ... for update;</span><br></pre></td></tr></table></figure>
<p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（<code>lock tables ... read</code>）和独占表锁（<code>lock tables ... write</code>）发生冲突。</p>
<p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>所以，意向锁的目的是为了快速判断表里是否有记录被加锁。</p>
<h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明<code>AUTO_INCREMENT</code>属性实现的。</p>
<p>之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。</p>
<p>在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被<code>AUTO_INCREMENT</code>修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被<code>AUTO_INCREMENT</code>修饰的字段的值是连续递增的。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种轻量级的锁来实现自增。</p>
<p>一样也是在插入数据的时候，会为被<code>AUTO_INCREMENT</code>修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</p>
<p>InnoDB 存储引擎提供了个<code>innodb_autoinc_lock_mode</code>的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当<code>innodb_autoinc_lock_mode = 0</code>，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li>
<li>当<code>innodb_autoinc_lock_mode = 2</code>，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li>
<li>当<code>innodb_autoinc_lock_mode = 1</code>：</li>
<li>普通<code>insert</code>语句，自增锁在申请之后就马上释放；</li>
<li>类似<code>insert … select</code>这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
<p>举个例子，考虑下面场景：</p>
<table>
<thead>
<tr>
<th align="center">session A</th>
<th align="center">session B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">insert into t values(null, 1, 1);<br>insert into t values(null, 2, 2);<br>insert into t values(null, 3, 3);<br>insert into t values(null, 4, 4);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">create table t2 like t;</td>
</tr>
<tr>
<td align="center">insert into t2 values(null, 5, 5);</td>
<td align="center">insert into t2(c, d) select c,d from t;</td>
</tr>
</tbody></table>
<p><code>session A</code>往表 t 中插入了 4 行数据，然后创建了一个相同结构的表<code>t2</code>，然后两个<code>session</code>同时执行向表<code>t2</code>中插入数据。</p>
<p>如果<code>innodb_autoinc_lock_mode = 2</code>，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：</p>
<ul>
<li><code>session B</code>先插入了两个记录，<code>(1,1,1)、(2,2,2)</code>；</li>
<li>然后，<code>session A</code>来申请自增 id 得到<code>id=3</code>，插入了<code>(3,5,5)</code>；</li>
<li>之后，<code>session B</code>继续执行，插入两条记录<code>(4,3,3)、(5,4,4)</code>。</li>
</ul>
<p>可以看到，<code>session B</code>的<code>insert</code>语句，生成的<code>id</code>不连续。</p>
<p>当「主库」发生了这种情况，<code>binlog</code>面对<code>t2</code>表的更新只会记录这两个<code>session</code>的<code>insert</code>语句，如果<code>binlog_format=statement</code>，记录的语句就是原始语句。记录的顺序要么先记<code>session A</code>的<code>insert</code>语句，要么先记<code>session B</code>的<code>insert</code>语句。</p>
<p>但不论是哪一种，这个<code>binlog</code>拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在从库上「不会」发生像主库那样两个<code>session</code>「同时」执行向表<code>t2</code>中插入数据的场景。所以，在备库上执行了<code>session B</code>的<code>insert</code>语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致。</p>
<p>要解决这问题，<code>binlog</code>日志格式要设置为<code>row</code>，这样在<code>binlog</code>里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。</p>
<p>所以，当<code>innodb_autoinc_lock_mode = 2</code>时，并且<code>binlog_format = row</code>，既能提升并发性，又不会出现数据一致性问题。</p>
<h2 id="页级锁（page-lock）"><a href="#页级锁（page-lock）" class="headerlink" title="页级锁（page lock）"></a>页级锁（page lock）</h2><p>页级锁是 MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中并不常见。</p>
<p>页级锁的颗粒度介于行级锁与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力同样也是介于上面二者之间。另外，页级锁和行级锁一样，会发生死锁。</p>
<p>页级锁主要应用于 BDB 存储引擎。</p>
<h2 id="行级锁（row-lock）"><a href="#行级锁（row-lock）" class="headerlink" title="行级锁（row lock）"></a>行级锁（row lock）</h2><p>行级锁的锁定颗粒度在 MySQL 中是最小的，只针对操作的当前行进行加锁，所以行级锁发生锁定资源争用的概率也最小。</p>
<p>行级锁能够给予应用程序尽可能大的并发处理能力，从而提高需要高并发应用系统的整体性能。虽然行级锁在并发处理能力上面有较大的优势，但也因此带来了不少弊端。</p>
<p>由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也就更多，带来的消耗自然也就更大。此外，行级锁也最容易发生死锁。所以说行级锁最大程度地支持并发处理的同时，也带来了最大的锁开销。</p>
<p>行级锁主要应用于 InnoDB 存储引擎。</p>
<p>随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量也越来越多，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也会随之提升。</p>
<p>MySQL 这 3 种锁的特性可大致归纳如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">表级锁</th>
<th align="center">行级锁</th>
<th align="center">页级锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开销</td>
<td align="center">小</td>
<td align="center">大</td>
<td align="center">介于表级锁和行级锁之间</td>
</tr>
<tr>
<td align="center">加锁</td>
<td align="center">快</td>
<td align="center">慢</td>
<td align="center">介于表级锁和行级锁之间</td>
</tr>
<tr>
<td align="center">死锁</td>
<td align="center">不会出现死锁</td>
<td align="center">会出现死锁</td>
<td align="center">会出现死锁</td>
</tr>
<tr>
<td align="center">锁粒度</td>
<td align="center">大</td>
<td align="center">小</td>
<td align="center">介于表级锁和行级锁之间</td>
</tr>
<tr>
<td align="center">并发度</td>
<td align="center">低</td>
<td align="center">高</td>
<td align="center">一般</td>
</tr>
</tbody></table>
<p>从上述特点可见，很难笼统的说哪种锁更好，只能具体应用具体分析。</p>
<p>从锁的角度来说，表级锁适合以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用。而行级锁更适合于有大量按索引条件，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p>
<h1 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h1><p>在 MySQL 中，InnoDB 行锁通过给索引上的索引项加锁来实现，如果没有索引，InnoDB 将通过隐藏的聚簇索引来对记录加锁。</p>
<p>InnoDB 支持 3 种行锁定方式：</p>
<ul>
<li>行锁（<code>Record Lock</code>）：直接对索引项加锁。</li>
<li>间隙锁（<code>Gap Lock</code>）：锁加在索引项之间的间隙，也可以是第一条记录前的“间隙”或最后一条记录后的“间隙”。</li>
<li><code>Next-Key Lock</code>：行锁与间隙锁组合起来用就叫做<code>Next-Key Lock</code>。前两种的组合，对记录及其前面的间隙加锁。</li>
</ul>
<p>默认情况下，InnoDB 工作在可重复读（默认隔离级别）下，并且以<code>Next-Key Lock</code>的方式对数据行进行加锁，这样可以有效防止幻读的发生。</p>
<p><code>Next-Key Lock</code>是行锁与间隙锁的组合，这样，当 InnoDB 扫描索引项的时候，会首先对选中的索引项加上行锁（<code>Record Lock</code>），再对索引项两边的间隙（向左扫描扫到第一个比给定参数小的值， 向右扫描扫到第一个比给定参数大的值， 然后以此为界，构建一个区间）加上间隙锁（<code>Gap Lock</code>）。如果一个间隙被事务 T1 加了锁，其它事务不能在这个间隙插入记录。</p>
<p>要禁止间隙锁的话，可以把隔离级别降为读已提交（<code>READ COMMITTED</code>），或者开启参数<code>innodb_locks_unsafe_for_binlog</code>。</p>
<p>注意：以上语句描述的情况，与 MySQL 所设置的事务隔离级别有较大的关系。</p>
<p>开启一个事务时，InnoDB 存储引擎会在更新的记录上加行级锁，此时其它事务不可以更新被锁定的记录。下面我们以示例1演示此过程。</p>
<p>下面的语句需要在两个命令行窗口中执行。为了方便理解，我们分别称之为 A 窗口和 B 窗口。</p>
<p>分别在 A 窗口和 B 窗口中查看事务隔离级别，A 窗口和 B 窗口的事务隔离级别需要保持一致。</p>
<p>A 窗口查看隔离级别的 SQL 语句和运行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;tx_isolation&#x27; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: tx_isolation</span><br><span class="line">        Value: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br><span class="line">B 窗口查看隔离级别 SQL 语句和运行结果如下所示：</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;tx_isolation&#x27; \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: tx_isolation</span><br><span class="line">        Value: REPEATABLE-READ</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>
<p>结果显示，A 窗口和 B 窗口的事务隔离级别都为<code>REPEATABLE-READ</code>。</p>
<p>在 A 窗口中开启一个事务，并修改<code>tb_student</code>表，SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> test.tb_student <span class="keyword">SET</span> age <span class="operator">=</span><span class="string">&#x27;30&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在 B 窗口中也开启一个事务，并修改<code>tb_student</code>表，SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> test.tb_student <span class="keyword">SET</span> age <span class="operator">=</span><span class="string">&#x27;30&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>会发现 UPDATE 语句一直在执行。这时我们在 A 窗口中提交事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>这时我们发现 B 窗口中的 UPDATE 语句执行成功。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> test.tb_student <span class="keyword">SET</span> age <span class="operator">=</span><span class="string">&#x27;30&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">1</span> min <span class="number">2.78</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>查询<code>tb_student</code>表中的数据，SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test.tb_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> sex  <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三 <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span> 男   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 李四 <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> 男   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 王五 <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span> 女   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 张四 <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span> 女   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 王四 <span class="operator">|</span>   <span class="number">15</span> <span class="operator">|</span> 男   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 赵六 <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> 女   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>如以上实例所示，当有不同的事务同时更新同一条记录时，另外一个事务需要等待另一个事务把锁释放，此时查看 MySQL 中 InnoDB 存储引擎的状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINE innodb status \G</span><br><span class="line">......</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 19556</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 19554 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 12</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 283572223909376, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 19555, ACTIVE 54 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)</span><br><span class="line">MySQL thread id 14, OS thread handle 4568, query id 886 localhost ::1 root updating</span><br><span class="line">UPDATE test.tb_student SET age =&#x27;30&#x27; WHERE id = 1</span><br><span class="line">------- TRX HAS BEEN WAITING 54 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 197 page no 3 n bits 80 index PRIMARY of table `test`.`tb_student` trx id 19555 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 7; compact format; info bits 0</span><br><span class="line">0: len 4; hex 80000001; asc     ;;</span><br><span class="line">1: len 6; hex 000000004c62; asc     Lb;;</span><br></pre></td></tr></table></figure>
<p>从上面运行结果可以看出，SQL 语句<code>UPDATE test.tb_student SET age =&#39;30&#39; WHERE id = 1</code>在等待，<code>RECORD LOCKS space id 197 page no 3 n bits 80 index PRIMARY of table `test`.`tb_student` trx id 19555 lock_mode X locks rec but not gap</code>表示锁住的资源，<code>locks rec but not gap</code>代表锁住的是一个索引，不是一个范围。</p>
<p><code>“MySQL thread id 14, OS thread handle 4568, query id 886 localhost ::1 root updating”</code>表示第 2 个事务连接的 ID 为 14，当前状态为正在更新，同时正在更新的记录需要等待其它事务将锁释放。当超过事务等待锁允许的最大时间，此时会提示<code>“ERROR 1205(HY000):Lock wait timeout exceeded; try restarting transaction&quot;</code>及当前事务执行失败，则自动执行回滚操作。</p>
<p>MySQL 数据库采用 InnoDB 模式，默认参数<code>innodb_lock_wait_timeout</code>设置锁等待的时间是 50s，一旦数据库锁超过这个时间就会报错。可通过以下命令查看当前数据库锁等待的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW GLOBAL VARIABLES LIKE &#x27;innodb_lock_wait_timeout&#x27;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_lock_wait_timeout | 120   |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>下面演示了 InnoDB 间隙锁的实现机制。</p>
<p>下面在保证 A 窗口和 B 窗口的前提下，将<code>tb_student</code>表中的 id 字段设为外键，并开启一个事务，修改<code>tb_student</code>表中<code>id</code>为 1 的<code>age</code>。SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test.tb_student <span class="keyword">ADD</span> <span class="keyword">unique</span> key idx_id(id);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.17</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> test.tb_student <span class="keyword">SET</span> age <span class="operator">=</span><span class="string">&#x27;31&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在 B 窗口中开启一个事务，修改 tb_student 表中 id 为 2 的 age，SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">UPDATE</span> test.tb_student <span class="keyword">SET</span> age <span class="operator">=</span><span class="string">&#x27;28&#x27;</span><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这时分别提交 A窗口和 B窗口的事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>查询 tb_student 表的数据，SQL 语句和运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test.tb_student;</span><br><span class="line">+----+------+------+------+------+</span><br><span class="line">| id | name | age  | sex  | num  |</span><br><span class="line">+----+------+------+------+------+</span><br><span class="line">|  1 | 张三 |   31 | 男   |    4 |</span><br><span class="line">|  2 | 李四 |   28 | 男   |    4 |</span><br><span class="line">|  3 | 王五 |   13 | 女   |    4 |</span><br><span class="line">|  4 | 张四 |   13 | 女   |    4 |</span><br><span class="line">|  5 | 王四 |   15 | 男   |    4 |</span><br><span class="line">|  6 | 赵六 |   12 | 女   |    4 |</span><br><span class="line">+----+------+------+------+------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>在上述示例中，由于 InnoDB 行级锁为间隙锁，只锁定需要的记录，因此 B 窗口中的事务可以更新其它记录，两个事务之间互不影响。</p>
<h1 id="锁等待和死锁"><a href="#锁等待和死锁" class="headerlink" title="锁等待和死锁"></a>锁等待和死锁</h1><p>使用数据库时，有时会出现死锁。对于实际应用来说，就是出现系统卡顿。</p>
<p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。就是所谓的锁资源请求产生了回路现象，即死循环，此时称系统处于死锁状态或系统产生了死锁。常见的报错信息为“Deadlock found when trying to get lock…”。</p>
<p>死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁。多数情况下只需要重新执行因死锁回滚的事务即可。下面我们通过一个实例来了解死锁是如何产生的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tb_student;</span><br><span class="line">+----+------+------+------+------+</span><br><span class="line">| id | name | age  | sex  | num  |</span><br><span class="line">+----+------+------+------+------+</span><br><span class="line">|  1 | 张三 |   31 | 男   |    4 |</span><br><span class="line">|  2 | 李四 |   28 | 男   |    4 |</span><br><span class="line">|  3 | 王五 |   13 | 女   |    4 |</span><br><span class="line">|  4 | 张四 |   13 | 女   |    4 |</span><br><span class="line">|  5 | 王四 |   15 | 男   |    4 |</span><br><span class="line">|  6 | 赵六 |   12 | 女   |    4 |</span><br><span class="line">+----+------+------+------+------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DESC tb_student;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(4)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(25) | NO   |     | NULL    |                |</span><br><span class="line">| age   | int(11)     | YES  | MUL | NULL    |                |</span><br><span class="line">| sex   | char(1)     | YES  |     | NULL    |                |</span><br><span class="line">| num   | int(11)     | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>以下操作需要打开两个会话窗口，即下面所提到的 A 窗口和 B 窗口。</p>
<p>在 A 窗口中执行以下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> tb_student <span class="keyword">SET</span> num<span class="operator">=</span><span class="number">5</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">13</span>;</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">2</span>  Changed: <span class="number">2</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>紧接着在 B 窗口中执行以下命令。由于<code>age</code>是索引字段，与 A 窗口中更新的是不同行的数据，所以这时不会出现锁等待现象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> tb_student <span class="keyword">SET</span> num<span class="operator">=</span><span class="number">8</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">15</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后在 A 窗口中，执行以下命令，这时就会出现锁等待现象了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> tb_student <span class="keyword">SET</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>最后在 B 窗口中，执行以下命令，这时会出现相互等待资源的现象，也就是死锁现象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> tb_student <span class="keyword">SET</span> num<span class="operator">=</span><span class="number">12</span> <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">13</span>;</span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>我们可以通过<code>SHOW ENGINE INNODB STATUS</code>命令查看死锁的信息，运行结果如下（这里只展示了部分信息）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2020-08-24 16:22:23 0x3944</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 22656, ACTIVE 108 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 5 lock struct(s), heap size 1136, 6 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 33, OS thread handle 8808, query id 1689 localhost ::1 root updating</span><br><span class="line">UPDATE tb_student SET num=10 WHERE age=15</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 197 page no 8 n bits 80 index index_age of table `test`.`tb_student` trx id 22656 lock_mode X waiting</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line">0: len 4; hex 8000000f; asc     ;;</span><br><span class="line">1: len 4; hex 80000005; asc     ;;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>通过以上日志，我们就能确定造成死锁的事务和 SQL 语句。</p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>InnoDB 的并发写操作会触发死锁，同时 InnoDB 也提供了死锁检测机制。通过设置<code>innodb_deadlock_detect</code>参数的值来控制是否打开死锁检测。</p>
<ul>
<li><code>innodb_deadlock_detect = ON</code>：默认值，打开死锁检测。数据库发生死锁时，系统会自动回滚其中的某一个事务，让其它事务可以继续执行。</li>
<li><code>innodb_deadlock_detect = OFF</code>：关闭死锁检测。发生死锁时，系统会用锁等待来处理。</li>
</ul>
<p>锁等待是指在事务过程中产生的锁，其它事务需要等待上一个事务释放锁，才能占用该资源。如果该事务一直不释放，就需要持续等待下去，直到超过了锁等待时间。当超过锁等待允许的最大时间，就会出现死锁，然后当前事务执行失败，自动执行回滚操作。</p>
<p>MySQL 通过<code>innodb_lock_wait_timeout</code>参数控制锁等待的时间，单位是秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%innodb_lock_wait%&#x27;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| innodb_lock_wait_timeout | 120   |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">1 row in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>在实际应用中，我们要尽量防止锁等待现象的发生，下面介绍几种避免死锁的方法：</p>
<ul>
<li>如果不同程序会并发存取多个表，或者涉及多行记录时，尽量约定以相同的顺序访问表，这样可以大大降低死锁的发生。</li>
<li>业务中要及时提交或者回滚事务，可减少死锁产生的概率。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁粒度，通过表锁定来减少死锁产生的概率（表级锁不会产生死锁）。</li>
</ul>
<h1 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h1><p>通常情况下，当出现锁问题时，我们习惯性通过<code>SHOW FULL PROCESSLIST</code>和<code>SHOW ENGINE INNODB STATUS</code>命令来判断事务中锁问题的情况。其实还有特别重要的三张表，即在<code>information_schema</code>数据库下的<code>innodb_trx、innodb_locks</code>和<code>innodb_lock_waits</code>表。 这三张表可以更方便地来帮助我们监控当前的事务并分析可能存在的锁问题。</p>
<p>下面通过实例来逐一了解一下这三张表。</p>
<p>在 A窗口中，开启一个事务，在查询 tb_student 表字段 age&lt;15 的语句上加一个写锁，SQL 命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test.tb_student <span class="keyword">WHERE</span> age<span class="operator">&lt;</span><span class="number">15</span> FOE <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> sex  <span class="operator">|</span> num  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 王五 <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 张四 <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span> 女   <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 赵六 <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> 女   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>
<p>在 B 窗口中开启一个事务，在<code>tb_student</code>表中插入<code>age=14</code>的记录，出现锁等待超时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tb_student(name,age) VALUES (&#x27;dd&#x27;,14);</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>
<p>我们通过开始提到的三张表来分析出现的锁等待问题。</p>
<p>查询<code>innodb_trx</code>表，SQL 语句和运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.innodb_trx \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                    trx_id: 22694</span><br><span class="line">                 trx_state: LOCK WAIT</span><br><span class="line">               trx_started: 2019-08-25 09:17:26</span><br><span class="line">     trx_requested_lock_id: 22694:197:3:1</span><br><span class="line">          trx_wait_started: 2019-08-25 09:17:26</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 42</span><br><span class="line">                 trx_query: INSERT INTO tb_student(name,age) VALUES (&#x27;dd&#x27;,14)</span><br><span class="line">       trx_operation_state: inserting</span><br><span class="line">         trx_tables_in_use: 1</span><br><span class="line">         trx_tables_locked: 1</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 1136</span><br><span class="line">           trx_rows_locked: 1</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line">trx_adaptive_hash_latched: 0</span><br><span class="line">trx_adaptive_hash_timeout: 0</span><br><span class="line">          trx_is_read_only: 0</span><br><span class="line">trx_autocommit_non_locking: 0</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">                    trx_id: 22693</span><br><span class="line">                 trx_state: RUNNING</span><br><span class="line">               trx_started: 2019-08-25 09:17:17</span><br><span class="line">     trx_requested_lock_id: NULL</span><br><span class="line">          trx_wait_started: NULL</span><br><span class="line">                trx_weight: 2</span><br><span class="line">       trx_mysql_thread_id: 41</span><br><span class="line">                 trx_query: select * FROM information_schema.innodb_trx</span><br><span class="line">       trx_operation_state: NULL</span><br><span class="line">         trx_tables_in_use: 0</span><br><span class="line">         trx_tables_locked: 1</span><br><span class="line">          trx_lock_structs: 2</span><br><span class="line">     trx_lock_memory_bytes: 1136</span><br><span class="line">           trx_rows_locked: 7</span><br><span class="line">         trx_rows_modified: 0</span><br><span class="line">   trx_concurrency_tickets: 0</span><br><span class="line">       trx_isolation_level: REPEATABLE READ</span><br><span class="line">         trx_unique_checks: 1</span><br><span class="line">    trx_foreign_key_checks: 1</span><br><span class="line">trx_last_foreign_key_error: NULL</span><br><span class="line">trx_adaptive_hash_latched: 0</span><br><span class="line">trx_adaptive_hash_timeout: 0</span><br><span class="line">          trx_is_read_only: 0</span><br><span class="line">trx_autocommit_non_locking: 0</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>以上各列含义说明如下：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">trx_id</td>
<td align="center">唯一的事务 id 号。本例为 22694 和 22693</td>
</tr>
<tr>
<td align="center">trx_state</td>
<td align="center">当前事务的状态。本例中 22694 事务号是 lock_wait 锁等待状态</td>
</tr>
<tr>
<td align="center">trx_wait_started</td>
<td align="center">事务开始等待的时间。本例为 2019-08-25 09:17:26</td>
</tr>
<tr>
<td align="center">trx_mysql_thread_id</td>
<td align="center">线程 id，与  SHOW FULL PROCESSLIST 相对应。本例为 42</td>
</tr>
<tr>
<td align="center">trx_query</td>
<td align="center">事务运行的 SQL 语句，本例为 INSERT INTO tb_student(name,age) VALUES (‘dd’,14)。</td>
</tr>
<tr>
<td align="center">trx_operation_state</td>
<td align="center">事务运行的状态。本例为 inserting。</td>
</tr>
</tbody></table>
<p>使用<code>SHOW FULL PROCESSLIST</code>语句查看当前线程处理情况，通常用来处理突发事件，返回的结果是实时变化的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW FULL PROCESSLIST;</span><br><span class="line">+----+------+-----------------+------+---------+------+----------+---------------------------------------------------+</span><br><span class="line">| id | User | Host            | db   | Command | Time | State    | Info                                              |</span><br><span class="line">+----+------+-----------------+------+---------+------+----------+---------------------------------------------------+</span><br><span class="line">| 35 | root | localhost:64579 | test | Sleep   | 1772 |          | NULL                                              |</span><br><span class="line">| 36 | root | localhost:64582 | NULL | Sleep   | 1775 |          | NULL                                              |</span><br><span class="line">| 45 | root | localhost:64933 | test | Query   |    0 | starting | SHOW FULL PROCESSLIST                             |</span><br><span class="line">| 46 | root | localhost:64934 | test | Query   |    8 | update   | INSERT INTO tb_student(name,age) VALUES (&#x27;dd&#x27;,14) |</span><br><span class="line">+----+------+-----------------+------+---------+------+----------+---------------------------------------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>以上各列含义说明如下：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">一个标识，kill 有问题的线程时使用</td>
</tr>
<tr>
<td align="center">user</td>
<td align="center">显示当前用户，如果不是 root，这个命令就只显示你权限范围内的 SQL 语句</td>
</tr>
<tr>
<td align="center">host</td>
<td align="center">显示这个语句是从哪个 ip 的哪个端口上发出的，可以用来追踪出问题语句的用户</td>
</tr>
<tr>
<td align="center">db</td>
<td align="center">显示这个进程目前连接的是哪个数据库</td>
</tr>
<tr>
<td align="center">command</td>
<td align="center">显示当前连接的执行命令，一般就是休眠（sleep），查询（query），连接（connect）</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">这个状态持续的时间，单位是秒</td>
</tr>
<tr>
<td align="center">state</td>
<td align="center">显示使用当前连接的 SQL 语句的状态</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">显示这个 SQL 语句，因为长度有限，所以长的 SQL 语句就会显示不全，是判断问题语句的重要依据</td>
</tr>
</tbody></table>
<p>下面通过<code>innodb_lock_waits</code>和<code>innodb_locks</code>两张表来判断持有锁和锁等待的对象。本例中 22696 是锁等待的对象，22695 是持有锁的对象。</p>
<p><code>innodb_lock_waits</code>表包含每个被阻止 InnoDB 事务的一个或多个行，指示它已请求的锁以及阻止该请求的任何锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.innodb_lock_waits \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">requesting_trx_id: 22696</span><br><span class="line">requested_lock_id: 22696:197:3:1</span><br><span class="line">  blocking_trx_id: 22695</span><br><span class="line">blocking_lock_id: 22695:197:3:1</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>以上各列含义说明如下：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">requesting_trx_id</td>
<td align="center">请求（阻止）事务的 id</td>
</tr>
<tr>
<td align="center">requested_lock_id</td>
<td align="center">事务正在等待的锁的id</td>
</tr>
<tr>
<td align="center">blocking_trx_id</td>
<td align="center">阻止事务的 id</td>
</tr>
<tr>
<td align="center">blocking_lock_id</td>
<td align="center">阻止另一个事务继续进行的事务所持有的锁的 id</td>
</tr>
<tr>
<td align="center">innodb_locks</td>
<td align="center">表提供有关 InnoDB 事务已请求但尚未获取的每个锁的信息，以及事务持有的阻止另一个事务的锁。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.innodb_locks \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">    lock_id: 22696:197:3:1</span><br><span class="line">lock_trx_id: 22696</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line">lock_table: `test`.`tb_student`</span><br><span class="line">lock_index: PRIMARY</span><br><span class="line">lock_space: 197</span><br><span class="line">  lock_page: 3</span><br><span class="line">   lock_pec: 1</span><br><span class="line">  lock_data: supremum pseudo-record</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">    lock_id: 22695:197:3:1</span><br><span class="line">lock_trx_id: 22695</span><br><span class="line">  lock_mode: X</span><br><span class="line">  lock_type: RECORD</span><br><span class="line">lock_table: `test`.`tb_student`</span><br><span class="line">lock_index: PRIMARY</span><br><span class="line">lock_space: 197</span><br><span class="line">  lock_page: 3</span><br><span class="line">   lock_pec: 1</span><br><span class="line">  lock_data: supremum pseudo-record</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>以上各列含义说明如下：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock_id</td>
<td align="center">一个唯一的锁 id 号，内部为 InnoDB</td>
</tr>
<tr>
<td align="center">lock_trx_id</td>
<td align="center">持有锁的交易的 id</td>
</tr>
<tr>
<td align="center">lock_mode</td>
<td align="center">如何请求锁定。允许锁定模式描述符 S，X， IS，IX， GAP，AUTO_INC 和 UNKNOWN。锁定模式描述符可以组合使用以识别特定的锁定模式。</td>
</tr>
<tr>
<td align="center">lock_type</td>
<td align="center">锁的类型</td>
</tr>
<tr>
<td align="center">lock_table</td>
<td align="center">已锁定或包含锁定记录的表的名称</td>
</tr>
<tr>
<td align="center">lock_index</td>
<td align="center">索引的名称，如果 lock_type 是 RECORD，否则 NULL</td>
</tr>
<tr>
<td align="center">lock_space</td>
<td align="center">锁定记录的表空间 id，如果 lock_type 是 RECORD，否则 NULL</td>
</tr>
<tr>
<td align="center">lock_page</td>
<td align="center">锁定记录的页码，如果 lock_type 是 RECORD，否则 NULL。</td>
</tr>
<tr>
<td align="center">lock_pec</td>
<td align="center">页面内锁定记录的堆号，如果 lock_type 是 RECORD，否则 NULL。</td>
</tr>
<tr>
<td align="center">lock_data</td>
<td align="center">与锁相关的数据。</td>
</tr>
</tbody></table>
<p>如果<code>lock_type</code>是<code>RECORD</code>，是锁定的记录的主键值，否则<code>NULL</code>。此列包含锁定行中主键列的值，格式为有效的 SQL 字符串。如果没有主键，<code>lock_data</code>则是唯一的 InnoDB 内部行 id 号。如果对键值或范围高于索引中的最大值的间隙锁定，则<code>lock_data</code>报告<code>supremum pseudo-record</code>。当包含锁定记录的页面不在缓冲池中时（如果在保持锁定时将其分页到磁盘），InnoDB 不从磁盘获取页面，以避免不必要的磁盘操作。相反，<code>lock_data</code>设置为<code>NULL</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL事务"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/15/MySQL/MySQL%E4%BA%8B%E5%8A%A1/"
    >MySQL 事务</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/05/15/MySQL/MySQL%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time datetime="2020-05-15T11:32:08.000Z" itemprop="datePublished">2020-05-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="数据库事务的概念和特性"><a href="#数据库事务的概念和特性" class="headerlink" title="数据库事务的概念和特性"></a>数据库事务的概念和特性</h1><p>数据库的事务（<code>Transaction</code>）是一种机制、一个操作序列，包含了一组数据库操作命令。事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。</p>
<p>在数据库系统上执行并发操作时，事务是作为最小的控制单元来使用的，特别适用于多用户同时操作的数据库系统。例如，航空公司的订票系统、银行、保险公司以及证券交易系统等。</p>
<p>事务具有 4 个特性，即原子性（<code>Atomicity</code>）、一致性（<code>Consistency</code>）、隔离性（<code>Isolation</code>）和持久性（<code>Durability</code>），这 4 个特性通常简称为<code>ACID</code>。</p>
<ol>
<li>原子性<br>事务是一个完整的操作。事务的各元素是不可分的。事务中的所有元素必须作为一个整体提交或回滚。如果事务中的任何元素失败，则整个事务将失败。</li>
<li>一致性<br>当事务完成时，数据必须处于一致状态。也就是说，在事务开始之前，数据库中存储的数据处于一致状态。在正在进行的事务中，数据可能处于不一致的状态，如数据可能有部分被修改。然而，当事务成功完成时，数据必须再次回到已知的一致状态。通过事务对数据所做的修改不能损坏数据，或者说事务不能使数据存储处于不稳定的状态。</li>
<li>隔离性<br>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。修改数据的事务可以在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据。<br>另外，当事务修改数据时，如果任何其他进程正在同时使用相同的数据，则直到该事务成功提交之后，对数据的修改才能生效。</li>
<li>持久性<br>事务的持久性指不管系统是否发生了故障，事务处理的结果都是永久的。<br>一个事务成功完成之后，它对数据库所作的改变是永久性的，即使系统出现故障也是如此。也就是说，一旦事务被提交，事务对数据所做的任何变动都会被永久地保留在数据库中。</li>
</ol>
<p>事务的<code>ACID</code>原则保证了一个事务或者成功提交，或者失败回滚，二者必居其一。因此，它对事务的修改具有可恢复性。即当事务失败时，它对数据的修改都会恢复到该事务执行前的状态。</p>
<h1 id="执行事务的语法和流程"><a href="#执行事务的语法和流程" class="headerlink" title="执行事务的语法和流程"></a>执行事务的语法和流程</h1><p>MySQL 提供了多种存储引擎来支持事务。支持事务的存储引擎有 InnoDB 和 BDB，其中，InnoDB 存储引擎事务主要通过 UNDO 日志和 REDO 日志实现，MyISAM 存储引擎不支持事务。</p>
<p>为了维护 MySQL 服务器，经常需要在 MySQL 数据库中进行日志操作：</p>
<ul>
<li>UNDO 日志：复制事务执行前的数据，用于在事务发生异常时回滚数据。</li>
<li>REDO 日志：记录在事务执行中，每条对数据进行更新的操作，当事务提交时，该内容将被刷新到磁盘。</li>
</ul>
<p>默认设置下，每条 SQL 语句就是一个事务，即执行 SQL 语句后自动提交。为了达到将几个操作做为一个整体的目的，需要使用<code>BEGIN</code>或<code>START TRANSACTION</code>开启一个事务，或者禁止当前会话的自动提交。</p>
<p>SQL 使用下列语句来管理事务。</p>
<ol>
<li>开始事务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">或</span><br><span class="line">START TRANSACTION;</span><br></pre></td></tr></table></figure>
这个语句显式地标记一个事务的起始点。</li>
<li>提交事务<br>MySQL 使用下面的语句来提交事务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<code>COMMIT</code>表示提交事务，即提交事务的所有操作，具体地说，就是将事务中所有对数据库的更新都写到磁盘上的物理数据库中，事务正常结束。<br>提交事务，意味着将事务开始以来所执行的所有数据都修改成为数据库的永久部分，因此也标志着一个事务的结束。一旦执行了该命令，将不能回滚事务。只有在所有修改都准备好提交给数据库时，才执行这一操作。</li>
<li>回滚（撤销）事务<br>MySQL 使用以下语句回滚事务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>
<code>ROLLBACK</code>表示撤销事务，即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。这里的操作指对数据库的更新操作。<br>当事务执行过程中遇到错误时，使用<code>ROLLBACK</code>语句使事务回滚到起点或指定的保持点处。同时，系统将清除自事务起点或到某个保存点所做的所有的数据修改，并且释放由事务控制的资源。因此，这条语句也标志着事务的结束。</li>
</ol>
<p><code>BEGIN</code>或<code>START TRANSACTION</code>语句后面的 SQL 语句对数据库数据的更新操作都将记录在事务日志中，直至遇到<code>ROLLBACK</code>语句或<code>COMMIT</code>语句。如果事务中某一操作失败且执行了<code>ROLLBACK</code>语句，那么在开启事务语句之后所有更新的数据都能回滚到事务开始前的状态。如果事务中的所有操作都全部正确完成，并且使用了<code>COMMIT</code>语句向数据库提交更新数据，则此时的数据又处在新的一致状态。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面模拟在张三的账户减少 500 元后，李四的账户还未增加 500 时，有其他会话访问数据表的场景。代码需要在两个窗口中执行，这里我们称为 A 窗口和 B 窗口。</p>
<ol>
<li>在 A 窗口中开启一个事务，并更新<code>mybank</code>数据库中<code>bank</code>表的数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE mybank;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; UPDATE bank SET currentMoney = currentMoney-500 WHERE customerName=&#x27;张三&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></li>
<li>在 B 窗口中查询<code>bank</code>数据表中的数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mybank.bank;</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| customerName | currentMoney |</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| 张三         |      1000.00 |</span><br><span class="line">| 李四         |         1.00 |</span><br><span class="line">+--------------+--------------+</span><br></pre></td></tr></table></figure>
从结果可以看出，虽然 A 窗口中的事务已经更改了<code>bank</code>表中的数据，但没有立即更新数据，这时其他会话读取到的仍然是更新前的数据。</li>
<li>在 A 窗口中继续执行事务并提交事务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; UPDATE bank SET currentMoney = currentMoney+500</span><br><span class="line">    -&gt; WHERE customerName=&#x27;李四&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br></pre></td></tr></table></figure></li>
<li>在 B 窗口中再次查询<code>bank</code>数据表的数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mybank.bank;</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| customerName | currentMoney |</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| 张三         |       500.00 |</span><br><span class="line">| 李四         |       501.00 |</span><br><span class="line">+--------------+--------------+</span><br></pre></td></tr></table></figure>
在 A 窗口中执行<code>COMMIT</code>提交事务后，对数据所做的更新将一起提交，其他会话读取到的是更新后的数据。从结果可以看出张三和李四的总账户余额和转账前保持一致，这样数据从一个一致性状态更新到另一个一致性状态。</li>
</ol>
<p>当事务在执行中出现问题，也就是不能按正常的流程执行一个完整的事务时，可以使用<code>ROLLBACK</code>语句进行回滚，使用数据恢复到初始状态。</p>
<p>在上例中，张三的账户余额已经减少到 500 元，如果再转出 1000 元，将会出现余额为负数，因此需要回滚到原始状态。将张三的账户余额减少 1000 元，并让事务回滚：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; UPDATE bank SET currentMoney = currentMoney-1000 WHERE customerName=&#x27;张三&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"> </span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; SELECT * FROM mybank.bank;</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| customerName | currentMoney |</span><br><span class="line">+--------------+--------------+</span><br><span class="line">| 张三         |       500.00 |</span><br><span class="line">| 李四         |       501.00 |</span><br><span class="line">+--------------+--------------+</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，执行事务回滚后，账户数据恢复到初始状态，即该事务执行之前的状态。</p>
<p>在数据库操作中，为了有效保证并发读取数据的正确性，提出了事务的隔离级别。在上例中，事务的隔离级别为默认隔离级别。在 MySQL 中，事务的默认隔离级别是<code>REPEATABLE-READ</code>（可重读）隔离级别，即事务未结束时（未执行<code>COMMIT</code>或<code>ROLLBACK</code>），其它会话只能读取到未提交数据。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>MySQL 事务是一项非常消耗资源的功能，在使用过程中要注意以下几点。</p>
<ol>
<li>事务尽可能简短<br>事务的开启到结束会在数据库管理系统中保留大量资源，以保证事务的原子性、一致性、隔离性和持久性。如果在多用户系统中，较大的事务将会占用系统的大量资源，使得系统不堪重负，会影响软件的运行性能，甚至导致系统崩溃。</li>
<li>事务中访问的数据量尽量最少<br>当并发执行事务处理时，事务操作的数据量越少，事务之间对相同数据的操作就越少。</li>
<li>查询数据时尽量不要使用事务<br>对数据进行浏览查询操作并不会更新数据库的数据，因此应尽量不使用事务查询数据，避免占用过量的系统资源。</li>
<li>在事务处理过程中尽量不要出现等待用户输入的操作<br>在处理事务的过程中，如果需要等待用户输入数据，那么事务会长时间地占用资源，有可能造成系统阻塞。</li>
</ol>
<h1 id="设置事务自动提交（开启和关闭）"><a href="#设置事务自动提交（开启和关闭）" class="headerlink" title="设置事务自动提交（开启和关闭）"></a>设置事务自动提交（开启和关闭）</h1><p>MySQL 默认开启事务自动提交模式，即除非显式的开启事务（<code>BEGIN</code>或<code>START TRANSACTION</code>），否则每条 SQL 语句都会被当做一个单独的事务自动执行。但有些情况下，我们需要关闭事务自动提交来保证数据的一致性。</p>
<p>在 MySQL 中，可以通过<code>SHOW VARIABLES</code>语句查看当前事务自动提交模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure>
<p>结果显示，<code>autocommit</code>的值是<code>ON</code>，表示系统开启自动提交模式。</p>
<p>在 MySQL 中，可以使用<code>SET autocommit</code>语句设置事务的自动提交模式，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = 0|1|ON|OFF;</span><br></pre></td></tr></table></figure>
<p>对取值的说明：</p>
<ul>
<li>值为 0 和值为<code>OFF</code>：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。</li>
<li>值为 1 和值为<code>ON</code>：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面我们关闭事务自动提交，模拟银行转账。</p>
<p>使用<code>SET autocommit</code>语句关闭事务自动提交，且张三转给李四 500 元：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mybank.bank;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> customerName <span class="operator">|</span> currentMoney <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> 张三         <span class="operator">|</span>      <span class="number">1000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李四         <span class="operator">|</span>         <span class="number">1.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> bank <span class="keyword">SET</span> currentMoney <span class="operator">=</span> currentMoney<span class="number">-500</span> <span class="keyword">WHERE</span> customerName<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span> ;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> bank <span class="keyword">SET</span> currentMoney <span class="operator">=</span> currentMoney<span class="operator">+</span><span class="number">500</span> <span class="keyword">WHERE</span> customerName<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这时重新打开一个 cmd 窗口，查看<code>bank</code>数据表中张三和李四的余额：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mybank.bank;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> customerName <span class="operator">|</span> currentMoney <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> 张三         <span class="operator">|</span>      <span class="number">1000.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李四         <span class="operator">|</span>         <span class="number">1.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br></pre></td></tr></table></figure>
<p>结果显示，张三和李四的余额是事务执行前的数据。</p>
<p>下面在之前的窗口中使用<code>COMMIT</code>语句提交事务，并查询<code>bank</code>数据表的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.07</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mybank.bank;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> customerName <span class="operator">|</span> currentMoney <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br><span class="line"><span class="operator">|</span> 张三         <span class="operator">|</span>       <span class="number">500.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李四         <span class="operator">|</span>       <span class="number">501.00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+--------------+</span></span><br></pre></td></tr></table></figure>
<p>结果显示，<code>bank</code>数据表的数据更新成功。</p>
<p>在本例中，关闭自动提交后，该位置会作为一个事务起点，直到执行<code>COMMIT</code>语句和<code>ROLLBACK</code>语句后，该事务才结束。结束之后，这就是下一个事务的起点。</p>
<p>关闭自动提交功能后，只用当执行<code>COMMIT</code>命令后，MySQL 才将数据表中的资料提交到数据库中。如果执行<code>ROLLBACK</code>命令，数据将会被回滚。如果不提交事务，而终止 MySQL 会话，数据库将会自动执行回滚操作。</p>
<p>使用<code>BEGIN</code>或<code>START TRANSACTION</code>开启一个事务之后，自动提交将保持禁用状态，直到使用<code>COMMIT</code>或<code>ROLLBACK</code>结束事务。之后，自动提交模式会恢复到之前的状态，即如果<code>BEGIN</code>前<code>autocommit = 1</code>，则完成本次事务后<code>autocommit</code>还是 1。如果<code>BEGIN</code>前<code>autocommit = 0</code>，则完成本次事务后<code>autocommit</code>还是 0。</p>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>其中事务的隔离性就是指当多个事务同时运行时，各事务之间相互隔离，不可互相干扰。如果事务没有隔离性，就容易出现脏读、不可重复读和幻读等情况。</p>
<p>为了保证并发时操作数据的正确性，数据库都会有事务隔离级别的概念。</p>
<ol>
<li>脏读<br>脏读是指一个事务正在访问数据，并且对数据进行了修改，但是这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li>
<li>不可重复读<br>不可重复读是指在一个事务内，多次读取同一个数据。<br>在这个事务还没有结束时，另外一个事务也访问了该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>
<li>幻读<br>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ol>
<p>为了解决以上这些问题，标准 SQL 定义了 4 类事务隔离级别，用来指定事务中的哪些数据改变是可见的，哪些数据改变是不可见的。</p>
<p>MySQL 包括的事务隔离级别如下：</p>
<ul>
<li>读未提交（<code>READ UNCOMITTED</code>）</li>
<li>读提交（<code>READ COMMITTED</code>）</li>
<li>可重复读（<code>REPEATABLE READ</code>）</li>
<li>串行化（<code>SERIALIZABLE</code>）</li>
</ul>
<p>MySQL 事务隔离级别可能产生的问题如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ UNCOMITTED</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">READ COMMITTED</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">REPEATABLE READ</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>MySQL 的事务的隔离级别由低到高分别为<code>READ UNCOMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE</code>。低级别的隔离级别可以支持更高的并发处理，同时占用的系统资源更少。</p>
<h2 id="1-读未提交（READ-UNCOMITTED，RU）"><a href="#1-读未提交（READ-UNCOMITTED，RU）" class="headerlink" title="1. 读未提交（READ UNCOMITTED，RU）"></a>1. 读未提交（READ UNCOMITTED，RU）</h2><p>顾名思义，读未提交就是可以读到未提交的内容。</p>
<p>如果一个事务读取到了另一个未提交事务修改过的数据，那么这种隔离级别就称之为读未提交。</p>
<p>在该隔离级别下，所有事务都可以看到其它未提交事务的执行结果。因为它的性能与其他隔离级别相比没有高多少，所以一般情况下，该隔离级别在实际应用中很少使用。</p>
<p>下例展示了在读未提交隔离级别中产生的脏读现象。</p>
<ol>
<li>先在<code>test</code>数据库中创建<code>testnum</code>数据表，并插入数据。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testnum(num <span class="type">INT</span>(<span class="number">4</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.57</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.testnum (num) <span class="keyword">VALUES</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>),(<span class="number">4</span>),(<span class="number">5</span>);</span><br><span class="line">Query OK, <span class="number">5</span> <span class="keyword">rows</span> affected (<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure></li>
<li>在 A 窗口中修改事务隔离级别，因为 A 窗口和 B 窗口的事务隔离级别需要保持一致，所以我们使用<code>SET GLOBAL TRANSACTION</code>修改全局变量。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.04</span> sec)</span><br><span class="line">flush privileges;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
查询事务隔离级别，SQL 语句和运行结果如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%tx_isolation%&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: tx_isolation</span><br><span class="line">        Value: READ-UNCOMMITTED</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
结果显示，现在 MySQL 的事务隔离级别为<code>READ-UNCOMMITTED</code>。</li>
<li>在 A 窗口中开启一个事务，并查询<code>testnum</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; SELECT * FROM testnum;</span><br><span class="line">+------+</span><br><span class="line">| num  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">|    3 |</span><br><span class="line">|    4 |</span><br><span class="line">|    5 |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>打开 B 窗口，查看当前 MySQL 的事务隔离级别：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%tx_isolation%&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: tx_isolation</span><br><span class="line">        Value: READ-UNCOMMITTED</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
确定事务隔离级别是<code>READ-UNCOMMITTED</code>后，开启一个事务，并使用<code>UPDATE</code>语句更新<code>testnum</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; UPDATE test.testnum SET num=num*2 WHERE num=2;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></li>
<li>现在返回 A 窗口，再次查询<code>testnum</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM testnum;</span><br><span class="line">+------+</span><br><span class="line">| num  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    4 |</span><br><span class="line">|    3 |</span><br><span class="line">|    4 |</span><br><span class="line">|    5 |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure>
由结果可以看出，A 窗口中的事务读取到了更新后的数据。</li>
<li>下面在 B 窗口中回滚事务，SQL 语句和运行结果如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br></pre></td></tr></table></figure></li>
<li>在 A 窗口中查询<code>testnum</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM testnum;</span><br><span class="line">+------+</span><br><span class="line">| num  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">|    3 |</span><br><span class="line">|    4 |</span><br><span class="line">|    5 |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
当 MySQL 的事务隔离级别为<code>READ UNCOMITTED</code>时，首先分别在 A 窗口和 B 窗口中开启事务，在 B 窗口中的事务更新但未提交之前， A 窗口中的事务就已经读取到了更新后的数据。但由于 B 窗口中的事务回滚了，所以 A 事务出现了脏读现象。</li>
</ol>
<p>使用读提交隔离级别可以解决实例中产生的脏读问题。</p>
<h2 id="2-读提交（READ-COMMITTED，RC）"><a href="#2-读提交（READ-COMMITTED，RC）" class="headerlink" title="2. 读提交（READ COMMITTED，RC）"></a>2. 读提交（READ COMMITTED，RC）</h2><p>顾名思义，读提交就是只能读到已经提交了的内容。</p>
<p>如果一个事务只能读取到另一个已提交事务修改过的数据，并且其它事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那么这种隔离级别就称之为读提交。</p>
<p>该隔离级别满足了隔离的简单定义：一个事务从开始到提交前所做的任何改变都是不可见的，事务只能读取到已经提交的事务所做的改变。</p>
<p>这是大多数数据库系统的默认事务隔离级别（例如 Oracle、SQL Server），但不是 MySQL 默认的。</p>
<p>下例演示了在读提交隔离级别中产生的不可重复读问题。</p>
<ol>
<li>使用<code>SET</code>语句将 MySQL 事务隔离级别修改为<code>READ COMMITTED</code>，并查看。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; show variables like &#x27;%tx_isolation%&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: tx_isolation</span><br><span class="line">        Value: READ-COMMITTED</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>确定当前事务隔离级别为<code>READ COMMITTED</code>后，开启一个事务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>在 B 窗口中开启事务，并使用<code>UPDATE</code>语句更新<code>testnum</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  UPDATE test.testnum SET num=num*2 WHERE num=2;</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></li>
<li>在 A 窗口中查询<code>testnum</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * from test.testnum;</span><br><span class="line">+------+</span><br><span class="line">| num  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">|    3 |</span><br><span class="line">|    4 |</span><br><span class="line">|    5 |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>提交 B 窗口中的事务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br></pre></td></tr></table></figure></li>
<li>在 A 窗口中查询<code>testnum</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * from test.testnum;</span><br><span class="line">+------+</span><br><span class="line">| num  |</span><br><span class="line">+------+</span><br><span class="line">|    1 |</span><br><span class="line">|    4 |</span><br><span class="line">|    3 |</span><br><span class="line">|    4 |</span><br><span class="line">|    5 |</span><br><span class="line">+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
当 MySQL 的事务隔离级别为<code>READ COMMITTED</code>时，首先分别在 A 窗口和 B 窗口中开启事务，在 B 窗口中的事务更新并提交后，A 窗口中的事务读取到了更新后的数据。在该过程中，A 窗口中的事务必须要等待 B 窗口中的事务提交后才能读取到更新后的数据，这样就解决了脏读问题。而处于 A 窗口中的事务出现了不同的查询结果，即不可重复读现象。</li>
</ol>
<p>使用可重复读隔离级别可以解决实例中产生的不可重复读问题。</p>
<h2 id="3-可重复读（REPEATABLE-READ，RR）"><a href="#3-可重复读（REPEATABLE-READ，RR）" class="headerlink" title="3. 可重复读（REPEATABLE READ，RR）"></a>3. 可重复读（REPEATABLE READ，RR）</h2><p>顾名思义，可重复读是专门针对不可重复读这种情况而制定的隔离级别，可以有效的避免不可重复读。</p>
<p>在一些场景中，一个事务只能读取到另一个已提交事务修改过的数据，但是第一次读过某条记录后，即使其它事务修改了该记录的值并且提交，之后该事务再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。那么这种隔离级别就称之为可重复读。</p>
<p>可重复读是 MySQL 的默认事务隔离级别，它能确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。在该隔离级别下，如果有事务正在读取数据，就不允许有其它事务进行修改操作，这样就解决了可重复读问题。</p>
<p>下例演示了在可重复读隔离级别中产生的幻读问题。</p>
<ol>
<li>在<code>test</code>数据库中创建<code>testuser</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE testuser(</span><br><span class="line">    -&gt; id INT (4) PRIMARY KEY,</span><br><span class="line">    -&gt; name VARCHAR(20));</span><br><span class="line">Query OK, 0 rows affected (0.29 sec)</span><br></pre></td></tr></table></figure></li>
<li>使用<code>SET</code>语句修改事务隔离级别：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>在 A 窗口中开启事务，并查询<code>testuser</code>数据表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM test.testuser where id=1;</span><br><span class="line">Empty set (0.04 sec)</span><br></pre></td></tr></table></figure></li>
<li>在 B 窗口中开启一个事务，并向<code>testuser</code>表中插入一条数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; BEGIN;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt;  INSERT INTO test.testuser VALUES(1,&#x27;zhangsan&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure></li>
<li>现在返回 A 窗口，向<code>testnum</code>数据表中插入数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO test.testuser VALUES(1,&#x27;lisi&#x27;);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line">mysql&gt;  SELECT * FROM test.testuser where id=1;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用串行化隔离级别可以解决实例中产生的幻读问题。</p>
<h2 id="4-串行化（SERIALIZABLE）"><a href="#4-串行化（SERIALIZABLE）" class="headerlink" title="4. 串行化（SERIALIZABLE）"></a>4. 串行化（SERIALIZABLE）</h2><p>如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。那么这种隔离级别就称之为串行化。</p>
<p><code>SERIALIZABLE</code>是最高的事务隔离级别，主要通过强制事务排序来解决幻读问题。简单来说，就是在每个读取的数据行上加上共享锁实现，这样就避免了脏读、不可重复读和幻读等问题。但是该事务隔离级别执行效率低下，且性能开销也最大，所以一般情况下不推荐使用。</p>
<h1 id="查看和修改事务隔离级别"><a href="#查看和修改事务隔离级别" class="headerlink" title="查看和修改事务隔离级别"></a>查看和修改事务隔离级别</h1><h2 id="查看事务隔离级别"><a href="#查看事务隔离级别" class="headerlink" title="查看事务隔离级别"></a>查看事务隔离级别</h2><p>在 MySQL 中，可以通过<code>show variables like &#39;%tx_isolation%&#39;</code>或<code>select @@tx_isolation;</code>语句来查看当前事务隔离级别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%tx_isolation%&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| tx_isolation  | REPEATABLE-READ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.17 sec）</span><br><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>结果显示，目前 MySQL 的事务隔离级别是<code>REPEATABLE-READ</code>。</p>
<p>另外，还可以使用下列语句分别查询全局和会话的事务隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@global.tx_isolation;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：在 MySQL 8.0.3 中，<code>tx_isolation</code>变量被<code>transaction_isolation</code>变量替换了。在 MySQL 8.0.3 版本中查询事务隔离级别，只要把上述查询语句中的<code>tx_isolation</code>变量替换成<code>transaction_isolation</code>变量即可。</p>
</blockquote>
<h2 id="修改事务隔离级别"><a href="#修改事务隔离级别" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h2><p>MySQL 提供了<code>SET TRANSACTION</code>语句，该语句可以改变单个会话或全局的事务隔离级别。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>SESSION</code>和<code>GLOBAL</code>关键字用来指定修改的事务隔离级别的范围：</p>
<ul>
<li><code>SESSION</code>：表示修改的事务隔离级别将应用于当前<code>session</code>（当前 cmd 窗口）内的所有事务；</li>
<li><code>GLOBAL</code>：表示修改的事务隔离级别将应用于所有<code>session</code>（全局）中的所有事务，且当前已经存在的<code>session</code>不受影响；</li>
<li>如果省略<code>SESSION</code>和<code>GLOBAL</code>，表示修改的事务隔离级别将应用于当前<code>session</code>内的下一个还未开始的事务。</li>
</ul>
<p>任何用户都能改变会话的事务隔离级别，但是只有拥有<code>SUPER</code>权限的用户才能改变全局的事务隔离级别。</p>
<p>如果使用普通用户修改全局事务隔离级别，就会提示需要超级权限才能执行此操作的错误信息，SQL 语句和运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\leovo&gt;mysql -utestuser -p</span><br><span class="line">Enter password: ******</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 41</span><br><span class="line">Server version: 5.7.29-log MySQL Community Server (GPL)</span><br><span class="line"> </span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"> </span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"> </span><br><span class="line">Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.</span><br><span class="line"> </span><br><span class="line">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">ERROR 1227 (42000): Access denied; you need (at least one of) the SUPER privilege(s) for this operation</span><br><span class="line">mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>使用<code>SET TRANSACTION</code>语句分别修改<code>session</code>和全局的事务隔离级别 SQL 语句和运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select @@session.tx_isolation;</span><br><span class="line">+------------------------+</span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+------------------------+</span><br><span class="line">| SERIALIZABLE           |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;  select @@global.tx_isolation;</span><br><span class="line">+-----------------------+</span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+-----------------------+</span><br><span class="line">| REPEATABLE-READ       |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>还可以使用<code>set tx_isolation</code>命令直接修改当前<code>session</code>的事务隔离级别，SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;READ-COMMITTED&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@session</span>.tx_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@session</span>.tx_isolation <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>COMMITTED         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL高级查询"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/10/MySQL/MySQL%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/"
    >MySQL 高级查询</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/05/10/MySQL/MySQL%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time datetime="2020-05-10T03:42:54.000Z" itemprop="datePublished">2020-05-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <!-- MySQL必知必会 -->

<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><p>SQL还允许创建子查询，即嵌套在其他查询中的查询。</p>
<h2 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h2><p>订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，<code>orders</code>表存储一行。各订单的物品存储在相关的<code>orderitems</code>表中。<code>orders</code>表不存储客户信息。它只存储客户的 ID。实际的客户信息存储在<code>customers</code>表中。</p>
<p>现在，假如需要列出订购物品 TNT2 的所有客户，具体的步骤：</p>
<ol>
<li>检索包含物品 TNT2 的所有订单的编号。</li>
<li>检索具有前一步骤列出的订单编号的所有客户的 ID。</li>
<li>检索前一步骤返回的所有客户 ID 的客户信息。</li>
</ol>
<p>上述每个步骤都可以单独作为一个查询来执行。可以把一条<code>SELECT</code>语句返回的结果用于另一条<code>SELECT</code>语句的<code>WHERE</code>子句。</p>
<p>也可以使用子查询来把3个查询组合成一条语句。</p>
<p>第一条<code>SELECT</code>语句的含义很明确，对于<code>prod_id</code>为<code>TNT2</code>的所有订单物品，它检索其<code>order_num</code>列。输出列出两个包含此物品的订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">order_num</span></span><br><span class="line"><span class="comment">20005</span></span><br><span class="line"><span class="comment">20007</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下一步，查询具有订单 20005 和 20007 的客户 ID。利用<code>IN</code>子句，编写如下的<code>SELECT</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="number">20005</span>, <span class="number">20007</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">cust_id</span></span><br><span class="line"><span class="comment">10001</span></span><br><span class="line"><span class="comment">10004</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>现在，把第一个查询（返回订单号的那一个）变为子查询组合两个查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_num</span><br><span class="line"><span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在得到了订购物品<code>TNT2</code>的所有客户的 ID。下一步是检索这些客户 ID 的客户信息。检索两列的 SQL 语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span> (<span class="number">10001</span>, <span class="number">10004</span>);</span><br></pre></td></tr></table></figure>
<p>可以把其中的<code>WHERE</code>子句转换为子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id</span><br><span class="line"><span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> cust_id</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">WHERE</span> order_num</span><br><span class="line">  <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br><span class="line">  );</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可见，在<code>WHERE</code>子句中使用子查询能够编写出功能很强并且很灵活的 SQL 语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>使用子查询的另一方法是创建计算字段。假如需要显示<code>customers</code>表中每个客户的订单总数。订单与相应的客户 ID 存储在<code>orders</code>表中。为了执行这个操作，遵循下面的步骤。</p>
<ol>
<li>从<code>customers</code>表中检索客户列表。</li>
<li>对于检索出的每个客户，统计其在<code>orders</code>表中的订单数目。</li>
</ol>
<p>可使用<code>SELECT COUNT(*)</code>对表中的行进行计数，并且通过提供一条<code>WHERE</code>子句来过滤某个特定的客户 ID，可仅对该客户的订单进行计数。例如，下面的代码对客户 10001 的订单进行计数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> orders <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> cust_id <span class="operator">=</span> <span class="number">10001</span>;</span><br></pre></td></tr></table></figure>
<p>为了对每个客户执行<code>COUNT(*)</code>计算，应该将<code>COUNT(*)</code>作为一个子查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  cust_name,</span><br><span class="line">  cust_state,</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">FROM</span> orders</span><br><span class="line">    <span class="keyword">WHERE</span> orders.cust_id <span class="operator">=</span> customer.cust_id</span><br><span class="line">  ) <span class="keyword">AS</span> orders</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">  cust_name;</span><br></pre></td></tr></table></figure>
<p>这条<code>SELECT</code>语句对<code>customers</code>表中每个客户返回 3 列：<code>cust_name、cust_state</code>和<code>orders</code>。<code>orders</code>是一个计算字段，它是由圆括号中的子查询建立的。该子查询对检索出的每个客户执行一<br>次。在此例子中，该子查询执行了5次，因为检索出了5个客户。</p>
<p>子查询中的WHERE子句使用了完全限定列名。这种类型的子查询称为相关子查询。任何时候只要列名可能有多义性，就必须使用这种语法（表名和列名由一个句点分隔）。</p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h2><p>SQL最强大的功能之一就是能在数据检索查询的执行中联结（<code>join</code>）表。</p>
<h4 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h4><p>理解关系表的最好方法是来看一个现实世界中的例子。</p>
<p>假如有一个包含产品目录的数据库表，其中每种类别的物品占一行。对于每种物品要存储的信息包括产品描述和价格，以及生产该产品的供应商信息。</p>
<p>现在，假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？将这些数据与产品信息分开存储的理由如下。</p>
<ul>
<li>因为同一供应商生产的每个产品的供应商信息都是相同的，对每个产品重复此信息既浪费时间又浪费存储空间。</li>
<li>如果供应商信息改变（例如，供应商搬家或电话号码变动），只需改动一次即可。</li>
<li>如果有重复数据（即每种产品都存储供应商信息），很难保证每次输入该数据的方式都相同。不一致的数据在报表中很难利用。</li>
</ul>
<p>关键是，相同数据出现多次决不是一件好事，此因素是关系数据库设计的基础。关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系）互相关联。</p>
<p>在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。<code>vendors</code>表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键（<code>primary key</code>），可以是供应商 ID 或任何其他唯一值。</p>
<p><code>products</code>表只存储产品信息，它除了存储供应商 ID（<code>vendors</code>表的主键）外不存储其他供应商信息。<code>vendors</code>表的主键又叫作<code>products</code>的外键，它将<code>vendors</code>表与<code>products</code>表关联，利用供应商 ID 能从<code>vendors</code>表中找出相应供应商的详细信息。</p>
<p>外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。</p>
<p>这样做的好处如下：</p>
<ul>
<li>供应商信息不重复，从而不浪费时间和空间；</li>
<li>如果供应商信息变动，可以只更新vendors表中的单个记录，相关表中的数据不用改动；</li>
<li>由于数据无重复，显然数据是一致的，这使得处理数据更简单。</li>
</ul>
<p>总之，关系数据可以有效地存储和方便地处理。因此，关系数据库的可伸缩性远比非关系数据库要好。</p>
<h4 id="为什么要使用联结"><a href="#为什么要使用联结" class="headerlink" title="为什么要使用联结"></a>为什么要使用联结</h4><p>正如所述，分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。如果数据存储在多个表中，怎样用单条<code>SELECT</code>语句检索出数据？答案是使用联结。简单地说，联结是一种机制，用来在一条<code>SELECT</code>语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p>
<h2 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h2><p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors, products</span><br><span class="line"><span class="keyword">WHERE</span> vendors.vend_id <span class="operator">=</span> products.vend_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<p>利用<code>WHERE</code>子句建立联结关系似乎有点奇怪，但实际上，有一个很充分的理由。请记住，在一条<code>SELECT</code>语句中联结几个表时，相应的关系是在运行中构造的。在数据库表的定义中不存在能指示 MySQL 如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。<code>WHERE</code>子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有<code>WHERE</code>子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。</p>
<p>应该保证所有联结都有<code>WHERE</code>子句，否则 MySQL 将返回比想要的数据多得多的数据。同理，应该保证<code>WHERE</code>子句的正确性。不正确的过滤条件将导致 MySQL 返回不正确的数据。</p>
<h4 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h4><p>目前为止所用的联结称为等值联结，它基于两个表之间的相等测试。这种联结也称为内部联结。其实，对于这种联结可以使用稍微不同的语法来明确指定联结的类型。下面的<code>SELECT</code>语句返回与前面例<br>子完全相同的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id <span class="operator">=</span> products.vend_id;</span><br></pre></td></tr></table></figure>
<p>此语句中的<code>SELECT</code>与前面的<code>SELECT</code>语句相同，但<code>FROM</code>子句不同。这里，两个表之间的关系是<code>FROM</code>子句的组成部分，以<code>INNER JOIN</code>指定。在使用这种语法时，联结条件用特定的<code>ON</code>子句而不是<code>WHERE</code>子句给出。传递给<code>ON</code>的实际条件与传递给<code>WHERE</code>的相同。</p>
<h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><p>SQL 对一条<code>SELECT</code>语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, vend_name, prod_price, quantity</span><br><span class="line"><span class="keyword">FROM</span> orderitems, products, vendors</span><br><span class="line"><span class="keyword">WHERE</span> products.vend_id <span class="operator">=</span> vendors.vend_id <span class="keyword">AND</span> orderitems.prod_id <span class="operator">=</span> products.prod_id <span class="keyword">AND</span> order_num <span class="operator">=</span> <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<p>此例子显示编号为 20005 的订单中的物品。订单物品存储在<code>orderitems</code>表中。每个产品按其产品 ID 存储，它引用<code>products</code>表中的产品。这些产品通过供应商ID联结到<code>vendors</code>表中相应的供应商，供应商 ID 存储在每个产品的记录中。这里的<code>FROM</code>子句列出了 3 个表，而<code>WHERE</code>子句定义了这两个联结条件，而第三个联结条件用来过滤出订单 20005 中的物品。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id</span><br><span class="line"><span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> cust_id</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">WHERE</span> order_num</span><br><span class="line">  <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> order_num <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br><span class="line">  );</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>子查询并不总是执行复杂<code>SELECT</code>操作的最有效的方法，下面是使用联结的相同查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers, orders, orderitems</span><br><span class="line"><span class="keyword">WHERE</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num <span class="operator">=</span> orders.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><h2 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h2><p>别名除了用于列名和计算字段外，SQL 还允许给表名起别名。这样做有两个主要理由：</p>
<ul>
<li>缩短 SQL 语句；</li>
<li>允许在单条<code>SELECT</code>语句中多次使用相同的表。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">AND</span> oi.order_num <span class="operator">=</span> o.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;TNT2&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在此例子中，表别名只用于<code>WHERE</code>子句。但是，表别名不仅能用于<code>WHERE</code>子句，它还可以用于<code>SELECT</code>的列表、<code>ORDER BY</code>子句以及语句的其他部分。</p>
<p>应该注意，表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户机。</p>
<h2 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h2><h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><p>使用表别名的主要原因之一是能在单条<code>SELECT</code>语句中不止一次引用相同的表。下面举一个例子。</p>
<p>假如你发现某物品（其 ID 为<code>DTNTR</code>）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产 ID 为<code>DTNTR</code>的物品的供应商，然后找出这个供应商生产的其他物品。下面是解决此问题的一种方法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_id, prod_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="operator">=</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> vend_id</span><br><span class="line">  <span class="keyword">FROM</span> products</span><br><span class="line">  <span class="keyword">WHERE</span> prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这是第一种解决方案，它使用了子查询。内部的<code>SELECT</code>语句做了一个简单的检索，返回生产 ID 为<code>DTNTR</code>的物品供应商的<code>vend_id</code>。该 ID 用于外部查询的<code>WHERE</code>子句中，以便检索出这个供应商生产的所有物品。现在来看使用联结的相同查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</span><br><span class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.vend_id <span class="operator">=</span> p2.vend_id <span class="keyword">AND</span> p2.prod_id <span class="operator">=</span> <span class="string">&#x27;DTNTR&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>此查询中需要的两个表实际上是相同的表，因此<code>products</code>表在<code>FROM</code>子句中出现了两次。虽然这是完全合法的，但对<code>products</code>的引用具有二义性，因为 MySQL 不知道你引用的是<code>products</code>表中的哪个实例。</p>
<p>为解决此问题，使用了表别名。<code>products</code>的第一次出现为别名<code>p1</code>，第二次出现为别名<code>p2</code>。现在可以将这些别名用作表名。例如，<code>SELECT</code>语句使用<code>p1</code>前缀明确地给出所需列的全名。如果不这样，MySQL 将返回错误，因为分别存在两个名为<code>prod_id</code>、<code>prod_name</code>的列。MySQL 不知道想要的是哪一个列（即使它们事实上是同一个列）。<code>WHERE</code>（通过匹配<code>p1</code>中的<code>vend_id</code>和<code>p2</code>中的<code>vend_id</code>）首先联结两个表，然后按第二个表中的<code>prod_id</code>过滤数据，返回所需的数据。</p>
<p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。</p>
<h4 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h4><p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。</p>
<p>怎样完成这项工作呢？答案是，系统不完成这项工作，由你自己完成它。自然联结是这样一种联结，其中你只能选择那些唯一的列。这一般是通过对表使用通配符（<code>SELECT *</code>），对所有其他表的列使用明确的子集来完成的。下面举一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.<span class="operator">*</span>, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id <span class="operator">=</span> o.cust_id</span><br><span class="line"><span class="keyword">AND</span> oi.order_num <span class="operator">=</span> o.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id <span class="operator">=</span> <span class="string">&#x27;FB&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来。</p>
<p>事实上，迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结。</p>
<h4 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h4><p>许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。例如，可能需要使用联结来完成以下工作：</p>
<ul>
<li>对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户；</li>
<li>列出所有产品以及订购数量，包括没有人订购的产品；</li>
<li>计算平均销售规模，包括那些至今尚未下订单的客户。</li>
</ul>
<p>在上述例子中，联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。</p>
<p>下面的<code>SELECT</code>语句给出一个简单的内部联结。它检索所有客户及其订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>外部联结语法类似。为了检索所有客户，包括那些没有订单的客户，可如下进行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>这条<code>SELECT</code>语句使用了关键字<code>OUTER JOIN</code>来指定联结的类型（而不是在<code>WHERE</code>子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用<code>OUTER JOIN</code>语法时，必须使用<code>RIGHT</code>或<code>LEFT</code>关键字指定包括其所有行的表（<code>RIGHT</code>指出的是<code>OUTER JOIN</code>右边的表，而<code>LEFT</code>指出的是<code>OUTER JOIN</code>左边的表）。上面的例子使用&#96;&#96;LEFT OUTER JOIN<code>从</code>FROM<code>子句的左边表（</code>customers<code>表）中选择所有行。为了从右边的表中选择所有行，应该使用</code>RIGHT OUTER JOIN&#96;，如下例所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_id, orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>存在两种基本的外部联结形式：左外部联结和右外部联结。它们之间的唯一差别是所关联的表的顺序不同。换句话说，左外部联结可通过颠倒<code>FROM</code>或<code>WHERE</code>子句中表的顺序转换为右外部联结。因此，两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。</p>
<h2 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h2><p>聚集函数用来汇总数据。虽然至今为止聚集函数的所有例子只是从单个表汇总数据，但这些函数也可以与联结一起使用。</p>
<p>为说明这一点，请看一个例子。如果要检索所有客户及每个客户所下的订单数，下面使用了<code>COUNT()</code>函数的代码可完成此工作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name, customers.cust_id, <span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>此<code>SELECT</code>语句使用<code>INNER JOIN</code>将<code>customers</code>和<code>orders</code>表互相关联。<code>GROUP BY</code>子句按客户分组数据，因此，函数调用<code>COUNT(orders.order_num)</code>对每个客户的订单计数，将它作为<code>num_ord</code>返回。</p>
<p>聚集函数也可以方便地与其他联结一起使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name, customers.cust_id, <span class="built_in">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> orders</span><br><span class="line"><span class="keyword">ON</span> customers.cust_id <span class="operator">=</span> orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>这个例子使用左外部联结来包含所有客户，甚至包含那些没有任何下订单的客户。结果显示也包含了客户<code>Mouse House</code>，它有 0 个订单。</p>
<h2 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h2><ul>
<li>注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。</li>
<li>保证使用正确的联结条件，否则将返回不正确的数据。</li>
<li>应该总是提供联结条件，否则会得出笛卡儿积。</li>
<li>在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。</li>
</ul>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>多数 SQL 查询都只包含从一个或多个表中返回数据的单条<code>SELECT</code>语句。MySQL也允许执行多个查询（多条<code>SELECT</code>语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（<code>union</code>）或复合查询（<code>compound query</code>）。</p>
<p>有两种基本情况需要使用组合查询：</p>
<ul>
<li>在单个查询中从不同的表返回类似结构的数据；</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
<p>多数情况下，组合相同表的两个查询完成的工作与具有多个<code>WHERE</code>子句条件的单条查询完成的工作相同。换句话说，任何具有多个<code>WHERE</code>子句的<code>SELECT</code>语句都可以作为一个组合查询给出。</p>
<p>这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。</p>
<h2 id="创建组合查询"><a href="#创建组合查询" class="headerlink" title="创建组合查询"></a>创建组合查询</h2><p>可用<code>UNION</code>操作符来组合数条 SQL 查询。利用<code>UNION</code>，可给出多条<code>SELECT</code>语句，将它们的结果组合成单个结果集。</p>
<h4 id="使用UNION"><a href="#使用UNION" class="headerlink" title="使用UNION"></a>使用UNION</h4><p><code>UNION</code>的使用很简单。所需做的只是给出每条<code>SELECT</code>语句，在各条语句之间放上关键字<code>UNION</code>。</p>
<p>举一个例子，假如需要价格小于等于 5 的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品（不考虑价格）。当然，可以利用<code>WHERE</code>子句来完成此工作，不过这次我们将使用<code>UNION</code>。</p>
<p>正如所述，创建<code>UNION</code>涉及编写多条<code>SELECT</code>语句。首先来看单条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p>第一条<code>SELECT</code>检索价格不高于5的所有物品。第二条<code>SELECT</code>使 用IN找出供应商 1001 和 1002 生产的所有物品。</p>
<p>为了组合这两条语句，按如下进行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<p><code>UNION</code>指示 MySQL 执行两条<code>SELECT</code>语句，并把输出组合成单个查询结果集。</p>
<p>作为参考，这里给出使用多条<code>WHERE</code>子句而不是使用<code>UNION</code>的相同查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">OR</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>);</span><br></pre></td></tr></table></figure>
<h4 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h4><ul>
<li><code>UNION</code>必须由两条或两条以上的<code>SELECT</code>语句组成，语句之间用关键字<code>UNION</code>分隔（因此，如果组合 4 条<code>SELECT</code>语句，将要使用 3 个<code>UNION</code>关键字）。</li>
<li><code>UNION</code>中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是 DBMS 可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li>
</ul>
<p>如果遵守了这些基本规则或限制，则可以将并用于任何数据检索任务。</p>
<h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><p>在使用<code>UNION</code>时，重复的行被自动取消。这是<code>UNION</code>的默认行为，但是如果需要，可以改变它。事实上，如果想返回所有匹配行，可使用<code>UNION ALL</code>而不是<code>UNION</code>。</p>
<h4 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h4><p><code>SELECT</code>语句的输出用<code>ORDER BY</code>子句排序。在用<code>UNION</code>组合查询时，只能使用一条<code>ORDER BY</code>子句，它必须出现在最后一条<code>SELECT</code>语句之后。对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条<code>ORDER BY</code>子句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price <span class="operator">&lt;=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_id, prod_id, prod_price</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> vend_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_id, prod_price;</span><br></pre></td></tr></table></figure>
<p>虽然<code>ORDER BY</code>子句似乎只是最后一条<code>SELECT</code>语句的组成部分，但实际上 MySQL 将用它来排序所有<code>SELECT</code>语句返回的所有结果。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL触发器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/MySQL/MySQL%E8%A7%A6%E5%8F%91%E5%99%A8/"
    >MySQL 触发器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/05/08/MySQL/MySQL%E8%A7%A6%E5%8F%91%E5%99%A8/" class="article-date">
  <time datetime="2020-05-08T09:57:08.000Z" itemprop="datePublished">2020-05-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="触发器到底是什么"><a href="#触发器到底是什么" class="headerlink" title="触发器到底是什么"></a>触发器到底是什么</h1><p>MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。</p>
<p>触发器与数据表关系密切，主要用于保护表中的数据。特别是当有多个表具有一定的相互联系的时候，触发器能够让不同的表保持数据的一致性。</p>
<p>在 MySQL 中，只有执行 INSERT、UPDATE 和 DELETE 操作时才能激活触发器，其它 SQL 语句则不会激活触发器。</p>
<p>那么为什么要使用触发器呢？比如，在实际开发项目时，我们经常会遇到以下情况：<br>在学生表中添加一条关于学生的记录时，学生的总数就必须同时改变。<br>增加一条学生记录时，需要检查年龄是否符合范围要求。<br>删除一条学生信息时，需要删除其成绩表上的对应记录。<br>删除一条数据时，需要在数据库存档表中保留一个备份副本。</p>
<p>虽然上述情况实现的业务逻辑不同，但是它们都需要在数据表发生更改时，自动进行一些处理。这时就可以使用触发器处理。例如，对于第一种情况，可以创建一个触发器对象，每当添加一条学生记录时，就执行一次计算学生总数的操作，这样就可以保证每次添加一条学生记录后，学生总数和学生记录数是一致的。</p>
<h2 id="触发器的优缺点"><a href="#触发器的优缺点" class="headerlink" title="触发器的优缺点"></a>触发器的优缺点</h2><p>触发器的优点如下：</p>
<ul>
<li>触发器的执行是自动的，当对触发器相关表的数据做出相应的修改后立即执行。</li>
<li>触发器可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。</li>
<li>触发器可以实现表数据的级联更改，在一定程度上保证了数据的完整性。</li>
</ul>
<p>触发器的缺点如下：</p>
<ul>
<li>使用触发器实现的业务逻辑在出现问题时很难进行定位，特别是涉及到多个触发器的情况下，会使后期维护变得困难。</li>
<li>大量使用触发器容易导致代码结构被打乱，增加了程序的复杂性，</li>
<li>如果需要变动的数据量较大时，触发器的执行效率会非常低。</li>
</ul>
<h2 id="MySQL-支持的触发器"><a href="#MySQL-支持的触发器" class="headerlink" title="MySQL 支持的触发器"></a>MySQL 支持的触发器</h2><p>在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。</p>
<ol>
<li>INSERT 触发器<br>在 INSERT 语句执行之前或之后响应的触发器。</li>
</ol>
<p>使用 INSERT 触发器需要注意以下几点：<br>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。<br>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。<br>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。<br>2) UPDATE 触发器<br>在 UPDATE 语句执行之前或之后响应的触发器。</p>
<p>使用 UPDATE 触发器需要注意以下几点：<br>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。<br>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。<br>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。<br>OLD 中的值全部是只读的，不能被更新。</p>
<p>注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。<br>3) DELETE 触发器<br>在 DELETE 语句执行之前或之后响应的触发器。</p>
<p>使用 DELETE 触发器需要注意以下几点：<br>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。<br>OLD 中的值全部是只读的，不能被更新。</p>
<p>总体来说，触发器使用的过程中，MySQL 会按照以下方式来处理错误。</p>
<p>对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。</p>
<p>若 BEFORE 触发程序失败，则 MySQL 将不执行相应行上的操作。</p>
<p>若在 BEFORE 或 AFTER 触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。</p>
<p>仅当 BEFORE 触发程序和行操作均已被成功执行，MySQL 才会执行 AFTER 触发程序。</p>
<h1 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h1><p>触发器是与 MySQL 数据表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>在 MySQL 5.7 中，可以使用<code>CREATE TRIGGER</code>语句创建触发器。</p>
<p>语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="operator">&lt;</span> BEFORE <span class="operator">|</span> AFTER <span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span> <span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">Row</span><span class="operator">&lt;</span>触发器主体<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法说明如下。</p>
<ol>
<li>触发器名<br>触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。</li>
<li>INSERT | UPDATE | DELETE<br>触发事件，用于指定激活触发器的语句的种类。</li>
</ol>
<p>注意：三种触发器的执行时间如下。<br>INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。<br>DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。<br>UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。<br>3) BEFORE | AFTER<br>BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。<br>4) 表名<br>与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。<br>5) 触发器主体<br>触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。<br>6) FOR EACH ROW<br>一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。</p>
<p>注意：每个表都支持 INSERT、UPDATE 和 DELETE 的 BEFORE 与 AFTER，因此每个表最多支持 6 个触发器。每个表的每个事件每次只允许有一个触发器。单一触发器不能与多个事件或多个表关联。</p>
<p>另外，在 MySQL 中，若需要查看数据库中已有的触发器，则可以使用<code>SHOW TRIGGERS</code>语句。</p>
<h2 id="创建-BEFORE-类型触发器"><a href="#创建-BEFORE-类型触发器" class="headerlink" title="创建 BEFORE 类型触发器"></a>创建 BEFORE 类型触发器</h2><p>在 test_db 数据库中，数据表 tb_emp8 为员工信息表，包含 id、name、deptId 和 salary 字段，数据表 tb_emp8 的表结构如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_emp8;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> tb_emp8;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field  <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">22</span>) <span class="operator">|</span> YES  <span class="operator">|</span> UNI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> deptId <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary <span class="operator">|</span> <span class="type">float</span>       <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure>
<p>创建一个名为 SumOfSalary 的触发器，触发的条件是向数据表 tb_emp8 中插入数据之前，对新插入的 salary 字段值进行求和计算。输入的 SQL 语句和执行过程如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> SumOfSalary</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> tb_emp8</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="variable">@sum</span><span class="operator">=</span><span class="variable">@sum</span><span class="operator">+</span>NEW.salary;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.35</span> sec)</span><br></pre></td></tr></table></figure>
<p>触发器 SumOfSalary 创建完成之后，向表 tb_emp8 中插入记录时，定义的 sum 值由 0 变成了 1500，即插入值 1000 和 500 的和，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@sum</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_emp8</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">1</span>,<span class="number">1000</span>),(<span class="number">2</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.09</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="variable">@sum</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="variable">@sum</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="创建-AFTER-类型触发器"><a href="#创建-AFTER-类型触发器" class="headerlink" title="创建 AFTER 类型触发器"></a>创建 AFTER 类型触发器</h2><p>在 test_db 数据库中，数据表 tb_emp6 和 tb_emp7 都为员工信息表，包含 id、name、deptId 和 salary 字段，数据表 tb_emp6 和 tb_emp7 的表结构如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_emp6;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_emp7;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> tb_emp6;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field  <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">25</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> deptId <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> YES  <span class="operator">|</span> MUL <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary <span class="operator">|</span> <span class="type">float</span>       <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> tb_emp7;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> Field  <span class="operator">|</span> Type        <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="operator">|</span> id     <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">25</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> deptId <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary <span class="operator">|</span> <span class="type">float</span>       <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+-------------+------+-----+---------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure>
<p>创建一个名为 double_salary 的触发器，触发的条件是向数据表 tb_emp6 中插入数据之后，再向数据表 tb_emp7 中插入相同的数据，并且 salary 为 tb_emp6 中新插入的 salary 字段值的 2 倍。输入的 SQL 语句和执行过程如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> double_salary</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> tb_emp6</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_emp7</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span> (NEW.id,NEW.name,deptId,<span class="number">2</span><span class="operator">*</span>NEW.salary);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.25</span> sec)</span><br></pre></td></tr></table></figure>
<p>触发器 double_salary 创建完成之后，向表 tb_emp6 中插入记录时，同时向表 tb_emp7 中插入相同的记录，并且 salary 字段为 tb_emp6 中 salary 字段值的 2 倍，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_emp6</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">1</span>,<span class="number">1000</span>),(<span class="number">2</span>,<span class="string">&#x27;B&#x27;</span>,<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.09</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_emp6;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> A    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> B    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_emp7;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> A    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> B    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h1><p>查看触发器是指查看数据库中已经存在的触发器的定义、状态和语法信息等。MySQL 中查看触发器的方法包括<code>SHOW TRIGGERS</code>语句和查询<code>information_schema</code>数据库下的<code>triggers</code>数据表等。</p>
<h2 id="SHOW-TRIGGERS语句查看触发器信息"><a href="#SHOW-TRIGGERS语句查看触发器信息" class="headerlink" title="SHOW TRIGGERS语句查看触发器信息"></a>SHOW TRIGGERS语句查看触发器信息</h2><p>在 MySQL 中，可以通过 SHOW TRIGGERS 语句来查看触发器的基本信息，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure>
<p>首先创建一个数据表 account，表中有两个字段，分别是 INT 类型的 accnum 和 DECIMAL 类型的 amount。SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> accnum <span class="type">INT</span>(<span class="number">4</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.49</span> sec)</span><br></pre></td></tr></table></figure>
<p>创建一个名为 trigupdate 的触发器，每次 account 表更新数据之后都向 myevent 数据表中插入一条数据。创建数据表 myevent 的 SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myevent(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> evtname <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.26</span> sec)</span><br></pre></td></tr></table></figure>
<p>创建 trigupdate 触发器的 SQL 代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigupdate AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> account</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> myevent <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;after update&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.15</span> sec)</span><br></pre></td></tr></table></figure>
<p>使用<code>SHOW TRIGGERS</code>语句查看触发器（在<code>SHOW TRIGGERS</code>命令后添加\G，这样显示信息会比较有条理），SQL 语句和运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TRIGGERS \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">             <span class="keyword">Trigger</span>: trigupdate</span><br><span class="line">               Event: <span class="keyword">UPDATE</span></span><br><span class="line">               <span class="keyword">Table</span>: account</span><br><span class="line">           Statement: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> myevent <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;after update&#x27;</span>)</span><br><span class="line">              Timing: AFTER</span><br><span class="line">             Created: <span class="number">2020</span><span class="number">-02</span><span class="number">-24</span> <span class="number">14</span>:<span class="number">07</span>:<span class="number">15.08</span></span><br><span class="line">            sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">             Definer: root<span class="variable">@localhost</span></span><br><span class="line">character_set_client: gbk</span><br><span class="line">collation_connection: gbk_chinese_ci</span><br><span class="line">  Database <span class="keyword">Collation</span>: latin1_swedish_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure>
<p>由运行结果可以看到触发器的基本信息。对以上显示信息的说明如下：</p>
<ul>
<li><code>Trigger</code>表示触发器的名称，在这里触发器的名称为<code>trigupdate</code>；</li>
<li><code>Event</code>表示激活触发器的事件，这里的触发事件为更新操作<code>UPDATE</code>；</li>
<li><code>Table</code>表示激活触发器的操作对象表，这里为<code>account</code>表；</li>
<li><code>Statement</code>表示触发器执行的操作，这里是向<code>myevent</code>数据表中插入一条数据；</li>
<li><code>Timing</code>表示触发器触发的时间，这里为更新操作之后（<code>AFTER</code>）；</li>
</ul>
<p>还有一些其他信息，比如触发器的创建时间、SQL 的模式、触发器的定义账户和字符集等，这里不再一一介绍。</p>
<p><code>SHOW TRIGGERS</code>语句用来查看当前创建的所有触发器的信息。因为该语句无法查询指定的触发器，所以在触发器较少的情况下，使用该语句会很方便。如果要查看特定触发器的信息或者数据库中触发器较多时，可以直接从<code>information_schema</code>数据库中的<code>triggers</code>数据表中查找。</p>
<h2 id="在triggers表中查看触发器信息"><a href="#在triggers表中查看触发器信息" class="headerlink" title="在triggers表中查看触发器信息"></a>在triggers表中查看触发器信息</h2><p>在 MySQL 中，所有触发器的信息都存在<code>information_schema</code>数据库的<code>triggers</code>表中，可以通过查询命令<code>SELECT</code>来查看，具体的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.triggers <span class="keyword">WHERE</span> trigger_name<span class="operator">=</span> <span class="string">&#x27;触发器名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>其中，’触发器名’用来指定要查看的触发器的名称，需要用单引号引起来。这种方式可以查询指定的触发器，使用起来更加方便、灵活。</p>
<p>下面使用<code>SELECT</code>命令查看<code>trigupdate</code>触发器，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.triggers <span class="keyword">WHERE</span> TRIGGER_NAME<span class="operator">=</span> <span class="string">&#x27;trigupdate&#x27;</span>\G</span><br></pre></td></tr></table></figure>
<p>上述命令通过 WHERE 来指定需要查看的触发器的名称，运行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.triggers <span class="keyword">WHERE</span> TRIGGER_NAME<span class="operator">=</span> <span class="string">&#x27;trigupdate&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           TRIGGER_CATALOG: def</span><br><span class="line">            TRIGGER_SCHEMA: test</span><br><span class="line">              TRIGGER_NAME: trigupdate</span><br><span class="line">        EVENT_MANIPULATION: <span class="keyword">UPDATE</span></span><br><span class="line">      EVENT_OBJECT_CATALOG: def</span><br><span class="line">       EVENT_OBJECT_SCHEMA: test</span><br><span class="line">        EVENT_OBJECT_TABLE: account</span><br><span class="line">              ACTION_ORDER: <span class="number">1</span></span><br><span class="line">          ACTION_CONDITION: <span class="keyword">NULL</span></span><br><span class="line">          ACTION_STATEMENT: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> myevent <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;after update&#x27;</span>)</span><br><span class="line">        ACTION_ORIENTATION: <span class="type">ROW</span></span><br><span class="line">             ACTION_TIMING: AFTER</span><br><span class="line">ACTION_REFERENCE_OLD_TABLE: <span class="keyword">NULL</span></span><br><span class="line">ACTION_REFERENCE_NEW_TABLE: <span class="keyword">NULL</span></span><br><span class="line">  ACTION_REFERENCE_OLD_ROW: <span class="keyword">OLD</span></span><br><span class="line">  ACTION_REFERENCE_NEW_ROW: <span class="keyword">NEW</span></span><br><span class="line">                   CREATED: <span class="number">2020</span><span class="number">-02</span><span class="number">-24</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">15.08</span></span><br><span class="line">                  SQL_MODE: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">                   DEFINER: root<span class="variable">@localhost</span></span><br><span class="line">      CHARACTER_SET_CLIENT: gbk</span><br><span class="line">      COLLATION_CONNECTION: gbk_chinese_ci</span><br><span class="line">        DATABASE_COLLATION: latin1_swedish_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.22</span> sec)</span><br></pre></td></tr></table></figure>
<p>由运行结果可以看到触发器的详细信息。对以上显示信息的说明如下：</p>
<ul>
<li><code>TRIGGER_SCHEMA</code>表示触发器所在的数据库；</li>
<li><code>TRIGGER_NAME</code>表示触发器的名称；</li>
<li><code>EVENT_OBJECT_TABLE</code>表示在哪个数据表上触发；</li>
<li><code>ACTION_STATEMENT</code>表示触发器触发的时候执行的具体操作；</li>
<li><code>ACTION_ORIENTATION</code>的值为<code>ROW</code>，表示在每条记录上都触发；</li>
<li><code>ACTION_TIMING</code>表示触发的时刻是<code>AFTER</code>；</li>
</ul>
<p>还有一些其他信息，比如触发器的创建时间、SQL 的模式、触发器的定义账户和字符集等，这里不再一一介绍。</p>
<p>上述 SQL 语句也可以不指定触发器名称，这样将查看所有的触发器，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.triggers \G</span><br></pre></td></tr></table></figure>
<p>这个语句会显示<code>triggers</code>数据表中所有的触发器信息。</p>
<h1 id="修改和删除触发器"><a href="#修改和删除触发器" class="headerlink" title="修改和删除触发器"></a>修改和删除触发器</h1><p>修改触发器可以通过删除原触发器，再以相同的名称创建新的触发器。</p>
<h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><p>与其他 MySQL 数据库对象一样，可以使用<code>DROP</code>语句将触发器从数据库中删除。</p>
<p>语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [ IF <span class="keyword">EXISTS</span> ] [数据库名] <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法说明如下：</p>
<ol>
<li>触发器名：要删除的触发器名称。</li>
<li>数据库名：可选项。指定触发器所在的数据库的名称。若没有指定，则为当前默认的数据库。</li>
<li>权限：执行<code>DROP TRIGGER</code>语句需要<code>SUPER</code>权限。</li>
<li><code>IF EXISTS</code>：可选项。避免在没有触发器的情况下删除触发器。</li>
</ol>
<p>注意：删除一个表的同时，也会自动删除该表上的触发器。另外，触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，再重新创建。</p>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>使用<code>DROP TRIGGER</code>语句可以删除 MySQL 中已经定义的触发器。</p>
<p>删除<code>double_salary</code>触发器，输入的 SQL 语句和执行过程如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> double_salary;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p>删除<code>double_salary</code>触发器后，再次向数据表<code>tb_emp6</code>中插入记录时，数据表<code>tb_emp7</code>的数据不再发生变化，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_emp6</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">&#x27;C&#x27;</span>,<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.09</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_emp6;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> A    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> B    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">500</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> C    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>    <span class="number">200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_emp7;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> deptId <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> A    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">2000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> B    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>   <span class="number">1000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+--------+--------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL存储过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/08/MySQL/MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"
    >MySQL 存储过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/05/08/MySQL/MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2020-05-08T08:44:13.000Z" itemprop="datePublished">2020-05-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="存储过程是什么？"><a href="#存储过程是什么？" class="headerlink" title="存储过程是什么？"></a>存储过程是什么？</h1><p>在数据库的实际操作中，经常会有需要多条 SQL 语句处理多个表才能完成的操作。</p>
<p>存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。</p>
<p>常用操作数据库的 SQL 语句在执行的时候需要先编译，然后执行。存储过程则采用另一种方式来执行 SQL 语句。</p>
<p>一个存储过程是一个可编程的函数，它在数据库中创建并保存，一般由 SQL 语句和一些特殊的控制结构组成。当希望在不同的应用程序或平台上执行相同的特定功能时，存储过程尤为合适。</p>
<p>存储过程是数据库中的一个重要功能，存储过程可以用来转换数据、数据迁移、制作报表，它类似于编程语言，一次执行成功，就可以随时被调用，完成指定的功能操作。</p>
<p>使用存储过程不仅可以提高数据库的访问效率，同时也可以提高数据库使用的安全性。</p>
<p>对于调用者来说，存储过程封装了 SQL 语句，调用者无需考虑逻辑功能的具体实现过程。只是简单调用即可，它可以被 Java 和 C# 等编程语言调用。</p>
<p>存储过程有如下优点：</p>
<ol>
<li>封装性<br>通常完成一个逻辑功能需要多条 SQL 语句，而且各个语句之间很可能传递参数，所以，编写逻辑功能相对来说稍微复杂些，而存储过程可以把这些 SQL 语句包含到一个独立的单元中，使外界看不到复杂的 SQL 语句，只需要简单调用即可达到目的。并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。</li>
<li>可增强 SQL 语句的功能和灵活性<br>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。</li>
<li>可减少网络流量<br>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。</li>
<li>高性能<br>当存储过程被成功编译后，就存储在数据库服务器里了，以后客户端可以直接调用，这样所有的 SQL 语句将从服务器执行，从而提高性能。但需要说明的是，存储过程不是越多越好，过多的使用存储过程反而影响系统性能。</li>
<li>提高数据库的安全性和数据的完整性<br>存储过程提高安全性的一个方案就是把它作为中间组件，存储过程里可以对某些表做相关操作，然后存储过程作为接口提供给外部程序。这样，外部程序无法直接操作数据库表，只能通过存储过程来操作对应的表，因此在一定程度上，安全性是可以得到提高的。</li>
<li>使数据独立<br>数据的独立可以达到解耦的效果，也就是说，程序可以调用存储过程，来替代执行多条的 SQL 语句。这种情况下，存储过程把数据同用户隔离开来，优点就是当数据表的结构改变时，调用表不用修改程序，只需要数据库管理者重新编写存储过程即可。</li>
</ol>
<h1 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h1><p>可以使用<code>CREATE PROCEDURE</code>语句创建存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="operator">&lt;</span>过程名<span class="operator">&gt;</span> ( [过程参数[,…] ] ) <span class="operator">&lt;</span>过程体<span class="operator">&gt;</span></span><br><span class="line">[过程参数[,…] ] 格式</span><br><span class="line">[ <span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">INOUT</span> ] <span class="operator">&lt;</span>参数名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法说明：</p>
<h3 id="1-过程名"><a href="#1-过程名" class="headerlink" title="1.过程名"></a>1.过程名</h3><p>存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即<code>db_name.sp_name</code>。</p>
<p>需要注意的是，名称应当尽量避免选取与 MySQL 内置函数相同的名称，否则会发生错误。</p>
<h3 id="2-过程参数"><a href="#2-过程参数" class="headerlink" title="2.过程参数"></a>2.过程参数</h3><p>存储过程的参数列表。其中，&lt;参数名&gt;为参数名，&lt;类型&gt;为参数的类型（可以是任何有效的 MySQL 数据类型）。当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍需加上一对括号），也可以有 1 个或多个参数。</p>
<p>MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入&#x2F;输出参数，分别用<code>IN、OUT</code>和<code>INOUT</code>三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入&#x2F;输出参数既可以充当输入参数也可以充当输出参数。</p>
<p>需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。</p>
<h3 id="3-过程体"><a href="#3-过程体" class="headerlink" title="3.过程体"></a>3.过程体</h3><p>存储过程的主体部分，也称为存储过程体，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字<code>BEGIN</code>开始，以关键字<code>END</code>结束。若存储过程体中只有一条 SQL 语句，则可以省略<code>BEGIN-END</code>标志。</p>
<p>在存储过程的创建中，经常会用到<code>DELIMITER</code>命令。</p>
<p>在 MySQL 中，服务器处理 SQL 语句默认是以分号作为语句结束标志的。然而，在创建存储过程时，存储过程体可能包含有多条 SQL 语句，这些 SQL 语句如果仍以分号作为语句结束符，那么 MySQL 服务器在处理时会以遇到的第一条 SQL 语句结尾处的分号作为整个程序的结束符，而不再去处理存储过程体中后面的 SQL 语句，这样显然不行。</p>
<p>为解决以上问题，通常使用<code>DELIMITER</code>命令将结束命令修改为其他字符。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br></pre></td></tr></table></figure>
<p>语法说明如下：</p>
<ul>
<li><code>$$</code>是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个<code>?</code>或两个<code>￥</code>等。</li>
<li>当使用<code>DELIMITER</code>命令时，应该避免使用反斜杠<code>\</code>字符，因为它是 MySQL 的转义字符。</li>
</ul>
<p>在 MySQL 命令行客户端输入如下 SQL 语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> DELIMITER ??</span><br></pre></td></tr></table></figure>
<p>成功执行这条 SQL 语句后，任何命令、语句或程序的结束标志就换为两个问号“??”了。</p>
<p>若希望换回默认的分号“;”作为结束标志，则在 MySQL 命令行客户端输入下列语句即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>注意：<code>DELIMITER</code>和分号<code>;</code>之间一定要有一个空格。在创建存储过程时，必须具有<code>CREATE ROUTINE</code>权限。</p>
<p>创建名称为<code>ShowStuScore</code>的存储过程，存储过程的作用是从学生成绩信息表中查询学生的成绩信息，输入的 SQL 语句和执行过程如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ShowStuScore()</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_students_score;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">Query OK， <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.09</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果显示 ShowStuScore 存储过程已经创建成功。</p>
<p>创建名称为<code>GetScoreByStu</code>的存储过程，输入参数是学生姓名。存储过程的作用是通过输入的学生姓名从学生成绩信息表中查询指定学生的成绩信息，输入的 SQL 语句和执行过程如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> GetScoreByStu</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="keyword">IN</span> name <span class="type">VARCHAR</span>(<span class="number">30</span>))</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> student_score <span class="keyword">FROM</span> tb_students_score</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> student_name<span class="operator">=</span>name;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h1><p>创建好存储过程后，用户可以通过<code>SHOW ATATUS</code>语句来查看存储过程的状态，也可以通过<code>SHOW CREATE</code>语句来查看存储过程的定义。</p>
<h2 id="查看存储过程的状态"><a href="#查看存储过程的状态" class="headerlink" title="查看存储过程的状态"></a>查看存储过程的状态</h2><p>MySQL 中可以通过<code>SHOW STATUS</code>语句查看存储过程的状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS <span class="keyword">LIKE</span> 存储过程名;</span><br></pre></td></tr></table></figure>
<p><code>LIKE</code>存储过程名用来匹配存储过程的名称，<code>LIKE</code>不能省略。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `studentinfo` (</span><br><span class="line">    `ID` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `NAME` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `SCORE` <span class="type">decimal</span>(<span class="number">4</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `SUBJECT` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `TEACHER` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`ID`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> studentinfo(id,name,score) <span class="keyword">VALUES</span>(<span class="number">1</span>,&quot;zhangsan&quot;,<span class="number">80</span>),(<span class="number">2</span>,&quot;lisi&quot;,&quot;70&quot;);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> showstuscore()</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> id,name,score <span class="keyword">FROM</span> studentinfo;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;showstuscore&#x27;</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                  Db: test</span><br><span class="line">                Name: showstuscore</span><br><span class="line">                Type: <span class="keyword">PROCEDURE</span></span><br><span class="line">             Definer: root<span class="variable">@localhost</span></span><br><span class="line">            Modified: <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">13</span>:<span class="number">34</span>:<span class="number">50</span></span><br><span class="line">             Created: <span class="number">2020</span><span class="number">-02</span><span class="number">-20</span> <span class="number">13</span>:<span class="number">34</span>:<span class="number">50</span></span><br><span class="line">       Security_type: DEFINER</span><br><span class="line">             Comment:</span><br><span class="line">character_set_client: gbk</span><br><span class="line">collation_connection: gbk_chinese_ci</span><br><span class="line">  Database <span class="keyword">Collation</span>: latin1_swedish_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">PROCEDURE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;show%&#x27;</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">                  Db: test</span><br><span class="line">                Name: showstuscore</span><br><span class="line">                Type: <span class="keyword">PROCEDURE</span></span><br><span class="line">             Definer: root<span class="variable">@localhost</span></span><br><span class="line">            Modified: <span class="number">2020</span><span class="number">-02</span><span class="number">-21</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">50</span></span><br><span class="line">             Created: <span class="number">2020</span><span class="number">-02</span><span class="number">-21</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">50</span></span><br><span class="line">       Security_type: DEFINER</span><br><span class="line">             Comment:</span><br><span class="line">character_set_client: gbk</span><br><span class="line">collation_connection: gbk_chinese_ci</span><br><span class="line">  Database <span class="keyword">Collation</span>: latin1_swedish_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>查询结果显示了存储过程的创建时间、修改时间和字符集等信息。</p>
<h2 id="查看存储过程的定义"><a href="#查看存储过程的定义" class="headerlink" title="查看存储过程的定义"></a>查看存储过程的定义</h2><p>MySQL 中可以通过<code>SHOW CREATE</code>语句查看存储过程的状态：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> showstuscore \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           <span class="keyword">Procedure</span>: showstuscore</span><br><span class="line">            sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">    <span class="keyword">Create</span> <span class="keyword">Procedure</span>: <span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `showstuscore`()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> id,name,score <span class="keyword">FROM</span> studentinfo;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">character_set_client: gbk</span><br><span class="line">collation_connection: gbk_chinese_ci</span><br><span class="line">  Database <span class="keyword">Collation</span>: latin1_swedish_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查询结果显示了存储过程的定义和字符集信息等。</p>
<p><code>SHOW STATUS</code>语句只能查看存储过程是操作的哪一个数据库、存储过程的名称、类型、谁定义的、创建和修改时间、字符编码等信息。但是，这个语句不能查询存储过程的集体定义，如果需要查看详细定义，需要使用<code>SHOW CREATE</code>语句。</p>
<p>存储过程的信息都存储在<code>information_schema</code>数据库下的<code>Routines</code>表中，可以通过查询该表的记录来查询存储过程的信息，SQL 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines <span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span>存储过程名;</span><br></pre></td></tr></table></figure>
<p>在<code>information_schema</code>数据库下的 routines 表中，存储着所有存储过程的定义。所以，使用<code>SELECT</code>语句查询<code>routines</code>表中的存储过程和函数的定义时，一定要使用<code>routine_name</code>字段指定存储过程的名称，否则，将查询出所有的存储过程的定义。</p>
<h1 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h1><p>MySQL 中通过<code>ALTER PROCEDURE</code>语句来修改存储过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> 存储过程名 [ 特征 ... ]</span><br></pre></td></tr></table></figure>
<p>特征指定了存储过程的特性，可能的取值有：</p>
<ul>
<li><code>CONTAINS SQL</code>表示子程序包含 SQL 语句，但不包含读或写数据的语句。</li>
<li><code>NO SQL</code>表示子程序中不包含 SQL 语句。</li>
<li><code>READS SQL DATA</code>表示子程序中包含读数据的语句。</li>
<li><code>MODIFIES SQL DATA</code>表示子程序中包含写数据的语句。</li>
<li><code>SQL SECURITY &#123; DEFINER |INVOKER &#125;</code>指明谁有权限来执行。</li>
<li><code>DEFINER</code>表示只有定义者自己才能够执行。</li>
<li><code>INVOKER</code>表示调用者可以执行。</li>
<li><code>COMMENT &#39;string&#39;</code>表示注释信息。</li>
</ul>
<p>下面修改存储过程 showstuscore 的定义，将读写权限改为 MODIFIES SQL DATA，并指明调用者可以执行，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> showstuscore <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA <span class="keyword">SQL</span> SECURITY INVOKER;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">执行代码，并查看修改后的信息，运行结果如下：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> showstuscore \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           <span class="keyword">Procedure</span>: showstuscore</span><br><span class="line">            sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">    <span class="keyword">Create</span> <span class="keyword">Procedure</span>: <span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `showstuscore`()</span><br><span class="line">    <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA</span><br><span class="line">    <span class="keyword">SQL</span> SECURITY INVOKER</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> id,name,score <span class="keyword">FROM</span> studentinfo;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">character_set_client: gbk</span><br><span class="line">collation_connection: gbk_chinese_ci</span><br><span class="line">  Database <span class="keyword">Collation</span>: latin1_swedish_ci</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果显示，存储过程修改成功。从运行结果可以看到，访问数据的权限已经变成了<code>MODIFIES SQL DATA</code>，安全类型也变成了<code>INVOKE</code>。</p>
<p>提示：<code>ALTER PROCEDURE</code>语句用于修改存储过程的某些特征。如果要修改存储过程的内容，可以先删除原存储过程，再以相同的命名创建新的存储过程；如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。</p>
<h1 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h1><p>存储过程被创建后，就会一直保存在数据库服务器上，直至被删除。当 MySQL 数据库中存在废弃的存储过程时，我们需要将它从数据库中删除。</p>
<p>MySQL 中使用<code>DROP PROCEDURE</code>语句来删除数据库中已经存在的存储过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [ IF <span class="keyword">EXISTS</span> ] <span class="operator">&lt;</span>过程名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法说明：</p>
<ul>
<li>过程名：指定要删除的存储过程的名称。</li>
<li><code>IF EXISTS</code>：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误。</li>
</ul>
<p>注意：存储过程名称后面没有参数列表，也没有括号，在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。</p>
<p>下面删除存储过程<code>ShowStuScore</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> ShowStuScore;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.08</span> sec)</span><br></pre></td></tr></table></figure>
<p>删除后，可以通过查询<code>information_schema</code>数据库下的<code>routines</code>表来确认上面的删除是否成功。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.routines <span class="keyword">WHERE</span> routine_name<span class="operator">=</span><span class="string">&#x27;ShowStuScore&#x27;</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p>结果显示，没有查询出任何记录，说明存储过程<code>ShowStuScore</code>已经被删除了。</p>
<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><p>存储函数和存储过程一样，都是在数据库中定义一些 SQL 语句的集合。存储函数可以通过<code>return</code>语句返回函数值，主要用于计算并返回一个值。而存储过程没有直接返回值，主要用于执行操作。</p>
<p>在 MySQL 中，使用<code>CREATE FUNCTION</code>语句来创建存储函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sp_name ([func_parameter[...]])</span><br><span class="line"><span class="keyword">RETURNS</span> type</span><br><span class="line">[characteristic ...] routine_body</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>sp_name</code>参数：表示存储函数的名称；</li>
<li><code>func_parameter</code>：表示存储函数的参数列表；</li>
<li><code>RETURNS type</code>：指定返回值的类型；</li>
<li><code>characteristic</code>参数：指定存储函数的特性，该参数的取值与存储过程是一样的；</li>
<li><code>routine_body</code>参数：表示 SQL 代码的内容，可以用<code>BEGIN...END</code>来标示 SQL 代码的开始和结束。</li>
</ul>
<p>注意：在具体创建函数时，函数名不能与已经存在的函数名重名。除了上述要求外，推荐函数名命名（标识符）为<code>function_xxx</code>或者<code>func_xxx</code>。</p>
<p><code>func_parameter</code>可以由多个参数组成，其中每个参数由参数名称和参数类型组成，其形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">IN</span> <span class="operator">|</span> <span class="keyword">OUT</span> <span class="operator">|</span> <span class="keyword">INOUT</span>] param_name type;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>IN</code>表示输入参数，<code>OUT</code>表示输出参数，<code>INOUT</code>表示既可以输入也可以输出；</li>
<li><code>param_name</code>参数是存储函数的参数名称；</li>
<li><code>type</code>参数指定存储函数的参数类型，该类型可以是 MySQL 数据库的任意数据类型。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> USE test;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> func_student(id <span class="type">INT</span>(<span class="number">11</span>))</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> COMMENT <span class="string">&#x27;查询某个学生的姓名&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">RETURN</span>(<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> tb_student.id <span class="operator">=</span> id);</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.10</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>上述代码中，创建了<code>func_student</code>函数，该函数拥有一个类型为<code>INT(11)</code>的参数<code>id</code>，返回值为<code>VARCHAR(20)</code>类型。<code>SELECT</code>语句从<code>tb_student</code>表中查询<code>id</code>字段值等于所传入参数<code>id</code>值的记录，同时返回该条记录的<code>name</code>字段值。</p>
<p>创建函数与创建存储过程一样，需要通过命令<code>DELIMITER //</code>将 SQL 语句的结束符由“;”修改为“&#x2F;&#x2F;”，最后通过命令<code>DELIMITER</code>; 将结束符号修改成 SQL 语句中默认的结束符号。</p>
<p>如果在存储函数中的<code>RETURN</code>语句返回一个类型不同于函数的<code>RETURNS</code>子句中指定类型的值，返回值将被强制为恰当的类型。比如，如果一个函数返回一个<code>ENUM</code>或<code>SET</code>值，但是<code>RETURN</code>语句返回一个整数，对于<code>SET</code>成员集的相应的<code>ENUM</code>成员，从函数返回的值是字符串。</p>
<p>查看存储函数的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW FUNCTION STATUS LIKE 存储函数名;</span><br><span class="line">SHOW CREATE FUNCTION 存储函数名;</span><br><span class="line">SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME=存储函数名;</span><br></pre></td></tr></table></figure>
<p>可以发现，操作存储函数和操作存储过程不同的是将<code>PROCEDURE</code>替换成了<code>FUNCTION</code>。同样，修改存储函数的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER FUNCTION 存储函数名 [ 特征 ... ]</span><br></pre></td></tr></table></figure>
<p>存储函数的特征与存储过程的基本一样。</p>
<p>删除存储过程的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION [ IF EXISTS ] &lt;函数名&gt;</span><br></pre></td></tr></table></figure>
<h1 id="调用存储过程和函数"><a href="#调用存储过程和函数" class="headerlink" title="调用存储过程和函数"></a>调用存储过程和函数</h1><p>存储过程和存储函数都是存储在服务器端的 SQL 语句集合。要想使用这些已经定义好的存储过程和存储函数就必须要通过调用的方式来实现。</p>
<p>存储过程通过<code>CALL</code>语句来调用，存储函数的使用方法与 MySQL 内部函数的使用方法相同。执行存储过程和存储函数需要拥有<code>EXECUTE</code>权限（<code>EXECUTE</code>权限的信息存储在<code>information_schema</code>数据库下的<code>USER_PRIVILEGES</code>表中）。</p>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><p>MySQL 中使用<code>CALL</code>语句来调用存储过程。调用存储过程后，数据库系统将执行存储过程中的 SQL 语句，然后将结果返回给输出值。</p>
<p><code>CALL</code>语句接收存储过程的名字以及需要传递给它的任意参数，基本语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL sp_name([parameter[...]]);</span><br></pre></td></tr></table></figure>
<p>其中，<code>sp_name</code>表示存储过程的名称，<code>parameter</code>表示存储过程的参数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> DELIMITER ;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CALL</span> ShowStuScore();</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> student_name <span class="operator">|</span> student_score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> Dany         <span class="operator">|</span>            <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Green        <span class="operator">|</span>            <span class="number">99</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Henry        <span class="operator">|</span>            <span class="number">95</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jane         <span class="operator">|</span>            <span class="number">98</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Jim          <span class="operator">|</span>            <span class="number">88</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> John         <span class="operator">|</span>            <span class="number">94</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Lily         <span class="operator">|</span>           <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Susan        <span class="operator">|</span>            <span class="number">96</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Thomas       <span class="operator">|</span>            <span class="number">93</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Tom          <span class="operator">|</span>            <span class="number">89</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------------+</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CALL</span> GetScoreByStu(<span class="string">&#x27;Green&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> student_score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span>            <span class="number">99</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p>因为存储过程实际上也是一种函数，所以存储过程名后需要有( )符号，即使不传递参数也需要。</p>
<h2 id="调用存储函数"><a href="#调用存储函数" class="headerlink" title="调用存储函数"></a>调用存储函数</h2><p>在 MySQL 中，存储函数的使用方法与 MySQL 内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与 MySQL 内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是 MySQL 开发者定义的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> func_student(<span class="number">3</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> func_student(<span class="number">3</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> 王五            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.10</span> sec)</span><br></pre></td></tr></table></figure>
<p>通过示例的比较，可以看出虽然存储函数和存储过程的定义稍有不同，但它们都可以实现相同的功能，我们应该在实际应用中灵活选择。</p>
<h1 id="变量的定义和赋值"><a href="#变量的定义和赋值" class="headerlink" title="变量的定义和赋值"></a>变量的定义和赋值</h1><p>在 MySQL 中，除了支持标准的存储过程和函数外，还引入了表达式。表达式与其它高级语言的表达式一样，由变量、运算符和流程控制来构成。</p>
<p>变量是表达式语句中最基本的元素，可以用来临时存储数据。在存储过程和函数中都可以定义和使用变量。用户可以使用<code>DECLARE</code>关键字来定义变量，定义后可以为变量赋值。这些变量的作用范围是<code>BEGIN...END</code>程序段中。</p>
<h2 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1. 定义变量"></a>1. 定义变量</h2><p>MySQL 中可以使用<code>DECLARE</code>关键字来定义变量，其基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE var_name[,...] type [DEFAULT value]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>DECLARE</code>关键字是用来声明变量的；</li>
<li><code>var_name</code>参数是变量的名称，这里可以同时定义多个变量；</li>
<li><code>type</code>参数用来指定变量的类型；</li>
<li><code>DEFAULT value</code>子句将变量默认值设置为<code>value</code>，没有使用<code>DEFAULT</code>子句时，默认值为<code>NULL</code>。</li>
</ul>
<p>下面定义变量<code>my_sql</code>，数据类型为<code>INT</code>类型，默认值为 10。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE my_sql INT DEFAULT 10;</span><br></pre></td></tr></table></figure>
<h2 id="2-为变量赋值"><a href="#2-为变量赋值" class="headerlink" title="2. 为变量赋值"></a>2. 为变量赋值</h2><p>MySQL 中可以使用<code>SET</code>关键字来为变量赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET var_name = expr[,var_name = expr]...</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>SET</code>关键字用来为变量赋值；</li>
<li><code>var_name</code>参数是变量的名称；</li>
<li><code>expr</code>参数是赋值表达式。</li>
</ul>
<p>注意：一个<code>SET</code>语句可以同时为多个变量赋值，各个变量的赋值语句之间用逗号隔开。</p>
<p>下面为变量<code>my_sql</code>赋值为 30。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET my_sql=30;</span><br></pre></td></tr></table></figure>
<p>MySQL 中还可以使用<code>SELECT..INTO</code>语句为变量赋值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name [...] <span class="keyword">INTO</span> var_name[,...]</span><br><span class="line"><span class="keyword">FROM</span> table_name WEHRE <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>col_name</code>参数表示查询的字段名称；</li>
<li><code>var_name</code>参数是变量的名称；</li>
<li><code>table_name</code>参数指表的名称；</li>
<li><code>condition</code>参数指查询条件。</li>
</ul>
<p>注意：当将查询结果赋值给变量时，该查询语句的返回结果只能是单行。</p>
<p>下面从<code>tb_student</code>表中查询<code>id</code>为 2 的记录，将该记录的<code>id</code>值赋给变量<code>my_sql</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">INTO</span> my_sql <span class="keyword">FROM</span> tb_student WEHRE id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h1 id="定义条件和处理程序"><a href="#定义条件和处理程序" class="headerlink" title="定义条件和处理程序"></a>定义条件和处理程序</h1><p>在程序的运行过程中可能会遇到问题，此时我们可以通过定义条件和处理程序来事先定义这些问题。</p>
<p>定义条件是指事先定义程序执行过程中遇到的问题，处理程序定义了在遇到这些问题时应当采取的处理方式和解决办法，保证存储过程和函数在遇到警告或错误时能继续执行，从而增强程序处理问题的能力，避免程序出现异常被停止执行。</p>
<h2 id="1-定义条件"><a href="#1-定义条件" class="headerlink" title="1. 定义条件"></a>1. 定义条件</h2><p>MySQL 中可以使用<code>DECLARE</code>关键字来定义条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> condition_name <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> condition_value</span><br><span class="line"><span class="keyword">condition</span> <span class="keyword">value</span>:</span><br><span class="line"><span class="keyword">SQLSTATE</span> [<span class="keyword">VALUE</span>] sqlstate_value <span class="operator">|</span> mysql_error_code</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>condition_name</code>参数表示条件的名称；</li>
<li><code>condition_value</code>参数表示条件的类型；</li>
<li><code>sqlstate_value</code>参数和<code>mysql_error_code</code>参数都可以表示 MySQL 的错误。<code>sqlstate_value</code>表示长度为 5 的字符串类型错误代码，<code>mysql_error_code</code>表示数值类型错误代码。例如<code>ERROR 1146(42S02)</code>中，<code>sqlstate_value</code>值是 42S02，<code>mysql_error_code</code>值是 1146。</li>
</ul>
<p>下面定义“ERROR 1146 (42S02)”这个错误，名称为 can_not_find。 可以用两种不同的方法来定义，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//方法一：使用sqlstate_value</span><br><span class="line">DECLARE can_not_find CONDITION FOR SQLSTATE &#x27;42S02&#x27;;</span><br><span class="line"></span><br><span class="line">//方法二：使用 mysql_error_code</span><br><span class="line">DECLARE can_not_find CONDITION FOR 1146;</span><br></pre></td></tr></table></figure>
<h2 id="2-定义处理程序"><a href="#2-定义处理程序" class="headerlink" title="2. 定义处理程序"></a>2. 定义处理程序</h2><p>MySQL 中可以使用<code>DECLARE</code>关键字来定义处理程序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_type HANDLER <span class="keyword">FOR</span> condition_value[...] sp_statement</span><br><span class="line">handler_type:</span><br><span class="line">CONTINUE <span class="operator">|</span> EXIT <span class="operator">|</span> UNDO</span><br><span class="line">condition_value:</span><br><span class="line"><span class="keyword">SQLSTATE</span> [<span class="keyword">VALUE</span>] sqlstate_value <span class="operator">|</span> condition_name <span class="operator">|</span> <span class="keyword">SQLWARNING</span> <span class="operator">|</span> <span class="keyword">NOT</span> FOUND <span class="operator">|</span> <span class="keyword">SQLEXCEPTION</span> <span class="operator">|</span> mysql_error_code</span><br></pre></td></tr></table></figure>
<p>其中，handler_type 参数指明错误的处理方式，该参数有 3 个取值。这 3 个取值分别是 CONTINUE、EXIT 和 UNDO。</p>
<ul>
<li><code>CONTINUE</code>表示遇到错误不进行处理，继续向下执行；</li>
<li><code>EXIT</code>表示遇到错误后马上退出；</li>
<li><code>UNDO</code>表示遇到错误后撤回之前的操作，MySQL 中暂时还不支持这种处理方式。</li>
</ul>
<p>注意：通常情况下，执行过程中遇到错误应该立刻停止执行下面的语句，并且撤回前面的操作。但是，MySQL 中现在还不能支持 UNDO 操作。因此，遇到错误时最好执行 EXIT 操作。如果事先能够预测错误类型，并且进行相应的处理，那么可以执行 CONTINUE 操作。</p>
<p>参数指明错误类型，该参数有 6 个取值：</p>
<ul>
<li><code>sqlstate_value</code>：包含 5 个字符的字符串错误值；</li>
<li><code>condition_name</code>：表示<code>DECLARE</code>定义的错误条件名称；</li>
<li><code>SQLWARNING</code>：匹配所有以 01 开头的<code>sqlstate_value</code>值；</li>
<li><code>NOT FOUND</code>：匹配所有以 02 开头的<code>sqlstate_value</code>值；</li>
<li><code>SQLEXCEPTION</code>：匹配所有没有被<code>SQLWARNING</code>或<code>NOT FOUND</code>捕获的<code>sqlstate_value</code>值；</li>
<li><code>mysql_error_code</code>：匹配数值类型错误代码。</li>
</ul>
<p><code>sp_statement</code>参数为程序语句段，表示在遇到定义的错误时，需要执行的一些存储过程或函数。</p>
<p>下面是定义处理程序的几种方式，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>方法一：捕获 sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;42S02&#x27;</span> <span class="keyword">SET</span> <span class="variable">@info</span><span class="operator">=</span><span class="string">&#x27;CAN NOT FIND&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法二：捕获 mysql_error_code</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1146</span> <span class="keyword">SET</span> <span class="variable">@info</span><span class="operator">=</span><span class="string">&#x27;CAN NOT FIND&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法三：先定义条件，然后调用</span><br><span class="line"><span class="keyword">DECLARE</span> can_not_find <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1146</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> can_not_find <span class="keyword">SET</span> <span class="variable">@info</span><span class="operator">=</span><span class="string">&#x27;CAN NOT FIND&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法四：使用 <span class="keyword">SQLWARNING</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLWARNING</span> <span class="keyword">SET</span> <span class="variable">@info</span><span class="operator">=</span><span class="string">&#x27;ERROR&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法五：使用 <span class="keyword">NOT</span> FOUND</span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> <span class="variable">@info</span><span class="operator">=</span><span class="string">&#x27;CAN NOT FIND&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>方法六：使用 <span class="keyword">SQLEXCEPTION</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span> <span class="keyword">SET</span> <span class="variable">@info</span><span class="operator">=</span><span class="string">&#x27;ERROR&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码是 6 种定义处理程序的方法。<br>捕获 sqlstate_value 值。如果遇到 sqlstate_value 值为 42S02，执行 CONTINUE 操作，并且输出“CAN NOT FIND”信息。<br>捕获 mysql_error_code 值。如果遇到 mysql_error_code 值为 1146， 执行 CONTINUE 操作，并且输出“CAN NOT FIND”信息。<br>先定义条件，然后再调用条件。这里先定义 can_not_find 条件，遇到 1146 错误就执行 CONTINUE 操作。<br>使用 SQLWARNING。SQLWARNING 捕获所有以 01 开头的 sqlstate_value 值，然后执行 EXIT 操作，并且输出“ERROR”信息。<br>使用 NOT FOUND。NOT FOUND 捕获所有以 02 开头的 sqlstate_value 值，然后执行 EXIT 操作，并且输出“CAN NOT FIND”信息。<br>使用 SQLEXCEPTION。 SQLEXCEPTION 捕获所有没有被 SQLWARNING 或 NOT FOUND 捕获的 sqlstate_value 值，然后执行 EXIT 操作，并且输出“ERROR”信息。</p>
<p>定义条件和处理顺序，具体的执行过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t8(s1 INT,PRIMARY KEY(s1));</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER //</span><br><span class="line">mysql&gt; CREATE PROCEDURE handlerdemo()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;23000&#x27; SET @X2=1;</span><br><span class="line">    -&gt; SET @X=1;</span><br><span class="line">    -&gt; INSERT INTO t8 VALUES(1);</span><br><span class="line">    -&gt; SET @X=2;</span><br><span class="line">    -&gt; INSERT INTO t8 VALUES(1);</span><br><span class="line">    -&gt; SET @X=3;</span><br><span class="line">    -&gt; END //</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELIMITER ;</span><br><span class="line">mysql&gt; CALL handlerdemo();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @X;</span><br><span class="line">+------+</span><br><span class="line">| @X   |</span><br><span class="line">+------+</span><br><span class="line">|    3 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>上述代码中，@X 是一个用户变量，执行结果 @X 等于 3，这表明 MySQL 执行到程序的末尾。</p>
<p>如果<code>DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;23000&#39; SET @X2=1;</code>这一行不存在，第二个 INSERT 因 PRIMARY KEY 约束而失败之后，MySQL 可能已经采取 EXIT 策略，且 SELECT @X 可能已经返回 2。</p>
<p>注意：@X 表示用户变量，使用 SET 语句为其赋值，用户变量与连接有关，一个客户端定义的变量不能被其他客户端所使用，当客户端退出时，该客户端连接的所有变量将自动释放。</p>
<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>在 MySQL 中，存储过程或函数中的查询有时会返回多条记录，而使用简单的<code>SELECT</code>语句，没有办法得到第一行、下一行或前十行的数据，这时可以使用游标来逐条读取查询结果集中的记录。游标在部分资料中也被称为光标。</p>
<p>关系数据库管理系统实质是面向集合的，在 MySQL 中并没有一种描述表中单一记录的表达形式，除非使用 WHERE 子句来限制只有一条记录被选中。所以有时我们必须借助于游标来进行单条记录的数据处理。</p>
<p>一般通过游标定位到结果集的某一行进行数据修改。<br>结果集是符合 SQL 语句的所有记录的集合。</p>
<p>个人理解游标就是一个标识，用来标识数据取到了什么地方，如果你了解编程语言，可以把他理解成数组中的下标。</p>
<p>不像多数 DBMS，MySQL 游标只能用于存储过程和函数。</p>
<p>下面介绍游标的使用，主要包括游标的声明、打开、使用和关闭。</p>
<ol>
<li>声明游标<br>MySQL 中使用 DECLARE 关键字来声明游标，并定义相应的 SELECT 语句，根据需要添加 WHERE 和其它子句。其语法的基本形式如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR FOR select_statement;</span><br></pre></td></tr></table></figure>
其中，<code>cursor_name</code>表示游标的名称；<code>select_statement</code>表示<code>SELECT</code>语句，可以返回一行或多行数据。<br>例 1<br>下面声明一个名为 nameCursor 的游标，代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELIMITER //</span><br><span class="line">mysql&gt; CREATE PROCEDURE processnames()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE nameCursor CURSOR</span><br><span class="line">    -&gt; FOR</span><br><span class="line">    -&gt; SELECT name FROM tb_student;</span><br><span class="line">    -&gt; END//</span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br></pre></td></tr></table></figure>
以上语句定义了 nameCursor 游标，游标只局限于存储过程中，存储过程处理完成后，游标就消失了。</li>
<li>打开游标<br>声明游标之后，要想从游标中提取数据，必须首先打开游标。在 MySQL 中，打开游标通过<code>OPEN</code>关键字来实现：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name;</span><br></pre></td></tr></table></figure>
其中，<code>cursor_name</code>表示所要打开游标的名称。需要注意的是，打开一个游标时，游标并不指向第一条记录，而是指向第一条记录的前边。</li>
</ol>
<p>在程序中，一个游标可以打开多次。用户打开游标后，其他用户或程序可能正在更新数据表，所以有时会导致用户每次打开游标后，显示的结果都不同。<br>3. 使用游标<br>游标顺利打开后，可以使用<code>FETCH...INTO</code>语句来读取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [,var_name]...</span><br></pre></td></tr></table></figure>
<p>上述语句中，将游标 cursor_name 中 SELECT 语句的执行结果保存到变量参数 var_name 中。变量参数 var_name 必须在游标使用之前定义。使用游标类似高级语言中的数组遍历，当第一次使用游标时，此时游标指向结果集的第一条记录。</p>
<p>MySQL 的游标是只读的，也就是说，你只能顺序地从开始往后读取结果集，不能从后往前，也不能直接跳到中间的记录。<br>4. 关闭游标<br>游标使用完毕后，要及时关闭，在 MySQL 中，使用<code>CLOSE</code>关键字关闭游标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLOSE cursor_name;</span><br></pre></td></tr></table></figure>
<p><code>CLOSE</code>释放游标使用的所有内部内存和资源，因此每个游标不再需要时都应该关闭。</p>
<p>在一个游标关闭后，如果没有重新打开，则不能使用它。但是，使用声明过的游标不需要再次声明，用<code>OPEN</code>语句打开它就可以了。</p>
<p>如果你不明确关闭游标，MySQL 将会在到达 END 语句时自动关闭它。游标关闭之后，不能使用 FETCH 来使用该游标。</p>
<p>创建 users 数据表，并插入数据，SQL 语句和运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `users`</span><br><span class="line">    -&gt;  (</span><br><span class="line">    -&gt;  `ID` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    -&gt;  `user_name` VARCHAR(60),</span><br><span class="line">    -&gt;  `user_pass` VARCHAR(64),</span><br><span class="line">    -&gt;  PRIMARY KEY (`ID`)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO users VALUES(null,&#x27;sheng&#x27;,&#x27;sheng123&#x27;),</span><br><span class="line">    -&gt; (null,&#x27;yu&#x27;,&#x27;yu123&#x27;),</span><br><span class="line">    -&gt; (null,&#x27;ling&#x27;,&#x27;ling123&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>创建存储过程 test_cursor，并创建游标 cur_test，查询 users 数据表中的第 3 条记录，SQL 语句和执行过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DELIMITER //</span><br><span class="line">mysql&gt; CREATE PROCEDURE test_cursor (in param INT(10),out result VARCHAR(90))</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE name VARCHAR(20);</span><br><span class="line">    -&gt; DECLARE pass VARCHAR(20);</span><br><span class="line">    -&gt; DECLARE done INT;</span><br><span class="line">    -&gt; DECLARE cur_test CURSOR FOR SELECT user_name,user_pass FROM users;</span><br><span class="line">    -&gt; DECLARE continue handler FOR SQLSTATE &#x27;02000&#x27; SET done = 1;</span><br><span class="line">    -&gt; IF param THEN INTO result FROM users WHERE id = param;</span><br><span class="line">    -&gt; ELSE</span><br><span class="line">    -&gt; OPEN cur_test;</span><br><span class="line">    -&gt; repeat</span><br><span class="line">    -&gt; FETCH cur_test into name,pass;</span><br><span class="line">    -&gt; SELECT concat_ws(&#x27;,&#x27;,result,name,pass) INTO result;</span><br><span class="line">    -&gt; until done</span><br><span class="line">    -&gt; END repeat;</span><br><span class="line">    -&gt; CLOSE cur_test;</span><br><span class="line">    -&gt; END IF;</span><br><span class="line">    -&gt; END //</span><br><span class="line">Query OK, 0 rows affected (0.10 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call test_cursor(3,@test)//</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @test//</span><br><span class="line">+-----------+</span><br><span class="line">| @test     |</span><br><span class="line">+-----------+</span><br><span class="line">| ling,ling123 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>创建 pro_users() 存储过程，定义 cur_1 游标，将表 users 中的 user_name 字段全部修改为 MySQL，SQL 语句和执行过程如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE PROCEDURE pro_users()</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; DECLARE result VARCHAR(100);</span><br><span class="line">    -&gt; DECLARE no INT;</span><br><span class="line">    -&gt; DECLARE cur_1 CURSOR FOR SELECT user_name FROM users;</span><br><span class="line">    -&gt; DECLARE CONTINUE HANDLER FOR NOT FOUND SET no=1;</span><br><span class="line">    -&gt; SET no=0;</span><br><span class="line">    -&gt; OPEN cur_1;</span><br><span class="line">    -&gt; WHILE no=0 do</span><br><span class="line">    -&gt; FETCH cur_1 into result;</span><br><span class="line">    -&gt; UPDATE users SET user_name=&#x27;MySQL&#x27;</span><br><span class="line">    -&gt; WHERE user_name=result;</span><br><span class="line">    -&gt; END WHILE;</span><br><span class="line">    -&gt; CLOSE cur_1;</span><br><span class="line">    -&gt; END //</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call pro_users() //</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM users //</span><br><span class="line">+----+-----------+-----------+</span><br><span class="line">| ID | user_name | user_pass |</span><br><span class="line">+----+-----------+-----------+</span><br><span class="line">|  1 | MySQL     | sheng      |</span><br><span class="line">|  2 | MySQL     | zhang     |</span><br><span class="line">|  3 | MySQL     | ying      |</span><br><span class="line">+----+-----------+-----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>结果显示，users 表中的 user_name 字段已经全部修改为 MySQL。</p>
<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><p>在存储过程和自定义函数中可以使用流程控制语句来控制程序的流程。MySQL 中流程控制语句有：<code>IF</code>语句、<code>CASE</code>语句、<code>LOOP</code>语句、<code>LEAVE</code>语句、<code>ITERATE</code>语句、<code>REPEAT</code>语句和<code>WHILE</code>语句等。</p>
<h2 id="1-IF语句"><a href="#1-IF语句" class="headerlink" title="1. IF语句"></a>1. IF语句</h2><p>IF 语句用来进行条件判断，根据是否满足条件（可包含多个条件），来执行不同的语句，是流程控制中最常用的判断语句。其语法的基本形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF search_condition <span class="keyword">THEN</span> statement_list</span><br><span class="line">    [ELSEIF search_condition <span class="keyword">THEN</span> statement_list]...</span><br><span class="line">    [<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> IF</span><br></pre></td></tr></table></figure>
<p>其中，<code>search_condition</code>参数表示条件判断语句，如果返回值为<code>TRUE</code>，相应的 SQL 语句列表（<code>statement_list</code>）被执行；如果返回值为<code>FALSE</code>，则<code>ELSE</code>子句的语句列表被执行。<code>statement_list</code>可以包括一个或多个语句。</p>
<p>注意：MySQL 中的<code>IF()</code>函数不同于这里的<code>IF</code>语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IF age&gt;20 THEN SET @count1=@count1+1;</span><br><span class="line">    ELSEIF age=20 THEN @count2=@count2+1;</span><br><span class="line">    ELSE @count3=@count3+1;</span><br><span class="line">END lF;</span><br></pre></td></tr></table></figure>
<p><code>IF</code>语句都需要使用<code>END IF</code>来结束。</p>
<h2 id="2-CASE语句"><a href="#2-CASE语句" class="headerlink" title="2. CASE语句"></a>2. CASE语句</h2><p><code>CASE</code>语句也是用来进行条件判断的，它提供了多个条件进行选择，可以实现比<code>IF</code>语句更复杂的条件判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">    WHEN when_value THEN statement_list</span><br><span class="line">    [WHEN when_value THEN statement_list]...</span><br><span class="line">    [ELSE statement_list]</span><br><span class="line">END CASE</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>case_value</code>参数表示条件判断的变量，决定了哪一个<code>WHEN</code>子句会被执行；</li>
<li><code>when_value</code>参数表示变量的取值，如果某个<code>when_value</code>表达式与<code>case_value</code>变量的值相同，则执行对应的<code>THEN</code>关键字后的<code>statement_list</code>中的语句；</li>
<li><code>statement_list</code>参数表示<code>when_value</code>值没有与<code>case_value</code>相同值时的执行语句。</li>
<li><code>CASE</code>语句都要使用<code>END CASE</code>结束。</li>
</ul>
<p><code>CASE</code>语句还有另一种形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE</span><br><span class="line">    WHEN search_condition THEN statement_list</span><br><span class="line">    [WHEN search_condition THEN statement_list] ...</span><br><span class="line">    [ELSE statement_list]</span><br><span class="line">END CASE</span><br></pre></td></tr></table></figure>
<p>其中，<code>search_condition</code>参数表示条件判断语句；<code>statement_list</code>参数表示不同条件的执行语句。</p>
<p>与上述语句不同的是，该语句中的 WHEN 语句将被逐个执行，直到某个 search_condition 表达式为真，则执行对应 THEN 关键字后面的 statement_list 语句。如果没有条件匹配，ELSE 子句里的语句被执行。</p>
<p>这里介绍的 CASE 语句与“控制流程函数”里描述的 SQL CASE 表达式的 CASE 语句有轻微的不同。这里的 CASE 语句不能有 ELSE NULL 语句，并且用 END CASE 替代 END 来终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CASE age</span><br><span class="line">    WHEN 20 THEN SET @count1=@count1+1;</span><br><span class="line">    ELSE SET @count2=@count2+1;</span><br><span class="line">END CASE;</span><br><span class="line"># 代码也可以是下面的形式：</span><br><span class="line">CASE</span><br><span class="line">    WHEN age=20 THEN SET @count1=@count1+1;</span><br><span class="line">    ELSE SET @count2=@count2+1;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<h2 id="3-LOOP-语句"><a href="#3-LOOP-语句" class="headerlink" title="3. LOOP 语句"></a>3. LOOP 语句</h2><p><code>LOOP</code>语句可以使某些特定的语句重复执行。与<code>IF</code>和<code>CASE</code>语句相比，<code>LOOP</code>只实现了一个简单的循环，并不进行条件判断。</p>
<p><code>LOOP</code>语句本身没有停止循环的语句，必须使用<code>LEAVE</code>语句等才能停止循环，跳出循环过程。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:]LOOP</span><br><span class="line">    statement_list</span><br><span class="line"><span class="keyword">END</span> LOOP [end_label]</span><br></pre></td></tr></table></figure>
<p>其中，<code>begin_label</code>参数和<code>end_label</code>参数分别表示循环开始和结束的标志，这两个标志必须相同，而且都可以省略；<code>statement_list</code>参数表示需要循环执行的语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_num:LOOP</span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@count</span><span class="operator">=</span><span class="variable">@count</span><span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> LOOP add_num;</span><br></pre></td></tr></table></figure>
<p>该示例循环执行<code>count</code>加 1 的操作。因为没有跳出循环的语句，这个循环成了一个死循环。<code>LOOP</code>循环都以<code>END LOOP</code>结束。</p>
<h2 id="4-LEAVE-语句"><a href="#4-LEAVE-语句" class="headerlink" title="4. LEAVE 语句"></a>4. LEAVE 语句</h2><p><code>LEAVE</code>语句主要用于跳出循环控制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAVE label</span><br></pre></td></tr></table></figure>
<p>其中，<code>label</code>参数表示循环的标志，<code>LEAVE</code>语句必须跟在循环标志前面。</p>
<p>下面是一个 LEAVE 语句的示例。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_num:LOOP</span><br><span class="line">    SET @count=@count+1;</span><br><span class="line">    IF @count=100 THEN</span><br><span class="line">        LEAVE add_num;</span><br><span class="line">END LOOP add num;</span><br></pre></td></tr></table></figure>
<p>该示例循环执行 count 加 1 的操作。当 count 的值等于 100 时，跳出循环。</p>
<h2 id="5-ITERATE-语句"><a href="#5-ITERATE-语句" class="headerlink" title="5. ITERATE 语句"></a>5. ITERATE 语句</h2><p><code>ITERATE</code>是“再次循环”的意思，用来跳出本次循环，直接进入下一次循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure>
<p>其中，<code>label</code>参数表示循环的标志，<code>ITERATE</code>语句必须跟在循环标志前面。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_num:LOOP</span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@count</span><span class="operator">=</span><span class="variable">@count</span><span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">    IF <span class="variable">@count</span><span class="operator">=</span><span class="number">100</span> <span class="keyword">THEN</span></span><br><span class="line">        LEAVE add_num;</span><br><span class="line">    <span class="keyword">ELSE</span> IF <span class="built_in">MOD</span>(<span class="variable">@count</span>,<span class="number">3</span>)<span class="operator">=</span><span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        ITERATE add_num;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">END</span> LOOP add_num;</span><br></pre></td></tr></table></figure>
<p>该示例循环执行 count 加 1 的操作，count 值为 100 时结束循环。如果 count 的值能够整除 3，则跳出本次循环，不再执行下面的 SELECT 语句。</p>
<p>说明：LEAVE 语句和 ITERATE 语句都用来跳出循环语句，但两者的功能是不一样的。LEAVE 语句是跳出整个循环，然后执行循环后面的程序。而 ITERATE 语句是跳出本次循环，然后进入下一次循环。使用这两个语句时一定要区分清楚。</p>
<h2 id="6-REPEAT-语句"><a href="#6-REPEAT-语句" class="headerlink" title="6. REPEAT 语句"></a>6. REPEAT 语句</h2><p><code>REPEAT</code>语句是有条件控制的循环语句，每次语句执行完毕后，会对条件表达式进行判断，如果表达式返回值为<code>TRUE</code>，则循环结束，否则重复执行循环中的语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] REPEAT</span><br><span class="line">    statement_list</span><br><span class="line">    UNTIL search_condition</span><br><span class="line"><span class="keyword">END</span> REPEAT [end_label]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>begin_label</code>为<code>REPEAT</code>语句的标注名称，该参数可以省略；</li>
<li><code>REPEAT</code>语句内的语句被重复，直至<code>search_condition</code>返回值为<code>TRUE</code>。</li>
<li><code>statement_list</code>参数表示循环的执行语句；</li>
<li><code>search_condition</code>参数表示结束循环的条件，满足该条件时循环结束。</li>
</ul>
<p><code>REPEAT</code>循环都用<code>END REPEAT</code>结束。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@count</span><span class="operator">=</span><span class="variable">@count</span><span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">    UNTIL <span class="variable">@count</span><span class="operator">=</span><span class="number">100</span></span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure>
<p>该示例循环执行<code>count</code>加 1 的操作，<code>count</code>值为 100 时结束循环。</p>
<h2 id="7-WHILE-语句"><a href="#7-WHILE-语句" class="headerlink" title="7. WHILE 语句"></a>7. WHILE 语句</h2><p><code>WHILE</code>语句也是有条件控制的循环语句。<code>WHILE</code>语句和<code>REPEAT</code>语句不同的是，<code>WHILE</code>语句是当满足条件时，执行循环内的语句，否则退出循环。<code>WHILE</code>语句的基本语法形式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] WHILE search_condition DO</span><br><span class="line">    statement list</span><br><span class="line"><span class="keyword">END</span> WHILE [<span class="keyword">end</span> label]</span><br></pre></td></tr></table></figure>
<p>其中，<code>search_condition</code>参数表示循环执行的条件，满足该条件时循环执行；<code>statement_list</code>参数表示循环的执行语句。<code>WHILE</code>循环需要使用<code>END WHILE</code>来结束。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE <span class="variable">@count</span><span class="operator">&lt;</span><span class="number">100</span> DO</span><br><span class="line">    <span class="keyword">SET</span> <span class="variable">@count</span><span class="operator">=</span><span class="variable">@count</span><span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure>
<p>该示例循环执行<code>count</code>加 1 的操作，<code>count</code>值小于 100 时执行循环。如果<code>count</code>值等于 100 了，则跳出循环。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL索引"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/"
    >MySQL 索引</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2020-05-06T09:35:51.000Z" itemprop="datePublished">2020-05-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h1><p>索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。</p>
<p>通过索引，查询数据时不用读完记录的所有信息，而只是查询索引列。否则，数据库系统将读取每条记录的所有信息进行匹配。</p>
<p>可以把索引比作新华字典的音序表。例如，要查“库”字，如果不使用音序，就需要从字典的 400 页中逐页来找。但是，如果提取拼音出来，构成音序表，就只需要从 10 多页的音序表中直接查找。这样就可以大大节省时间。</p>
<p>因此，使用索引可以很大程度上提高数据库的查询速度，还有效的提高了数据库系统的性能。</p>
<p>索引和数据位于存储引擎中。</p>
<h2 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h2><p>索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。</p>
<p>索引是数据库性能调优技术的基础，常用于实现数据的快速检索。</p>
<p>在 MySQL 中，通常有以下两种方式访问数据库表的行数据：</p>
<h3 id="1-顺序访问"><a href="#1-顺序访问" class="headerlink" title="1. 顺序访问"></a>1. 顺序访问</h3><p>顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。顺序访问实现比较简单，但是当表中有大量数据的时候，效率非常低下。</p>
<h3 id="2-索引访问"><a href="#2-索引访问" class="headerlink" title="2. 索引访问"></a>2. 索引访问</h3><p>索引访问是通过遍历索引来直接访问表中记录行的方式。</p>
<p>使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。</p>
<p>例如，在学生基本信息表<code>tb_students</code>中，如果基于<code>student_id</code>建立了索引，系统就建立了一张索引列到实际记录的映射表。当用户需要查找<code>student_id</code>为 12022 的数据的时候，系统先在<code>student_id</code>索引上找到该记录，然后通过映射表直接找到数据行，并且返回该行数据。因为扫描索引的速度一般远远大于扫描实际数据行的速度，所以采用索引的方式可以大大提高数据库的工作效率。</p>
<p>简而言之，不使用索引，MySQL 就必须从第一条记录开始读完整个表，直到找出相关的行。表越大，查询数据所花费的时间就越多。如果表中查询的列有一个索引，MySQL 就能快速到达一个位置去搜索数据文件，而不必查看所有数据，这样将会节省很大一部分时间。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>索引的优点如下：</p>
<ul>
<li>通过创建唯一索引可以保证数据库表中每一行数据的唯一性。</li>
<li>可以给所有的 MySQL 列类型设置索引。</li>
<li>可以大大加快数据的查询速度，这是使用索引最主要的原因。</li>
<li>在实现数据的参考完整性方面可以加速表与表之间的连接。</li>
<li>在使用分组和排序子句进行数据查询时也可以显著减少查询中分组和排序的时间</li>
</ul>
<p>增加索引也有许多不利的方面，主要如下：</p>
<ul>
<li>创建和维护索引组要耗费时间，并且随着数据量的增加所耗费的时间也会增加。</li>
<li>索引需要占磁盘空间，除了数据表占数据空间以外，每一个索引还要占一定的物理空间。如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态维护，这样就降低了数据的维护速度。</li>
</ul>
<p>使用索引时，需要综合考虑索引的优点和缺点。</p>
<p>索引可以提高查询速度，但是会影响插入记录的速度。因为，向有索引的表中插入记录时，数据库系统会按照索引进行排序，这样就降低了插入记录的速度，插入大量记录时的速度影响会更加明显。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后，再创建索引。</p>
<h2 id="什么时候需要-x2F-不需要创建索引"><a href="#什么时候需要-x2F-不需要创建索引" class="headerlink" title="什么时候需要&#x2F;不需要创建索引"></a>什么时候需要&#x2F;不需要创建索引</h2><h3 id="什么时候适用索引"><a href="#什么时候适用索引" class="headerlink" title="什么时候适用索引"></a>什么时候适用索引</h3><ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常用于<code>WHERE</code>查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于<code>GROUP BY</code>和<code>ORDER BY</code>的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在<code>B+Tree</code>中的记录都是排序好的。</li>
</ul>
<h3 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h3><ul>
<li><code>WHERE</code>条件，<code>GROUP BY，ORDER BY</code>里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护<code>B+Tree</code>的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>索引的分类和存储引擎有关，每种存储引擎所支持的索引类型不一定完全相同。</p>
<p>我们可以按照四个角度来分类索引。</p>
<ul>
<li>按「数据结构」分类：<code>B+tree</code>索引、<code>Hash</code>索引、<code>Full-text</code>索引。</li>
<li>按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。</li>
<li>按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。</li>
<li>按「字段个数」分类：单列索引、联合索引。</li>
</ul>
<h2 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h2><p>从数据结构的角度来看，MySQL 常见索引有<code>B+Tree</code>索引、<code>HASH</code>索引、<code>Full-Text</code>索引。</p>
<table>
<thead>
<tr>
<th align="center">索引类型</th>
<th align="center">InnoDB 引擎</th>
<th align="center">MyISAM 引擎</th>
<th align="center">Memory 引擎</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B+Tree 索引</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">HASH 索引</td>
<td align="center">No <br>不支持 HASH 索引，但是在内存结构中有一个自适应 HASH 索引</td>
<td align="center">NO</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">Full-Text 索引</td>
<td align="center">Yes<br>MySQL5.6版本后支持</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
</tbody></table>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p>InnoDB 是在 MySQL5.5 之后成为默认的 MySQL 存储引擎，<code>B+Tree</code>索引类型也是 MySQL 存储引擎采用最多的索引类型。</p>
<p><code>B+Tree</code>索引是一个典型的数据结构，其包含的组件主要有以下几个：</p>
<ul>
<li>叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。</li>
<li>分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。</li>
<li>根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。</li>
</ul>
<p>基于这种树形数据结构，表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行。</p>
<p><code>B+Tree</code>索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行<code>ORDER BY</code>排序。但<code>B+Tree</code>树索引必须遵循左边前缀原则，要考虑以下几点约束：</p>
<ul>
<li>查询必须从索引的最左边的列开始。</li>
<li>查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。</li>
<li>存储引擎不能使用索引中范围条件右边的列。</li>
</ul>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键（<code>key</code>）；</li>
<li>如果没有主键，就选择第一个不包含<code>NULL</code>值的唯一列作为聚簇索引的索引键（<code>key</code>）；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增<code>id</code>列作为聚簇索引的索引键（<code>key</code>）；</li>
</ul>
<p>其它索引都属于辅助索引（<code>Secondary Index</code>），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是<code>B+Tree</code>索引。</p>
<h3 id="B-Tree-索引的存储和查询的过程"><a href="#B-Tree-索引的存储和查询的过程" class="headerlink" title="B+Tree 索引的存储和查询的过程"></a>B+Tree 索引的存储和查询的过程</h3><p>接下来通过一个简单例子，说明一下<code>B+Tree</code>索引在存储数据中的具体实现。</p>
<p>先创建一张商品表，<code>id</code>为主键，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `product`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `product_no` <span class="type">varchar</span>(<span class="number">20</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>
<p>商品表里，有这些行数据：</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/1.png" class="">

<p>这些行数据，存储在<code>B+Tree</code>索引时是长什么样子的？</p>
<p><code>B+Tree</code>是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</p>
<p>主键索引的<code>B+Tree</code>如图所示：</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/2.png" class="">

<h4 id="通过主键查询商品数据的过程"><a href="#通过主键查询商品数据的过程" class="headerlink" title="通过主键查询商品数据的过程"></a>通过主键查询商品数据的过程</h4><p>比如，我们执行了下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id<span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句使用了主键索引查询<code>id</code>号为 5 的商品。查询过程是这样的，<code>B+Tree</code>会自顶向下逐层进行查找：</p>
<ul>
<li>将 5 与根节点的索引数据<code>(1，10，20)</code>比较，5 在 1 和 10 之间，所以根据<code>B+Tree</code>的搜索逻辑，找到第二层的索引数据<code>(1，4，7)</code>；</li>
<li>在第二层的索引数据<code>(1，4，7)</code>中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据<code>(4，5，6)</code>；</li>
<li>在叶子节点的索引数据<code>(4，5，6)</code>中进行查找，然后我们找到了索引值为 5 的行数据。</li>
</ul>
<p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I&#x2F;O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I&#x2F;O 操作。</p>
<p><code>B+Tree</code>存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I&#x2F;O，所以<code>B+Tree</code>相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I&#x2F;O 依然维持在 3-4 次。</p>
<h4 id="通过二级索引查询商品数据的过程"><a href="#通过二级索引查询商品数据的过程" class="headerlink" title="通过二级索引查询商品数据的过程"></a>通过二级索引查询商品数据的过程</h4><p>主键索引的<code>B+Tree</code>和二级索引的<code>B+Tree</code>区别如下：</p>
<ul>
<li>主键索引的<code>B+Tree</code>的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的<code>B+Tree</code>的叶子节点里；</li>
<li>二级索引的<code>B+Tree</code>的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>将前面的商品表中的<code>product_no</code>字段设置为二级索引，那么二级索引的<code>B+Tree</code>如下图。</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/3.png" class="">

<p>其中非叶子的<code>key</code>值是<code>product_no</code>（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。</p>
<p>如果用<code>product_no</code>二级索引查询商品，如下查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>会先检二级索引中的<code>B+Tree</code>的索引值（商品编码，<code>product_no</code>），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的<code>B+Tree</code>树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个<code>B+Tree</code>才能查到数据。如下图：</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/4.png" class="">

<p>不过，当查询的数据是能在二级索引的<code>B+Tree</code>的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这种在二级索引的<code>B+Tree</code>就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个<code>B+Tree</code>就能找到数据。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希（<code>Hash</code>）就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。哈希索引也称为散列索引或<code>HASH</code>索引。</p>
<p><code>HASH</code>索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p>
<ul>
<li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于<code>B+Tree</code>索引来说，建立哈希索引会耗费更多的时间。</li>
<li>不能使用<code>HASH</code>索引排序。</li>
<li><code>HASH</code>索引只支持等值比较，如<code>= IN()</code>或<code>&lt;=&gt;</code>。</li>
<li><code>HASH</code>索引不支持键的部分匹配，因为在计算<code>HASH</code>值的时候是通过整个索引值来计算的。</li>
</ul>
<h2 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h2><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）：</p>
<ul>
<li>主键索引的<code>B+Tree</code>的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的<code>B+Tree</code>的叶子节点里；</li>
<li>二级索引的<code>B+Tree</code>的叶子节点存放的是主键值，而不是实际数据。</li>
</ul>
<p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p>
<h2 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h2><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许重复或为空。</p>
<p>创建主键索引通常使用<code>PRIMARY KEY</code>关键字。不能使用<code>CREATE INDEX</code>语句创建主键索引。</p>
<p>在创建表时，创建主键索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>唯一索引建立在<code>UNIQUE</code>字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p>
<p>创建唯一索引通常使用<code>UNIQUE</code>关键字。</p>
<p>在创建表时，创建唯一索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name <span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure>
<h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为<code>UNIQUE</code>。</p>
<p>普通索引没有任何限制，唯一任务就是加快系统对数据的访问速度。普通索引允许在定义索引的列中插入重复值和空值。</p>
<p>创建普通索引时，通常使用的关键字是<code>INDEX</code>或<code>KEY</code>。</p>
<p>在创建表时，创建普通索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>建表后，如果要创建普通索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为<code>char、varchar、binary、varbinary</code>的列上。</p>
<p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p>
<p>在创建表时，创建前缀索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">  column_list,</span><br><span class="line">  INDEX(column_name(length))</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name(column_name(length)); </span><br></pre></td></tr></table></figure>
<h2 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h2><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p>
<ul>
<li>建立在单列上的索引称为单列索引，比如主键索引；</li>
<li>建立在多列上的索引称为联合索引；</li>
</ul>
<h3 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h3><p>单列索引就是索引只包含原表的一个列。在表中的单个字段上创建索引，单列索引只根据该字段进行索引。</p>
<p>单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。</p>
<p>下面在<code>tb_student</code>表中的<code>address</code>字段上建立名为<code>index_addr</code>的单列索引，<code>address</code>字段的数据类型为<code>VARCHAR(20)</code>，索引的数据类型为<code>CHAR(4)</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_addr <span class="keyword">ON</span> tb_student(address(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p>这样，查询时可以只查询<code>address</code>字段的前 4 个字符，而不需要全部查询。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>通过将多个字段组合成一个索引，该索引就被称为联合索引(多列索引)。</p>
<p>联合索引指向创建时对应的多个字段，可以通过这几个字段进行查询。但是，只有查询条件中使用了这些字段中第一个字段时，索引才会被使用。</p>
<p>比如将商品表中的<code>product_no</code>和<code>name</code>字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure>
<p>联合索引<code>(product_no, name)</code>的<code>B+Tree</code>示意图如下：</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/5.png" class="">

<p>可以看到，联合索引的非叶子节点用两个字段的值作为<code>B+Tree</code>的<code>key</code>值。当在联合索引查询数据时，先按<code>product_no</code>字段比较，在<code>product_no</code>相同的情况下再按<code>name</code>字段比较。</p>
<p>也就是说，联合索引查询的<code>B+Tree</code>是先按<code>product_no</code>进行排序，然后再<code>product_no</code>相同的情况再按<code>name</code>字段排序。</p>
<p>因此，使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p>
<p>比如，如果创建了一个<code>(a, b, c)</code>联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span>；</span><br><span class="line"><span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="number">3</span>；</span><br><span class="line"><span class="keyword">where</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">2</span>；</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为有查询优化器，所以<code>a</code>字段在<code>where</code>子句的顺序并不重要。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> b<span class="operator">=</span><span class="number">2</span>；</span><br><span class="line"><span class="keyword">where</span> c<span class="operator">=</span><span class="number">3</span>；</span><br><span class="line"><span class="keyword">where</span> b<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> c<span class="operator">=</span><span class="number">3</span>；</span><br></pre></td></tr></table></figure>
<p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code>联合索引，是先按<code>a</code>排序，在<code>a</code>相同的情况再按<code>b</code>排序，在<code>b</code>相同的情况再按<code>c</code>排序。所以，<code>b</code>和<code>c</code>是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p>
<p>我这里举联合索引<code>(a, b)</code>的例子，该联合索引的<code>B+ Tree</code>如下。</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/6.png" class="">

<p>可以看到，<code>a</code>是全局有序的<code>(1, 2, 2, 3, 4, 5, 6, 7 ,8)</code>，而<code>b</code>是全局是无序的<code>(12, 7, 8, 2, 3, 8, 10, 5, 2)</code>。因此，直接执行<code>where b = 2</code>这种查询条件没有办法利用联合索引的，利用索引的前提是索引里的<code>key</code>是有序的。</p>
<p>只有在<code>a</code>相同的情况才，<code>b</code>才是有序的，比如<code>a</code>等于 2 的时候，<code>b</code>的值为<code>(7, 8)</code>，这时就是有序的，这个有序状态是局部的，因此，执行<code>where a = 2 and b = 7</code>是<code>a</code>和<code>b</code>字段能用到联合索引的，也就是联合索引生效了。</p>
<h4 id="联合索引范围查询"><a href="#联合索引范围查询" class="headerlink" title="联合索引范围查询"></a>联合索引范围查询</h4><p>联合索引有一些特殊情况，并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询，也就是可能存在部分字段用到联合索引的<code>B+Tree</code>，部分字段没有用到联合索引的<code>B+Tree</code>的情况。</p>
<p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</p>
<p>范围查询有很多种，那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？</p>
<p>接下来，举例几个范围查例子。</p>
<p>Q1: <code>select * from t_table where a &gt; 1 and b = 2</code>，联合索引<code>(a, b)</code>哪一个字段用到了联合索引的<code>B+Tree</code>？</p>
<p>由于联合索引（二级索引）是先按照<code>a</code>字段的值排序的，所以符合<code>a &gt; 1</code>条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合<code>a &gt; 1</code>条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合<code>a &gt; 1</code>条件位置。所以<code>a</code>字段可以在联合索引的<code>B+Tree</code>中进行索引查询。</p>
<p>但是在符合<code>a &gt; 1</code>条件的二级索引记录的范围里，<code>b</code>字段的值是无序的。比如前面图的联合索引的<code>B+Tree</code>里，下面这三条记录的<code>a</code>字段的值都符合<code>a &gt; 1</code>查询条件，而<code>b</code>字段的值是无序的：</p>
<ul>
<li><code>a</code>字段值为 5 的记录，该记录的<code>b</code>字段值为 8；</li>
<li><code>a</code>字段值为 6 的记录，该记录的<code>b</code>字段值为 10；</li>
<li><code>a</code>字段值为 7 的记录，该记录的<code>b</code>字段值为 5；</li>
</ul>
<p>因此，我们不能根据查询条件<code>b = 2</code>来进一步减少需要扫描的记录数量（<code>b</code>字段无法利用联合索引进行索引查询的意思）。</p>
<p>所以在执行 Q1 这条查询语句的时候，对应的扫描区间是<code>(2, + ∞)</code>，形成该扫描区间的边界条件是<code>a &gt; 1</code>，与<code>b = 2</code>无关。</p>
<p>因此，Q1 这条查询语句只有<code>a</code>字段用到了联合索引进行索引查询，而<code>b</code>字段并没有使用到联合索引。</p>
<p>我们也可以在执行计划中的<code>key_len</code>知道这一点，在使用联合索引进行查询的时候，通过<code>key_len</code>我们可以知道优化器具体使用了多少个字段的搜索条件来形成扫描区间的边界条件。</p>
<p>举例个例子，<code>a</code>和<code>b</code>都是<code>int</code>类型且不为<code>NULL</code>的字段，那么 Q1 这条查询语句执行计划如下，可以看到<code>key_len</code>为 4 字节（如果字段允许为<code>NULL</code>，就在字段类型占用的字节数上加 1，也就是 5 字节），说明只有<code>a</code>字段用到了联合索引进行索引查询，而且可以看到，即使<code>b</code>字段没用到联合索引，<code>key</code>为<code>idx_a_b</code>，说明 Q1 查询语句使用了<code>idx_a_b</code>联合索引。</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/7.png" class="">

<p>通过 Q1 查询语句我们可以知道，<code>a</code>字段使用了<code>&gt;</code>进行范围查询，联合索引的最左匹配原则在遇到<code>a</code>字段的范围查询（<code>&gt;</code>）后就停止匹配了，因此<code>b</code>字段并没有使用到联合索引。</p>
<p>Q2: <code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引<code>(a, b)</code>哪一个字段用到了联合索引的<code>B+Tree</code>？</p>
<p>Q2 和 Q1 的查询语句很像，唯一的区别就是<code>a</code>字段的查询条件「大于等于」。</p>
<p>由于联合索引（二级索引）是先按照<code>a</code>字段的值排序的，所以符合<code>&gt;= 1</code>条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合<code>&gt;= 1</code>条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合<code>a &gt;= 1</code>条件位置。所以<code>a</code>字段可以在联合索引的<code>B+Tree</code>中进行索引查询。</p>
<p>虽然在符合<code>a &gt;= 1</code>条件的二级索引记录的范围里，<code>b</code>字段的值是「无序」的，但是对于符合<code>a = 1</code>的二级索引记录的范围里，<code>b</code>字段的值是「有序」的（因为对于联合索引，是先按照<code>a</code>字段的值排序，然后在<code>a</code>字段的值相同的情况下，再按照<code>b</code>字段的值进行排序）。</p>
<p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的<code>a</code>字段值为 1 时，可以通过<code>b = 2</code>条件减少需要扫描的二级索引记录范围（<code>b</code>字段可以利用联合索引进行索引查询的意思）。也就是说，从符合<code>a = 1 and b = 2</code>条件的第一条记录开始扫描，而不需要从第一个<code>a</code>字段值为 1 的记录开始扫描。</p>
<p>所以，Q2 这条查询语句<code>a</code>和<code>b</code>字段都用到了联合索引进行索引查询。</p>
<p>我们也可以在执行计划中的<code>key_len</code>知道这一点。执行计划如下，可以看到<code>key_len</code>为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是<code>a</code>和<code>b</code>字段都用到了联合索引进行索引查询。</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/8.png" class="">

<p>通过 Q2 查询语句我们可以知道，虽然<code>a</code>字段使用了<code>&gt;=</code>进行范围查询，但是联合索引的最左匹配原则并没有在遇到<code>a</code>字段的范围查询（<code>&gt;=</code>）后就停止匹配了，<code>b</code>字段还是可以用到了联合索引的。</p>
<p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引<code>(a, b)</code>哪一个字段用到了联合索引的<code>B+Tree</code>？</p>
<p>Q3 查询条件中<code>a BETWEEN 2 AND 8</code>的意思是查询<code>a</code>字段的值在 2 和 8 之间的记录。不同的数据库对<code>BETWEEN ... AND</code>处理方式是有差异的。在 MySQL 中，<code>BETWEEN</code>包含了<code>value1</code>和<code>value2</code>边界值，类似于<code>&gt;= and =&lt;</code>。而有的数据库则不包含<code>value1</code>和<code>value2</code>边界值（类似于<code>&gt; and &lt;</code>）。</p>
<p>由于 MySQL 的<code>BETWEEN</code>包含<code>value1</code>和<code>value2</code>边界值，所以类似于 Q2 查询语句，因此 Q3 这条查询语句<code>a</code>和<code>b</code>字段都用到了联合索引进行索引查询。</p>
<p>我们也可以在执行计划中的<code>key_len</code>知道这一点。执行计划如下，可以看到<code>key_len</code>为 8 字节，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是<code>a</code>和<code>b</code>字段都用到了联合索引进行索引查询。</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/9.png" class="">

<p>通过 Q3 查询语句我们可以知道，虽然<code>a</code>字段使用了<code>BETWEEN</code>进行范围查询，但是联合索引的最左匹配原则并没有在遇到<code>a</code>字段的范围查询（<code>BETWEEN</code>）后就停止匹配了，<code>b</code>字段还是可以用到了联合索引的。</p>
<p>Q4: <code>SELECT * FROM t_user WHERE name like &#39;j%&#39; and age = 22</code>，联合索引<code>(name, age)</code>哪一个字段用到了联合索引的<code>B+Tree</code>？</p>
<p>由于联合索引（二级索引）是先按照<code>name</code>字段的值排序的，所以前缀为<code>j</code>的<code>name</code>字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为<code>j</code>的<code>name</code>字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的<code>name</code>前缀不为<code>j</code>为止。</p>
<p>所以<code>a</code>字段可以在联合索引的<code>B+Tree</code>中进行索引查询，形成的扫描区间是<code>[&#39;j&#39;,&#39;k&#39;)</code>。注意，<code>j</code>是闭区间。如下图：</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/10.png" class="">

<p>虽然在符合前缀为<code>j</code>的<code>name</code>字段的二级索引记录的范围里，<code>age</code>字段的值是「无序」的，但是对于符合<code>name = j</code>的二级索引记录的范围里，<code>age</code>字段的值是「有序」的（因为对于联合索引，是先按照<code>name</code>字段的值排序，然后在<code>name</code>字段的值相同的情况下，再按照<code>age</code>字段的值进行排序）。</p>
<p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的<code>name</code>字段值为<code>j</code>时，可以通过<code>age = 22</code>条件减少需要扫描的二级索引记录范围（<code>age</code>字段可以利用联合索引进行索引查询的意思）。也就是说，从符合<code>name = &#39;j&#39; and age = 22</code>条件的第一条记录时开始扫描，而不需要从第一个<code>name</code>为<code>j</code>的记录开始扫描。如下图的右边：</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/11.png" class="">

<p>所以，Q4 这条查询语句<code>a</code>和<code>b</code>字段都用到了联合索引进行索引查询。</p>
<p>我们也可以在执行计划中的<code>key_len</code>知道这一点。本次例子中：</p>
<ul>
<li><code>name</code>字段的类型是<code>varchar(30)</code>且不为<code>NULL</code>，数据库表使用了<code>utf8mb4</code>字符集，一个字符集为<code>utf8mb4</code>的字符是 4 个字节，因此<code>name</code>字段的实际数据最多占用的存储空间长度是 120 字节（30 x 4），然后因为<code>name</code>是变长类型的字段，需要再加 2 字节（用于存储该字段实际数据的长度值），也就是<code>name</code>的<code>key_len</code>为 122。</li>
<li><code>age</code>字段的类型是<code>int</code>且不为<code>NULL</code>，<code>key_len</code>为 4。</li>
</ul>
<p>Q4 查询语句的执行计划如下，可以看到<code>key_len</code>为 126 字节，<code>name</code>的<code>key_len</code>为 122，<code>age</code>的<code>key_len</code>为 4，说明优化器使用了 2 个字段的查询条件来形成扫描区间的边界条件，也就是<code>name</code>和<code>age</code>字段都用到了联合索引进行索引查询。</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/12.png" class="">

<p>通过 Q4 查询语句我们可以知道，虽然<code>name</code>字段使用了<code>like</code>前缀匹配进行范围查询，但是联合索引的最左匹配原则并没有在遇到<code>name</code>字段的范围查询（<code>like &#39;j%&#39;</code>）后就停止匹配了，<code>age</code>字段还是可以用到了联合索引的。</p>
<p>综上所示，联合索引的最左匹配原则，在遇到范围查询（如<code>&gt;、&lt;</code>）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于<code>&gt;=、&lt;=、BETWEEN、like</code>前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>现在我们知道，对于联合索引<code>（a, b）</code>，在执行<code>select * from table where a &gt; 1 and b = 2</code>语句的时候，只有<code>a</code>字段能用到索引，那在联合索引的<code>B+Tree</code>找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看<code>b</code>是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p>
<ul>
<li>在 MySQL5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比<code>b</code>字段值。</li>
<li>而 MySQL5.6 引入的索引下推优化<code>(index condition pushdown)</code>， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li>
</ul>
<p>当你的查询语句的执行计划里，出现了<code>Extra</code>为<code>Using index condition</code>，那么说明使用了索引下推的优化。</p>
<h4 id="索引区分度"><a href="#索引区分度" class="headerlink" title="索引区分度"></a>索引区分度</h4><p>另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。</p>
<p>区分度就是某个字段<code>column</code>不同值的个数「除以」表的总行数，计算公式如下：</p>
<img src="/2020/05/06/MySQL/MySQL%E7%B4%A2%E5%BC%95/13.png" class="">

<p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p>
<p>因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</p>
<h4 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h4><p>针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
<p>给<code>status</code>和<code>create_time</code>列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</p>
<p>因为在查询时，如果只用到<code>status</code>的索引，但是这条语句还要对<code>create_time</code>排序，这时就要用文件排序<code>filesort</code>，也就是在 SQL 执行计划中，<code>Extra</code>列会出现<code>Using filesort</code>。</p>
<p>所以，要利用索引的有序性，在<code>status</code>和<code>create_time</code>列建立联合索引，这样根据<code>status</code>筛选后的数据就是按照<code>create_time</code>排好序的，避免在文件排序，提高了查询效率。</p>
<p>提示：一个表可以有多个单列索引，但这些索引不是组合索引。一个组合索引实质上为表的查询提供了多个索引，以此来加快查询速度。比如，在一个表中创建了一个组合索引<code>(c1，c2，c3)</code>，在实际查询中，系统用来实际加速的索引有三个：单个索引<code>(c1)</code>、双列索引<code>(c1，c2)</code>和多列索引<code>(c1，c2，c3)</code>。</p>
<h1 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h1><p>创建索引是指在某个表的一列或多列上建立一个索引，可以提高对表的访问速度。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>MySQL 提供了三种创建索引的方法：</p>
<h3 id="1-使用-CREATE-INDEX-语句"><a href="#1-使用-CREATE-INDEX-语句" class="headerlink" title="1.使用 CREATE INDEX 语句"></a>1.使用 CREATE INDEX 语句</h3><p>可以使用专门用于创建索引的<code>CREATE INDEX</code>语句在一个已有的表上创建索引，但该语句不能创建主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="operator">&lt;</span>长度<span class="operator">&gt;</span>] [ <span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>])</span><br></pre></td></tr></table></figure>
<p>语法说明：</p>
<ul>
<li>&lt;索引名&gt;：指定索引名。一个表可以创建多个索引，但每个索引在该表中的名称是唯一的。</li>
<li>&lt;表名&gt;：指定要创建索引的表名。</li>
<li>&lt;列名&gt;：指定要创建索引的列名。通常可以考虑将查询语句中在<code>JOIN</code>子句和<code>WHERE</code>子句里经常出现的列作为索引列。</li>
<li>&lt;长度&gt;：可选项。指定使用列前的<code>length</code>个字符来创建索引。使用列的一部分创建索引有利于减小索引文件的大小，节省索引列所占的空间。在某些情况下，只能对列的前缀进行索引。索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，<code>BLOB</code>或<code>TEXT</code>类型的列也必须使用前缀索引。</li>
<li><code>ASC|DESC</code>：可选项。<code>ASC</code>指定索引按照升序来排列，<code>DESC</code>指定索引按照降序来排列，默认为<code>ASC</code>。</li>
</ul>
<h3 id="2-使用-CREATE-TABLE-语句"><a href="#2-使用-CREATE-TABLE-语句" class="headerlink" title="2.使用 CREATE TABLE 语句"></a>2.使用 CREATE TABLE 语句</h3><p>索引也可以在创建表（<code>CREATE TABLE</code>）的同时创建。在<code>CREATE TABLE</code>语句中添加以下语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> <span class="keyword">PRIMARY</span> KEY [索引类型] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure>
<p>在<code>CREATE TABLE</code>语句中添加此语句，表示在创建新表的同时创建该表的主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY <span class="operator">|</span> INDEX [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure>
<p>在<code>CREATE TABLE</code>语句中添加此语句，表示在创建新表的同时创建该表的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNIQUE</span> [ INDEX <span class="operator">|</span> KEY] [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure>
<p>在<code>CREATE TABLE</code>语句中添加此语句，表示在创建新表的同时创建该表的唯一性索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOREIGN</span> KEY <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>CREATE TABLE</code>语句中添加此语句，表示在创建新表的同时创建该表的外键。</p>
<p>在使用<code>CREATE TABLE</code>语句定义列选项的时候，可以通过直接在某个列定义后面添加<code>PRIMARY KEY</code>的方式创建主键。而当主键是由多个列组成的多列索引时，则不能使用这种方法，只能用在语句的最后加上一个<code>PRIMARY KRY(&lt;列名&gt;，…)</code>子句的方式来实现。</p>
<h3 id="2-使用-ALTER-TABLE-语句"><a href="#2-使用-ALTER-TABLE-语句" class="headerlink" title="2.使用 ALTER TABLE 语句"></a>2.使用 ALTER TABLE 语句</h3><p><code>CREATE INDEX</code>语句可以在一个已有的表上创建索引，<code>ALTER TABLE</code>语句也可以在一个已有的表上创建索引。在使用<code>ALTER TABLE</code>语句修改表的同时，可以向已有的表添加索引。具体的做法是在<code>ALTER TABLE</code>语句中添加以下语法成分的某一项或几项。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span> INDEX [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure>
<p>在<code>ALTER TABLE</code>语句中添加此语法成分，表示在修改表的同时为该表添加索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure>
<p>在<code>ALTER TABLE</code>语句中添加此语法成分，表示在修改表的同时为该表添加主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [ INDEX <span class="operator">|</span> KEY] [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>索引类型<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure>
<p>在<code>ALTER TABLE</code>语句中添加此语法成分，表示在修改表的同时为该表添加唯一性索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY [<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>] (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>,…)</span><br></pre></td></tr></table></figure>
<p>在<code>ALTER TABLE</code>语句中添加此语法成分，表示在修改表的同时为该表添加外键。</p>
<h2 id="创建普通索引"><a href="#创建普通索引" class="headerlink" title="创建普通索引"></a>创建普通索引</h2><p>创建普通索引时，通常使用<code>INDEX</code>关键字。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_stu_info</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">CHAR</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> dept_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> height <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> INDEX(height)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">Query OK，<span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.40</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_stu_info\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: tb_stu_info</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_stu_info` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `dept_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `height` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  KEY `height` (`height`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>gb2312</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h2><p>创建唯一索引，通常使用<code>UNIQUE</code>参数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_stu_info2</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">CHAR</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> dept_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> height <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">UNIQUE</span> INDEX(height)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">Query OK，<span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.40</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_stu_info2\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: tb_stu_info2</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_stu_info2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `dept_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `height` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `height` (`height`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>gb2312</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h1><p>可以使用<code>SHOW INDEX</code>语句查看表中创建的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [ <span class="keyword">FROM</span> <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure>
<p>语法说明：</p>
<ul>
<li>&lt;表名&gt;：指定需要查看索引的数据表名。</li>
<li>&lt;数据库名&gt;：指定需要查看索引的数据表所在的数据库，可省略。比如，<code>SHOW INDEX FROM student FROM test;</code>语句表示查看<code>test</code>数据库中<code>student</code>数据表的索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> tb_stu_info2\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">        <span class="keyword">Table</span>: tb_stu_info2</span><br><span class="line">   Non_unique: <span class="number">0</span></span><br><span class="line">     Key_name: height</span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: height</span><br><span class="line">    <span class="keyword">Collation</span>: A</span><br><span class="line">  <span class="keyword">Cardinality</span>: <span class="number">0</span></span><br><span class="line">     Sub_part: <span class="keyword">NULL</span></span><br><span class="line">       Packed: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">Null</span>: YES</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br></pre></td></tr></table></figure>
<p>其中各主要参数说明如下：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Table</td>
<td align="center">表示创建索引的数据表名，这里是 tb_stu_info2 数据表。</td>
</tr>
<tr>
<td align="center">Non_unique</td>
<td align="center">表示该索引是否是唯一索引。若不是唯一索引，则该列的值为 1；若是唯一索引，则该列的值为 0。</td>
</tr>
<tr>
<td align="center">Key_name</td>
<td align="center">表示索引的名称。</td>
</tr>
<tr>
<td align="center">Seq_in_index</td>
<td align="center">表示该列在索引中的位置，如果索引是单列的，则该列的值为 1；如果索引是组合索引，则该列的值为每列在索引定义中的顺序。</td>
</tr>
<tr>
<td align="center">Column_name</td>
<td align="center">表示定义索引的列字段。</td>
</tr>
<tr>
<td align="center">Collation</td>
<td align="center">表示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。</td>
</tr>
<tr>
<td align="center">Cardinality</td>
<td align="center">索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</td>
</tr>
<tr>
<td align="center">Sub_part</td>
<td align="center">表示列中被编入索引的字符的数量。若列只是部分被编入索引，则该列的值为被编入索引的字符的数目；若整列被编入索引，则该列的值为 NULL。</td>
</tr>
<tr>
<td align="center">Packed</td>
<td align="center">指示关键字如何被压缩。若没有被压缩，值为 NULL。</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="center">用于显示索引列中是否包含 NULL。若列含有 NULL，该列的值为 YES。若没有，则该列的值为 NO。</td>
</tr>
<tr>
<td align="center">Index_type</td>
<td align="center">显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。</td>
</tr>
<tr>
<td align="center">Comment</td>
<td align="center">显示评注。</td>
</tr>
</tbody></table>
<h1 id="修改和删除索引"><a href="#修改和删除索引" class="headerlink" title="修改和删除索引"></a>修改和删除索引</h1><p>删除索引是指将表中已经存在的索引删除掉。不用的索引建议进行删除，因为它们会降低表的更新速度，影响数据库的性能。</p>
<p>修改索引可以通过删除原索引，再根据需要创建一个同名的索引，从而实现修改索引的操作。</p>
<h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><p>当不再需要索引时，可以使用<code>DROP INDEX</code>语句或<code>ALTER TABLE</code>语句来对索引进行删除。</p>
<h3 id="1-使用-DROP-INDEX-语句"><a href="#1-使用-DROP-INDEX-语句" class="headerlink" title="1. 使用 DROP INDEX 语句"></a>1. 使用 DROP INDEX 语句</h3><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>语法说明如下：</p>
<ul>
<li>&lt;索引名&gt;：要删除的索引名。</li>
<li>&lt;表名&gt;：指定该索引所在的表名。</li>
</ul>
<h3 id="2-使用-ALTER-TABLE-语句-1"><a href="#2-使用-ALTER-TABLE-语句-1" class="headerlink" title="2. 使用 ALTER TABLE 语句"></a>2. 使用 ALTER TABLE 语句</h3><p>根据<code>ALTER TABLE</code>语句的语法可知，该语句也可以用于删除索引。具体使用方法是将<code>ALTER TABLE</code>语句的语法中部分指定为以下子句中的某一项。</p>
<ul>
<li><code>DROP PRIMARY KEY</code>：表示删除表中的主键。一个表只有一个主键，主键也是一个索引。</li>
<li><code>DROP INDEX index_name</code>：表示删除名称为<code>index_name</code>的索引。</li>
<li><code>DROP FOREIGN KEY fk_symbol</code>：表示删除外键。</li>
</ul>
<p>注意：如果删除的列是索引的组成部分，那么在删除该列时，也会将该列从索引中删除；如果组成索引的所有列都被删除，那么整个索引将被删除。</p>
<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>删除表<code>tb_stu_info</code>中的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX height <span class="keyword">ON</span> tb_stu_info;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.27</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_stu_info\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: tb_stu_info</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_stu_info` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `dept_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `height` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>gb2312</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>删除表<code>tb_stu_info2</code>中名称为<code>id</code>的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb_stu_info2 <span class="keyword">DROP</span> INDEX height;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.13</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_stu_info2\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: tb_stu_info2</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_stu_info2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `dept_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `height` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>gb2312</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h1 id="索引在什么情况下不会被使用"><a href="#索引在什么情况下不会被使用" class="headerlink" title="索引在什么情况下不会被使用"></a>索引在什么情况下不会被使用</h1><p>索引可以提高查询的速度，但并不是使用带有索引的字段查询时，索引都会起作用。使用索引有几种特殊情况，在这些情况下，有可能使用带有索引的字段查询时，索引并没有起作用。</p>
<h2 id="1-查询语句中使用LIKE关键字"><a href="#1-查询语句中使用LIKE关键字" class="headerlink" title="1. 查询语句中使用LIKE关键字"></a>1. 查询语句中使用LIKE关键字</h2><p>在查询语句中使用<code>LIKE</code>关键字进行查询时，如果匹配字符串的第一个字符为<code>%</code>，索引不会被使用。如果<code>%</code>不是在第一个位置，索引就会被使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span> sex  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 张三 <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> 男   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 李四 <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> 男   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 王五 <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span> 女   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 张四 <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span> 女   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 王四 <span class="operator">|</span>   <span class="number">15</span> <span class="operator">|</span> 男   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> 赵六 <span class="operator">|</span>   <span class="number">12</span> <span class="operator">|</span> 女   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+------+</span></span><br></pre></td></tr></table></figure>
<p>下面在查询语句中使用<code>LIKE</code>关键字，且匹配的字符串中含有“%”符号，使用<code>EXPLAIN</code>分析查询情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%四&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb_student</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">16.67</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> tb_student(name);</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.13</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span>  EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;李%&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb_student</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">range</span></span><br><span class="line">possible_keys: index_name</span><br><span class="line">          key: index_name</span><br><span class="line">      key_len: <span class="number">77</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index <span class="keyword">condition</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>第一个查询语句执行后，<code>rows</code>参数的值为 6，表示这次查询过程中查询了 6 条记录；第二个查询语句执行后，<code>rows</code>参数的值为 1，表示这次查询过程只查询 1 条记录。同样是使用<code>name</code>字段进行查询，因为第一个查询语句的<code>LIKE</code>关键字后的字符串是以“%”开头的，所以第一个查询语句没有使用索引，而第二个查询语句使用了索引<code>index_name</code>。</p>
<h3 id="2-查询语句中使用多列索引"><a href="#2-查询语句中使用多列索引" class="headerlink" title="2. 查询语句中使用多列索引"></a>2. 查询语句中使用多列索引</h3><p>多列索引是在表的多个字段上创建一个索引，只有查询条件中使用了这些字段中的第一个字段，索引才会被使用。</p>
<p>在<code>name</code>和<code>age</code>两个字段上创建多列索引，并验证多列索引的使用情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX index_name_age <span class="keyword">ON</span> tb_student(name,age);</span><br><span class="line">Query OK, <span class="number">6</span> <span class="keyword">rows</span> affected (<span class="number">0.11</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;李%&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb_student</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">range</span></span><br><span class="line">possible_keys: index_name_age</span><br><span class="line">          key: index_name_age</span><br><span class="line">      key_len: <span class="number">77</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> index <span class="keyword">condition</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> age <span class="keyword">LIKE</span> <span class="string">&#x27;12&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb_student</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: <span class="keyword">NULL</span></span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">16.67</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>第一条查询语句的查询条件使用了<code>name</code>字段，分析结果显示<code>rows</code>参数的值为 1，且查询过程中使用了<code>index_name_age</code>索引。第二条查询语句的查询条件使用了<code>age</code>字段，结果显示<code>rows</code>参数的值为 6，且<code>key</code>参数的值为<code>NULL</code>，这说明第二个查询语句没有使用索引。</p>
<p>因为<code>name</code>字段是多列索引的第一个字段，所以只有查询条件中使用了<code>name</code>字段才会使<code>index_name_age</code>索引起作用。</p>
<h3 id="3-查询语句中使用OR关键字"><a href="#3-查询语句中使用OR关键字" class="headerlink" title="3. 查询语句中使用OR关键字"></a>3. 查询语句中使用OR关键字</h3><p>查询语句只有<code>OR</code>关键字时，如果<code>OR</code>前后的两个条件的列都是索引，那么查询中将使用索引。如果<code>OR</code>前后有一个条件的列不是索引，那么查询中将不使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb_student</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: <span class="keyword">ALL</span></span><br><span class="line">possible_keys: index_name,index_name_age</span><br><span class="line">          key: <span class="keyword">NULL</span></span><br><span class="line">      key_len: <span class="keyword">NULL</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">6</span></span><br><span class="line">     filtered: <span class="number">30.56</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.06</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span> <span class="keyword">or</span> id<span class="operator">=</span><span class="string">&#x27;12&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: tb_student</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: index_merge</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span>,index_name,index_name_age</span><br><span class="line">          key: index_name,<span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">77</span>,<span class="number">4</span></span><br><span class="line">          <span class="keyword">ref</span>: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">2</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">union</span>(index_name,<span class="keyword">PRIMARY</span>); <span class="keyword">Using</span> <span class="keyword">where</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>由于<code>sex</code>字段没有索引，所以第一条查询语句没有使用索引；<code>name</code>字段和<code>id</code>字段都有索引，所以第二条查询语句使用了<code>index_name</code>和<code>PRIMARY</code>索引 。</p>
<p>使用索引查询记录时，一定要注意索引的使用情况。例如，<code>LIKE</code>关键字配置的字符串不能以“%”开头；使用多列索引时，查询条件必须要使用这个索引的第一个字段；使用<code>OR</code>关键字时，<code>OR</code>关键字连接的所有条件都必须使用索引。</p>
<h1 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h1><p>索引的设计可以遵循一些已有的原则，创建索引的时候应尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p>
<ol>
<li>选择唯一性索引<br>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</li>
<li>为经常需要排序、分组和联合操作的字段建立索引<br>经常需要<code>ORDER BY、GROUP BY、DISTINCT</code>和<code>UNION</code>等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</li>
<li>为常作为查询条件的字段建立索引<br>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。<br>注意：常查询条件的字段不一定是所要选择的列，换句话说，最适合索引的列是出现在<code>WHERE</code>子句中的列，或连接子句中指定的列，而不是出现在<code>SELECT</code>关键字后的选择列表中的列。</li>
<li>限制索引的数目<br>索引的数目不是“越多越好”。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。在修改表的内容时，索引必须进行更新，有时还可能需要重构。因此，索引越多，更新表的时间就越长。<br>如果有一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要花费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最佳索引。</li>
<li>尽量使用数据量少的索引<br>如果索引的值很长，那么查询的速度会受到影响。例如，对一个<code>CHAR(100)</code>类型的字段进行全文检索需要的时间肯定要比对<code>CHAR(10)</code>类型的字段需要的时间要多。</li>
<li>数据量小的表最好不要使用索引<br>由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</li>
<li>尽量使用前缀来索引<br>如果索引字段的值很长，最好使用值的前缀来索引。例如，<code>TEXT</code>和<code>BLOG</code>类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</li>
<li>删除不再使用或者很少使用的索引<br>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应该定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/21/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/23/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>