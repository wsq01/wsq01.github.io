<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-计算机网络/应用层——HTTP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/"
    >应用层——HTTP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/" class="article-date">
  <time datetime="2020-10-21T02:09:28.000Z" itemprop="datePublished">2020-10-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="万维网的工作过程"><a href="#万维网的工作过程" class="headerlink" title="万维网的工作过程"></a>万维网的工作过程</h1><img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img2.png" class="">

<p>每个万维网网点都有一个服务器进程，它不断地监听 TCP 的端口 80，以便发现是否有浏览器向它发出连接建立请求。</p>
<p>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</p>
<p>最后，TCP 连接就被释放了。</p>
<p>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这些格式和规则就是超文本传送协议 HTTP。</p>
<p>HTTP 规定在 HTTP 客户与 HTTP 服务器之间的每次交互，都由一个 ASCII 码串构成的请求和一个类似的通用互联网扩充，即“类 MIME(<code>MIME-like</code>)”的响应组成。</p>
<p>HTTP 报文通常都使用 TCP 连接传送。</p>
<p>用户浏览页面的两种方法：</p>
<ol>
<li>在浏览器的地址窗口中键入所要找的页面的 URL。</li>
<li>在某一个页面中用鼠标点击一个可选部分，这时浏览器会自动在互联网上找到所要链接的页面。</li>
</ol>
<h1 id="HTTP-的主要特点"><a href="#HTTP-的主要特点" class="headerlink" title="HTTP 的主要特点"></a>HTTP 的主要特点</h1><p>HTTP 使用了面向连接的 TCP 作为运输层协议，保证了数据的可靠传输。</p>
<p>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。</p>
<p>HTTP 是面向事务的客户服务器协议。</p>
<p>HTTP 1.0 协议是无状态的。</p>
<h2 id="请求一个万维网文档所需的时间"><a href="#请求一个万维网文档所需的时间" class="headerlink" title="请求一个万维网文档所需的时间"></a>请求一个万维网文档所需的时间</h2><p>用户在点击鼠标链接某个万维网文档时，HTTP 协议首先要和服务器建立 TCP 链接，这需要使用三报文握手。当建立 TCP 连接的三报文握手的前两部分完成后（即经过了一个 RTT 的时间后），万维网客户就把 HTTP 请求报文，作为建立 TCP 连接的三报文握手中的第三个报文的数据发送给万维网服务器。服务器收到 HTTP 请求报文后，就把所请求的文档作为响应报文返回给客户。</p>
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img3.png" class="">

<p>从图中可以看出，请求一个万维网文档所需的时间是该文档的传输时间加上两倍往返时间 RTT（一个 RTT 用于 TCP 连接，一个用于请求和接收万维网文档）。</p>
<p>HTTP&#x2F;1.0 主要的缺点就是每请求一个文档就要有两倍 RTT 的开销。另一种开销就是万维网客户和服务器每建立一次新的 TCP 连接都要分配缓存和变量。</p>
<p>HTTP&#x2F;1.1 较好的解决了这个问题，它使用了持续连接。</p>
<h2 id="持续连接"><a href="#持续连接" class="headerlink" title="持续连接"></a>持续连接</h2><p>持续连接就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。</p>
<p>这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</p>
<p>持续连接的两种工作方式：</p>
<ul>
<li>非流水线方式：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li>
<li>流水线方式：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li>
</ul>
<h1 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h1><p>代理服务器又称为万维网高速缓存，它代表浏览器发出 HTTP 请求。</p>
<p>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。</p>
<p>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源。</p>
<p>代理服务器可在客户端或服务器工作，也可在中间系统工作。</p>
<p>使用高速缓存可减少访问互联网服务器的时延。</p>
<h2 id="没有使用高速缓存的情况"><a href="#没有使用高速缓存的情况" class="headerlink" title="没有使用高速缓存的情况"></a>没有使用高速缓存的情况</h2><img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img4.png" class="">

<h2 id="使用高速缓存的情况"><a href="#使用高速缓存的情况" class="headerlink" title="使用高速缓存的情况"></a>使用高速缓存的情况</h2><img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img5.png" class="">
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img6.png" class="">
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img7.png" class="">
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img8.png" class="">
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img9.png" class="">

<p>在使用代理服务器的情况下，由于有相当大一部分通信量局限在校园网内，因此，专线链路上的通信量大大减少，因而减小了访问互联网的时延。</p>
<h1 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h1><p>HTTP 有两类报文：</p>
<ul>
<li>请求报文——从客户向服务器发送请求报文。</li>
<li>响应报文——从服务器到客户的回答。</li>
</ul>
<p>由于 HTTP 是面向正文的，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>报文由三个部分组成，即开始行、首部行和实体主体。</p>
<p>在请求报文中开始行叫请求行，在响应报文中开始行叫状态行。</p>
<p>首部行用来说明浏览器、服务器或报文主体的一些信息。首部行可以有好几行，也可以不使用。</p>
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img10.png" class="">

<p>HTTP 请求报文的一些方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OPTION</td>
<td align="center">请求一些选项的信息</td>
</tr>
<tr>
<td align="center">GET</td>
<td align="center">请求读取由 URL所标志的信息</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">请求读取由 URL所标志的信息的首部</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">给服务器添加信息</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">在指明的 URL下存储一个文档</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">删除指明的 URL所标志的资源</td>
</tr>
<tr>
<td align="center">TRACE</td>
<td align="center">用来进行环回测试的请求报文</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="center">用于代理服务器</td>
</tr>
</tbody></table>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/img11.png" class="">

<p>状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。</p>
<h3 id="HTTP-常见状态码"><a href="#HTTP-常见状态码" class="headerlink" title="HTTP 常见状态码"></a>HTTP 常见状态码</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">含义</th>
<th align="center">常见状态码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1xx</td>
<td align="center">提示信息，如请求收到了或正在进行处理</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2xx</td>
<td align="center">成功，报文已经收到并被正确处理</td>
<td align="center">200、204、206</td>
</tr>
<tr>
<td align="center">3xx</td>
<td align="center">重定向，资源位置发生变动，需要客户端重新发送请求</td>
<td align="center">301、302、304</td>
</tr>
<tr>
<td align="center">4xx</td>
<td align="center">客户端错误，请求报文有误，服务器无法处理</td>
<td align="center">400、403、404</td>
</tr>
<tr>
<td align="center">5xx</td>
<td align="center">服务器错误，服务器正在处理请求时内部发生了错误</td>
<td align="center">500， 502、503</td>
</tr>
</tbody></table>
<p><code>1xx</code>类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p>
<p><code>2xx</code>类状态码表示服务器成功处理了客户端的请求。</p>
<ul>
<li><code>200 OK</code>是最常见的成功状态码，表示一切正常。如果是非<code>HEAD</code>请求，服务器返回的响应头都会有<code>body</code>数据。</li>
<li><code>204 No Content</code>也是常见的成功状态码，与<code>200 OK</code>基本相同，但响应头没有<code>body</code>数据。</li>
<li><code>206 Partial Content</code>是应用于 HTTP 分块下载或断点续传，表示响应返回的<code>body</code>数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><code>3xx</code>类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p>
<ul>
<li><code>301 Moved Permanently</code>表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>
<li><code>302 Found</code>表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br>301 和 302 都会在响应头里使用字段<code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</li>
<li><code>304 Not Modified</code>不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<p><code>4xx</code>类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li><code>400 Bad Request</code>表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li><code>403 Forbidden</code>表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li><code>404 Not Found</code>表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><code>5xx</code>类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p>
<ul>
<li><code>500 Internal Server Error</code>与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li><code>501 Not Implemented</code>表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li><code>502 Bad Gateway</code>通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li><code>503 Service Unavailable</code>表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h1 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h1><h2 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h2><p>根据 RFC 规范，GET 的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP 协议本身对 URL 长度并没有做任何规定）。</p>
<p>根据 RFC 规范，POST 的语义是根据请求负荷（报文<code>body</code>）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文<code>body</code>中，<code>body</code>中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对<code>body</code>大小做限制。</p>
<h2 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h2><p>安全和幂等的概念：</p>
<ul>
<li>在 HTTP 协议里，所谓的安全是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的幂等，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<p>如果从 RFC 规范定义的语义来看：</p>
<ul>
<li>GET 方法就是安全且幂等的，因为它是只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如 nginx），而且在浏览器中 GET 请求可以保存为书签。</li>
<li>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</li>
</ul>
<p>做个简要的小结。</p>
<ul>
<li>GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。</li>
<li>POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。</li>
</ul>
<p>注意， 上面是从 RFC 规范定义的语义来分析的。</p>
<p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p>
<ul>
<li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</li>
<li>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</li>
</ul>
<p>如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。</p>
<p>因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。</p>
<p>所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。</p>
<h2 id="GET-请求可以带-body-吗？"><a href="#GET-请求可以带-body-吗？" class="headerlink" title="GET 请求可以带 body 吗？"></a>GET 请求可以带 body 吗？</h2><p>RFC 规范并没有规定 GET 请求不能带<code>body</code>的。理论上，任何请求都可以带<code>body</code>的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到<code>body</code>。</p>
<p>另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</p>
<h1 id="HTTP-常见字段"><a href="#HTTP-常见字段" class="headerlink" title="HTTP 常见字段"></a>HTTP 常见字段</h1><h3 id="Host-字段"><a href="#Host-字段" class="headerlink" title="Host 字段"></a>Host 字段</h3><p>客户端发送请求时，用来指定服务器的域名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.A.com</span><br></pre></td></tr></table></figure>
<p>有了<code>Host</code>字段，就可以将请求发往同一台服务器上的不同网站。</p>
<h3 id="Content-Length-字段"><a href="#Content-Length-字段" class="headerlink" title="Content-Length 字段"></a>Content-Length 字段</h3><p>服务器在返回数据时，会有<code>Content-Length</code>字段，表明本次回应的数据长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 1000</span><br></pre></td></tr></table></figure>
<p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p>
<p>HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，HTTP 协议通过设置回车符、换行符作为 HTTP<code>header</code>的边界，通过<code>Content-Length</code>字段作为 HTTP<code>body</code>的边界，这两个方式都是为了解决“粘包”的问题。</p>
<h3 id="Connection-字段"><a href="#Connection-字段" class="headerlink" title="Connection 字段"></a>Connection 字段</h3><p><code>Connection</code>字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p>
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/20.png" class="">

<p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/21.png" class="">

<p>HTTP&#x2F;1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定<code>Connection</code>首部字段的值为<code>Keep-Alive</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>开启了 HTTP<code>Keep-Alive</code>机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</p>
<h3 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h3><p><code>Content-Type</code>字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; Charset=utf-8</span><br></pre></td></tr></table></figure>
<p>上面的类型表明，发送的是网页，而且编码是 UTF-8。</p>
<p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p>
<h3 id="Content-Encoding-字段"><a href="#Content-Encoding-字段" class="headerlink" title="Content-Encoding 字段"></a>Content-Encoding 字段</h3><p><code>Content-Encoding</code>字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>
<p>上面表示服务器返回的数据采用了<code>gzip</code>方式压缩，告知客户端需要用此方式解压。</p>
<p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<h1 id="HTTP-缓存技术"><a href="#HTTP-缓存技术" class="headerlink" title="HTTP 缓存技术"></a>HTTP 缓存技术</h1><p>对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP&#x2F;1.1 的性能肯定肉眼可见的提升。</p>
<p>所以，避免发送 HTTP 请求的方法就是通过缓存技术，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。</p>
<p>HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。</p>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<p>如下图中，返回的是 200 状态码，但在<code>size</code>项中标识的是<code>from disk cache</code>，就是使用了强制缓存。</p>
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/30.png" class="">

<p>强缓存是利用下面这两个 HTTP 响应头部（<code>Response Header</code>）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p>
<ul>
<li><code>Cache-Control</code>，是一个相对时间；</li>
<li><code>Expires</code>，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有<code>Cache-Control</code>和<code>Expires</code>字段的话，<code>Cache-Control</code>的优先级高于<code>Expires</code>。</p>
<p><code>Cache-control</code>选项更多一些，设置更加精细，所以建议使用<code>Cache-Control</code>来实现强缓存。具体的实现流程如下：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在<code>Response</code>头部加上<code>Cache-Control</code>，<code>Cache-Control</code>中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与<code>Cache-Control</code>中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新<code>Response</code>头部的<code>Cache-Control</code>。</li>
</ul>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/31.png" class="">

<p>上图就是一个协商缓存的过程，所以协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。</p>
<p>协商缓存可以基于两种头部来实现。</p>
<p>第一种：请求头部中的<code>If-Modified-Since</code>字段与响应头部中的<code>Last-Modified</code>字段实现，这两个字段的意思是：</p>
<ul>
<li>响应头部中的<code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的<code>If-Modified-Since</code>：当资源过期了，发现响应头中具有<code>Last-Modified</code>声明，则再次发起请求的时候带上<code>Last-Modified</code>的时间，服务器收到请求后发现有<code>If-Modified-Since</code>则与被请求资源的最后修改时间进行对比（<code>Last-Modified</code>），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段，这两个字段的意思是：</p>
<ul>
<li>响应头部中<code>Etag</code>：唯一标识响应资源；</li>
<li>请求头部中的<code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有<code>Etag</code>，则再次向服务器发起请求时，会将请求头<code>If-None-Match</code>值设置为<code>Etag</code>的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<p>如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有<code>Etag</code>和<code>Last-Modified</code>字段，那么客户端再下一次请求的时候，如果带上了<code>ETag</code>和<code>Last-Modified</code>字段信息给服务端，这时<code>Etag</code>的优先级更高，也就是服务端先会判断<code>Etag</code>是否变化了，如果<code>Etag</code>有变化就不用在判断<code>Last-Modified</code>了，如果<code>Etag</code>没有变化，然后再看<code>Last-Modified</code>。</p>
<p>为什么<code>ETag</code>的优先级更高？</p>
<p>这是因为<code>ETag</code>主要能解决<code>Last-Modified</code>几个比较难以解决的问题：</p>
<ul>
<li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；</li>
<li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code>能检查到的粒度是秒级的，使用<code>Etag</code>就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
<li>有些服务器不能精确获取文件的最后修改时间。</li>
</ul>
<p>注意，协商缓存这两个字段都需要配合强制缓存中<code>Cache-Control</code>字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</p>
<p>下图是强制缓存和协商缓存的工作流程：</p>
<img src="/2020/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94HTTP/32.png" class="">

<p>当使用<code>ETag</code>字段实现的协商缓存的过程：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在<code>Response</code>头部加上<code>ETag</code>唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</li>
<li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</li>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在<code>Request</code>头部加上<code>If-None-Match</code>字段，该字段的值就是<code>ETag</code>唯一标识；</li>
<li>服务器再次收到请求后，会根据请求中的<code>If-None-Match</code>值与当前请求的资源生成的唯一标识进行比较：</li>
<li>如果值相等，则返回<code>304 Not Modified</code>，不会返回资源；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在<code>Response</code>头部加上新的<code>ETag</code>唯一标识；</li>
<li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/应用层——FTP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94FTP/"
    >应用层——FTP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94FTP/" class="article-date">
  <time datetime="2020-10-20T02:57:33.000Z" itemprop="datePublished">2020-10-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h1><p>文件传送协议 FTP(<code>File Transfer Protocol</code>) 是互联网上使用得最广泛的文件传送协议。</p>
<p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</p>
<p>我们必须分清文件传送和文件存取之间的区别，前者是 FTP 提供的，后者是如 NFS（Sun 的网络文件系统）等应用系统提供的。由 FTP 提供的文件传送是将一个完整的文件从一个系统复制到另一个系统中。要使用 FTP，就需要有登录服务器的注册帐号，或者通过允许匿名 FTP 的服务器来使用。</p>
<h1 id="FTP-的基本工作原理"><a href="#FTP-的基本工作原理" class="headerlink" title="FTP 的基本工作原理"></a>FTP 的基本工作原理</h1><h2 id="FTP-特点"><a href="#FTP-特点" class="headerlink" title="FTP 特点"></a>FTP 特点</h2><ul>
<li>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。</li>
<li>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li>
<li>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接受新的请求；另外有若干个从属进程，负责处理单个请求。</li>
</ul>
<h2 id="主进程的工作步骤"><a href="#主进程的工作步骤" class="headerlink" title="主进程的工作步骤"></a>主进程的工作步骤</h2><ol>
<li>打开熟知端口 21，使客户进程能够连接上。</li>
<li>等待客户进程发出连接请求。</li>
<li>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li>
<li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。</li>
</ol>
<h2 id="两个-TCP-连接"><a href="#两个-TCP-连接" class="headerlink" title="两个 TCP 连接"></a>两个 TCP 连接</h2><img src="/2020/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94FTP/img1.png" class="">

<p>服务器端有两个从属进程：控制进程和数据传送进程。客户端主要有控制进程、数据传送进程和用户界面进程。</p>
<p>FTP 采用两个并行的 TCP 连接（控制连接和数据连接）来传输一个文件。</p>
<ol>
<li>控制连接以通常的客户服务器方式建立。服务器以被动方式打开用于 FTP 的端口 21，等待客户的连接。客户则以主动方式打开 TCP 端口 21，来建立连接。控制连接始终等待客户与服务器之间的通信。该连接将命令从客户传给服务器，并传回服务器的应答。<br>由于命令通常是由用户键入的，所以 IP 对控制连接的服务类型就是“最大限度地减小迟延”。</li>
<li>每当一个文件在客户与服务器之间传输时，就创建一个数据连接（其他时间也可以创建）。<br>由于该连接用于传输目的，所以 IP 对数据连接的服务特点就是“最大限度提高吞吐量”。</li>
</ol>
<p>控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。实际用于传输文件的是“数据连接”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p>
<h2 id="两个不同的端口号"><a href="#两个不同的端口号" class="headerlink" title="两个不同的端口号"></a>两个不同的端口号</h2><p>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口(21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。</p>
<p>接着，服务器进程用自己传送数据的熟知端口(20)与客户进程所提供的端口号码建立数据传送连接。</p>
<p>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。</p>
<p>使用两个不同端口号的好处：</p>
<ul>
<li>使协议更加简单和更容易实现。</li>
<li>在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。</li>
</ul>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>数据连接有以下三大用途：</p>
<ol>
<li>从客户向服务器发送一个文件。</li>
<li>从服务器向客户发送一个文件。</li>
<li>从服务器向客户发送文件或目录列表。</li>
</ol>
<p>FTP 服务器把文件列表从数据连接上发回，而不是控制连接上的多行应答。这就避免了行的有限性对目录大小的限制，而且更易于客户将目录列表以文件形式保存，而不是把列表显<br>示在终端上。</p>
<p>通用传输方式（Unix环境下唯一的传输方式）是流方式，并且文件结尾是以关闭数据连接为标志。这意味着对每一个文件传输或目录列表来说都要建立一个全新的数据连接。其一般过程如下：</p>
<ol>
<li>正由于是客户发出命令要求建立数据连接，所以数据连接是在客户的控制下建立的。</li>
<li>客户通常在客户端主机上为所在数据连接端选择一个临时端口号。客户从该端口发布一个被动的打开。</li>
<li>客户使用<code>PORT</code>命令从控制连接上把端口号发向服务器。</li>
<li>服务器在控制连接上接收端口号，并向客户端主机上的端口发布一个主动的打开。服务器的数据连接端一直使用端口 20。</li>
</ol>
<p>第3步执行时的连接状态。</p>
<img src="/2020/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94FTP/2.png" class="">

<p>假设客户用于控制连接的临时端口是 1173，客户用于数据连接的临时端口是 1174。客户发出的命令是<code>PORT</code>命令，其参数是 6 个 ASCII 中的十进制数字，它们之间由逗点隔开。前面 4 个数字指明客户上的 IP 地址，服务器将向它发出主动打开（<code>140.252.13.34</code>），而后两位指明<code>16bit</code>端口地址。由于<code>16bit</code>端口地址是从这两个数字中得来，所以其值就是<code>4×256+150 = 1174</code>。</p>
<p>服务器向客户所在数据连接端发布主动打开时的连接状态。服务器的端点是端口 20。</p>
<img src="/2020/10/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94FTP/3.png" class="">

<p>服务器总是执行数据连接的主动打开。通常服务器也执行数据连接的主动关闭，除非当客户向服务器发送流形式的文件时，需要客户来关闭连接（它给服务器一个文件结束的通知）。</p>
<p>客户也有可能不发出<code>PORT</code>命令，而由服务器向正被客户使用的同一个端口号发出主动打开，来结束控制连接。这是可行的，因为服务器面向这两个连接的端口号是不同的：一个是 20，另一个是 21。不过，现有实现通常不这样做。</p>
<h2 id="NFS-采用另一种思路"><a href="#NFS-采用另一种思路" class="headerlink" title="NFS 采用另一种思路"></a>NFS 采用另一种思路</h2><p>网络文件系统 NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。</p>
<p>NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</p>
<p>例如，计算机 A 的 NFS 客户软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 的 NFS 服务器。NFS 服务器更新文件后返回应答信息。</p>
<p>NFS 在网络上传送的只是少量的修改数据。 </p>
<h1 id="简单文件传送协议-TFTP"><a href="#简单文件传送协议-TFTP" class="headerlink" title="简单文件传送协议 TFTP"></a>简单文件传送协议 TFTP</h1><p>TFTP(<code>Trivial File Transfer Protocol</code>) 是一个很小且易于实现的文件传送协议。</p>
<p>TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。</p>
<p>TFTP 只支持文件传输而不支持交互。</p>
<p>TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 </p>
<h2 id="TFTP-的主要特点"><a href="#TFTP-的主要特点" class="headerlink" title="TFTP 的主要特点"></a>TFTP 的主要特点</h2><ul>
<li>每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。</li>
<li>数据 PDU 也称为文件块，每个块按序编号，从 1 开始。</li>
<li>支持 ASCII 码或二进制传送。</li>
<li>可对文件进行读或写。</li>
<li>使用很简单的首部。</li>
</ul>
<p>TFTP 的工作很像停止等待协议：</p>
<ul>
<li>发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。</li>
<li>发完数据后在规定时间内收不到确认就要重发数据 PDU。</li>
<li>发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。</li>
</ul>
<p>开始工作时，TFTP 客户进程发送一个读请求 PDU 或写请求 PDU 给 TFTP 服务器进程，其熟知端口号码为 69。</p>
<p>TFTP 服务器进程要选择一个新的端口和 TFTP 客户进程进行通信。</p>
<p>若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据 PDU。</p>
<p>若文件长度不是 512 字节的整数倍，则最后传送数据 PDU 的数据字段一定不满 512 字节，这正好可作为文件结束的标志。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/DNS详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/"
    >DNS详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-10-19T03:08:41.000Z" itemprop="datePublished">2020-10-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>TCP&#x2F;IP 是基于 IP 地址进行通信的，但是 IP 地址不太好记。于是出现了另一种方便记忆的标识符，那就是主机名。为计算机配置主机名，在进行网络通信时，直接使用主机名，而不用输入一大串的 IP 地址。同时，系统通过一个叫<code>hosts</code>的文件，实现主机名转换 IP 地址的功能。<code>hosts</code>文件包括主机名和 IP 地址的对应关系。当需要通过主机名访问主机时，它就会查看本地的<code>hosts</code>文件，从文件中找到相对应的 IP 地址，然后进行报文发送。如果在<code>hosts</code>文件中没找到相关信息，则主机访问失败。</p>
<p><code>hosts</code>文件是主机的本地文件，优点是查找响应速度快。它主要用来存储一些本地网络的主机名和 IP 地址的对应信息。这样，主机在以主机名访问本地网络主机时，通过<code>hosts</code>文件可以迅速获得相应的 IP 地址。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>每台主机的<code>hosts</code>文件都需要单独手工更新。随着网络规模的不断扩大、接入计算机的数量不断增加，维护难度越来越大，每台主机同步更新，几乎是一件不可能完成的任务。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/2.png" class="">

<p>为了解决<code>hosts</code>文件维护困难的问题，出现了 DNS 域名系统，一个可以解决主机名和 IP 地址互相转换的系统。无论网络规模变得多么庞大，都能在一个小范围内通过 DNS 进行管理。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/3.png" class="">

<h1 id="DNS-介绍"><a href="#DNS-介绍" class="headerlink" title="DNS 介绍"></a>DNS 介绍</h1><p>DNS，全称<code>Domain Name System</code>。采用<code>client/server</code>模式，DNS client 发出查询请求，DNS server 响应请求。DNS client 通过查询 DNS server 获得主机的 IP 地址，进而完成后续的 TCP&#x2F;IP 通信过程。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/4.png" class="">

<p>当 Windows 系统用户使用<code>nslookup hostname/domainname</code>命令时，DNS 会自动查找注册了主机名和 IP 地址的数据库，并返回对应的 IP 地址。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/5.png" class="">

<h2 id="DNS-域名"><a href="#DNS-域名" class="headerlink" title="DNS 域名"></a>DNS 域名</h2><p>域名是为了识别主机名或机构的一种分层的名称。因为单独的一台域名服务器是不可能知道所有域名信息，所以域名系统是一个分布式数据库系统，域名（主机名）到 IP 地址的解析可以由若干个域名服务器共同完成。每一个站点维护自己的信息数据库，并运行一个服务器程序供互联网上的客户端查询。DNS 提供了客户端与服务器的通信协议，也提供了服务器之间交换信息的协议。由于是分布式系统，即使单个服务器出现故障，也不会导致整个系统失效，消除了单点故障。</p>
<h2 id="DNS-域名组成"><a href="#DNS-域名组成" class="headerlink" title="DNS 域名组成"></a>DNS 域名组成</h2><p>DNS 域的本质是一种管理范围的划分，最大的域是根域，向下可以划分为顶级域、二级域、三级域、四级域等。相对应的域名是根域名、顶级域名、二级域名、三级域名等。不同等级的域名使用点号分隔，级别最低的域名写在最左边，而级别最高的域名写在最右边。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/6.png" class="">

<p>举个栗子：网站域名<code>www.tsinghua.edu.cn</code>中，从右到左开始，<code>cn</code>是顶级域名，代表中国，<code>edu</code>是二级域名，代表教育机构，<code>tsinghua</code>是三级域名，表示清华大学，<code>www</code>则表示三级域名中的主机，并提供了 web 服务。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/7.png" class="">

<p>除了<code>www</code>主机外，常见的主机还有<code>arch 、sem 、mail</code>，域名如下：</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/8.png" class="">

<p>每一级的域名都由英文字母和数字组成，域名不区分大小写，长度不能超过 63 字节，一个完整的域名不能超过 255 个字节。根域名用 “ . ”（点）表示。目前我们看到的域名例子都是完全合格域名（ FQDN ），FQDN 的完整格式是以点结尾的域名。接入互联网的主机、服务器或其它网络设备都可以拥有一个唯一的 FQDN。与 FQDN 对应的，系统中的默认域名是非合格域名，会把当前的区域域名添加到尾部。例如，<code>tsinghua</code>域内的主机上查找<code>mail</code>，本地解析器就会将这个名称转换为 FQDN ，即<code>mail.tsinghua.edu.cn</code>，然后解析出 IP 地址。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/9.png" class="">

<h2 id="DNS-域名空间"><a href="#DNS-域名空间" class="headerlink" title="DNS 域名空间"></a>DNS 域名空间</h2><p>域名空间结构像是一棵倒过来的树，也叫做树形结构。根域名就是树根，用点号表示，往下是这棵树的各层枝叶。根域名的下一层叫顶级域名，顶级域名包括三大类：</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/10.png" class="">

<h3 id="国家顶级域名"><a href="#国家顶级域名" class="headerlink" title="国家顶级域名"></a>国家顶级域名</h3><p>国家顶级域名采用 ISO3166 的规定。比如：<code>.cn</code>表示中国，<code>.us</code>表示美国，<code>.uk</code>表示英国等。现在使用的国家顶级域名大约在 200个左右。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/11.png" class="">

<h3 id="国际顶级域名"><a href="#国际顶级域名" class="headerlink" title="国际顶级域名"></a>国际顶级域名</h3><p>国际顶级域名采用<code>.int</code>。国际性的组织可以在<code>.int</code>下注册。</p>
<h3 id="通用顶级域名"><a href="#通用顶级域名" class="headerlink" title="通用顶级域名"></a>通用顶级域名</h3><img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/12.png" class="">

<p>最早的顶级域名共有 6 个。分别为：</p>
<ul>
<li><code>.com</code>表示公司企业，</li>
<li><code>.net</code>表示网络服务机构，</li>
<li><code>.org</code>表示非盈利组织，</li>
<li><code>.edu</code>表示教育机构（仅限美国），</li>
<li><code>.gov</code>表示政府部门（仅限美国），</li>
<li><code>.mil</code>表示军事部门（仅限美国）。</li>
</ul>
<p>随着互联网用户不断增加，又增加了 7 个通用顶级域名。分别为：</p>
<ul>
<li><code>.aero</code>用于航空运输业，</li>
<li><code>.biz</code>用于公司和企业，</li>
<li><code>.coop</code>用于合作团体，</li>
<li><code>.info</code>用于各种情况，</li>
<li><code>.museum</code>用于博物馆，</li>
<li><code>.name</code>用于个人，</li>
<li><code>.pro</code>用于自由职业者。</li>
</ul>
<p>顶级域名下面是二级域名。国家顶级域名下注册的二级域名均由国家自行确定。我国二级域名分为类别域名和行政域名两大类，类别域名如：<code>.com，.edu，.gov</code>等分别代表不同的机构；行政域名如：<code>.bj</code>表示北京，<code>.sh</code>表示上海，代表我国各省、自治区及直辖市等。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/13.png" class="">

<p>二级域名下面是三级域名、四级域名等。命名树上任何一个节点的域名就是从这个节点到最高层的域名串起来，中间以<code>.</code>分隔。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/14.png" class="">

<p>在域名结构中，节点在所属域中的主机名标识可以相同，但是域名必须不同。比如：清华大学和新浪公司下都有一台主机的标识是<code>mail</code>，但是两者的域名却是不同的，前者为<code>mail.tsinghua.edu.cn</code>，而后者为<code>mail.sina.com.cn</code>。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/15.png" class="">

<h1 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h1><p>将域名转换为对应的 IP 地址的过程叫做域名解析。在域名解析过程中，DNS client 的主机调用解析器（<code>Resolver</code>），向 DNS server 发出请求，DNS server 完成域名解析。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/16.png" class="">

<p>域名解析是按照 DNS 分层结构的特点，自顶向下进行的。但是如果每一个域名解析都从根域名服务器开始，那么根域名服务器有可能无法承载海量的流量。在实际应用中，大多数域名解析都是在本地域名服务器完成。通过合理设置本地域名服务器，由本地域名服务器负责大部分的域名解析请求，提高域名解析效率。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/17.png" class="">

<h2 id="DNS-解析器"><a href="#DNS-解析器" class="headerlink" title="DNS 解析器"></a>DNS 解析器</h2><p>从应用程序的角度看，访问 DNS 是通过一个叫解析器的应用程序来完成的。发送一个 TCP 或 UDP 数据包之前，解析器必须将域名（主机名）转换为 IP 地址。一个解析器至少要注册一个域名服务器的 IP 地址。通常，它至少包括本地域名服务器的 IP 地址。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/18.png" class="">

<h2 id="DNS-域名服务器"><a href="#DNS-域名服务器" class="headerlink" title="DNS 域名服务器"></a>DNS 域名服务器</h2><p>DNS 域名空间的层次结构，允许不同的域名服务器管理域名空间的不同部分。域名服务器是指管理域名的主机及软件，它可以管理所在分层的域。其所管理的分层叫做区域（<code>zone</code>）。一个<code>zone</code>是 DNS 域名空间的一棵子树，它可以单独管理而不受其它<code>zone</code>影响。每层都设有一个域名服务器。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/19.png" class="">

<p>根所设置的 DNS 叫做根域名服务器，它对 DNS 的检索数据功能起着至关重要的作用。根域名服务器中注册了顶级域名服务器的 IP 地址。如果想要新增一个一级域名，或者修改已有的顶级域名，就要在根域名服务器中进行新增或变更。</p>
<p>类似的，顶级域名服务器中注册了二级域名服务器的 IP 地址。如果域名服务器下面没有其它分层，就可以自由地指定主机名称。如果想重新设置域名服务器的 IP 地址或修改域名，必须在上一层的域名服务器中进行修改。</p>
<p>域名和域名服务器都需要按照分层进行设置。如果域名服务器出现故障，那么针对这个域的 DNS 查询就无法正常工作。因此，为了提高可用性，至少设置两台域名服务器。一旦第一台域名服务器无法提供查询时，就会自动转到第二个甚至第三个域名服务器上进行。</p>
<h2 id="DNS-域名服务器类型"><a href="#DNS-域名服务器类型" class="headerlink" title="DNS 域名服务器类型"></a>DNS 域名服务器类型</h2><h3 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h3><p>互联网接入服务运营商或者一个大的网络机构，像公司、大学等都有一台或多台可以自行管理的域名服务器，这类域名服务器称为本地域名服务器，也称为默认域名服务器。本地域名服务器离客户端较近。当一个 DNS客户端发出 DNS 查询时，首先送到本地域名服务器。如果本地域名服务器数据库中有对应的域名信息，会将查询的域名转换为 IP 地址返回客户端。如果没有，它会以 DNS 客户端的身份向根域名服务器进行查询。根域名服务器收到本地域名服务器的查询后，会返回相关域名服务器的 IP 地址，本地域名服务器再向相关域名服务器发送查询请求。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/20.png" class="">

<h3 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h3><p>通常根域名服务器用来管理顶级域，本身并不对域名进行解析，但它知道相关域名服务器的 IP 地址。IPv4 根域名服务器全球有 13 台，主机名分别为 A ~ M。1 台为主根服务器在美国，其余 12 个均为辅根服务器，其中 9 个在美国，2 个在欧洲，位于英国和瑞典，1 台在亚洲，位于日本。所有的域名服务器都必须注册根域名服务器的 IP 地址，因为 DNS 根据 IP 地址进行检索时，需要按顺序从根域名服务器开始。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/21.png" class="">

<h3 id="授权域名服务器"><a href="#授权域名服务器" class="headerlink" title="授权域名服务器"></a>授权域名服务器</h3><p>互联网上的主机在域名服务器上进行注册，这个域名服务器就是主机的授权域名服务器。通常，主机的授权域名服务器就是本地域名服务器。实际上，主机会有两个授权域名服务器，防止单点故障。授权域名服务器上有注册主机域名与 IP 地址的映射信息，当查询注册主机域名时，它会返回相应主机的 IP 地址。如果主机域名和 IP 地址需要进行变更，只需要在授权域名服务器处理即可，不用再向其它域名服务器进行申请或报告。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/22.png" class="">

<h3 id="主域名服务器"><a href="#主域名服务器" class="headerlink" title="主域名服务器"></a>主域名服务器</h3><p>主域名服务器是完成一个或多个区域域名解析工作的主要域名服务器，通常也是一个或多个区域的授权域名服务器。主域名服务器有区域内主机地址信息的源数据文件，并且是区域传送中区域数据的唯一来源。</p>
<h3 id="辅助域名服务器"><a href="#辅助域名服务器" class="headerlink" title="辅助域名服务器"></a>辅助域名服务器</h3><p>辅助域名服务器可以协助主域名服务器提供域名查询服务，在主机很多的情况下，可以有效分担主域名服务器的压力。辅助域名服务器也有冗余功能，当主域名服务器故障时，辅助域名服务器能够在数据有效期内继续为主机提供域名解析服务。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/23.png" class="">

<p>一台主域名服务器可以有多台辅助域名服务器，一台辅助域名服务器也可以是其它区域的主域名服务器。辅助域名服务器中包含区域内主机地址数据的授权信息，通过区域配置文件副本的方式存储。辅助域名服务器也是区域的授权域名服务器，可以完成本区域内域名查询的授权回答。</p>
<p>辅助域名服务器并不建立数据文件，它获得区域数据的唯一途径就是通过区域传送的方式，从主域名服务器上获得区域数据的最新副本。获得数据副本的方式有两种，第一种是辅助域名服务器定期主动获得主域名服务器的副本，或更新副本中的数据。第二种是主域名服务器在区域数据发生变化时，及时通知辅助域名服务器更新副本中的数据。</p>
<h2 id="DNS-域名完整解析过程"><a href="#DNS-域名完整解析过程" class="headerlink" title="DNS 域名完整解析过程"></a>DNS 域名完整解析过程</h2><img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/24.png" class="">

<p>DNS 客户端进行域名<code>www.tsinghua.edu.cn</code>的解析过程如下：</p>
<ol>
<li>DNS 客户端向本地域名服务器发送请求，查询<code>www.tsinghua.edu.cn</code>主机的 IP 地址；</li>
<li>本地域名服务器查询数据库，发现没有域名为<code>www.tsinghua.edu.cn</code>的主机，于是将请求发送给根域名服务器；</li>
<li>根域名服务器查询数据库，发现没有这个主机域名记录，但是根域名服务器知道 cn 域名服务器可以解析这个域名，于是将 cn 域名服务器的 IP 地址返回给本地域名服务器；</li>
<li>本地域名服务器向 cn 域名服务器查询<code>www.tsinghua.edu.cn</code>主机的 IP 地址；</li>
<li>cn 域名服务器查询数据库，也没有相关记录，但是知道<code>edu.cn</code>域名服务器可以解析这个域名，于是将<code>edu.cn</code>域名服务器的 IP 地址返回给本地域名服务器；</li>
<li>本地域名服务器再向<code>edu.cn</code>域名服务器查询<code>www.tsinghua.edu.cn</code>主机 IP 地址；</li>
<li><code>edu.cn</code>域名服务器查询数据库，也没有相关记录，但是知道<code>tsinghua.edu.cn</code>域名服务器可以解析这个域名，于是将<code>tsinghua.edu.cn</code>的域名服务器 IP 地址返回给本地域名服务器；</li>
<li>本地域名服务器向<code>tsinghua.edu.cn</code>域名服务器查询<code>www.tsinghua.edu.cn</code>主机的 IP 地址；</li>
<li><code>tsinghua.edu.cn</code>域名服务器查询数据库，发现有主机域名记录，于是给本地域名服务器返回<code>www.tsinghua.edu.cn</code>对应的 IP 地址；</li>
<li>最后本地域名服务器将<code>www.tsinghua.edu.cn</code>的 IP 地址返回给客户端，整个解析过程完成。</li>
</ol>
<h1 id="DNS-记录类型"><a href="#DNS-记录类型" class="headerlink" title="DNS 记录类型"></a>DNS 记录类型</h1><table>
<thead>
<tr>
<th align="center">记录类型</th>
<th align="center">说明</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SOA</td>
<td align="center">SOA 叫起始授权机构记录，SOA 记录用于在众多 NS 记录中指明哪一台是主服务器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">把主机名解析为 IP 地址</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a> &#x3D;&gt; 1.1.1.1</td>
</tr>
<tr>
<td align="center">指针 PTR</td>
<td align="center">反向查询，把 IP 地址解析为主机名</td>
<td align="center">1.1.1.1 &#x3D;&gt; <a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a></td>
</tr>
<tr>
<td align="center">名字服务器 NS</td>
<td align="center">为一个域指定授权域名服务器，该域的所有子域也被委派给这个服务器</td>
<td align="center">比如某个区域由 ns1.domain.com 进行解析</td>
</tr>
<tr>
<td align="center">邮件服务器 MX</td>
<td align="center">指明区域的邮件服务器及优先级</td>
<td align="center">建立电子邮件服务，需要 MX 记录指向邮件服务器地址</td>
</tr>
<tr>
<td align="center">别名 CNAME</td>
<td align="center">指定主机名的别名，把主机名解析为另一个主机名</td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a> 别名为 webserver12.test.com</td>
</tr>
</tbody></table>
<h1 id="DNS-传输层协议"><a href="#DNS-传输层协议" class="headerlink" title="DNS 传输层协议"></a>DNS 传输层协议</h1><p>DNS 域名服务器使用的端口号是 53，并且同时支持 UDP 和 TCP 协议。为什么同时使用两种协议呢？</p>
<p>因为 DNS 响应报文中有一个删减标志位，用 TC 表示。当响应报文使用 UDP 封装，且报文长度大于 512 字节时，那么服务器只返回前 512 字节，同时 TC 标志位置位，表示报文进行了删减。当客户端收到 TC 置位的响应报文后，将采用 TCP 封装查询请求。DNS 服务器返回的响应报文长度大于 512 字节。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/25.png" class="">

<p>UDP 报文的最大长度是 512 字节，最多可以包含 13 台根域名服务器数据，因此 IPv4 根域名服务器只能限制在 13 个，且每个服务器使用单个字母命名，也是 IPv4 根服务器是从 A~M 命名的原因。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/26.png" class="">

<p>当辅助域名服务器启动时，将从主域名服务器执行区域传送。正常运行过程中，辅助域名服务器也会定时向主域名服务器进行查询，以便了解主域名服务器数据是否发送变化。如果有变化，将执行一次区域传送。因为区域传送的数据多，所以传送的数据采用 TCP 封装。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/27.png" class="">

<p>因此，UDP 用于 client 和 server 的查询和响应，TCP 用于主从 server 之间的传送。</p>
<h1 id="DNS-查询方式"><a href="#DNS-查询方式" class="headerlink" title="DNS 查询方式"></a>DNS 查询方式</h1><p>DNS 域名解析包括两种查询方式，一种是递归查询，另一种是迭代查询。本地域名服务器向根域名服务器的查询通常是采用迭代查询。</p>
<h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p>DNS 服务器如果不能直接响应解析请求，它将继续请求其它的 DNS 服务器，直到查询域名解析的结果。查询的结果可以是域名主机的 IP 地址，或者是域名无法解析。无论哪种结果，DNS 服务器都会将结果返回给客户端。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/img5.png" class="">

<p>举个栗子：当本地域名服务器接收了客户端的查询请求，本地域名服务器将代表客户端来找答案，而在本地域名服务器执行工作时，客户端只是等待，直到本地域名服务器将最终查询结果返回客户端。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/28.png" class="">

<h2 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h2><p>如果 DNS 服务器查不到相应记录，会向客户端返回一个可能知道结果的域名服务器 IP 地址，由客户端继续向新的服务器发送查询请求。对域名服务器的迭代查询，只得到一个提示，则继续查询。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/img4.png" class="">

<p>举个栗子：本地域名服务器发送请求到根域名服务器，根域名服务器并没有相应记录，它只是给本地域名服务器返回一个提示，引导本地域名服务器到另一台域名服务器进行查询。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/29.png" class="">

<p>客户端在查询 IP 地址时，向本地域名服务器进行递归查询。如果本地域名服务器的数据库有相应数据，则直接返回相应数据。如果没有，则本地域名服务器向根域名服务器进行迭代查询。从根开始对这棵树按照顺序进行遍历，直到找到指定的域名服务器，并由这个域名服务器返回相应的数据。客户端和本地域名服务器会将收到的信息保存在缓存里，这样可以减少每次查询时的性能消耗。</p>
<h2 id="DNS-反向查询"><a href="#DNS-反向查询" class="headerlink" title="DNS 反向查询"></a>DNS 反向查询</h2><p>在 DNS 查询中，客户端希望知道域名对应的 IP 地址，这种查询称为正向查询。大部分的 DNS 查询都是正向查询。与正向查询对应的，是反向查询。它允许 DNS 客户端通过 IP 地址查找对应的域名。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/30.png" class="">

<p>为实现反向查询，在 DNS 标准中定义了特色域<code>in-addr.arpa</code>域，并保留在域名空间中，以便执行反向查询。为创建反向域名空间，<code>in-addr.arpa</code>域中的子域是按照 IP 地址相反的顺序构造的。</p>
<p>举个栗子：<code>www.tsinghua.edu.cn</code>的 IP 地址是<code>166.111.4.100</code>，那么在<code>in-addr.arpa</code>域中对应的节点就是<code>100.4.111.166</code>。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/31.png" class="">

<h1 id="DNS-应用场景"><a href="#DNS-应用场景" class="headerlink" title="DNS 应用场景"></a>DNS 应用场景</h1><h2 id="静态域名解析"><a href="#静态域名解析" class="headerlink" title="静态域名解析"></a>静态域名解析</h2><p>域名解析分为动态域名解析和静态域名解析。在解析域名时，首先采用静态域名解析，如果静态解析不成功，再采用动态域名解析。</p>
<p>静态域名解析是通过静态域名解析表进行的，手动建立域名和 IP 地址之间的对应关系表，该表的作用类似于 Windows 操作系统下的 hosts 文件，可以将一些常用的域名放入表中。当 DNS client 需要域名所对应的 IP 地址时，即到静态域名解析表中去查找指定的域名，从而获得所对应的 IP 地址，提高域名解析的效率。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/32.png" class="">

<h2 id="动态域名解析"><a href="#动态域名解析" class="headerlink" title="动态域名解析"></a>动态域名解析</h2><p>动态域名解析需要专用的域名服务器（DNS server）运行域名解析服务器程序，提供从域名到 IP 地址的映射关系，负责接收客户端（DNS client）提出的域名解析请求。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/4.png" class="">

<h2 id="DNS-代理"><a href="#DNS-代理" class="headerlink" title="DNS 代理"></a>DNS 代理</h2><p>在使用了 DNS 代理功能的组网中，DNS client 将 DNS 请求报文直接发送给 DNS proxy。DNS proxy 会先查找本地域名解析表，如果未查询到对应的解析表项，会将 DNS 请求报文转发给 DNS Server，并在收到 DNS server 的应答报文后将其返回给 DNS client，从而实现域名解析。</p>
<img src="/2020/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%AF%A6%E8%A7%A3/33.png" class="">

<p>因此，当 DNS server 的地址发生变化时，只需改变 DNS proxy 上的配置，无需逐一改变局域网内每个 DNS client 的配置，从而简化了网络管理。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/运输层——TCP的传输连接管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"
    >运输层——TCP的传输连接管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2020-10-17T03:51:33.000Z" itemprop="datePublished">2020-10-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>TCP 连接有三个阶段：连接建立、数据传送、连接释放。</p>
<p>TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。</p>
<p>TCP 连接建立过程中要解决的三个问题：</p>
<ol>
<li>要使每一方能够确知对方的存在。</li>
<li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li>
<li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ol>
<p>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户，被动等待建立连接的应用进程叫服务器。</p>
<h1 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h1><p>TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/img1.png" class="" title="用三次握手建立TCP连接的各状态">

<p>假定主机 A 运行的是 TCP 客户程序，B 运行 TCP 服务器程序。最初两端的 TCP 进程都处于<code>CLOSED</code>（关闭）状态。图中在主机下面的方框分别是 TCP 进程所处的状态。注意，A 主动打开连接，B 被动打开连接。</p>
<p>B 的 TCP 服务器进程先创建传输控制块 TCB，准备接受客户进程的连接请求。然后服务器进程就处于<code>LISTEN</code>（收听）状态，等待客户的连接请求。</p>
<p>A 的 TCP 客户进程也是首先创建传输控制块 TCB，然后向 B 发出连接请求报文段，这时，首部中的同部位<code>SYN = 1</code>，同时选择一个初始序号<code>seq = x</code>。TCP 规定<code>SYN</code>报文段（即<code>SYN = 1</code>的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入<code>SYN-SENT</code>（同步已发送）状态。</p>
<p>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中，<code>SYN = 1, ACK = 1</code>，确认号是<code>ack = x + 1</code>，同时也为自己选择一个初始序号<code>seq = y</code>。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，TCP 服务器进程进入<code>SYN-RCVD</code>（同步收到）状态。</p>
<p>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。<code>ACK = 1, ack = y + 1</code>，而自己的序号<code>seq = x + 1</code>。TCP 规定，<code>ACK</code>报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是<code>seq = x + 1</code>。这时 TCP 连接已经建立，A 进入<code>ESTABLISHED</code>（已建立连接）状态。</p>
<p>当 B 收到 A 的确认后，也进入<code>ESTABLISHED</code>状态。</p>
<p>从上⾯的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</p>
<p>⼀旦完成三次握手，双方都处于<code>ESTABLISHED</code>态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。</p>
<h2 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h2><p>三次握手的原因：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<h3 id="原因⼀：避免历史连接"><a href="#原因⼀：避免历史连接" class="headerlink" title="原因⼀：避免历史连接"></a>原因⼀：避免历史连接</h3><p>简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p>我们考虑一个场景，客户端先发送了<code>SYN(seq = 90)</code>报文，然后客户端宕机了，而且这个<code>SYN</code>报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了<code>SYN(seq = 100)</code>报文（注意！不是重传<code>SYN</code>，重传的<code>SYN</code>的序列号是一样的）。</p>
<p>看看三次握手是如何阻止历史连接的：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/10.jpg" class="">

<p>客户端连续发送多次<code>SYN</code>建立连接的报文，在网络拥堵情况下：</p>
<ul>
<li>一个「旧<code>SYN</code>报文」比「最新的<code>SYN</code>」 报文早到达了服务端，那么此时服务端就会回一个<code>SYN + ACK</code>报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回<code>RST</code>报文。</li>
<li>服务端收到<code>RST</code>报文后，就会释放连接。</li>
<li>后续最新的<code>SYN</code>抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>如果服务端在收到<code>RST</code>报文之前，先收到了「新<code>SYN</code>报文」，也就是服务端收到客户端报文的顺序是：「旧<code>SYN</code>报文」-&gt;「新<code>SYN</code>报文」，此时会发生什么?</p>
<p>当服务端第一次收到<code>SYN</code>报文，也就是收到 「旧<code>SYN</code>报文」时，就会回复<code>SYN + ACK</code>报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新<code>SYN</code>报文」时，就会回<code>Challenge Ack</code>报文给客户端，这个<code>ack</code>报文并不是确认收到「新<code>SYN</code>报文」的，而是上一次的<code>ack</code>确认号，也就是 91（90+1）。所以客户端收到此<code>ACK</code>报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回<code>RST</code>报文。</p>
<p>如果是两次握手连接，就无法阻止历史连接，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p>
<p>主要是因为在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。</p>
<p>在两次握手的情况下，服务端在收到<code>SYN</code>报文后，就进入<code>ESTABLISHED</code>状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入<code>ESTABLISHED</code>状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回<code>RST</code>报文来断开连接，而服务端在第一次握手的时候就进入<code>ESTABLISHED</code>状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到<code>RST</code>报文后，才会断开连接。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/9.png" class="">

<p>可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p>
<p>因此，要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。</p>
<p>所以，TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</p>
<h3 id="原因二：同步双方初始序列号"><a href="#原因二：同步双方初始序列号" class="headerlink" title="原因二：同步双方初始序列号"></a>原因二：同步双方初始序列号</h3><p>TCP 协议的通信双方， 都必须维护⼀个序列号， 序列号是可靠传输的⼀个关键因素，它的作用： </p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
<p>可⻅，序列号在 TCP 连接中占据着⾮常重要的作用，所以当客户端发送携带「初始序列号」的<code>SYN</code>报文的时候，需要服务端回⼀个<code>ACK</code>应答报文，表示客户端的<code>SYN</code>报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样⼀来⼀回，才能确保双方的初始序列号能被可靠的同步。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/12.jpg" class="">

<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成⼀步，所以就成了三次握手。</p>
<p>而两次握手只保证了⼀方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h3 id="原因三：避免资源浪费"><a href="#原因三：避免资源浪费" class="headerlink" title="原因三：避免资源浪费"></a>原因三：避免资源浪费</h3><p>如果只有两次握手，当客户端的<code>SYN</code>请求连接在网络中阻塞，客户端没有接收到<code>ACK</code>报文，就会重新发送<code>SYN</code>，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的<code>ACK</code>确认信号，所以每收到⼀个<code>SYN</code>就只能先主动建立⼀个连接，这会造成什么情况呢？</p>
<p>如果客户端的<code>SYN</code>阻塞了，重复发送多次<code>SYN</code>报文，那么服务器在收到请求后就会建立多个冗余的⽆效链接，造成不必要的资源浪费。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/13.jpg" class="">

<p>即两次握手会造成消息滞留情况下，服务器重复接受⽆用的连接请求<code>SYN</code>报文，而造成重复分配资源。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用两次握手和四次握手的原因：</p>
<ul>
<li>两次握手：⽆法防止历史连接的建立，会造成双方资源的浪费，也⽆法可靠的同步双方序列号；</li>
<li>四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h2 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h2><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是<code>SYN</code>报文，然后进入到<code>SYN_SENT</code>状态。</p>
<p>在这之后，如果客户端迟迟收不到服务端的<code>SYN-ACK</code>报文（第二次握手），就会触发「超时重传」机制，重传<code>SYN</code>报文，而且重传的<code>SYN</code>报文的序列号都是一样的。</p>
<p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
<p>当客户端在 1 秒后没收到服务端的<code>SYN-ACK</code>报文后，客户端就会重发<code>SYN</code>报文，那到底重发几次呢？</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由<code>tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应<code>ACK</code>，客户端就不再发送<code>SYN</code>包，然后断开 TCP 连接。</p>
<p>所以，总耗时是<code>1+2+4+8+16+32=63</code>秒，大约 1 分钟左右。</p>
<p>举个例子，假设<code>tcp_syn_retries</code>参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/14.png" class="">

<p>具体过程：<br>当客户端超时重传 3 次 SYN 报文后，由于<code>tcp_syn_retries</code>为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（<code>SYN-ACK</code>报文），那么客户端就会断开连接。</p>
<h2 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h2><p>当服务端收到客户端的第一次握手后，就会回<code>SYN-ACK</code>报文给客户端，这个就是第二次握手，此时服务端会进入<code>SYN_RCVD</code>状态。</p>
<p>第二次握手的<code>SYN-ACK</code>报文其实有两个目的：</p>
<ul>
<li>第二次握手里的<code>ACK</code>，是对第一次握手的确认报文；</li>
<li>第二次握手里的<code>SYN</code>，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p>
<p>因为第二次握手报文里是包含对客户端的第一次握手的<code>ACK</code>确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的<code>SYN</code>报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传<code>SYN</code>报文。</p>
<p>然后，因为第二次握手中包含服务端的<code>SYN</code>报文，所以当客户端收到后，需要给服务端发送<code>ACK</code>确认报文（第三次握手），服务端才会认为该<code>SYN</code>报文被客户端收到了。</p>
<p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传<code>SYN-ACK</code>报文。</p>
<p>在 Linux 下，<code>SYN-ACK</code>报文的最大重传次数由<code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/net/ipv4/tcp_synack_retries</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传<code>SYN</code>报文，也就是第一次握手，最大重传次数由<code>tcp_syn_retries</code>内核参数决定；</li>
<li>服务端会重传<code>SYN-ACK</code>报文，也就是第二次握手，最大重传次数由<code>tcp_synack_retries</code>内核参数决定。</li>
</ul>
<p>举个例子，假设<code>tcp_syn_retries</code>参数值为 1，<code>tcp_synack_retries</code>参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/15.png" class="">

<p>具体过程：</p>
<ul>
<li>当客户端超时重传 1 次<code>SYN</code>报文后，由于<code>tcp_syn_retries</code>为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（<code>SYN-ACK</code>报文），那么客户端就会断开连接。</li>
<li>当服务端超时重传 2 次<code>SYN-ACK</code>报文后，由于<code>tcp_synack_retries</code>为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（<code>ACK</code>报文），那么服务端就会断开连接。</li>
</ul>
<h2 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h2><p>客户端收到服务端的<code>SYN-ACK</code>报文后，就会给服务端回一个<code>ACK</code>报文，也就是第三次握手，此时客户端状态进入到<code>ESTABLISH</code>状态。</p>
<p>因为这个第三次握手的<code>ACK</code>是对第二次握手的<code>SYN</code>的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传<code>SYN-ACK</code>报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<code>ACK</code>报文是不会有重传的，当<code>ACK</code>丢失了，就由对方重传对应的报文。</p>
<p>举个例子，假设<code>tcp_synack_retries</code>参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/16.png" class="">

<p>具体过程：<br>当服务端超时重传 2 次<code>SYN-ACK</code>报文后，由于<code>tcp_synack_retries</code>为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（<code>ACK</code>报文），那么服务端就会断开连接。</p>
<h2 id="初始序列号-ISN-是如何随机产生的？"><a href="#初始序列号-ISN-是如何随机产生的？" class="headerlink" title="初始序列号 ISN 是如何随机产生的？"></a>初始序列号 ISN 是如何随机产生的？</h2><p>起始 ISN 是基于时钟的，每 4 毫秒<code>+1</code>，转⼀圈要 4.55 个小时。</p>
<p>RFC1948 中提出了⼀个较好的初始化序列号 ISN 随机生成算法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISN = M + F(localhost, localport, remotehost, remoteport)</span><br></pre></td></tr></table></figure>
<p>M 是⼀个计时器，这个计时器每隔 4 毫秒加 1。 F 是⼀个 Hash 算法，根据源 IP、⽬的 IP、源端口、⽬的端口生成⼀个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是⼀个比较好的选择。</p>
<h1 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h1><p>TCP 连接释放过程是通过四次挥手方式。</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/img2.png" class="">

<p>数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于<code>ESTABLISHED</code>状态。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的<code>FIN</code>置1，其序号<code>seq = u</code>，它等于前面已传送过的数据的最后一个字节的序号加1。这时 A 进入<code>FIN-WAIT-1</code>（终止等待1）状态，等待 B 的确认。TCP 规定，<code>FIN</code>报文段即使不携带数据也消耗掉一个序号。</p>
<p>B 收到连接释放报文段后立即发出确认，确认号是<code>ack = u + 1</code>，而这个报文段自己的序号是<code>v</code>，等于 B 前面已传送过的数据的最后一个字节的序号加1。然后 B 进入<code>CLOSE-WAIT</code>（关闭等待）状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭。这个状态可能会持续一些时间。</p>
<p>A 收到来自 B 的确认后，就进入<code>FIN-WAIT-2</code>（终止等待2）状态，等待 B 发出的连接释放报文段。</p>
<p>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使<code>FIN = 1</code>。现假定 B 的序号为<code>w</code>（半关闭状态 B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号<code>ack = u + 1</code>。这时 B 就进入<code>LAST-ACK</code>（最后确认）状态，等待 A 的确认。</p>
<p>A 在收到 B 的连接释放报文段后，必须对此发出确认。在确认报文段中，<code>ACK = 1, ack = w + 1</code>，而自己的序号是<code>seq = u + 1</code>。然后进入到<code>TIME-WAIT</code>（时间等待）状态。现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL 后，A 才进入到<code>CLOSED</code>状态。时间 MSL 叫最长报文段寿命(<code>Maximum Segment Lifetime</code>)。当 A 撤销相应的传输控制块 TCB 后，就结束了这次 TCP 连接。</p>
<p>B 只要收到了 A 的确认，就进入<code>CLOSED</code>状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早。</p>
<p>可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。</p>
<p>需要注意是：主动关闭连接的，才有<code>TIME_WAIT</code>状态。</p>
<h2 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h2><p>关闭连接时，客户端向服务端发送<code>FIN</code>时，仅仅表示客户端不再发送数据了但是还能接收数据。</p>
<p>服务器收到客户端的<code>FIN</code>报文时，先回一个<code>ACK</code>应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送<code>FIN</code>报文给客户端来表示同意现在关闭连接。</p>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p>
<h2 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h2><p>当客户端（主动关闭方）调用<code>close</code>函数后，就会向服务端发送<code>FIN</code>报文，试图与服务端断开连接，此时客户端的连接进入到<code>FIN_WAIT_1</code>状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的<code>ACK</code>，则会很快变为<code>FIN_WAIT2</code>状态。</p>
<p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的<code>ACK</code>的话，也就会触发超时重传机制，重传<code>FIN</code>报文，重发次数由<code>tcp_orphan_retries</code>参数控制。</p>
<p>当客户端重传<code>FIN</code>报文的次数超过<code>tcp_orphan_retries</code>后，就不再发送<code>FIN</code>报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到<code>close</code>状态。</p>
<p>举个例子，假设<code>tcp_orphan_retries</code>参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/17.png" class="">

<p>具体过程：<br>当客户端超时重传 3 次<code>FIN</code>报文后，由于<code>tcp_orphan_retries</code>为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（<code>ACK</code>报文），那么客户端就会断开连接。</p>
<h2 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h2><p>当服务端收到客户端的第一次挥手后，就会先回一个<code>ACK</code>确认报文，此时服务端的连接进入到<code>CLOSE_WAIT</code>状态。</p>
<p><code>ACK</code>报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传<code>FIN</code>报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<p>举个例子，假设<code>tcp_orphan_retries</code>参数值为 2，当第二次挥手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/18.png" class="">

<p>具体过程：<br>当客户端超时重传 2 次<code>FIN</code>报文后，由于<code>tcp_orphan_retries</code>为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（<code>ACK</code>报文），那么客户端就会断开连接。</p>
<p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的<code>ACK</code>报文后，客户端就会处于<code>FIN_WAIT2</code>状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的<code>FIN</code>报文。</p>
<p>对于<code>close</code>函数关闭的连接，由于无法再发送和接收数据，所以<code>FIN_WAIT2</code>状态不可以持续太久，而<code>tcp_fin_timeout</code>控制了这个状态下连接的持续时长，默认值是 60 秒。</p>
<p>这意味着对于调用<code>close</code>关闭的连接，如果在 60 秒后还没有收到<code>FIN</code>报文，客户端（主动关闭方）的连接就会直接关闭，如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/19.png" class="">

<p>但是注意，如果主动关闭方使用<code>shutdown</code>函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p>
<p>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于<code>FIN_WAIT2</code>状态（<code>tcp_fin_timeout</code>无法控制<code>shutdown</code>关闭的连接）。如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/20.png" class="">

<h2 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h2><p>当服务端（被动关闭方）收到客户端（主动关闭方）的<code>FIN</code>报文后，内核会自动回复<code>ACK</code>，同时连接处于<code>CLOSE_WAIT</code>状态，顾名思义，它表示等待应用进程调用<code>close</code>函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用<code>close</code>函数来触发服务端发送<code>FIN</code>报文。</p>
<p>服务端处于<code>CLOSE_WAIT</code>状态时，调用了<code>close</code>函数，内核就会发出<code>FIN</code>报文，同时连接进入<code>LAST_ACK</code>状态，等待客户端返回<code>ACK</code>来确认连接关闭。</p>
<p>如果迟迟收不到这个<code>ACK</code>，服务端就会重发<code>FIN</code>报文，重发次数仍然由<code>tcp_orphan_retries</code>参数控制，这与客户端重发<code>FIN</code>报文的重传次数控制方式是一样的。</p>
<p>举个例子，假设<code>tcp_orphan_retries = 3</code>，当第三次挥手一直丢失时，发生的过程如下图：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/21.png" class="">

<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于<code>tcp_orphan_retries</code>为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（<code>ACK</code>报文），那么服务端就会断开连接。</li>
<li>客户端因为是通过<code>close</code>函数关闭连接的，处于<code>FIN_WAIT_2</code>状态是有时长限制的，如果<code>tcp_fin_timeout</code>时间内还是没能收到服务端的第三次挥手（<code>FIN</code>报文），那么客户端就会断开连接。</li>
</ul>
<h2 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h2><p>当客户端收到服务端的第三次挥手的<code>FIN</code>报文后，就会回<code>ACK</code>报文，也就是第四次挥手，此时客户端连接进入<code>TIME_WAIT</code>状态。</p>
<p>在 Linux 系统，<code>TIME_WAIT</code>状态会持续 2MSL 后才会进入关闭状态。</p>
<p>然后，服务端（被动关闭方）没有收到<code>ACK</code>报文前，还是处于<code>LAST_ACK</code>状态。</p>
<p>如果第四次挥手的<code>ACK</code>报文没有到达服务端，服务端就会重发<code>FIN</code>报文，重发次数仍然由<code>tcp_orphan_retries</code>参数控制。</p>
<p>举个例子，假设<code>tcp_orphan_retries</code>为 2，当第四次挥手一直丢失时，发生的过程如下：</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/22.png" class="">

<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文达到 2 时，由于<code>tcp_orphan_retries</code>为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（<code>ACK</code>报文），那么服务端就会断开连接。</li>
<li>客户端在收到第三次挥手后，就会进入<code>TIME_WAIT</code>状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（<code>FIN</code>报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li>
</ul>
<h2 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h2><p>MSL 是<code>Maximum Segment Lifetime</code>，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。</p>
<p><code>TIME_WAIT</code>等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p>
<p>比如如果被动关闭方没有收到断开连接的最后的<code>ACK</code>报文，就会触发超时重发<code>FIN</code>报文，另一方接收到<code>FIN</code>后，会重发<code>ACK</code>给被动关闭方，一来一去正好 2 个 MSL。</p>
<p>2MSL 的时间是从客户端接收到<code>FIN</code>后发送<code>ACK</code>开始计时的。如果在<code>TIME-WAIT</code>时间内，因为客户端的<code>ACK</code>没有传输到服务端，客户端又接收到了服务端重发的<code>FIN</code>报文，那么 2MSL 时间将重新计时。</p>
<p>在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。Linux 系统停留在<code>TIME_WAIT</code>的时间为固定的 60 秒。</p>
<p>其定义在 Linux 内核代码里的名称为<code>TCP_TIMEWAIT_LEN</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT </span><br><span class="line">                                    state, about 60 seconds  */</span><br></pre></td></tr></table></figure>
<p>如果要修改<code>TIME_WAIT</code>的时间长度，只能修改 Linux 内核代码里<code>TCP_TIMEWAIT_LEN</code>的值，并重新编译 Linux 内核。</p>
<h2 id="A-必须等待-2MSL-的时间"><a href="#A-必须等待-2MSL-的时间" class="headerlink" title="A 必须等待 2MSL 的时间"></a>A 必须等待 2MSL 的时间</h2><p>第一，为了保证 A 发送的最后一个<code>ACK</code>报文段能够到达 B。这个<code>ACK</code>报文段有可能丢失，因而使处在<code>LAST-ACK</code>状态的 B 收不到对已发送的<code>FIN + ACK</code>报文段的确认。B 会超时重传这个<code>FIN + ACK</code>报文段，而 A 就能在 2MSL 时间内收到这个重传的<code>FIN + ACK</code>报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到<code>CLOSED</code>状态。如果 A 在<code>TIME_WAIT</code>状态不等待一段时间，而是在发送完<code>ACK</code>报文段后立即释放连接，那么就无法收到 B 重传的<code>FIN + ACK</code>报文段，因而也不会再发送一次确认报文段。这样，B 就无法按照正常步骤进入<code>CLOSED</code>状态。</p>
<p>第二，防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个<code>ACK</code>报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<p>B 只要收到了 A 发岀的确认，就进入<code>CLOSED</code>状态。同样，B 在撤销相应的传输控制块 TCB 后，就结束了这次的 TCP 连接。B 结束 TCP 连接的时间要比 A 早一些。</p>
<h2 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h2><p>主动发起关闭连接的一方，才会有<code>TIME-WAIT</code>状态。</p>
<p>需要<code>TIME-WAIT</code>状态，主要是两个原因：</p>
<ul>
<li>防止具有相同「四元组」的旧数据包被收到；</li>
<li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的<code>ACK</code>能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
<h3 id="原因一：防止旧连接的数据包"><a href="#原因一：防止旧连接的数据包" class="headerlink" title="原因一：防止旧连接的数据包"></a>原因一：防止旧连接的数据包</h3><p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/23.jpg" class="">

<ul>
<li>如上图黄色框框服务端在关闭连接之前发送的<code>SEQ = 301</code>报文，被网络延迟了。</li>
<li>这时有相同端口的 TCP 连接被复用后，被延迟的<code>SEQ = 301</code>抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li>
</ul>
<p>所以，TCP 就设计出了这么一个机制，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</p>
<h3 id="原因二：保证连接正确关闭"><a href="#原因二：保证连接正确关闭" class="headerlink" title="原因二：保证连接正确关闭"></a>原因二：保证连接正确关闭</h3><p><code>TIME-WAIT</code>另一个重要的作用是等待足够的时间以确保最后的<code>ACK</code>能让被动关闭方接收，从而帮助其正常关闭。</p>
<p>假设<code>TIME-WAIT</code>没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/24.jpg" class="">

<ul>
<li>如上图红色框框客户端四次挥手的最后一个<code>ACK</code>报文如果在网络中被丢失了，此时如果客户端<code>TIME-WAIT</code>过短或没有，则就直接进入了<code>CLOSED</code>状态了，那么服务端则会一直处在<code>LASE_ACK</code>状态。</li>
<li>当客户端发起建立连接的<code>SYN</code>请求报文后，服务端会发送<code>RST</code>报文给客户端，连接建立的过程就会被终止。</li>
</ul>
<p>如果<code>TIME-WAIT</code>等待足够长的情况就会遇到两种情况：</p>
<ul>
<li>服务端正常收到四次挥手的最后一个<code>ACK</code>报文，则服务端正常关闭连接。</li>
<li>服务端没有收到四次挥手的最后一个<code>ACK</code>报文时，则会重发<code>FIN</code>关闭连接报文并等待新的<code>ACK</code>报文。</li>
</ul>
<p>所以客户端在<code>TIME-WAIT</code>状态等待 2MSL 时间后，就可以保证双方的连接都可以正常的关闭。</p>
<h2 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h2><p>除时间等待计时器外，TCP还设有一个保活计时器(<code>keepalive timer</code>)，用来防止在 TCP 连接出现长时期的空闲。</p>
<p>设想有这样的情况：客户己主动与服务器建立了 TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器。</p>
<p>保活计时器通常设置为2小时。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。 </p>
<h1 id="TCP的有限状态机"><a href="#TCP的有限状态机" class="headerlink" title="TCP的有限状态机"></a>TCP的有限状态机</h1><img src="/2020/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/img3.png" class="" title="TCP 的有限状态机">

<p>图中每一个方框都是 TCP 可能具有的状态。</p>
<p>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。</p>
<p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p>
<p>图中有三种不同的箭头：</p>
<ul>
<li>粗实线箭头表示对客户进程的正常变迁。</li>
<li>粗虚线箭头表示对服务器进程的正常变迁。</li>
<li>另一种细线箭头表示异常变迁。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/运输层——TCP的流量控制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"
    >运输层——TCP的流量控制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2020-10-15T03:14:12.000Z" itemprop="datePublished">2020-10-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h1><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</p>
<p>流量控制就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p>
<p>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</p>
<h2 id="利用可变窗口进行流量控制举例"><a href="#利用可变窗口进行流量控制举例" class="headerlink" title="利用可变窗口进行流量控制举例"></a>利用可变窗口进行流量控制举例</h2><p>A 向 B 发送数据。在连接建立时，B 告诉 A：“我的接收窗口 rwnd &#x3D; 400（字节）”。</p>
<img src="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/img1.png" class="">

<p>B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd &#x3D; 400 的报文段。</p>
<p>但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。</p>
<p>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p>
<p>为了解决这个问题， TCP 为每一个连接设有一个持续计时器。</p>
<p>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。</p>
<p>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</p>
<p>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</p>
<p>若窗口不是零，则死锁的僵局就可以打破了。 </p>
<h1 id="必须考虑传输效率"><a href="#必须考虑传输效率" class="headerlink" title="必须考虑传输效率"></a>必须考虑传输效率</h1><p>可以用不同的机制来控制 TCP 报文段的发送时机:</p>
<ul>
<li>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li>
<li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送操作。</li>
<li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li>
</ul>
<p>如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。</p>
<h2 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h2><p>糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。</p>
<img src="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/img2.png" class="">

<h3 id="发送方糊涂窗口综合症"><a href="#发送方糊涂窗口综合症" class="headerlink" title="发送方糊涂窗口综合症"></a>发送方糊涂窗口综合症</h3><p>发送方 TCP 每次接收到一字节的数据后就发送。</p>
<p>这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。</p>
<p>解决方法：使用 Nagle 算法。</p>
<h3 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h3><p>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。</p>
<p>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。</p>
<p>只有在收到对前一个报文段的确认后才继续发送下一个报文段。</p>
<p>当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</p>
<h3 id="Nagle算法原理"><a href="#Nagle算法原理" class="headerlink" title="Nagle算法原理"></a>Nagle算法原理</h3><img src="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/img3.png" class="">

<h3 id="接收方糊涂窗口综合症"><a href="#接收方糊涂窗口综合症" class="headerlink" title="接收方糊涂窗口综合症"></a>接收方糊涂窗口综合症</h3><p>当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。</p>
<p>若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。</p>
<p>原因：接收方应用进程消耗数据太慢，例如：每次只读取一个字节。</p>
<img src="/2020/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/img4.png" class="">

<p>解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/运输层——TCP的可靠传输"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"
    >运输层——TCP的可靠传输</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/" class="article-date">
  <time datetime="2020-10-14T11:11:53.000Z" itemprop="datePublished">2020-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><p>IP 网络所提供的是不可靠的传输。因此，TCP 必须采用适当的措施才能使得两个运输层之间的通信变得可靠。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img1.png" class="">

<p>理想的传输条件有以下两个特点：</p>
<ul>
<li>传输信道不产生差错。</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。</li>
</ul>
<p>在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。</p>
<p>然而实际的网络都不具备以上两个理想条件。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。</p>
<h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p>
<p>全双工通信的双方既是发送方也是接收方。为了方便，仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方。</p>
<h3 id="1-无差错情况"><a href="#1-无差错情况" class="headerlink" title="1.无差错情况"></a>1.无差错情况</h3><img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img2.png" class="">

<p>A 发送分组 M<sub>1</sub>，发完就暂停发送，等待 B 的确认。B 收到了 M<sub>1</sub> 向 A 发送  ACK。A 在收到了对 M<sub>1</sub> 的确认后，就再发送下一个分组 M<sub>2</sub>。</p>
<h3 id="2-出现差错"><a href="#2-出现差错" class="headerlink" title="2.出现差错"></a>2.出现差错</h3><img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img3.png" class="">

<p>在接收方 B 会出现两种情况：</p>
<ul>
<li>B 接收 M<sub>1</sub> 时检测出了差错，就丢弃 M<sub>1</sub>，其他什么也不做（不通知 A 收到有差错的分组）。</li>
<li>M<sub>1</sub> 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。</li>
</ul>
<p>在这两种情况下，B 都不会发送任何信息。但 A 都必须重发分组，直到 B 正确接收为止，这样才能实现可靠通信。</p>
<p>问题：A如何知道 B 是否正确收到了 M<sub>1</sub> 呢?</p>
<p>解决方法：超时重传</p>
<ul>
<li>A 为每一个已发送的分组都设置了一个超时计时器。</li>
<li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M<sub>2</sub>。</li>
<li>若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。</li>
</ul>
<p>问题：若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M<sub>1</sub>。B如何知道收到了重复的分组，需要丢弃呢?</p>
<p>解决方法：编号</p>
<ul>
<li>A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。</li>
<li>B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。</li>
<li>A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。</li>
</ul>
<h3 id="3-确认丢失和确认迟到"><a href="#3-确认丢失和确认迟到" class="headerlink" title="3. 确认丢失和确认迟到"></a>3. 确认丢失和确认迟到</h3><img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img4.png" class="">

<h4 id="确认丢失"><a href="#确认丢失" class="headerlink" title="确认丢失"></a>确认丢失</h4><p>若 B 所发送的对 M<sub>1</sub> 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M<sub>1</sub>。</p>
<p>假定 B 又收到了重传的分组 M<sub>1</sub>。这时 B 应采取两个行动：</p>
<ul>
<li>第一，丢弃这个重复的分组 M<sub>1</sub>，不向上层交付。</li>
<li>第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M<sub>1</sub> 就表示 A 没有收到对 M<sub>1</sub> 的确认。</li>
</ul>
<h4 id="确认迟到"><a href="#确认迟到" class="headerlink" title="确认迟到"></a>确认迟到</h4><p>传输过程中没有出现差错，但 B 对分组 M<sub>1</sub> 的确认迟到了。</p>
<p>A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。</p>
<p>B 仍然会收到重复的 M<sub>1</sub>，并且同样要丢弃重复的 M<sub>1</sub>，并重传确认分组。</p>
<h3 id="请注意"><a href="#请注意" class="headerlink" title="请注意"></a>请注意</h3><p>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。</p>
<p>分组和确认分组都必须进行编号。</p>
<p>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 </p>
<p>通常 A 最终总是可以收到对所有发出的分组的确认。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。</p>
<p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</p>
<p>像上述的这种可靠传输协议常称为自动重传请求 ARQ(<code>Automatic Repeat reQuest</code>)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</p>
<h3 id="4-信道利用率"><a href="#4-信道利用率" class="headerlink" title="4. 信道利用率"></a>4. 信道利用率</h3><p>停止等待协议的优点是简单，缺点是信道利用率太低。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img5.png" class="">

<p>假定 A 发送分组需要的时间是 T<sub>D</sub>。T<sub>D</sub> 等于分组长度除以数据率。分组正确到达 B 后，B 处理分组的时间忽略不计，同时立即发送确认。假定 B 发送确认分组需要时间 T<sub>A</sub>。如果 A 处理确认分组的时间忽略不计，那么 A 在经过时间 T<sub>D</sub> + RTT + T<sub>A</sub> 后就可以再发送下一个分组，这里的 RTT 是往返时间。</p>
<p>可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。</p>
<p>若出现重传，则对传送有用的数据信息来说，信道的利用率就还要降低。</p>
<p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。</p>
<p>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。</p>
<p>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 </p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img6.png" class="">

<p>停止等待协议要点：</p>
<ul>
<li>停止等待。发送方每次只发送一个分组。在收到确认后再发送下一个分组。</li>
<li>编号。对发送的每个分组和确认都进行编号。</li>
<li>自动重传请求。发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。</li>
<li>简单，但信道利用率太低。</li>
</ul>
<h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><p>基本思想：</p>
<ul>
<li>发送方一次可以发出多个分组。</li>
<li>使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。</li>
<li>每收到一个确认，发送方就把发送窗口向前滑动一个分组的位置。</li>
<li>接收方一般采用累积确认的方式。</li>
<li>采用回退N（Go-Back-N）方法进行重传。</li>
</ul>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img7.png" class="">

<p>发送方维持的发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</p>
<h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img10-1.png" class="">
<br>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img10-2.png" class="">
<br>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img10-3.png" class="">
<br>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img10-4.png" class="">

<h3 id="累积确认"><a href="#累积确认" class="headerlink" title="累积确认"></a>累积确认</h3><p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p>
<p>优点：容易实现，即使确认丢失也不必重传。</p>
<p>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img9.png" class="">

<h3 id="Go-back-N（回退-N）"><a href="#Go-back-N（回退-N）" class="headerlink" title="Go-back-N（回退 N）"></a>Go-back-N（回退 N）</h3><p>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。</p>
<p>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img10.png" class="">

<h3 id="连续-ARQ-协议与停止等待协议"><a href="#连续-ARQ-协议与停止等待协议" class="headerlink" title="连续 ARQ 协议与停止等待协议"></a>连续 ARQ 协议与停止等待协议</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">连续ARQ协议</th>
<th align="center">停止等待协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">发送的分组数量</td>
<td align="center">一次发送多个分组</td>
<td align="center">一次发送一个分组</td>
</tr>
<tr>
<td align="center">传输控制</td>
<td align="center">滑动窗口协议</td>
<td align="center">停等-等待</td>
</tr>
<tr>
<td align="center">确认</td>
<td align="center">单独确认 + 累积确认</td>
<td align="center">单独确认</td>
</tr>
<tr>
<td align="center">超时定时器</td>
<td align="center">每个发送的分组</td>
<td align="center">每个发送的分组</td>
</tr>
<tr>
<td align="center">编号</td>
<td align="center">每个发送的分组</td>
<td align="center">每个发送的分组</td>
</tr>
<tr>
<td align="center">重传</td>
<td align="center">回退N，多个分组</td>
<td align="center">一个分组</td>
</tr>
</tbody></table>
<h1 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h1><p>为了方便，我们假定数据传输只在一个方向进行，即 A 发送数据，B 给出确认。这样的好处是使讨论限于两个窗口，即发送方 A 的发送窗口和接收方 B 的接收窗口。</p>
<h2 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h2><p>TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。</p>
<p>TCP 的滑动窗口是以字节为单位的。</p>
<p>发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。</p>
<p>根据 B 给出的窗口值，A 构造出自己的发送窗口。假定 A 收到了 B 发来的确认报文段，其中窗口是 20 字节，而确认号是 31（这表明B期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了）。根据这两个数据，A 就构造出自己的发送窗口。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img11.png" class="">

<p>先看发送方 A 的发送窗口。发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。</p>
<p>发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。接收方会把自己的接收窗口数值放在窗口字段中发送给对方。因此，A 的发送窗口一 定不能超过 B 的接收窗口数值。发送方的发送窗口大小还要受到当时网络拥塞程度的制约。但在目前，我们暂不考虑网络拥塞的影响。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img12.png" class="">

<p>上图中，B 收到了序号为 32 和 33 的数据。这些数据没有按序到达，因为序号 31 的数据没有收到（也许丢失，也许滞留）。因此 B 发送的确认报文段中的确认号仍为 31。</p>
<p>现在假定 B 收到了序号为 31 的数据，并把序号 31~33 的数据交付主机，然后 B 删除这些数据。接着把窗口向前移动 3 个序号，同时给 A 发送确认，其中窗口值仍为 20，但确认号是 34。这表明 B 已经收到了到序号 33 为止的数据。B 还收到了 序号为 37，38 和 40 的数据，但这些都没有按序到达，只能暂存在接收窗口中。如下图。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img13.png" class="">

<p>A 收到 B 的确认后，就可以把发送窗口向前滑动 3 个序号，但指针 P<sub>2</sub> 不动。可以看出，现在 A 的可用窗口增大了，可发送范围是42~53。如下图。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img14.png" class="">

<p>A 在继续发送完序号 42~53 的数据后，指针 P<sub>2</sub> 向前移动和 P <sub>3</sub> 重合，发送窗口内的序号都已用完，但还没有再收到确认。由于 A 的发送窗口已满，可用窗口已减小到 0，因此必须停止发送。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img15.png" class="">

<p>如果 A 收到确认号落在发送窗口内，那么 A 就可以使发送窗口继续向前滑动，并发送新的数据。</p>
<h3 id="发送缓存与接收缓存的作用"><a href="#发送缓存与接收缓存的作用" class="headerlink" title="发送缓存与接收缓存的作用"></a>发送缓存与接收缓存的作用</h3><p>发送缓存用来暂时存放：</p>
<ul>
<li>发送应用程序传送给发送方 TCP 准备发送的数据；</li>
<li>TCP 已发送出但尚未收到确认的数据。</li>
</ul>
<p>接收缓存用来暂时存放：</p>
<ul>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据。</li>
</ul>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img16.png" class="">
<br>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img17.png" class="">

<p>需要强调三点：</p>
<ol>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。另外，发送方 A 还可能根据网络当时的拥塞情况适当减小自己的发送窗口数值。</li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li>
<li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li>
</ol>
<p>接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</p>
<p>但请注意两点：</p>
<ol>
<li>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认。</li>
<li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li>
</ol>
<p>最后再强调一下，TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清是哪一方的窗口。</p>
<h2 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h2><p>重传机制是 TCP 中最重要和最复杂的问题之一。</p>
<p>TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</p>
<p>由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间(RTT)的方差也很大。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img18.png" class="">

<h3 id="TCP-超时重传时间设置"><a href="#TCP-超时重传时间设置" class="headerlink" title="TCP 超时重传时间设置"></a>TCP 超时重传时间设置</h3><p>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。</p>
<p>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</p>
<p>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。</p>
<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间"></a>加权平均往返时间</h3><p>TCP保留了RTT的一个加权平均往返时间RTTS（这又称为平滑的往返时间）。</p>
<p>第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTT<sub>S</sub>：</p>
<p>新的RTT<sub>S</sub> &#x3D; (1 - α) * (旧的RTT<sub>S</sub>) + α * (新的RTT样本)</p>
<p>式中，<code>0 ≤ α &lt; 1</code>。若<code>α</code>很接近于零，表示 RTT 值更新较慢。若选择<code>α</code>接近于 1，则表示 RTT 值更新较快。</p>
<p>RFC 6298 推荐的 α 值为 1&#x2F;8，即 0.125。 </p>
<h3 id="超时重传时间-RTO"><a href="#超时重传时间-RTO" class="headerlink" title="超时重传时间 RTO"></a>超时重传时间 RTO</h3><p>RTO(<code>Retransmission Time-Out</code>) 应略大于上面得出的加权平均往返时间 RTT<sub>S</sub>。</p>
<p>RFC 6298 建议使用下式计算 RTO：</p>
<p>RTO &#x3D; RTT<sub>S</sub> + 4 * RTT<sub>D</sub>             </p>
<p>RTT<sub>D</sub> 是 RTT 的偏差的加权平均值。</p>
<p>RFC 6298 建议这样计算RTT<sub>D</sub>。第一次测量时， RTT<sub>D</sub> 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTT<sub>D</sub>：</p>
<p>新的 RTT<sub>D</sub> &#x3D; (1 - β) * (旧的RTT<sub>D</sub>) + β | RTT<sub>S</sub> - 新的 RTT 样本 |</p>
<p><code>β</code>是个小于 1 的系数，其推荐值是 1&#x2F;4，即 0.25。</p>
<h3 id="往返时间-RTT-的测量相当复杂"><a href="#往返时间-RTT-的测量相当复杂" class="headerlink" title="往返时间 (RTT) 的测量相当复杂"></a>往返时间 (RTT) 的测量相当复杂</h3><p>TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。</p>
<p>如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？ </p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img19.png" class="">

<h3 id="Karn-算法"><a href="#Karn-算法" class="headerlink" title="Karn 算法"></a>Karn 算法</h3><p>在计算平均往返时间 RTT 时，只要报文段重传了，就不采用其往返时间样本。</p>
<p>这样得出的加权平均平均往返时间 RTTS 和超时重传时间 RTO 就较准确。</p>
<p>但是，这又引起新的问题。当报文段的时延突然增大了很多时，在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</p>
<h3 id="修正的-Karn-算法"><a href="#修正的-Karn-算法" class="headerlink" title="修正的 Karn 算法"></a>修正的 Karn 算法</h3><p>报文段每重传一次，就把 RTO 增大一些：</p>
<p>新的 RTO &#x3D; γ * (旧的 RTO)  </p>
<p>系数<code>γ</code>的典型值是 2。</p>
<p>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。</p>
<p>实践证明，这种策略较为合理。 </p>
<h2 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h2><p>问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据?</p>
<p>答案是可以的。选择确认 SACK(<code>Selective ACK</code>) 就是一种可行的处理方法。</p>
<h3 id="接收到的字节流序号不连续"><a href="#接收到的字节流序号不连续" class="headerlink" title="接收到的字节流序号不连续"></a>接收到的字节流序号不连续</h3><p>TCP 的接收方在接收对方发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块。</p>
<img src="/2020/10/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/img20.png" class="">

<p>和前后字节不连续的每一个字节块都有两个边界：边界和右边界。</p>
<p>第一个字节块的左边界<code>L1 = 1501</code>，但右边界<code>R1 = 3001</code>。左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。</p>
<p>第二个字节块的左边界<code>L2 = 3501</code>，而右边界<code>R2 = 4501</code>。 </p>
<h3 id="RFC-2018-的规定"><a href="#RFC-2018-的规定" class="headerlink" title="RFC 2018 的规定"></a>RFC 2018 的规定</h3><p>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</p>
<p>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</p>
<p>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java反射机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/14/java/%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"
    >Java 反射机制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/14/java/%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2020-10-14T10:54:15.000Z" itemprop="datePublished">2020-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="编译期和运行期"><a href="#编译期和运行期" class="headerlink" title="编译期和运行期"></a>编译期和运行期</h1><p>编译期是指把源码交给编译器编译成计算机可以执行的文件的过程。也就是把 Java 代码编成<code>class</code>文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p>
<p>运行期是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。</p>
<p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p>
<p>Java 反射机制在服务器程序和中间件程序中得到了广泛运用。在服务器端，往往需要根据客户的请求，动态调用某一个对象的特定方法。此外，在 ORM 中间件的实现中，运用 Java 反射机制可以读取任意一个<code>JavaBean</code>的所有属性，或者给这些属性赋值。</p>
<img src="/2020/10/14/java/%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/1.png" class="">

<p>Java 反射机制主要提供了以下功能，这些功能都位于<code>java.lang.reflect</code>包。</p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>要想知道一个类的属性和方法，必须先获取到该类的字节码文件对象。获取类的信息时，使用的就是<code>Class</code>类中的方法。所以先要获取到每一个字节码文件（<code>.class</code>）对应的<code>Class</code>类型的对象.</p>
<p>众所周知，所有 Java 类均继承了<code>Object</code>类，在<code>Object</code>类中定义了一个<code>getClass()</code>方法，该方法返回同一个类型为<code>Class</code>的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">labelCls</span> <span class="operator">=</span> label1.getClass();    <span class="comment">// label1为 JLabel 类的对象</span></span><br></pre></td></tr></table></figure>
<p>利用<code>Class</code>类的对象<code>labelCls</code>可以访问<code>labelCls</code>对象的描述信息、<code>JLabel</code>类的信息以及基类<code>Object</code>的信息。反射可访问的常用信息：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">访问方法</th>
<th align="center">返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">包路径</td>
<td align="center">getPackage()</td>
<td align="center">Package 对象</td>
<td align="center">获取该类的存放路径</td>
</tr>
<tr>
<td align="center">类名称</td>
<td align="center">getName()</td>
<td align="center">String 对象</td>
<td align="center">获取该类的名称</td>
</tr>
<tr>
<td align="center">继承类</td>
<td align="center">getSuperclass()</td>
<td align="center">Class 对象</td>
<td align="center">获取该类继承的类</td>
</tr>
<tr>
<td align="center">实现接口</td>
<td align="center">getlnterfaces()</td>
<td align="center">Class 型数组</td>
<td align="center">获取该类实现的所有接口</td>
</tr>
<tr>
<td align="center">构造方法</td>
<td align="center">getConstructors()</td>
<td align="center">Constructor 型数组</td>
<td align="center">获取所有权限为 public 的构造方法</td>
</tr>
<tr>
<td align="center">构造方法</td>
<td align="center">getDeclaredContruectors()</td>
<td align="center">Constructor 对象</td>
<td align="center">获取当前对象的所有构造方法</td>
</tr>
<tr>
<td align="center">方法</td>
<td align="center">getMethods()</td>
<td align="center">Methods 型数组</td>
<td align="center">获取所有权限为 public 的方法</td>
</tr>
<tr>
<td align="center">方法</td>
<td align="center">getDeclaredMethods()</td>
<td align="center">Methods 对象</td>
<td align="center">获取当前对象的所有方法</td>
</tr>
<tr>
<td align="center">成员变量</td>
<td align="center">getFields()</td>
<td align="center">Field 型数组</td>
<td align="center">获取所有权限为 public 的成员变量</td>
</tr>
<tr>
<td align="center">成员变量</td>
<td align="center">getDeclareFileds()</td>
<td align="center">Field 对象</td>
<td align="center">获取当前对象的所有成员变量</td>
</tr>
<tr>
<td align="center">内部类</td>
<td align="center">getClasses()</td>
<td align="center">Class 型数组</td>
<td align="center">获取所有权限为 public 的内部类</td>
</tr>
<tr>
<td align="center">内部类</td>
<td align="center">getDeclaredClasses()</td>
<td align="center">Class 型数组</td>
<td align="center">获取所有内部类</td>
</tr>
<tr>
<td align="center">内部类的声明类</td>
<td align="center">getDeclaringClass()</td>
<td align="center">Class 对象</td>
<td align="center">如果该类为内部类，则返回它的成员类，否则返回 null</td>
</tr>
</tbody></table>
<p>在调用<code>getFields()</code>和<code>getMethods()</code>方法时将会依次获取权限为<code>public</code>的字段和变量，然后将包含从超类中继承到的成员变量和方法。而通过<code>getDeclareFields()</code>和<code>getDeclareMethod()</code>只是获取在本类中定义的成员变量和方法。</p>
<h2 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h2><p>优点：</p>
<ul>
<li>能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性。</li>
<li>与 Java 动态编译相结合，可以实现无比强大的功能。</li>
<li>对于 Java 这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li>
</ul>
<p>缺点：</p>
<ul>
<li>反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li>
<li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li>
</ul>
<h1 id="反射机制API"><a href="#反射机制API" class="headerlink" title="反射机制API"></a>反射机制API</h1><p>实现反射机制的类都位于<code>java.lang.reflect</code>包中，<code>java.lang.Class</code>类是反射机制 API 中的核心类。</p>
<h2 id="java-lang-Class-类"><a href="#java-lang-Class-类" class="headerlink" title="java.lang.Class 类"></a>java.lang.Class 类</h2><p><code>java.lang.Class</code>类是实现反射的关键所在，<code>Class</code>类的一个实例表示 Java 的一种数据类型，包括类、接口、枚举、注解（<code>Annotation</code>）、数组、基本数据类型和<code>void</code>。<code>Class</code>没有公有的构造方法，<code>Class</code>实例是由 JVM 在类加载时自动创建的。</p>
<p>在程序代码中获得<code>Class</code>实例可以通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过类型class静态变量</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz1</span> <span class="operator">=</span> String.class;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 2. 通过对象的getClass()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz2</span> <span class="operator">=</span> str.getClass();</span><br></pre></td></tr></table></figure>
<p>每一种类型包括类和接口等，都有一个<code>class</code>静态变量可以获得<code>Class</code>实例。另外，每一个对象都有<code>getClass()</code>方法可以获得<code>Class</code>实例，该方法是由<code>Object</code>类提供的实例方法。</p>
<p><code>Class</code>类提供了很多方法可以获得运行时对象的相关信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest01</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得Class实例</span></span><br><span class="line">    <span class="comment">// 1.通过类型class静态变量</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clz1</span> <span class="operator">=</span> String.class;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.通过对象的getClass()方法</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clz2</span> <span class="operator">=</span> str.getClass();</span><br><span class="line">    <span class="comment">// 获得int类型Class实例</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clz3</span> <span class="operator">=</span> <span class="type">int</span>.class;</span><br><span class="line">    <span class="comment">// 获得Integer类型Class实例</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clz4</span> <span class="operator">=</span> Integer.class;</span><br><span class="line">    System.out.println(<span class="string">&quot;clz2类名称：&quot;</span> + clz2.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;clz2是否为接口：&quot;</span> + clz2.isInterface());</span><br><span class="line">    System.out.println(<span class="string">&quot;clz2是否为数组对象：&quot;</span> + clz2.isArray());</span><br><span class="line">    System.out.println(<span class="string">&quot;clz2父类名称：&quot;</span> + clz2.getSuperclass().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;clz2是否为基本类型：&quot;</span> + clz2.isPrimitive());</span><br><span class="line">    System.out.println(<span class="string">&quot;clz3是否为基本类型：&quot;</span> + clz3.isPrimitive());</span><br><span class="line">    System.out.println(<span class="string">&quot;clz4是否为基本类型：&quot;</span> + clz4.isPrimitive());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clz2类名称：java.lang.String</span><br><span class="line">clz2是否为接口：false</span><br><span class="line">clz2是否为数组对象：false</span><br><span class="line">clz2父类名称：java.lang.Object</span><br><span class="line">clz2是否为基本类型：false</span><br><span class="line">clz3是否为基本类型：true</span><br><span class="line">clz4是否为基本类型：false</span><br></pre></td></tr></table></figure>
<h2 id="java-lang-reflect-包"><a href="#java-lang-reflect-包" class="headerlink" title="java.lang.reflect 包"></a>java.lang.reflect 包</h2><p><code>java.lang.reflect</code>包提供了反射中用到类，主要的类说明如下：</p>
<ul>
<li><code>Constructor</code>类：提供类的构造方法信息。</li>
<li><code>Field</code>类：提供类或接口中成员变量信息。</li>
<li><code>Method</code>类：提供类或接口成员方法信息。</li>
<li><code>Array</code>类：提供了动态创建和访问 Java 数组的方法。</li>
<li><code>Modifier</code>类：提供类和成员访问修饰符信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest02</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 动态加载xx类的运行时对象</span></span><br><span class="line">      <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取成员方法集合</span></span><br><span class="line">      Method[] methods = c.getDeclaredMethods();</span><br><span class="line">      <span class="comment">// 遍历成员方法集合</span></span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 打印权限修饰符，如public、protected、private</span></span><br><span class="line">        System.out.print(Modifier.toString(method.getModifiers()));</span><br><span class="line">        <span class="comment">// 打印返回值类型名称</span></span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span> + method.getReturnType().getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 打印方法名称</span></span><br><span class="line">        System.out.println(method.getName() + <span class="string">&quot;();&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;找不到指定类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码第 5 行是通过<code>Class</code>的静态方法<code>forName(String)</code>创建某个类的运行时对象，其中的参数是类全名字符串，如果在类路径中找不到这个类则抛出<code>ClassNotFoundException</code>异常。</p>
<p>代码第 7 行是通过<code>Class</code>的实例方法<code>getDeclaredMethods()</code>返回某个类的成员方法对象数组。代码第 9 行是遍历成员方法集合，其中的元素是<code>Method</code>类型。</p>
<p>代码第 11 行的<code>method.getModifiers()</code>方法返回访问权限修饰符常量代码，是<code>int</code>类型，例如 1 代表<code>public</code>，这些数字代表的含义可以通过<code>Modifier.toString(int)</code>方法转换为字符串。代码第 13 行通过<code>Method</code>的<code>getReturnType()</code>方法获得方法返回值类型，然后再调用<code>getName()</code>方法返回该类型的名称。代码第 15 行<code>method.getName()</code>返回方法名称。</p>
<h1 id="通过反射访问构造方法"><a href="#通过反射访问构造方法" class="headerlink" title="通过反射访问构造方法"></a>通过反射访问构造方法</h1><p>为了能够动态获取对象构造方法的信息，首先需要通过下列方法之一创建一个<code>Constructor</code>类型的对象或者数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getConstructors()</span><br><span class="line">getConstructor(Class&lt;?&gt;…parameterTypes)</span><br><span class="line">getDeclaredConstructors()</span><br><span class="line">getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)</span><br></pre></td></tr></table></figure>
<p>如果是访问指定的构造方法，需要根据该构造方法的入口参数的类型来访问。例如，访问一个入口参数类型依次为<code>int</code>和<code>String</code>类型的构造方法，下面的两种方式均可以实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectClass.getDeclaredConstructor(<span class="type">int</span>.class,String.class);</span><br><span class="line">objectClass.getDeclaredConstructor(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;<span class="type">int</span>.class,String.class&#125;);</span><br></pre></td></tr></table></figure>
<p>创建的每个<code>Constructor</code>对象表示一个构造方法，然后利用<code>Constructor</code>对象的方法操作构造方法。<code>Constructor</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isVarArgs()</td>
<td align="center">查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回false</td>
</tr>
<tr>
<td align="center">getParameterTypes()</td>
<td align="center">按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型</td>
</tr>
<tr>
<td align="center">getExceptionTypes()</td>
<td align="center">以 Class 数组的形式获取该构造方法可能抛出的异常类型</td>
</tr>
<tr>
<td align="center">newInstance(Object … initargs)</td>
<td align="center">通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示采用默认无参的构造方法</td>
</tr>
<tr>
<td align="center">setAccessiable(boolean flag)</td>
<td align="center">如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance() 方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对象</td>
</tr>
<tr>
<td align="center">getModifiers()</td>
<td align="center">获得可以解析出该构造方法所采用修饰符的整数</td>
</tr>
</tbody></table>
<p>通过<code>java.lang.reflect.Modifier</code>类可以解析出<code>getMocMers()</code>方法的返回值所表示的修饰符信息。在该类中提供了一系列用来解析的静态方法，既可以查看是否被指定的修饰符修饰，还可以字符串的形式获得所有修饰符。<code>Modifier</code>类的常用静态方法：</p>
<table>
<thead>
<tr>
<th align="center">静态方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isStatic(int mod)</td>
<td align="center">如果使用 static 修饰符修饰则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">isPublic(int mod)</td>
<td align="center">如果使用 public 修饰符修饰则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">isProtected(int mod)</td>
<td align="center">如果使用 protected 修饰符修饰则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">isPrivate(int mod)</td>
<td align="center">如果使用 private 修饰符修饰则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">isFinal(int mod)</td>
<td align="center">如果使用 final 修饰符修饰则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">toString(int mod)</td>
<td align="center">以字符串形式返回所有修饰符</td>
</tr>
</tbody></table>
<p>例如，下列代码判断对象<code>con</code>所代表的构造方法是否被<code>public</code>修饰，以及以字符串形式获取该构造方法的所有修饰符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> con.getModifiers();    <span class="comment">// 获取构造方法的修饰符整数</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isPublic</span> <span class="operator">=</span> Modifier.isPublic(modifiers);    <span class="comment">// 判断修饰符整数是否为public </span></span><br><span class="line"><span class="type">string</span> <span class="variable">allModifiers</span> <span class="operator">=</span> Modifier.toString(modifiers);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  String name; <span class="comment">// 图书名称</span></span><br><span class="line">  <span class="type">int</span> id, price; <span class="comment">// 图书编号和价格</span></span><br><span class="line">  <span class="comment">// 空的构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 带两个参数的构造方法</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">Book</span><span class="params">(String _name, <span class="type">int</span> _id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = _name;</span><br><span class="line">    <span class="built_in">this</span>.id = _id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 带可变参数的构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> NumberFormatException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; strings.length)</span><br><span class="line">      id = Integer.valueOf(strings[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt; strings.length)</span><br><span class="line">      price = Integer.valueOf(strings[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输出图书信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name=&quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;id=&quot;</span> + id);</span><br><span class="line">    System.out.println(<span class="string">&quot;price=&quot;</span> + price);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取动态类Book</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">book</span> <span class="operator">=</span> Book.class;</span><br><span class="line">    <span class="comment">// 获取Book类的所有构造方法</span></span><br><span class="line">    Constructor[] declaredContructors = book.getDeclaredConstructors();</span><br><span class="line">    <span class="comment">// 遍历所有构造方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; declaredContructors.length; i++) &#123;</span><br><span class="line">      <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> declaredContructors[i];</span><br><span class="line">      <span class="comment">// 判断构造方法的参数是否可变</span></span><br><span class="line">      System.out.println(<span class="string">&quot;查看是否允许带可变数量的参数：&quot;</span> + con.isVarArgs());</span><br><span class="line">      System.out.println(<span class="string">&quot;该构造方法的入口参数类型依次为：&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取所有参数类型</span></span><br><span class="line">      Class[] parameterTypes = con.getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; parameterTypes.length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span> + parameterTypes[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;该构造方法可能拋出的异常类型为：&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取所有可能拋出的异常类型</span></span><br><span class="line">      Class[] exceptionTypes = con.getExceptionTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; exceptionTypes.length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span> + parameterTypes[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建一个未实例化的Book类实例</span></span><br><span class="line">      <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (book1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 如果该成员变量的访问权限为private，则拋出异常</span></span><br><span class="line">          <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过执行带两个参数的构造方法实例化book1</span></span><br><span class="line">            book1 = (Book) con.newInstance(<span class="string">&quot;Java 教程&quot;</span>, <span class="number">10</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过执行默认构造方法实例化book1</span></span><br><span class="line">            book1 = (Book) con.newInstance();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过执行可变数量参数的构造方法实例化book1</span></span><br><span class="line">            Object[] parameters = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;100&quot;</span>, <span class="string">&quot;200&quot;</span> &#125; &#125;;</span><br><span class="line">              book1 = (Book) con.newInstance(parameters);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;在创建对象时拋出异常，下面执行 setAccessible() 方法&quot;</span>);</span><br><span class="line">          con.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置允许访问 private 成员</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      book1.print();</span><br><span class="line">      System.out.println(<span class="string">&quot;=============================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看是否允许带可变数量的参数：false</span><br><span class="line">该构造方法的入口参数类型依次为：</span><br><span class="line">该构造方法可能抛出的异常类型为：</span><br><span class="line">在创建对象时抛出异常，下面执行setAccessible()方法</span><br><span class="line">name = null</span><br><span class="line">id = 0</span><br><span class="line">price = 0</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>当通过反射访问两个参数的构造方法<code>Book(String_name,int_id)</code>时，将看到如下所示的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看是否允许带可变数量的参数：false</span><br><span class="line">该构造方法的入口参数类型依次为：</span><br><span class="line">class java.lang.String</span><br><span class="line">int</span><br><span class="line">该构造方法可能抛出的异常类型为：</span><br><span class="line">在创建对象时抛出异常，下面执行setAccessible()方法</span><br><span class="line">name = null</span><br><span class="line">id = 0</span><br><span class="line">price = 0</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>当通过反射访问可变参数数量的构造方法<code>Book(String...strings)</code>时，将看到如下所示的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查看是否允许带可变数量的参数：true</span><br><span class="line">该构造方法的入口参数类型依次为：</span><br><span class="line">class java.lang.String;</span><br><span class="line">该构造方法可能抛出的异常类型为：</span><br><span class="line">class java.lang.String;</span><br><span class="line">在创建对象时抛出异常，下面执行setAccessible()方法</span><br><span class="line">name = null</span><br><span class="line">id = 0</span><br><span class="line">price = 0</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<h1 id="通过反射访问方法"><a href="#通过反射访问方法" class="headerlink" title="通过反射访问方法"></a>通过反射访问方法</h1><p>要动态获取一个对象方法的信息，首先需要通过下列方法之一创建一个<code>Method</code>类型的对象或者数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getMethods()</span><br><span class="line">getMethods(String name,Class&lt;?&gt; …parameterTypes)</span><br><span class="line">getDeclaredMethods()</span><br><span class="line">getDeclaredMethods(String name,Class&lt;?&gt;...parameterTypes)</span><br></pre></td></tr></table></figure>
<p>如果是访问指定的构造方法，需要根据该方法的入口参数的类型来访问。例如，访问一个名称为<code>max</code>，入口参数类型依次为<code>int</code>和<code>String</code>类型的方法。</p>
<p>下面的两种方式均可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectClass.getDeclaredConstructor(<span class="string">&quot;max&quot;</span>,<span class="type">int</span>.class,String.class);</span><br><span class="line">objectClass.getDeclaredConstructor(<span class="string">&quot;max&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;<span class="type">int</span>.class,String.class&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Method</code>类的常用方法。</p>
<table>
<thead>
<tr>
<th align="center">静态方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getName()</td>
<td align="center">获取该方法的名称</td>
</tr>
<tr>
<td align="center">getParameterType()</td>
<td align="center">按照声明顺序以 Class 数组的形式返回该方法各个参数的类型</td>
</tr>
<tr>
<td align="center">getReturnType()</td>
<td align="center">以 Class 对象的形式获得该方法的返回值类型</td>
</tr>
<tr>
<td align="center">getExceptionTypes()</td>
<td align="center">以 Class 数组的形式获得该方法可能抛出的异常类型</td>
</tr>
<tr>
<td align="center">invoke(Object obj,Object…args)</td>
<td align="center">利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型</td>
</tr>
<tr>
<td align="center">isVarArgs()</td>
<td align="center">查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">getModifiers()</td>
<td align="center">获得可以解析出该方法所采用修饰符的整数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book1</span> &#123;</span><br><span class="line">  <span class="comment">// static 作用域方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行staticMethod()方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// public 作用域方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">publicMethod</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行publicMethod()方法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// protected 作用域方法</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">protectedMethod</span><span class="params">(String s, <span class="type">int</span> i)</span> <span class="keyword">throws</span> NumberFormatException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行protectedMethod()方法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(s) + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// private 作用域方法</span></span><br><span class="line">  <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String... strings)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行privateMethod()方法&quot;</span>);</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">      sb.append(strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取动态类Book1</span></span><br><span class="line">    <span class="type">Book1</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book1</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> book.getClass();</span><br><span class="line">    <span class="comment">// 获取Book1类的所有方法</span></span><br><span class="line">    Method[] declaredMethods = class1.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; declaredMethods.length; i++) &#123;</span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> declaredMethods[i];</span><br><span class="line">      System.out.println(<span class="string">&quot;方法名称为：&quot;</span> + method.getName());</span><br><span class="line">      System.out.println(<span class="string">&quot;方法是否带有可变数量的参数：&quot;</span> + method.isVarArgs());</span><br><span class="line">      System.out.println(<span class="string">&quot;方法的参数类型依次为：&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取所有参数类型</span></span><br><span class="line">      Class[] methodType = method.getParameterTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; methodType.length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span> + methodType[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取返回值类型</span></span><br><span class="line">      System.out.println(<span class="string">&quot;方法的返回值类型为：&quot;</span> + method.getReturnType());</span><br><span class="line">      System.out.println(<span class="string">&quot;方法可能抛出的异常类型有：&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取所有可能抛出的异常</span></span><br><span class="line">      Class[] methodExceptions = method.getExceptionTypes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; methodExceptions.length; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span> + methodExceptions[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isTurn</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (isTurn) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 如果该成员变量的访问权限为private，则抛出异常</span></span><br><span class="line">          isTurn = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;staticMethod&quot;</span>)) &#123; <span class="comment">// 调用没有参数的方法</span></span><br><span class="line">            method.invoke(book);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;publicMethod&quot;</span>)) &#123; <span class="comment">// 调用一个参数的方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;publicMethod(10)的返回值为：&quot;</span> + method.invoke(book, <span class="number">10</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;protectedMethod&quot;</span>)) &#123; <span class="comment">// 调用两个参数的方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;protectedMethod(\&quot;10\&quot;,15)的返回值为：&quot;</span> + method.invoke(book, <span class="string">&quot;10&quot;</span>, <span class="number">15</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;privateMethod&quot;</span>)) &#123; <span class="comment">// 调用可变数量参数的方法</span></span><br><span class="line">            Object[] parameters = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;J&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;A&quot;</span> &#125; &#125;;</span><br><span class="line">            System.out.println(<span class="string">&quot;privateMethod()的返回值为：&quot;</span> + method.invoke(book, parameters));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;在设置成员变量值时抛出异常，下面执行setAccessible()方法&quot;</span>);</span><br><span class="line">          method.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置为允许访问private方法</span></span><br><span class="line">          isTurn = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;=============================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试类 test02，程序将会依次动态访问<code>Book1</code>类中的所有方法。访问<code>staticMethod()</code>方法的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法名称为：staticMethod</span><br><span class="line">方法是否带有可变数量的参数：false</span><br><span class="line">方法的参数类型依次为：</span><br><span class="line">方法的返回值类型为：void</span><br><span class="line">方法可能抛出的异常类型有：</span><br><span class="line">执行staticMethod()方法</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>访问<code>publicMethod()</code>方法的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">方法名称为：publicMethod</span><br><span class="line">方法是否带有可变数量的参数：false</span><br><span class="line">方法的参数类型依次为：</span><br><span class="line">int</span><br><span class="line">方法的返回值类型为：int</span><br><span class="line">方法可能抛出的异常类型有：</span><br><span class="line">执行publicMethod()方法</span><br><span class="line">publicMethod(10)的返回值为：110</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>访问<code>protectedMethod()</code>方法的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法名称为：protectedMethod</span><br><span class="line">方法是否带有可变数量的参数：false</span><br><span class="line">方法的参数类型依次为：</span><br><span class="line">class java.lang.String</span><br><span class="line">int</span><br><span class="line">方法的返回值类型为：int</span><br><span class="line">方法可能抛出的异常类型有：</span><br><span class="line">class java.lang.NumberFormatException</span><br><span class="line">执行protectedMethod()方法</span><br><span class="line">protectedMethod(&quot;10&quot;,15)的返回值为：25</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>访问<code>privateMethod()</code>方法的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方法名称为：privateMethod</span><br><span class="line">方法是否带有可变数量的参数：true</span><br><span class="line">方法的参数类型依次为：</span><br><span class="line">class java.lang.String;</span><br><span class="line">方法的返回值类型为：class java.lang.String</span><br><span class="line">方法可能抛出的异常类型有：</span><br><span class="line">在设置成员变量值时抛出异常，下面执行setAccessible()方法</span><br><span class="line">执行privateMethod()方法</span><br><span class="line">privateMethod()的返回值为：</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<h1 id="通过反射访问成员变量"><a href="#通过反射访问成员变量" class="headerlink" title="通过反射访问成员变量"></a>通过反射访问成员变量</h1><p>通过下列任意一个方法访问成员变量时将返回<code>Field</code>类型的对象或数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getFields()</span><br><span class="line">getField(String name)</span><br><span class="line">getDeclaredFields()</span><br><span class="line">getDeclaredField(String name)</span><br></pre></td></tr></table></figure>
<p>上述方法返回的<code>Field</code>对象代表一个成员变量。例如，要访问一个名称为<code>price</code>的成员变量，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.getDeciaredField(&quot;price&quot;);</span><br></pre></td></tr></table></figure>
<p><code>Field</code>类的常用方法</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getName()</td>
<td align="center">获得该成员变量的名称</td>
</tr>
<tr>
<td align="center">getType()</td>
<td align="center">获取表示该成员变量的 Class 对象</td>
</tr>
<tr>
<td align="center">get(Object obj)</td>
<td align="center">获得指定对象 obj 中成员变量的值，返回值为 Object 类型</td>
</tr>
<tr>
<td align="center">set(Object obj, Object value)</td>
<td align="center">将指定对象 obj 中成员变量的值设置为 value</td>
</tr>
<tr>
<td align="center">getlnt(0bject obj)</td>
<td align="center">获得指定对象 obj 中成员类型为 int 的成员变量的值</td>
</tr>
<tr>
<td align="center">setlnt(0bject obj, int i)</td>
<td align="center">将指定对象 obj 中成员变量的值设置为 i</td>
</tr>
<tr>
<td align="center">setFloat(Object obj, float f)</td>
<td align="center">将指定对象 obj 中成员变量的值设置为 f</td>
</tr>
<tr>
<td align="center">getBoolean(Object obj)</td>
<td align="center">获得指定对象 obj 中成员类型为 boolean 的成员变量的值</td>
</tr>
<tr>
<td align="center">setBoolean(Object obj, boolean b)</td>
<td align="center">将指定对象 obj 中成员变量的值设置为 b</td>
</tr>
<tr>
<td align="center">getFloat(Object obj)</td>
<td align="center">获得指定对象 obj 中成员类型为 float 的成员变量的值</td>
</tr>
<tr>
<td align="center">setAccessible(boolean flag)</td>
<td align="center">此方法可以设置是否忽略权限直接访问 private 等私有权限的成员变量</td>
</tr>
<tr>
<td align="center">getModifiers()</td>
<td align="center">获得可以解析出该方法所采用修饰符的整数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book2</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> isLoan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Book2</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book2</span>();</span><br><span class="line">    <span class="comment">// 获取动态类Book2</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> book.getClass();</span><br><span class="line">    <span class="comment">// 获取Book2类的所有成员</span></span><br><span class="line">    Field[] declaredFields = class1.getDeclaredFields();</span><br><span class="line">    <span class="comment">// 遍历所有的成员</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; declaredFields.length;i++) &#123;    </span><br><span class="line">      <span class="comment">// 获取类中的成员变量</span></span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> declaredFields[i];</span><br><span class="line">      System.out.println(<span class="string">&quot;成员名称为：&quot;</span> + field.getName());</span><br><span class="line">      <span class="type">Class</span> <span class="variable">fieldType</span> <span class="operator">=</span> field.getType();</span><br><span class="line">      System.out.println(<span class="string">&quot;成员类型为：&quot;</span> + fieldType);</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isTurn</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span>(isTurn) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;    </span><br><span class="line">          <span class="comment">// 如果该成员变量的访问权限为private，则抛出异常</span></span><br><span class="line">          isTurn = <span class="literal">false</span>;</span><br><span class="line">          System.out.println(<span class="string">&quot;修改前成员的值为：&quot;</span> + field.get(book));</span><br><span class="line">          <span class="comment">// 判断成员类型是否为int</span></span><br><span class="line">          <span class="keyword">if</span>(fieldType.equals(<span class="type">int</span>.class)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;利用setInt()方法修改成员的值&quot;</span>);</span><br><span class="line">            field.setInt(book, <span class="number">100</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fieldType.equals(<span class="type">float</span>.class)) &#123;    </span><br><span class="line">            <span class="comment">// 判断成员变量类型是否为float</span></span><br><span class="line">            System.out.println(<span class="string">&quot;利用setFloat()方法修改成员的值&quot;</span>);</span><br><span class="line">            field.setFloat(book, <span class="number">29.815f</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fieldType.equals(<span class="type">boolean</span>.class)) &#123;    </span><br><span class="line">            <span class="comment">// 判断成员变量是否为boolean</span></span><br><span class="line">            System.out.println(<span class="string">&quot;利用setBoolean()方法修改成员的值&quot;</span>);</span><br><span class="line">            field.setBoolean(book, <span class="literal">true</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;利用set()方法修改成员的值&quot;</span>);</span><br><span class="line">            field.set(book, <span class="string">&quot;Java编程&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;修改后成员的值为：&quot;</span> + field.get(book));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;在设置成员变量值时抛出异常，下面执行setAccessible()方法&quot;</span>);</span><br><span class="line">          field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">          isTurn = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;=============================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试类 Test03，程序将会依次动态访问<code>Book2</code>类中的所有成员。访问<code>name</code>成员的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">成员名称为：name</span><br><span class="line">成员类型为：class java.lang.String</span><br><span class="line">修改前成员的值为：null</span><br><span class="line">利用set()方法修改成员的值</span><br><span class="line">修改后成员的值为：Java编程</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>访问<code>id</code>成员的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">成员名称为：id</span><br><span class="line">成员类型为：int</span><br><span class="line">修改前成员的值为：0</span><br><span class="line">利用setInt()方法修改成员的值</span><br><span class="line">修改后成员的值为：100</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>访问<code>price</code>成员的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">成员名称为：price</span><br><span class="line">成员类型为：float</span><br><span class="line">在设置成员变量值时抛出异常，下面执行setAccessible()方法</span><br><span class="line">修改前成员的值为：0.0</span><br><span class="line">利用setFloat()方法修改成员的值</span><br><span class="line">修改后成员的值为：29.815</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>访问<code>isLoan</code>成员的运行效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">成员名称为：isLoan</span><br><span class="line">成员类型为：boolean</span><br><span class="line">修改前成员的值为：false</span><br><span class="line">利用setBoolean()方法修改成员的值</span><br><span class="line">修改后成员的值为：true</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<h1 id="在远程方法调用中运用反射机制"><a href="#在远程方法调用中运用反射机制" class="headerlink" title="在远程方法调用中运用反射机制"></a>在远程方法调用中运用反射机制</h1><p>反射机制在网络编程中实现如何在客户端通过远程方法调用服务器端的方法。</p>
<p>假定在服务器端有一个<code>HelloService</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">echo</span><span class="params">(String msg)</span>;</span><br><span class="line">  <span class="keyword">public</span> Date <span class="title function_">getTime</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在服务器上创建一个<code>HelloServiceImpl</code>类并实现<code>HelloService</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">echo</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;echo:&quot;</span> + msg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Date <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端要调用服务器端<code>Hello-ServiceImpl</code>类中的<code>getTime()</code>和<code>echo()</code>方法，具体方法是：客户端需要把调用的方法名、方法参数类型、方法参数值，以及方法所属的类名或接口名发送给服务器端。服务器端再调用相关对象的方法，然后把方法的返回值发送给客户端。</p>
<p>为了便于按照面向对象的方式来处理客户端与服务器端的通信，可以把它们发送的信息用<code>Call</code>类来表示。一个<code>Call</code>对象表示客户端发起的一个远程调用，它包括调用的类名或接口名、方法名、方法参数类型、方法参数值和方法执行结果。</p>
<p><code>Call</code>类的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Call</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6659953547331194808L</span>;</span><br><span class="line">  <span class="keyword">private</span> String className; <span class="comment">// 表示类名或接口名</span></span><br><span class="line">  <span class="keyword">private</span> String methodName; <span class="comment">// 表示方法名</span></span><br><span class="line">  <span class="keyword">private</span> Class[] paramTypes; <span class="comment">// 表示方法参数类型</span></span><br><span class="line">  <span class="keyword">private</span> Object[] params; <span class="comment">// 表示方法参数值</span></span><br><span class="line">  <span class="comment">// 表示方法的执行结果</span></span><br><span class="line">  <span class="comment">// 如果方法正常执行，则result为方法返回值，如果方法抛出异常，那么result为该异常。</span></span><br><span class="line">  <span class="keyword">private</span> Object result;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Call</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Call</span><span class="params">(String className, String methodName, Class[] paramTypes, Object[] params)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.className = className;</span><br><span class="line">    <span class="built_in">this</span>.methodName = methodName;</span><br><span class="line">    <span class="built_in">this</span>.paramTypes = paramTypes;</span><br><span class="line">    <span class="built_in">this</span>.params = params;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> className;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.className = className;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getMethodName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> methodName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodName</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.methodName = methodName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Class[] getParamTypes() &#123;</span><br><span class="line">    <span class="keyword">return</span> paramTypes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParamTypes</span><span class="params">(Class[] paramTypes)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paramTypes = paramTypes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Object[] getParams() &#123;</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParams</span><span class="params">(Object[] params)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.params = params;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.result = result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;className=&quot;</span> + className + <span class="string">&quot;methodName=&quot;</span> + methodName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设客户端为<code>SimpleClient</code>，服务器端为<code>SimpleServer</code>。<code>SimpleClient</code>调用<code>SimpleServer</code>的<code>HelloServiceImpl</code>对象中<code>echo()</code>方法的流程如下：</p>
<ul>
<li><code>SimpleClient</code>创建一个<code>Call</code>对象，它包含调用<code>HelloService</code>接口的<code>echo()</code>方法的信息。</li>
<li><code>SimpleClient</code>通过对象输出流把<code>Call</code>对象发送给<code>SimpleServer</code>。</li>
<li><code>SimpleServer</code>通过对象输入流读取<code>Call</code>对象，运用反射机制调用<code>HelloServiceImpl</code>对象的<code>echo()</code>方法，把<code>echo()</code>方法的执行结果保存到<code>Call</code>对象中。</li>
<li><code>SimpleServer</code>通过对象输出流把包含方法执行结果的<code>Call</code>对象发送给<code>SimpleClient</code>。</li>
<li><code>SimpleClient</code>通过对象输入流读取<code>Call</code>对象，从中获得方法执行结果。</li>
</ul>
<p>客户端程序<code>SimpleClient</code>类的实现代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClient</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);</span><br><span class="line">    <span class="comment">// 创建一个远程调用对象</span></span><br><span class="line">    <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Call</span>(<span class="string">&quot;ch12.HelloService&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; String.class &#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;Java&quot;</span> &#125;);</span><br><span class="line">    oos.writeObject(call); <span class="comment">// 向服务器发送Call对象</span></span><br><span class="line">    call = (Call) ois.readObject(); <span class="comment">// 接收包含了方法执行结果的Call对象</span></span><br><span class="line">    System.out.println(call.getResult());</span><br><span class="line">    ois.close();</span><br><span class="line">    oos.close();</span><br><span class="line">    socket.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SimpleClient</span>().invoke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端<code>SimpleClient</code>类的主要作用是建立与服务器的连接，然后将带有调用信息的<code>Call</code>对象发送到服务器端。</p>
<p>服务器端<code>SimpleServer</code>类在收到调用请求之后会使用反射机制动态调用指定对象的指定方法，再将执行结果返回给客户端。</p>
<p><code>SimpleServer</code>类的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">Map</span> <span class="variable">remoteObjects</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// 存放远程对象的缓存</span></span><br><span class="line">  <span class="comment">/** 把一个远程对象放到缓存中 */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String className, Object remoteObject)</span> &#123;</span><br><span class="line">    remoteObjects.put(className, remoteObject);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器启动.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">      <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);</span><br><span class="line">      <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">      <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);</span><br><span class="line">      <span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> (Call) ois.readObject(); <span class="comment">// 接收客户发送的Call对象</span></span><br><span class="line">      System.out.println(call);</span><br><span class="line">      call = invoke(call); <span class="comment">// 调用相关对象的方法</span></span><br><span class="line">      oos.writeObject(call); <span class="comment">// 向客户发送包含了执行结果的Call对象</span></span><br><span class="line">      ois.close();</span><br><span class="line">      oos.close();</span><br><span class="line">      socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Call <span class="title function_">invoke</span><span class="params">(Call call)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> call.getClassName();</span><br><span class="line">      <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> call.getMethodName();</span><br><span class="line">      Object[] params = call.getParams();</span><br><span class="line">      <span class="type">Class</span> <span class="variable">classType</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">      Class[] paramTypes = call.getParamTypes();</span><br><span class="line">      <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> classType.getMethod(methodName, paramTypes);</span><br><span class="line">      <span class="type">Object</span> <span class="variable">remoteObject</span> <span class="operator">=</span> remoteObjects.get(className); <span class="comment">// 从缓存中取出相关的远程对象</span></span><br><span class="line">      <span class="keyword">if</span> (remoteObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(className + <span class="string">&quot;的远程对象不存在&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = method.invoke(remoteObject, params);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      result = e;</span><br><span class="line">    &#125;</span><br><span class="line">    call.setResult(result); <span class="comment">// 设置方法执行结果</span></span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SimpleServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleServer</span>();</span><br><span class="line">    <span class="comment">// 把事先创建的HelloServiceImpl对象加入到服务器的缓存中</span></span><br><span class="line">    server.register(<span class="string">&quot;ch13.HelloService&quot;</span>, <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>());</span><br><span class="line">    server.service();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这是一个网络程序，首先需要运行服务器端<code>SimpleServer</code>，然后再运行客户端<code>SimpleClient</code>。运行结果是在客户端看到输出<code>echoJava</code>，这个结果是服务器端执行<code>HelloServicelmpl</code>对象的<code>echo()</code>方法的返回值。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/ARP详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/"
    >ARP详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-10-13T03:08:41.000Z" itemprop="datePublished">2020-10-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>从网络分层上看，我们知道二层网络中，使用 MAC 地址进行传输，MAC 地址做为数据链路层的设备标识符。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>三层网络中，使用 IP 地址进行传输，IP 地址做为网络层的设备标识符。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/2.png" class="">

<p>我们还知道，容易记忆的域名，通过 DNS 解析成 IP 地址，有了 IP 地址就可以在网络上找到目的地。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/3.png" class="">

<p>IP 地址通过 ARP，获得 MAC 地址，有了 MAC 地址才能在物理网络上传输数据。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/4.png" class="">

<p>ARP，是地址解析协议。根据设备的 IP 地址来查询对应 MAC 地址的协议。主机通过 ARP 查询到 MAC 地址后，将在 ARP 缓存表中增加映射表项，即 IP 地址和 MAC 地址的映射表项。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/5.png" class="">

<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/img15.png" class="">

<h1 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h1><p>每个网卡或三层网口都有一个 MAC 地址， MAC 地址是烧录到硬件上，因此也称为硬件地址。MAC 地址作为数据链路设备的地址标识符，需要保证网络中的每个 MAC 地址都是唯一的，才能正确识别到数据链路上的设备。</p>
<p>MAC 地址由 6 个字节组成。前 3 个字节表示厂商识别码，每个网卡厂商都有特定唯一的识别数字。后 3 个字节由厂商给每个网卡进行分配。厂商可以保证生产出来的网卡不会有相同 MAC 地址的网卡。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/0.png" class="">

<p>现在可以通过软件修改 MAC 地址，虚拟机使用物理机网卡的 MAC 地址，并不能保证 MAC 地址是唯一的。但是只要 MAC 地址相同的设备不在同一个数据链路上就没问题。</p>
<p>为了查看方便，6 个字节的 MAC 地址使用十六进制来表示。每个字节的 8 位二进制数分别用 2 个十六进制数来表示，例如我的网卡 MAC 地址是<code>E0-06-E6-39-86-31</code>。</p>
<p>比特，英文名<code>bit</code>，也叫位。二进制中最小单位，一个比特的值要么是 0 要么是 1。</p>
<p>字节，英文名<code>Byte</code>。一个字节由八个比特构成。</p>
<h1 id="ARP-原理"><a href="#ARP-原理" class="headerlink" title="ARP 原理"></a>ARP 原理</h1><p>ARP 是如何知道 MAC 地址的呢？简单说，ARP 是通过 ARP 请求和 ARP 响应报文确定 MAC 地址的。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/6.png" class="">

<p>假如主机 A 向同一网段上的主机 B 发送数据。主机 A 的 IP 地址为<code>10.0.0.1</code>，主机 B 的 IP 地址为<code>10.0.0.2</code>，主机 C 的 IP 地址为<code>10.0.0.3</code>。它们都不知道对方的 MAC 地址。ARP 地址解析过程如下：</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/7.png" class="">

<ol>
<li>主机 A 首先查看自己的 ARP 表（即 ARP 缓存表），确定是否有主机 B 的 IP 地址对应表项。如果有，则直接使用表项中的 MAC 地址进行封装，封装成帧后发送给主机 B。<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/8.png" class=""></li>
<li>如果主机 A 的 ARP 表没有对应的表项，就发送一个广播帧，源 IP 和源 MAC 地址是主机 A，目的 IP 地址是主机 B，目的 MAC 地址是广播 MAC 地址，即<code>FFFF-FFFF-FFFF</code>。这就是 ARP 请求报文。<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/9.png" class=""></li>
<li>ARP 请求是广播报文，同一个网段的所有主机都能收到。只有主机 B 发现报文中的目的 IP 地址是自己，于是主机 B 发送响应报文给主机 A，源 MAC 地址和源 IP 地址是主机 B，目的 MAC 地址和目的 IP 地址是主机 A ，这个报文就叫 ARP 响应报文。同时，主机 B 的 ARP 表记录主机 A 的映射关系，即主机 A 的 IP 地址和 MAC 地址的对应关系。<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/10.png" class=""></li>
<li>主机 C 也收到了 ARP 请求报文，但目的 IP 地址不是自己，所以不会进行响应。于是主机 C 添加主机 A 的映射关系到 ARP 表，并丢弃 ARP 请求报文。<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/11.png" class=""></li>
<li>主机 A 收到 ARP 响应报文后，添加主机 B 的映射关系，同时用主机 B 的 MAC 地址做为目的地址封装成帧，并发送给主机 B。<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/12.png" class=""></li>
</ol>
<p>如果每发送一个 IP 报文就要进行一次 ARP 请求，来确定 MAC 地址，那将会造成不必要的网络流量，通常的做法是用 ARP 表记录 IP 地址和 MAC 地址的映射关系。主机发送报文时，首先会查看它的 ARP 表，目的是为了确定是否是已知的设备 MAC 地址。如果有，就直接使用；如果没有，就发起 ARP 请求获取。不过，缓存是有一定期限的。ARP 表项在老化时间（<code>aging time</code>）内是有效的，如果老化时间内未被使用，表项就会被删除。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/13.png" class="">

<p>ARP 表项分为动态 ARP 表项和静态 ARP 表项：</p>
<ul>
<li>动态 ARP 表项由 ARP 动态获取，因此在网络通信中，无需事先知道 MAC 地址，只要有 IP 地址即可。如果老化时间内未被使用，表项就会被自动删除。</li>
<li>静态 ARP 表项是手工配置，不会老化。静态 ARP 表项的优先级高于动态 ARP 表项，可以将相应的动态 ARP 表项覆盖。</li>
</ul>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/14.png" class="">

<h1 id="代理-ARP"><a href="#代理-ARP" class="headerlink" title="代理 ARP"></a>代理 ARP</h1><p>ARP 广播报文会被路由器隔离，没有默认网关、网段不同的主机相互通信时，连接这两个网络的路由器可以响应这个 ARP 请求，这个过程叫做代理 ARP（<code>Proxy ARP</code>）。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/15.png" class="">

<p>主机 A 与另一个网段的主机 B 通信，主机 A 直接发送 ARP 请求，解析主机 B 的 MAC 地址。运行了代理 ARP 的路由器收到 ARP 请求后，代替主机 A 在<code>20.0.0.0</code>网段发出 ARP 请求，解析主机 B 的地址。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/16.png" class="">

<p>主机 B 收到路由器发出的 ARP 请求，发出 ARP 响应报文，告知自己的 MAC 地址是<code>2222-2222-2222</code>。路由器收到 ARP 响应后，也向主机 A 发送 ARP 响应，但目的 MAC 地址是与<code>10.0.0.0</code>网段连接的端口 MAC 地址是<code>1010-1010-1010</code>。主机 A 收到报文后，在 ARP 表中添加 IP 地址是<code>20.0.0.1</code>和 MAC 地址是<code>1010-1010-1010</code>的映射表项。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/17.png" class="">

<p>因此主机 A 会将所有要发送给主机 B 的数据发送给路由器，路由器再将其转发给主机 B。反之亦然。</p>
<p>代理 ARP 功能屏蔽了分离的网络，主机不用修改 IP地址和子网掩码就可以和现有的网络互通。让用户使用起来，跟在同一个网络上一样。代理 ARP 使用在主机没有默认网络，或没有任何路由的网络上，通常是那些不支持设定子网掩码的老设备。但代理 ARP 会转发 ARP 广播报文，造成网络效率低，不适合用于大规模网络。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/18.png" class="">

<h1 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h1><p>RARP 是将 ARP 反过来，从设备 MAC 地址获取 IP 地址的一种协议。通常是打印机等小型嵌入式设备接入网络时会用得到。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/19.png" class="">

<h2 id="RARP-原理"><a href="#RARP-原理" class="headerlink" title="RARP 原理"></a>RARP 原理</h2><p>使用 RARP 需要搭建一台 RARP 服务器，在服务器上注册设备的 MAC 地址及 IP 地址。</p>
<p>设备插电启动后，广播发送一个请求报文，希望获得 IP 地址应答。目的 MAC 地址是广播地址，源 MAC 地址是自己的物理地址。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/20.png" class="">

<p>RARP 服务器收到 IP 地址请求后，给设备分配一个 IP 地址，并通过响应报文发送给设备。设备收到响应报文后，把 RARP 服务器分配的 IP 地址设置成自己的 IP 地址。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/21.png" class="">

<h1 id="免费-ARP"><a href="#免费-ARP" class="headerlink" title="免费 ARP"></a>免费 ARP</h1><p>免费 ARP 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/22.png" class="">

<p>与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，目标 IP 地址是自己的 IP 地址。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/23.png" class="">

<p>免费 ARP 的作用：</p>
<p>起到一个宣告作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。</p>
<p>可用于检测 IP 地址冲突。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</p>
<p>可用于更新其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。</p>
<h1 id="ARP-报文"><a href="#ARP-报文" class="headerlink" title="ARP 报文"></a>ARP 报文</h1><p>ARP 报文分为 ARP 请求报文和 ARP 应答报文，它们的报文格式相同，但是各个字段的取值不同。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/24.png" class="">

<p>ARP 报文中各个字段的含义如下。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/25.png" class="">

<h1 id="网络实战"><a href="#网络实战" class="headerlink" title="网络实战"></a>网络实战</h1><p>ARP 可以动态地进行地址解析，因此网络中的设备无需配置，只要有 IP 地址就可以自动获得 MAC 地址。但是静态 ARP 和代理 ARP 等是需要单独配置。下面我们代理 ARP 的实验。</p>
<h2 id="代理-ARP-1"><a href="#代理-ARP-1" class="headerlink" title="代理 ARP"></a>代理 ARP</h2><h3 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h3><img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/26.png" class="">

<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ul>
<li>PC1 和 PC2 只配置 IP 地址和子网掩码；</li>
<li>RT（路由器）配置代理 ARP 功能，PC1 可以 ping 通 PC2。</li>
</ul>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>PC1 、PC2 分别配置 IP 地址。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/27.png" class="">

<p>RT 配置 IP 地址和代理 ARP 功能。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/28.png" class="">

<h3 id="功能验证"><a href="#功能验证" class="headerlink" title="功能验证"></a>功能验证</h3><p>配置完成后，下面就要进行验证，检查功能是否生效、配置是否正确。在 PC1 上 ping PC2 的 IP 地址，进行连通性测试。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/29.png" class="">

<p>还可以抓包查看完整的报文交互过程，同时验证下理论知识是否正确。</p>
<img src="/2020/10/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARP%E8%AF%A6%E8%A7%A3/30.png" class="">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/运输层——TCP和UDP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/"
    >传输层——TCP和UDP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/" class="article-date">
  <time datetime="2020-10-12T09:21:43.000Z" itemprop="datePublished">2020-10-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="传输协议概述"><a href="#传输协议概述" class="headerlink" title="传输协议概述"></a>传输协议概述</h1><h2 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h2><p>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有传输，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 </p>
<h3 id="端系统之间通信的含义"><a href="#端系统之间通信的含义" class="headerlink" title="端系统之间通信的含义"></a>端系统之间通信的含义</h3><p>从IP层来说，通信的两端是两台主机。IP 数据报的首部明确的标志了这两台主机的 IP 地址。但“两台主机之间的通信”这种说法还不够清楚。IP 协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。</p>
<p>从传输的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。</p>
<p>“主机A和主机B进行通信”实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。简称为“计算机之间通信”。</p>
<p>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。</p>
<h3 id="网络层和传输的区别"><a href="#网络层和传输的区别" class="headerlink" title="网络层和传输的区别"></a>网络层和传输的区别</h3><p>网络层是为主机之间提供逻辑通信；传输为应用进程之间提供端到端的逻辑通信。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img2.png" class="">

<p>上图中，主机 A 的应用进程 AP<sub>1</sub> 和主机 B 的应用进程 AP<sub>3</sub> 通信，应用进程 AP<sub>2</sub> 和应用进程 AP<sub>4</sub> 通信。</p>
<h3 id="基于端口的复用和分用功能"><a href="#基于端口的复用和分用功能" class="headerlink" title="基于端口的复用和分用功能"></a>基于端口的复用和分用功能</h3><p>传输有一个很重要的功能：复用和分用。复用是指在发送方不同的应用进程都可以使用同一个传输协议传送数据；分用是指接收方的传输在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img3.png" class="">

<h3 id="两种不同的运输协议"><a href="#两种不同的运输协议" class="headerlink" title="两种不同的运输协议"></a>两种不同的运输协议</h3><p>传输向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个传输实体之间有一条端到端的逻辑通信信道。但这条逻辑通信信道对上层的表现却因传输使用的不同协议而有很大的差别。</p>
<p>当传输采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。</p>
<p>当传输采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 </p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img4.png" class="">

<h2 id="传输的两个主要协议"><a href="#传输的两个主要协议" class="headerlink" title="传输的两个主要协议"></a>传输的两个主要协议</h2><p>TCP&#x2F;IP 的传输有两个主要协议：</p>
<ul>
<li>用户数据报协议 UDP(<code>User Datagram Protocol</code>)</li>
<li>传输控制协议 TCP(<code>Transmission Control Protocol</code>)</li>
</ul>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img5.png" class="">

<h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU(<code>Transport Protocol Data Unit</code>)。</p>
<ul>
<li>TCP 传送的数据单位协议是 TCP 报文段。</li>
<li>UDP 传送的数据单位协议是 UDP 报文或用户数据报。</li>
</ul>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img6.png" class="">

<h3 id="使用-UDP-和-TCP-的典型应用和应用层协议"><a href="#使用-UDP-和-TCP-的典型应用和应用层协议" class="headerlink" title="使用 UDP 和 TCP 的典型应用和应用层协议"></a>使用 UDP 和 TCP 的典型应用和应用层协议</h3><img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img7.png" class="">

<p>还要强调两点：</p>
<ul>
<li>传输的 UDP 用户数据报与网际层的IP数据报有很大区别。<br>IP 数据报要经过互连网中许多路由器的存储转发。<br>UDP 用户数据报是在传输的端到端抽象的逻辑信道中传送的。</li>
<li>TCP 报文段是在传输抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的传输是否建立了 TCP 连接。</li>
</ul>
<h2 id="传输的端口"><a href="#传输的端口" class="headerlink" title="传输的端口"></a>传输的端口</h2><p>运行在计算机中的进程是用进程标识符来标志的。</p>
<p>但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。</p>
<p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP&#x2F;IP 体系的应用进程进行标志。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img8.png" class="">

<p>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</p>
<p>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</p>
<p>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</p>
<p>解决这个问题的方法就是在传输使用协议端口号(<code>protocol port number</code>)，或通常简称为端口(<code>port</code>)。</p>
<p>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p>
<h3 id="软件端口与硬件端口"><a href="#软件端口与硬件端口" class="headerlink" title="软件端口与硬件端口"></a>软件端口与硬件端口</h3><p>在协议栈层间的抽象的协议端口是软件端口。</p>
<p>路由器或交换机上的端口是硬件端口。</p>
<p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。 </p>
<h3 id="TCP-x2F-IP-传输端口"><a href="#TCP-x2F-IP-传输端口" class="headerlink" title="TCP&#x2F;IP 传输端口"></a>TCP&#x2F;IP 传输端口</h3><p>端口用一个 16 位端口号进行标志，允许有 65535 个不同的端口号。</p>
<p>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在互联网中，不同计算机的相同端口号是没有联系的。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img9.png" class="">

<p>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机）。</p>
<h3 id="两大类端口"><a href="#两大类端口" class="headerlink" title="两大类端口"></a>两大类端口</h3><p>计算机通信是采用客户——服务器方式，客户在发起通信请求时，必须先知道对方服务器的 IP 地址和端口号。因此传输的端口号分为两大类：</p>
<ol>
<li>服务器端使用的端口号，又分为两类：</li>
</ol>
<ul>
<li>熟知端口，数值一般为 0 ~ 1023。</li>
<li>登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
</ul>
<ol start="2">
<li>客户端使用的端口号，又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。<br>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ol>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img10.png" class="">

<h3 id="常用的熟知端口"><a href="#常用的熟知端口" class="headerlink" title="常用的熟知端口"></a>常用的熟知端口</h3><img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img11.png" class="">

<h2 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h2><p>可以的。</p>
<p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p>
<p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p>
<p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/23.png" class="">

<p>因此，TCP&#x2F;UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-的特点"><a href="#TCP-的特点" class="headerlink" title="TCP 的特点"></a>TCP 的特点</h2><img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img19.png" class="">

<ul>
<li>TCP 是面向连接的传输层协议。</li>
<li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）。 </li>
<li>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li>
<li>TCP 提供全双工通信。</li>
<li>面向字节流。</li>
</ul>
<p>总结一句话：TCP 是⾯向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>全双工通信是指 TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而 TCP 在合适的时候把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。</p>
<h2 id="TCP-面向流的概念"><a href="#TCP-面向流的概念" class="headerlink" title="TCP 面向流的概念"></a>TCP 面向流的概念</h2><p>TCP 中的“流”指的是流入或流出进程的字节序列。</p>
<p>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块(大小不等)，但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP 并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系(例如，发送方应用程序交给发送方的 TCP 共 10 个数据块，但接收方的 TCP 可能只用了 4 个数据块就把收到的字节流交付上层的应用程序)。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img20.png" class="">
<br>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img21.png" class="">

<p>TCP 连接是一条虚连接而不是一条真正的物理连接。</p>
<p>TCP 对应用进程一次把多长的报文发送到 TCP 的缓存中是不关心的。</p>
<p>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</p>
<p>TCP 可把太长的数据块划分短一些再传送。</p>
<p>TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</p>
<h2 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h2><p>TCP 把连接作为最基本的抽象。每一条 TCP 连接有两个端点。</p>
<p>TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是传输的协议端口。TCP 连接的端点叫做套接字(<code>socket</code>)。 </p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img22.png" class="">

<p>端口号拼接到 IP 地址即构成了套接字。套接字<code>socket = (IP地址:端口号)</code></p>
<h2 id="TCP-连接，IP-地址，套接字"><a href="#TCP-连接，IP-地址，套接字" class="headerlink" title="TCP 连接，IP 地址，套接字"></a>TCP 连接，IP 地址，套接字</h2><p>TCP 连接就是由协议软件所提供的一种抽象。</p>
<p>TCP 连接的端点是个很抽象的套接字，即（IP 地址:端口号）。</p>
<p>同一个 IP 地址可以有多个不同的 TCP 连接。</p>
<p>同一个端口号也可以出现在多个不同的 TCP 连接中。</p>
<h2 id="为什么需要-TCP-协议？"><a href="#为什么需要-TCP-协议？" class="headerlink" title="为什么需要 TCP 协议？"></a>为什么需要 TCP 协议？</h2><p>IP 层是不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。</p>
<h2 id="如何唯⼀确定⼀个-TCP-连接？"><a href="#如何唯⼀确定⼀个-TCP-连接？" class="headerlink" title="如何唯⼀确定⼀个 TCP 连接？"></a>如何唯⼀确定⼀个 TCP 连接？</h2><p>TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>⽬的地址</li>
<li>⽬的端口</li>
</ul>
<p>源地址和⽬的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报⽂给对方主机。</p>
<p>源端口和⽬的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报⽂发给哪个进程。</p>
<h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><p>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。</p>
<p>一个 TCP 报文段分为首部和数据两部分，TCP 的全部功能都体现在它首部中各字段的作用。</p>
<p>TCP 报文段首部的前 20 个字节是固定的，后面有<code>4n</code>字节是根据需要而增加的选项 (<code>n</code>是整数)。因此 TCP 首部的最小长度是 20 字节。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img33.png" class="">

<h2 id="首部固定部分各字段含义"><a href="#首部固定部分各字段含义" class="headerlink" title="首部固定部分各字段含义"></a>首部固定部分各字段含义</h2><ul>
<li>源端口和目的端口：各占 2 字节。端口是传输与应用层的服务接口。传输的复用和分用功能都要通过端口才能实现。</li>
<li>序号：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。序号增加到2<sup>32</sup>-1后，下一个序号就又回到 0。也就是说，序号使用 mod 2<sup>32</sup>运算。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。</li>
<li>确认号：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
<li>数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度(即选项长度不能超过 40 字节)。</li>
<li>保留字段：占 6 位，保留为今后使用，但目前应置为 0。 </li>
<li>紧急 URG (<code>URGent</code>)：当<code>URG = 1</code>时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。当<code>URG = 1</code>时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针字段配合使用。</li>
<li>确认<code>ACK(ACKnowledgment)</code>：只有当<code>ACK=1</code>时确认号字段才有效。当<code>ACK=0</code>时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把<code>ACK</code>置 1。</li>
<li>推送<code>PSH(PuSH)</code>：当两个应用进程进行交互式的通信时，有时在一端的应用进程 希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送操作。这时，发送方 TCP 把 PSH 置 1,并立即创建一个报文段发送出去。接收方 TCP 收到<code>PSH = 1</code>的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。虽然应用程序可以选择推送操作，但推送操作很少使用。</li>
<li>复位<code>RST(ReSeT)</code>：当<code>RST=1</code>时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。<code>RST</code>置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。<code>RST</code>也可称为重建位或重置位。</li>
<li>同步<code>SYN(SYNchronization)</code>：<code>SYN=1</code>表示这是一个连接请求或连接接受报文。当<code>SYN=1</code>而<code>ACK=0</code>时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使<code>SYN=1</code>和<code>ACK=1</code>。</li>
<li>终止<code>FIN</code>：用来释放一个连接。<code>FIN=1</code>表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。 </li>
<li>窗口：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。</li>
<li>检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。在计算检验和时，临时把 12 字节的“伪首部”和 TCP 报文段连接在一起。伪首部仅仅是为了计算检验和。伪首部的格式与 UDP 的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6(TCP 的协议号是 6)，把第 5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。</li>
<li>紧急指针：占 16 位，紧急指针仅在<code>URG = 1</code>时才有意义，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。即使窗口为零时也可发送紧急数据。</li>
<li>选项字段：长度可变。最长可达 40 字节。当没有使用“选项“时，TCP 的首部长度是 20 字节。</li>
<li>填充：这是为了使整个首部长度是 4 字节的整数倍。</li>
</ul>
<p>TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS(<code>Maximum Segment Size</code>)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以，MSS是“TCP 报文段长度减去 TCP 首部长度”。</p>
<p>MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” </p>
<p>为什么要规定一个最大报文段长度 MSS 呢？这并不是考虑接收方的接收缓存可能放不下 TCP 报文段中的数据。实际上，MSS 与接收窗口值没有关系。我们知道，TCP 报文段的数据部分，至少要加上 40 字节的首部（TCP 首部 20 字节和 IP 首部 20 字节，这里都还没有考虑首部中的选项部分），才能组装成一个 IP 数据报。若选择较小的 MSS 长度，网络的利用率就降低。设想在极端的情况下，当 TCP 报文段只含有 1 字节的数据时，在 IP 层传输的数据报的开销至少有 40 字节（包括 TCP 报文段的首部和 IP 数据报的首部）。这样，对网络的利用率就不会超过 1&#x2F;41。到了数据链路层还要加上一些开销。但反过来，若TCP 报文段非常长，那么在 IP 层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。</p>
<p>因此，MSS 应尽可能大些，只要在 IP 层传输时不需要再分片就行。由于 IP 数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要分片的 MSS，如果改走另一条路径就可能需要进行分片。因此最佳的 MSS 是很难确定的。在连接建立的过程中，双方都把自己能够支持的 MSS 写入这一字段，以后就按照这个数值传送数据，两个传送方向可以有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是 536 字节长。因此，所有在互联网上的主机都应能接受的报文段长度是 536 + 20 （固定首部长度）&#x3D;556 字节。</p>
<h2 id="选项字段的其他选项"><a href="#选项字段的其他选项" class="headerlink" title="选项字段的其他选项"></a>选项字段的其他选项</h2><ul>
<li>窗口扩大选项 ——占 3 字节，其中有一个字节表示移位值<code>S</code>。新的窗口值等于 TCP 首部中的窗口位数增大到<code>16 + S</code>，相当于把窗口值向左移动<code>S</code>位后获得实际的窗口大小。</li>
<li>时间戳选项——占 10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）。</li>
<li>选择确认选项（<code>SACK</code>）。</li>
</ul>
<p>窗口扩大选项是为了扩大窗口。我们知道，TCP 首部中窗口字段长度是 16 位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和带宽都很大，要获得高吞吐率需要更大的窗口大小。</p>
<p>窗口扩大选项可以在双方初始建立 TCP 连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送<code>S = 0</code>的选项，使窗口大小回到 16。</p>
<p>时间戳选项有以下两个功能：</p>
<ul>
<li>第一，用来计算往返时间 RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出 RTT 来。</li>
<li>第二，用于处理 TCP 序号超过 2<sup>32</sup>的情况，这又称为防止序号绕回 PAWS（<code>Protect Against Wrapped Sequence numbers</code>）。我们知道，TCP 报文段的序号只有 32 位,而每增加 2<sup>32</sup>个序号就会重复使用原来用过的序号。当使用高速网络时，在一次 TCP 连接的数据传送中序号很可能会被重复使用。例如，当使用 1.5Mbit&#x2F;s 的速率发送报文段时，序号重复要 6 小时以上。但若用 2.5Gbit&#x2F;s 的速率发送报文段，则不到 14 秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。</li>
</ul>
<h1 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h1><p>UDP 只在 IP 的数据报服务之上增加了很少的功能：复用和分用、差错检测。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img12.png" class="">

<h2 id="UDP-的特点"><a href="#UDP-的特点" class="headerlink" title="UDP 的特点"></a>UDP 的特点</h2><ul>
<li>UDP 是无连接的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li>
<li>UDP 是面向报文的。</li>
<li>UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。如 IP 电话、实时视频会议等。 </li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li>
</ul>
<h2 id="面向报文的-UDP-解释"><a href="#面向报文的-UDP-解释" class="headerlink" title="面向报文的 UDP 解释"></a>面向报文的 UDP 解释</h2><p>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。即应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</p>
<p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。因此应用程序必须选择合适大小的报文。</p>
<ul>
<li>若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。</li>
<li>若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。</li>
</ul>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img13.png" class="">
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img14.png" class="">

<h2 id="UDP-的首部格式"><a href="#UDP-的首部格式" class="headerlink" title="UDP 的首部格式"></a>UDP 的首部格式</h2><p>用户数据报 UDP 有两个字段：数据字段和首部字段。</p>
<p>首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节。</p>
<ul>
<li>源端口：源端口号。在需要对方回信时选用。不需要时可用全 0；</li>
<li>目的端口：目的端口号。这在终点交付报文时必须使用；</li>
<li>长度：UDP 用户数据报的长度，其最小值是 8 (仅有首部)；</li>
<li>检验和：检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</li>
</ul>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img15.png" class="">

<h2 id="UDP-基于端口的分用"><a href="#UDP-基于端口的分用" class="headerlink" title="UDP 基于端口的分用"></a>UDP 基于端口的分用</h2><p>当传输从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给最后的终点——应用进程。</p>
<p>如果接收方 UDP 发现收到的报文中的目的端口号不正确(即不存在对应于该端口号的应用进程)，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</p>
<blockquote>
<p>注意，虽然在 UDP 之间的通信要用到端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字来建立连接(TCP之间的通信必须要在两个套接字之间建立连接)。</p>
</blockquote>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img16.png" class="">
<br>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img17.png" class="">

<p>计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是 UDP 用户数据报真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报前面，得到一个临时的  UDP 用户数据报。检验和就是按照这个临时的 UDP 用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。</p>
<h2 id="计算-UDP-检验和的例子"><a href="#计算-UDP-检验和的例子" class="headerlink" title="计算 UDP 检验和的例子"></a>计算 UDP 检验和的例子</h2><p>UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但不同的是：IP数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和是把首部和数据部分一起都检验。</p>
<p>在发送方，首先是先把全零放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来的。若 UDP 用户数据报的数据部分不是偶数个字节，则要填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些 16 位字的和。将此和的二进制反码写入检验和字段后，就发送这样的 UDP 用户数据报。</p>
<p>在接收方，把收到的 UDP 用户数据报连同伪首部（以及可能的填充全零字节）一起，按二进制反码求这些 16 位字的和。当无差错时其结果应为全 1。否则就表明有差错出现，接收方就应丢弃这个 UDP 用户数据报（也可以上交给应用层，但附上出现了差错的警告）。</p>
<p>这里假定用户数据报的长度是 15 字节，因此要添加一个全 0 的字节。</p>
<img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E2%80%94%E2%80%94TCP%E5%92%8CUDP/img18.png" class="">

<p>伪首部的第 3 字段是全零；第 4 字段是 IP 首部中的协议字段的值。对于 UDP 此协议字段值为 17；第 5 字段是 UDP 用户数据报的长度。因此，这样的检验和，既检查了 UDP 用户数据报的源端口号和目的端口号以及 UDP 用户数据报的数据部分，又检查了 IP 数据报的源 IP 地址和目的地址。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/网络层——MPLS"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/"
    >网络层——MPLS</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/" class="article-date">
  <time datetime="2020-10-10T07:33:51.000Z" itemprop="datePublished">2020-10-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>多协议标记交换 MPLS(<code>MultiProtocol Label Switching</code>)。“多协议”表示在 MPLS 的上层可以采用多种协议，例如：IP，IPX；可以使用多种数据链路层协议，例如：PPP，以太网，ATM 等。“标记”是指每个分组被打上一个标记，根据该标记对分组进行转发。</p>
<p>为了实现交换，可以利用面向连接的概念，使每个分组携带一个叫做标记的小整数。当分组到达交换机（即标记交换路由器）时，交换机读取分组的标记，并用标记值来检索分组转发表。 这样就比查找路由表来转发分组要快得多。</p>
<h2 id="MPLS-特点"><a href="#MPLS-特点" class="headerlink" title="MPLS 特点"></a>MPLS 特点</h2><p>MPLS 并没有取代 IP，而是作为一种 IP 增强技术，被广泛地应用在互联网中。</p>
<p>MPLS 具有以下三个方面的特点：</p>
<ul>
<li>支持面向连接的服务质量；</li>
<li>支持流量工程，平衡网络负载；</li>
<li>有效地支持虚拟专用网 VPN。</li>
</ul>
<h1 id="MPLS-的工作原理"><a href="#MPLS-的工作原理" class="headerlink" title="MPLS 的工作原理"></a>MPLS 的工作原理</h1><h2 id="基本工作过程"><a href="#基本工作过程" class="headerlink" title="基本工作过程"></a>基本工作过程</h2><p>IP 分组的转发</p>
<ol>
<li>在传统的 IP 网络中，分组每到达一个路由器后，都必须提取出其目的地址，按目的地址查找路由表，并按照“最长前缀匹配”的原则找到下一跳的 IP 地址（请注意，前缀的长度是不确定的）。</li>
<li>当网络很大时，查找含有大量项目的路由表要花费很多的时间。</li>
<li>在出现突发性的通信量时，往往还会使缓存溢出，这就会引起分组丢失、传输时延增大和服务质量下降。</li>
</ol>
<img src="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/img2.png" class="">

<p>在 MPLS 域的入口处，给每一个 IP 数据报打上固定长度“标记”，然后对打上标记的 IP 数据报用硬件进行转发。</p>
<p>采用硬件技术对打上标记的 IP 数据报进行转发就称为标记交换。</p>
<p>“交换”也表示在转发时不再上升到第三层查找转发表，而是根据标记在第二层（链路层）用硬件进行转发。</p>
<p>MPLS 域是指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持 MPLS 技术的标记交换路由器 LSR(<code>Label Switching Router</code>)。</p>
<p>LSR 同时具有标记交换和路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择功能构造转发表。</p>
<img src="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/img3.png" class="">

<p>MPLS 的基本工作过程：</p>
<ol>
<li>MPLS 域中的各 LSR 使用专门的标记分配协议 LDP 交换报文，并找出标记交换路径 LSP。各 LSR 根据这些路径构造出分组转发表。 </li>
<li>分组进入到 MPLS 域时， MPLS 入口结点把分组打上标记，并按照转发表将分组转发给下一个 LSR。给 IP 数据报打标记的过程叫做分类 (classification)。</li>
<li>一个标记仅仅在两个标记交换路由器 LSR 之间才有意义。分组每经过一个 LSR，LSR 就要做两件事：一是转发，二是更换新的标记，即把入标记更换成为出标记。这就叫做标记对换(<code>label swapping</code>)。</li>
</ol>
<img src="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/img4.png" class="">

<p>项目含义：从入接口 0 收到一个入标记为 3 的IP 数据报，转发时，应当把该IP数据报从出接口 1 转发出去，同时把标记对换为 1。</p>
<ol start="4">
<li>当分组离开 MPLS 域时，MPLS 出口结点把分组的标记去除。再以后就按照一般分组的转发方法进行转发。</li>
</ol>
<p>上述的这种“由入口 LSR 确定进入 MPLS 域以后的转发路径”称为显式路由选择(<code>explicit routing</code>)，它和互联网中通常使用的“每一个路由器逐跳进行路由选择”有着很大的区别。</p>
<h2 id="转发等价类-FEC"><a href="#转发等价类-FEC" class="headerlink" title="转发等价类 FEC"></a>转发等价类 FEC</h2><p>MPLS 有个很重要的概念就是转发等价类 FEC(<code>Forwarding Equivalence Class</code>)。</p>
<p>“转发等价类”就是路由器按照同样方式对待的分组的集合。 </p>
<p>“按照同样方式对待”表示：从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。</p>
<p>划分 FEC 的方法不受什么限制，这都由网络管理员来控制，因此非常灵活。</p>
<p>入口结点并不是给每一个分组指派一个不同的标记，而是将属于同样 FEC 的分组都指派同样的标记。</p>
<p>FEC 和标记是一一对应的关系。</p>
<p>FEC 用于负载平衡</p>
<img src="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/img5.png" class="">

<h3 id="流量工程"><a href="#流量工程" class="headerlink" title="流量工程"></a>流量工程</h3><p>(1) 网络管理员采用自定义的 FEC 就可以更好地管理网络的资源。</p>
<p>(2) 这种均衡网络负载的做法也称为流量工程 TE(<code>Traffic Engineering</code>) 或通信量工程。</p>
<h1 id="MPLS-首部的位置与格式"><a href="#MPLS-首部的位置与格式" class="headerlink" title="MPLS 首部的位置与格式"></a>MPLS 首部的位置与格式</h1><p>MPLS 并不要求下层的网络都使用面向连接的技术。</p>
<p>下层的网络并不提供打标记的手段，而 IPv4 数据报首部也没有多余的位置存放 MPLS 标记。</p>
<p>这就需要使用一种封装技术：在把 IP 数据报封装成以太网帧之前，先要插入一个 MPLS 首部。</p>
<p>从层次的角度看，MPLS 首部就处在第二层和第三层之间。</p>
<img src="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/img6.png" class="">
<img src="/2020/10/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94MPLS/img7.png" class="">

<p>“给 IP 数据报打上标记”其实就是在以太网的帧首部和  IP 数据报的首部之间插入一个 4 字节的 MPLS 首部。</p>
<p>MPLS 首部共包括以下四个字段：</p>
<ul>
<li>标记值（占 20 位）。可以同时容纳高达 220 个流（即 1048576 个流）。实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管理和设置每条交换路径。</li>
<li>试验（占 3 位）。目前保留用作试验。</li>
<li>栈S（占 1 位）。在有“标记栈”时使用。</li>
<li>生存时间TTL（占 8 位）。用来防止 MPLS 分组在 MPLS 域中兜圈子。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/19/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>