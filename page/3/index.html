<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/js/实战/JS面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/%E5%AE%9E%E6%88%98/JS%E9%9D%A2%E8%AF%95%E9%A2%98/"
    >JS面试题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/%E5%AE%9E%E6%88%98/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2023-04-13T06:25:50.767Z" itemprop="datePublished">2023-04-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="typeof相关"><a href="#typeof相关" class="headerlink" title="typeof相关"></a>typeof相关</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Function</span>(); <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> /\*.<span class="property">js</span>/; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">1</span>) === <span class="string">&#x27;string&#x27;</span>; <span class="comment">// typeof返回的肯定是一个字符串</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>.<span class="property">iterator</span>; <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&#x27;undefined&#x27;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Math</span>.<span class="property">sin</span> === <span class="string">&#x27;function&#x27;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">isNaN</span>; <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">isNaN</span>(); <span class="comment">// &#x27;boolean&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>) <span class="comment">// 1, NaN, NaN</span></span><br></pre></td></tr></table></figure>

<p>总结：<br><code>typeof</code>运算符返回7种类型:<code>undefined,string,number,boolean,symbol,object,function</code>。<br>前5个是值类型，后4个是引用类型，<code>typeof</code>只能区分值类型的详细类型，对引用类型无法区分,只能区分<code>function</code>类型。</p>
<h2 id="数值相关"><a href="#数值相关" class="headerlink" title="数值相关"></a>数值相关</h2><h4 id="判断下面的值"><a href="#判断下面的值" class="headerlink" title="判断下面的值"></a>判断下面的值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0a&quot;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// parseInt(&quot;0a&quot;)==&gt;parseInt(&quot;0&quot;)==&gt;parseInt(&quot;0&quot;,10)==&gt;0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;010a&quot;</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// parseInt(&quot;010a&quot;)==&gt;parseInt(&quot;010&quot;)==&gt;parseInt(&quot;10&quot;,8)==&gt;8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0xt&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// parseInt(&quot;0xt&quot;)==&gt;parseInt(&quot;&quot;,16)==&gt;NaN</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> &gt; <span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="下面代码输出什么"><a href="#下面代码输出什么" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> two   = <span class="number">0.2</span></span><br><span class="line"><span class="keyword">var</span> one   = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> eight = <span class="number">0.8</span></span><br><span class="line"><span class="keyword">var</span> six   = <span class="number">0.6</span></span><br><span class="line">[two - one == one, eight - six == two] <span class="comment">// [true, false]</span></span><br></pre></td></tr></table></figure>
<h4 id="表达式的结果是什么"><a href="#表达式的结果是什么" class="headerlink" title="表达式的结果是什么"></a>表达式的结果是什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">111111111111111110000</span>, b = <span class="number">1111</span>;</span><br><span class="line">a + b;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A: 111111111111111111111</span></span><br><span class="line"><span class="comment">B: 111111111111111110000</span></span><br><span class="line"><span class="comment">C: NaN</span></span><br><span class="line"><span class="comment">D: Infinity</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>答案：B</p>
<p>解析：<br>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2<sup>53</sup>到2<sup>53</sup>，都可以精确表示。<br>大于2<sup>53</sup>的数值，都无法保持精度。由于2<sup>53</sup>是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。大于2<sup>53</sup>以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。</p>
<h4 id="下面代码输出什么-1"><a href="#下面代码输出什么-1" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>, <span class="number">3</span> &lt; <span class="number">2</span> &lt; <span class="number">1</span>] <span class="comment">// [true, true]</span></span><br></pre></td></tr></table></figure>


<h2 id="运算符相关"><a href="#运算符相关" class="headerlink" title="运算符相关"></a>运算符相关</h2><h4 id="下面代码输出什么-2"><a href="#下面代码输出什么-2" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="string">&#x27;smtg&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Value is &#x27;</span> + (val === <span class="string">&#x27;smtg&#x27;</span>) ? <span class="string">&#x27;Something&#x27;</span> : <span class="string">&#x27;Nothing&#x27;</span>);</span><br><span class="line"><span class="comment">// Something</span></span><br></pre></td></tr></table></figure>
<p>解析：<br><code>+</code>运算符的优先级比三目运算符的优先级高。</p>
<h4 id="下面代码输出什么-3"><a href="#下面代码输出什么-3" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isOdd</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isEven</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSane</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isEven</span>(num) || <span class="title function_">isOdd</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">7</span>, <span class="number">4</span>, <span class="string">&#x27;13&#x27;</span>, -<span class="number">9</span>, <span class="title class_">Infinity</span>];</span><br><span class="line">values.<span class="title function_">map</span>(isSane);</span><br><span class="line"><span class="comment">// [true, true, true, false, false]</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>余数运算符（<code>%</code>）返回前一个运算子被后一个运算子除，所得的余数，运算结果的正负号由第一个运算子的正负号决定，因此<code>-9 % 2 === -1</code>。<br><code>Infinity % 2</code>返回<code>NaN</code>。</p>
<h4 id="下面代码输出什么-4"><a href="#下面代码输出什么-4" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] == [] <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</p>
<h4 id="下面代码输出什么-5"><a href="#下面代码输出什么-5" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> x = y = <span class="number">1</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"><span class="comment">// 1, error</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>赋值运算符的计算顺序是从右开始计算，即右结合。<br><code>y</code>是全局变量。</p>
<h4 id="下面代码输出什么-6"><a href="#下面代码输出什么-6" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line">a ==  b</span><br><span class="line">a === b</span><br><span class="line">a &gt;   c</span><br><span class="line">a &lt;   c</span><br><span class="line"><span class="comment">// false, false, false, true</span></span><br></pre></td></tr></table></figure>
<p>解析：</p>
<ul>
<li>非相等运算符：如果运算子是对象，会转为原始类型的值，再进行比较。对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法。</li>
<li>非相等运算符：两个字符串进行比较时，字符串按照字典顺序进行比较。</li>
<li>相等运算符和严格相等运算符：两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</li>
<li>数组的<code>valueOf</code>方法返回数组本身，数组的<code>toString</code>方法返回数组的字符串形式。</li>
<li>对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</li>
</ul>
<h2 id="标准库相关"><a href="#标准库相关" class="headerlink" title="标准库相关"></a>标准库相关</h2><h4 id="下面代码输出什么-7"><a href="#下面代码输出什么-7" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showCase</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case A&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case B&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">undefined</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;undefined&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Do not know!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showCase</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">// Do not know</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>需要注意的是，<code>switch</code>语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>）。<br><code>new String(&#39;A&#39;)</code>返回的是一个对象。</p>
<h4 id="下面代码输出什么-8"><a href="#下面代码输出什么-8" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showCase2</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(value) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case A&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Case B&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">undefined</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;undefined&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Do not know!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showCase2</span>(<span class="title class_">String</span>(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">// Case A</span></span><br></pre></td></tr></table></figure>
<p>解析：<br><code>String</code>函数可以将任意类型的值转化成字符串，因此<code>String(&#39;A&#39;) === &#39;A&#39; =&gt; true</code>。</p>
<h4 id="下面代码输出什么-9"><a href="#下面代码输出什么-9" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">ary[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">ary.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x === <span class="literal">undefined</span>;&#125;);</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。<br>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、<code>Object.keys</code>等方法进行遍历，空位都会被跳过。如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p>
<h2 id="作用域相关"><a href="#作用域相关" class="headerlink" title="作用域相关"></a>作用域相关</h2><h4 id="下面代码输出什么-10"><a href="#下面代码输出什么-10" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>依次输出：<code>undefined -&gt; 10 -&gt; 20</code></p>
<p>解析：<br>在立即执行函数中，<code>var a = 20;</code>语句定义了一个局部变量<code>a</code>，由于js的变量声明提升机制，局部变量<code>a</code>的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印<code>undefined</code>，最后一条语句会打印20。</p>
<p>由于变量声明提升，<code>a = 5;</code>这条语句执行时，局部的变量<code>a</code>已经声明，因此它产生的效果是对局部的变量<code>a</code>赋值，此时<code>window.a</code>依旧是最开始赋值的10。</p>
<h4 id="下面代码输出什么-11"><a href="#下面代码输出什么-11" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> name == <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Goodbye &#x27;</span> + name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// Hello Tom</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>1、首先在进入函数作用域当中，获取<code>name</code>属性<br>2、在当前作用域没有找到<code>name</code><br>3、通过作用域链找到最外层，得到<code>name</code>属性<br>4、执行<code>else</code>的内容，得到<code>Hello Tom</code></p>
<h2 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h2><h4 id="下面代码输出什么-12"><a href="#下面代码输出什么-12" class="headerlink" title="下面代码输出什么"></a>下面代码输出什么</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.<span class="property">x</span> = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>) 	</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>)</span><br><span class="line"><span class="comment">// undefined &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>解析：<br>1、第3行，<code>.</code>运算符优先级比<code>=</code>高，所以这里首先执行<code>a.x</code>，相当于为<code>a</code>（或者<code>b</code>）所指向的<code>&#123;n: 1&#125;</code>对象新增了一个属性<code>x</code>，即此时对象将变为<code>&#123;n: 1, x: undefined&#125;</code>。<br>2、<code>=</code>从右往左进行赋值，<code>a = &#123;n: 2&#125;</code>，此时<code>a</code>的引用已经变成了<code>&#123;n: 2&#125;</code>这个对象，<code>a = &#123;n: 2&#125;</code>这条赋值语句返回<code>&#123;n: 2&#125;</code>。<br>3、执行<code>a.x = &#123;n：2&#125;</code>，此时因为<code>a.x</code>已经绑定到了<code>&#123;n: 1 , x: undefined&#125;</code>这个内存地址，也就是<code>b.x</code>，于是<code>&#123; n: 1, x: undefined&#125; =&gt; &#123;n: 1, x: &#123; n: 2&#125;&#125;</code>，即<code>b.x = &#123; n: 2 &#125;</code>。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h4 id="promise输出结果"><a href="#promise输出结果" class="headerlink" title="promise输出结果"></a>promise输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = (<span class="params"></span>) =&gt; (<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">6</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line">  p.<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="title function_">first</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="comment">// =&gt; 7</span></span><br><span class="line"><span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;once&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">once</span></span><br><span class="line"><span class="comment">success 1005</span></span><br><span class="line"><span class="comment">success 1007</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">nextTick</span></span><br><span class="line"><span class="comment">then</span></span><br><span class="line"><span class="comment">setImmediate</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="封装一个异步加载图片的方法"><a href="#封装一个异步加载图片的方法" class="headerlink" title="封装一个异步加载图片的方法"></a>封装一个异步加载图片的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image) </span><br><span class="line">    &#125;;</span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at&#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何使用Promise让三个灯不断交替重复亮灯？"><a href="#红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何使用Promise让三个灯不断交替重复亮灯？" class="headerlink" title="红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何使用Promise让三个灯不断交替重复亮灯？"></a>红灯3秒亮一次，绿灯1秒亮一次，黄灯2秒亮一次；如何使用Promise让三个灯不断交替重复亮灯？</h4><p>题目要求红灯亮过后，绿灯才能亮，绿灯亮过后，黄灯才能亮，黄灯亮过后，红灯才能亮……所以怎么通过Promise实现？</p>
<p>换句话说，就是红灯亮起时，承诺2s秒后亮绿灯，绿灯亮起时承诺1s后亮黄灯，黄灯亮起时，承诺3s后亮红灯……这显然是一个Promise链式调用，看到这里你心里或许就有思路了，我们需要将我们的每一个亮灯动作写在<code>then()</code>方法中，同时返回一个新的<code>Promise</code>，并将其状态由<code>pending</code>设置为<code>fulfilled</code>，允许下一盏灯亮起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">red</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">green</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">myLight</span> = (<span class="params">timer, cb</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cb</span>();</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;, timer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">myStep</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">myLight</span>(<span class="number">3000</span>, red);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">myLight</span>(<span class="number">2000</span>, green);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">myLight</span>(<span class="number">1000</span>, yellow);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">myStep</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">myStep</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// =&gt; red</span></span><br><span class="line"><span class="comment">// =&gt; green</span></span><br><span class="line"><span class="comment">// =&gt; yellow</span></span><br><span class="line"><span class="comment">// =&gt; red</span></span><br><span class="line"><span class="comment">// =&gt; green</span></span><br><span class="line"><span class="comment">// =&gt; yellow</span></span><br><span class="line"><span class="comment">// =&gt; red</span></span><br></pre></td></tr></table></figure>
<h4 id="输出结果-3"><a href="#输出结果-3" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">success</span> (res) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title function_">fail1</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;fail1: &#x27;</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> <span class="title function_">fail2</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;fail2: &#x27;</span>, e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p><code>.then</code>可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。</p>
<p><code>.catch</code>是<code>.then</code>第二个参数的简便写法，但是它们用法上有一点需要注意：<code>.then</code>的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的<code>.catch</code>可以捕获之前的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">fail2:  Error: error</span><br><span class="line">    at success (&lt;anonymous&gt;)</span><br></pre></td></tr></table></figure>
<h4 id="输出结果-4"><a href="#输出结果-4" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then: &#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p><code>.then</code>或者<code>.catch</code>中<code>return</code>一个<code>error</code>对象并不会抛出错误，所以不会被后续的<code>.catch</code>捕获，因为返回任意一个非<code>promise</code>的值都会被包裹成<code>promise</code>对象，即<code>return new Error(&#39;error!!!&#39;)</code>等价于<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">then:  Error: error!!!</span><br><span class="line">    at &lt;anonymous&gt;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">JS面试题</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/实战/leetcode真题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/%E5%AE%9E%E6%88%98/leetcode%E7%9C%9F%E9%A2%98/" class="article-date">
  <time datetime="2023-04-13T06:25:50.767Z" itemprop="datePublished">2023-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br>示例 1:<br>输入: <code>&quot;Let&#39;s take LeetCode contest&quot;</code><br>输出: <code>&quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code><br>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverseWords</span> = s =&gt; s.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/Three.js/Three.js相机对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/Three.js/Three.js%E7%9B%B8%E6%9C%BA%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2023-04-13T06:25:50.716Z" itemprop="datePublished">2023-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是照相机"><a href="#什么是照相机" class="headerlink" title="什么是照相机"></a>什么是照相机</h1><p>我们使用 Three.js 创建的场景是三维的，而通常情况下显示屏是二维的，那么三维的场景如何显示到二维的显示屏上呢？照相机就是这样一个抽象，它定义了三维空间到二维屏幕的投影方式，用“照相机”这样一个类比，可以使我们直观地理解这一投影方式。</p>
<p>而针对投影方式的不同，照相机又分为正投影照相机与透视投影照相机。</p>
<h1 id="正投影和透视投影"><a href="#正投影和透视投影" class="headerlink" title="正投影和透视投影"></a>正投影和透视投影</h1><p>生活中的物体都是三维的，但是人的眼睛只能看到正面，不能看到被遮挡的背面，三维几何体在人眼睛中的效果就像一张相机拍摄的二维照片，你看到的是一个2D的投影图。 空间几何体转化为一个二维图的过程就是投影，不同的投影方式意味着投影尺寸不同的算法。</p>
<img src="/2023/04/13/%E5%89%8D%E7%AB%AF/js/Three.js/Three.js%E7%9B%B8%E6%9C%BA%E5%AF%B9%E8%B1%A1/1.jpg" class="">

<p>对于正投影而言，一条直线放置的角度不同，投影在投影面上面的长短不同；对于透视投影而言，投影的结果除了与几何体的角度有关，还和距离相关，人的眼睛观察世界就是透视投影，比如你观察一条铁路距离越远你会感到两条轨道之间的宽度越小。</p>
<p>无论正投影还是透视投影，three.js 都对相关的投影算法进行了封装， 大家只需要根据不同的应用场景自行选择不同的投影方式。使用<code>OrthographicCamera</code>相机对象的时候，three.js 会按照正投影算法自动计算几何体的投影结果； 使用<code>PerspectiveCamera</code>相机对象的时候，three.js 会按照透视投影算法自动计算几何体的投影结果。</p>
<h1 id="正投影相机对象OrthographicCamera"><a href="#正投影相机对象OrthographicCamera" class="headerlink" title="正投影相机对象OrthographicCamera"></a>正投影相机对象OrthographicCamera</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正投影相机设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="variable language_">window</span>.<span class="property">innerWidth</span>; <span class="comment">//窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="variable language_">window</span>.<span class="property">innerHeight</span>; <span class="comment">//窗口高度</span></span><br><span class="line"><span class="keyword">var</span> k = width / height; <span class="comment">//窗口宽高比</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="number">150</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span><br><span class="line"><span class="comment">//创建相机对象</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">OrthographicCamera</span>(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(scene.<span class="property">position</span>); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数格式</span></span><br><span class="line"><span class="title class_">OrthographicCamera</span>( left, right, top, bottom, near, far )</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数(属性)</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">left</td>
<td align="center">渲染空间的左边界</td>
</tr>
<tr>
<td align="center">right</td>
<td align="center">渲染空间的右边界</td>
</tr>
<tr>
<td align="center">top</td>
<td align="center">渲染空间的上边界</td>
</tr>
<tr>
<td align="center">bottom</td>
<td align="center">渲染空间的下边界</td>
</tr>
<tr>
<td align="center">near</td>
<td align="center">near属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。 默认值0.1</td>
</tr>
<tr>
<td align="center">far</td>
<td align="center">far属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小小，会有部分场景看不到。 默认值1000</td>
</tr>
</tbody></table>
<img src="/2023/04/13/%E5%89%8D%E7%AB%AF/js/Three.js/Three.js%E7%9B%B8%E6%9C%BA%E5%AF%B9%E8%B1%A1/2.png" class="">

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>左右边界的距离与上下边界的距离比值与画布的渲染窗口的宽高比例要一致，否则三维模型的显示效果会被单方向不等比例拉伸</p>
<p>构造函数<code>OrthographicCamera的参数( left,right,top,bottom,near,far)</code>本质上是对 WebGL 投影矩阵的封装，宽度<code>width</code>、高度<code>height</code>越大，三维模型顶点的位置坐标就会越大，超出可视区域的网格模型就会被剪裁掉，不会再显示在屏幕上，大家还可以看到<code>left</code>与<code>right</code>、<code>top</code>与<code>bottom</code>互为相反数，这样做的目的是<code>lookAt</code>指向的对象能够显示在<code>canvas</code>画布的中间位置。</p>
<p>为了保持照相机的横竖比例，需要保证<code>(right - left)</code>与<code>(top - bottom)</code>的比例与 Canvas 宽度与高度的比例一致。</p>
<p><code>near</code>与<code>far</code>都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般<code>near</code>的值设置得较小，<code>far</code>的值设置得较大，具体值视场景中物体的位置等决定。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/Three.js/Three.js材质"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/Three.js/Three.js%E6%9D%90%E8%B4%A8/" class="article-date">
  <time datetime="2023-04-13T06:25:50.715Z" itemprop="datePublished">2023-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="材质-Material"><a href="#材质-Material" class="headerlink" title="材质(Material)"></a>材质(Material)</h1><p>材质的抽象基类。材质描述了对象的外观。它们的定义方式与渲染器无关。</p>
<p>所有其他材质类型都继承了以下属性和方法（尽管它们可能具有不同的默认值）。</p>
<h2 id="构造函数-Constructor"><a href="#构造函数-Constructor" class="headerlink" title="构造函数(Constructor)"></a>构造函数(Constructor)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Material</span>()</span><br></pre></td></tr></table></figure>
<p>该方法创建一个通用材质。</p>
<h2 id="属性-Properties"><a href="#属性-Properties" class="headerlink" title="属性(Properties)"></a>属性(Properties)</h2><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">参数类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">Integer</td>
<td align="center">此材质实例的唯一编号。</td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">String</td>
<td align="center">对象的可选名称（不必是唯一的）。默认值为空字符串。</td>
</tr>
<tr>
<td align="center">opacity</td>
<td align="center">Float</td>
<td align="center">表明材质的透明度。值0.0表示完全透明，1.0表示完全不透明。如果材质的<code>transparent</code>属性未设置为<code>true</code>，则材质将保持完全不透明，此值仅影响其颜色。默认值为1.0。</td>
</tr>
<tr>
<td align="center">transparent</td>
<td align="center">Boolean</td>
<td align="center">定义此材质是否透明。这对渲染有影响，因为透明对象需要特殊处理，并在非透明对象之后渲染。设置为true时，通过设置材质的opacity属性来控制材质透明的程度。默认值为false。</td>
</tr>
<tr>
<td align="center">visible</td>
<td align="center">Boolean</td>
<td align="center">此材质是否可见。默认为true。</td>
</tr>
<tr>
<td align="center">side</td>
<td align="center">Integer</td>
<td align="center">定义将要渲染哪一面，正面，背面或两者。默认为THREE.FrontSide。其他选项有THREE.BackSide和THREE.DoubleSide。</td>
</tr>
<tr>
<td align="center">needsUpdate</td>
<td align="center">Boolean</td>
<td align="center">指定需要重新编译材质。如果为true，则会使用新的材质属性刷新它的缓存</td>
</tr>
<tr>
<td align="center">blending</td>
<td align="center">决定物体上的材质如何跟背景融合，设置为CustomBlending才能使用自定义blendSrc, blendDst，默认值为NormalBlending。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">blendSrc</td>
<td align="center">指定物体如何跟背景融合，默认值为SrcAlphaFactor。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">blendDst</td>
<td align="center">定义混合时如何使用背景，默认值为OneMinusSrcAlphaFactor。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">blendEquation</td>
<td align="center">使用混合时所采用的混合方程式。默认值为AddEquation，即将两个颜色值相加。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">deptTest</td>
<td align="center">是否在渲染此材质时启用深度测试。默认为 true。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="常用材质"><a href="#常用材质" class="headerlink" title="常用材质"></a>常用材质</h1><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MeshBasicMaterial</td>
<td align="center">基础网格材质，可以用它赋予几何体一种简单的颜色，或显示几何体的线框</td>
</tr>
<tr>
<td align="center">MeshDepthMaterial</td>
<td align="center">深度网格材质，根据网格到相机的距离决定如何给网格染色</td>
</tr>
<tr>
<td align="center">MeshNormalMaterial</td>
<td align="center">法线网格材质，一种把法向量映射到RGB颜色的材质。</td>
</tr>
<tr>
<td align="center">MeshLambertMaterial</td>
<td align="center">Lambert网格材质</td>
</tr>
<tr>
<td align="center">MeshPhongMaterial</td>
<td align="center">Phong网格材质，一种用于具有镜面高光的光泽表面的材质。</td>
</tr>
<tr>
<td align="center">MeshPhysicalMaterial</td>
<td align="center">物理网格材质</td>
</tr>
<tr>
<td align="center">LineBasicMaterial</td>
<td align="center">基础线条材质，一种用于绘制线框样式几何体的材质。</td>
</tr>
<tr>
<td align="center">LineDashedMaterial</td>
<td align="center">虚线材质，一种用于绘制虚线样式几何体的材质。</td>
</tr>
</tbody></table>
<h2 id="基础网格材质-MeshBasicMaterial"><a href="#基础网格材质-MeshBasicMaterial" class="headerlink" title="基础网格材质(MeshBasicMaterial)"></a>基础网格材质(MeshBasicMaterial)</h2><p>一个以简单着色（平面或线框）方式来绘制几何体的材质。</p>
<p>这种材质不受光照的影响。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MeshBasicMaterial</span>( <span class="attr">parameters</span>: <span class="title class_">Object</span> )</span><br></pre></td></tr></table></figure>
<h4 id="属性-Properties-1"><a href="#属性-Properties-1" class="headerlink" title="属性(Properties)"></a>属性(Properties)</h4><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">数据类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">color</td>
<td align="center">Color</td>
<td align="center">材质的颜色(Color)，默认值为白色 (0xffffff)。</td>
</tr>
<tr>
<td align="center">wireframe</td>
<td align="center">Boolean</td>
<td align="center">将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</td>
</tr>
<tr>
<td align="center">wireframeLinecap</td>
<td align="center">String</td>
<td align="center">定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</td>
</tr>
<tr>
<td align="center">wireframeLinejoin</td>
<td align="center">String</td>
<td align="center">定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</td>
</tr>
<tr>
<td align="center">wireframeLinewidth</td>
<td align="center">Float</td>
<td align="center">控制线框宽度。默认值为1。</td>
</tr>
<tr>
<td align="center">fog</td>
<td align="center">Boolean</td>
<td align="center">材质是否受雾影响。默认为true。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> meshMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">color</span>: <span class="number">0x7777ff</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="深度网格材质-MeshDepthMaterial"><a href="#深度网格材质-MeshDepthMaterial" class="headerlink" title="深度网格材质(MeshDepthMaterial)"></a>深度网格材质(MeshDepthMaterial)</h2><p>一种按深度绘制几何体的材质。深度基于相机远近平面。白色最近，黑色最远。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MeshDepthMaterial</span>( <span class="attr">parameters</span>: <span class="title class_">Object</span> )</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">数据类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wireframe</td>
<td align="center">Boolean</td>
<td align="center">将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</td>
</tr>
<tr>
<td align="center">wireframeLinewidth</td>
<td align="center">Float</td>
<td align="center">控制线框宽度。默认值为1。</td>
</tr>
</tbody></table>
<h2 id="Lambert网格材质-MeshLambertMaterial"><a href="#Lambert网格材质-MeshLambertMaterial" class="headerlink" title="Lambert网格材质(MeshLambertMaterial)"></a>Lambert网格材质(MeshLambertMaterial)</h2><p>一种非光泽表面的材质，没有镜面高光。</p>
<p>该材质使用基于非物理的Lambertian模型来计算反射率。 这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MeshLambertMaterial</span>( parameters : <span class="title class_">Object</span> )</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">数据类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">color</td>
<td align="center">Color</td>
<td align="center">材质的颜色(Color)，默认值为白色 (0xffffff)。</td>
</tr>
<tr>
<td align="center">wireframe</td>
<td align="center">Boolean</td>
<td align="center">将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</td>
</tr>
<tr>
<td align="center">wireframeLinecap</td>
<td align="center">String</td>
<td align="center">定义线两端的外观。可选值为 ‘butt’，’round’ 和 ‘square’。默认为’round’。</td>
</tr>
<tr>
<td align="center">wireframeLinejoin</td>
<td align="center">String</td>
<td align="center">定义线连接节点的样式。可选值为 ‘round’, ‘bevel’ 和 ‘miter’。默认值为 ‘round’。</td>
</tr>
<tr>
<td align="center">wireframeLinewidth</td>
<td align="center">Float</td>
<td align="center">控制线框宽度。默认值为1。</td>
</tr>
<tr>
<td align="center">fog</td>
<td align="center">Boolean</td>
<td align="center">材质是否受雾影响。默认为true。</td>
</tr>
<tr>
<td align="center">emissive</td>
<td align="center">Color</td>
<td align="center">材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</td>
</tr>
<tr>
<td align="center">aoMapIntensity</td>
<td align="center">Float</td>
<td align="center">环境遮挡效果的强度。默认值为1。零是不遮挡效果。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> meshMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;<span class="attr">color</span>: <span class="number">0x7777ff</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="法线网格材质-MeshNormalMaterial"><a href="#法线网格材质-MeshNormalMaterial" class="headerlink" title="法线网格材质(MeshNormalMaterial)"></a>法线网格材质(MeshNormalMaterial)</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/Three.js/Three.js几何体"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/Three.js/Three.js%E5%87%A0%E4%BD%95%E4%BD%93/" class="article-date">
  <time datetime="2023-04-13T06:25:50.714Z" itemprop="datePublished">2023-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BoxGeometry</td>
<td align="center">立方缓冲几何体</td>
<td align="center">BoxGeometry是四边形的原始几何类，它通常使用构造函数所提供的“width”、“height”、“depth”参数来创建立方体或者不规则四边形。</td>
</tr>
<tr>
<td align="center">CircleGeometry</td>
<td align="center">圆形缓冲几何体</td>
<td align="center">CircleGeometry是欧式几何的一个简单形状，它由围绕着一个中心点的三角分段的数量所构造，由给定的半径来延展。 同时它也可以用于创建规则多边形，其分段数量取决于该规则多边形的边数。</td>
</tr>
<tr>
<td align="center">ConeGeometry</td>
<td align="center">圆锥缓冲几何体</td>
<td align="center">一个用于生成圆锥几何体的类。</td>
</tr>
<tr>
<td align="center">CylinderGeometry</td>
<td align="center">圆柱缓冲几何体</td>
<td align="center">一个用于生成圆柱几何体的类。</td>
</tr>
<tr>
<td align="center">DodecahedronGeometry</td>
<td align="center">十二面缓冲几何体</td>
<td align="center">一个用于创建十二面几何体的类。</td>
</tr>
<tr>
<td align="center">IcosahedronGeometry</td>
<td align="center">二十面缓冲几何体</td>
<td align="center">一个用于生成二十面体的类。</td>
</tr>
<tr>
<td align="center">LatheGeometry</td>
<td align="center">车削缓冲几何体</td>
<td align="center">创建具有轴对称性的网格，比如花瓶。车削绕着Y轴来进行旋转。</td>
</tr>
<tr>
<td align="center">OctahedronGeometry</td>
<td align="center">八面缓冲几何体</td>
<td align="center">一个用于创建八面体的类。</td>
</tr>
<tr>
<td align="center">PlaneGeometry</td>
<td align="center">平面缓冲几何体</td>
<td align="center">一个用于生成平面几何体的类。</td>
</tr>
<tr>
<td align="center">RingGeometry</td>
<td align="center">圆环缓冲几何体</td>
<td align="center">一个用于生成二维圆环几何体的类。</td>
</tr>
<tr>
<td align="center">ShapeGeometry</td>
<td align="center">形状缓冲几何体</td>
<td align="center">从一个或多个路径形状中创建一个单面多边形几何体。</td>
</tr>
<tr>
<td align="center">SphereGeometry</td>
<td align="center">球缓冲几何体</td>
<td align="center">一个用于生成球体的类。</td>
</tr>
<tr>
<td align="center">TetrahedronGeometry</td>
<td align="center">四面缓冲几何体</td>
<td align="center">一个用于生成四面几何体的类。</td>
</tr>
<tr>
<td align="center">TorusGeometry</td>
<td align="center">圆环缓冲几何体</td>
<td align="center">一个用于生成圆环几何体的类。</td>
</tr>
<tr>
<td align="center">TorusKnotGeometry</td>
<td align="center">圆环缓冲扭结几何体</td>
<td align="center">创建一个圆环扭结，其特殊形状由一对互质的整数，p和q所定义。如果p和q不互质，创建出来的几何体将是一个环面链接。</td>
</tr>
<tr>
<td align="center">TubeGeometry</td>
<td align="center">管道缓冲几何体</td>
<td align="center">创建一个沿着三维曲线延伸的管道。</td>
</tr>
<tr>
<td align="center">ConvexGeometry</td>
<td align="center">凸包几何体</td>
<td align="center">可被用于为传入的一组点生成凸包。</td>
</tr>
<tr>
<td align="center">DecalGeometry</td>
<td align="center">贴花几何体</td>
<td align="center">可被用于创建贴花网格物体，以达到不同的目的，例如：为模型增加独特的细节、进行动态的视觉环境改变或覆盖接缝。</td>
</tr>
<tr>
<td align="center">TextGeometry</td>
<td align="center">文本缓冲几何体</td>
<td align="center">一个用于将文本生成为单一的几何体的类。</td>
</tr>
<tr>
<td align="center">ParametricGeometry</td>
<td align="center">参数化缓冲几何体</td>
<td align="center">生成由参数表示其表面的几何体。</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/Three.js/Three.js光源"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/Three.js/Three.js%E5%85%89%E6%BA%90/" class="article-date">
  <time datetime="2023-04-13T06:25:50.713Z" itemprop="datePublished">2023-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <table>
<thead>
<tr>
<th align="center">光源名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AmbientLight</td>
<td align="center">它的颜色会添加到整个场景和所有对象的当前颜色上</td>
</tr>
<tr>
<td align="center">PointLight</td>
<td align="center">从一个点向各个方向发射的光源</td>
</tr>
<tr>
<td align="center">SportLight</td>
<td align="center">这种光源有聚光的效果，类似台灯、手电筒</td>
</tr>
<tr>
<td align="center">DirectionalLight</td>
<td align="center">平行光是沿着特定方向发射的光</td>
</tr>
<tr>
<td align="center">HemisphereLight</td>
<td align="center">可以用来创建更加自然的室外光线、模拟反光面和光线微弱的天空</td>
</tr>
</tbody></table>
<h1 id="AmbientLight-环境光"><a href="#AmbientLight-环境光" class="headerlink" title="AmbientLight(环境光)"></a>AmbientLight(环境光)</h1><p>环境光会均匀的照亮场景中的所有物体。环境光会影响整个场景。环境光的光线没有特定的来源，而且这个光源也不会影响阴影的生成，即环境光不能用来投射阴影，因为它没有方向。</p>
<p>不能将环境光作为场景中的唯一光源，需要配合其他光源使用，目的是弱化阴影或添加一些颜色。</p>
<h2 id="创建AmbientLight"><a href="#创建AmbientLight" class="headerlink" title="创建AmbientLight"></a>创建AmbientLight</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AmbientLight</span>( <span class="attr">color</span>: <span class="title class_">Integer</span>, <span class="attr">intensity</span>: <span class="title class_">Float</span> )</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>color</code>：(参数可选）颜色的<code>rgb</code>数值。缺省值为<code>0xffffff</code>。</li>
<li><code>intensity</code>：(参数可选)光照的强度。缺省值为 1。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ambiColor = <span class="string">&quot;#0c0c0c&quot;</span></span><br><span class="line"><span class="keyword">var</span> ambientLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AmbientLight</span>(ambiColor)</span><br><span class="line">scene.<span class="title function_">add</span>(ambientLight)</span><br></pre></td></tr></table></figure>
<h1 id="PointLight-点光源"><a href="#PointLight-点光源" class="headerlink" title="PointLight(点光源)"></a>PointLight(点光源)</h1><p>点光源从一个点向各个方向发射的光源。一个常见的例子是模拟一个灯泡发出的光。该光源可以投射阴影。</p>
<h2 id="创建点光源"><a href="#创建点光源" class="headerlink" title="创建点光源"></a>创建点光源</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointLight</span>( <span class="attr">color</span>: <span class="title class_">Integer</span>, <span class="attr">intensity</span>: <span class="title class_">Float</span>, <span class="attr">distance</span>: <span class="title class_">Number</span>, <span class="attr">decay</span>: <span class="title class_">Float</span> )</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>color</code>：光源颜色(可选参数)，十六进制光照颜色，缺省值<code>0xffffff</code>。</li>
<li><code>intensity</code>：光照强度(可选参数)，当设置为 0 时，什么都看不到，设成 2，得到的是两倍的亮度，缺省值 1。</li>
<li><code>distance</code>：光源照射的距离，这个距离表示从光源到光照强度为 0 的位置。 当设置为 0 时，光永远不会消失(距离无穷大)。缺省值 0。</li>
<li><code>decay</code>：沿着光照距离的衰退量。缺省值 1。在<code>physically correct</code>模式中，<code>decay = 2</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pointColor = <span class="string">&quot;#ccffcc&quot;</span></span><br><span class="line"><span class="keyword">var</span> pointLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointLight</span>(pointColor)</span><br><span class="line">pointLight.<span class="property">distance</span> = <span class="number">100</span></span><br><span class="line">scene.<span class="title function_">add</span>(pointLight)</span><br></pre></td></tr></table></figure>
<h1 id="SpotLight-聚光灯"><a href="#SpotLight-聚光灯" class="headerlink" title="SpotLight(聚光灯)"></a>SpotLight(聚光灯)</h1><p>光线从一个点沿一个方向射出，随着光线照射的变远，光线圆锥体的尺寸也逐渐增大。该光源可以投射阴影。</p>
<h2 id="创建聚光灯"><a href="#创建聚光灯" class="headerlink" title="创建聚光灯"></a>创建聚光灯</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SpotLight</span>( <span class="attr">color</span>: <span class="title class_">Integer</span>, <span class="attr">intensity</span>: <span class="title class_">Float</span>, <span class="attr">distance</span>: <span class="title class_">Float</span>, <span class="attr">angle</span>: <span class="title class_">Radians</span>, <span class="attr">penumbra</span>: <span class="title class_">Float</span>, <span class="attr">decay</span>: <span class="title class_">Float</span> )</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>color</code>：(可选参数)十六进制光照颜色。 缺省值<code>0xffffff</code>。</li>
<li><code>intensity</code>：(可选参数)光照强度。 缺省值 1。</li>
<li><code>distance</code>：从光源发出光的最大距离，其强度根据光源的距离线性衰减。</li>
<li><code>angle</code>：光线散射角度，最大为<code>Math.PI/2</code>。</li>
<li><code>penumbra</code>：聚光锥的半影衰减百分比。在 0 和 1 之间的值，默认为 0。</li>
<li><code>decay</code>：沿着光照距离的衰减量。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pointColor = <span class="string">&quot;#ffffff&quot;</span></span><br><span class="line"><span class="keyword">var</span> spotLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SpotLight</span>(pointColor)</span><br><span class="line">spotLight.<span class="property">position</span>.<span class="title function_">set</span>(-<span class="number">40</span>, <span class="number">60</span>, -<span class="number">10</span>)</span><br><span class="line">spotLight.<span class="property">castShadow</span> = <span class="literal">true</span></span><br><span class="line">spotLight.<span class="property">shadowCameraNear</span> = <span class="number">2</span></span><br><span class="line">spotLight.<span class="property">shadowCameraFar</span> = <span class="number">200</span></span><br><span class="line">spotLight.<span class="property">shadowCameraFov</span> = <span class="number">30</span></span><br><span class="line">spotLight.<span class="property">target</span> = plane</span><br><span class="line">spotLight.<span class="property">distance</span> = <span class="number">0</span></span><br><span class="line">spotLight.<span class="property">angle</span> = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line">scene.<span class="title function_">add</span>(spotLight);</span><br></pre></td></tr></table></figure>
<h1 id="DirectionalLight-平行光"><a href="#DirectionalLight-平行光" class="headerlink" title="DirectionalLight(平行光)"></a>DirectionalLight(平行光)</h1><p>平行光是沿着特定方向发射的光。这种光的表现像是无限远，从它发出的光线都是平行的。常常用平行光来模拟太阳光的效果；太阳足够远，因此我们可以认为太阳的位置是无限远，所以我们认为从太阳发出的光线也都是平行的。平行光可以投射阴影。</p>
<h2 id="创建平行光"><a href="#创建平行光" class="headerlink" title="创建平行光"></a>创建平行光</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">DirectionalLight</span>( <span class="attr">color</span>: <span class="title class_">Integer</span>, <span class="attr">intensity</span>: <span class="title class_">Float</span> )</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pointColor = <span class="string">&quot;#ff5808&quot;</span></span><br><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">DirectionalLight</span>(pointColor)</span><br><span class="line">directionalLight.<span class="property">position</span>.<span class="title function_">set</span>(-<span class="number">40</span>, <span class="number">60</span>, -<span class="number">10</span>)</span><br><span class="line">directionalLight.<span class="property">castShadow</span> = <span class="literal">true</span></span><br><span class="line">directionalLight.<span class="property">shadowCameraNear</span> = <span class="number">2</span></span><br><span class="line">directionalLight.<span class="property">shadowCameraFar</span> = <span class="number">200</span></span><br><span class="line">directionalLight.<span class="property">shadowCameraLeft</span> = -<span class="number">50</span></span><br><span class="line">directionalLight.<span class="property">shadowCameraRight</span> = <span class="number">50</span></span><br><span class="line">directionalLight.<span class="property">shadowCameraTop</span> = <span class="number">50</span></span><br><span class="line">directionalLight.<span class="property">shadowCameraBottom</span> = -<span class="number">50</span></span><br><span class="line"></span><br><span class="line">directionalLight.<span class="property">distance</span> = <span class="number">0</span></span><br><span class="line">directionalLight.<span class="property">intensity</span> = <span class="number">0.5</span></span><br><span class="line">directionalLight.<span class="property">shadowMapHeight</span> = <span class="number">1024</span></span><br><span class="line">directionalLight.<span class="property">shadowMapWidth</span> = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">scene.<span class="title function_">add</span>(directionalLight)</span><br></pre></td></tr></table></figure>
<h1 id="半球光-HemisphereLight"><a href="#半球光-HemisphereLight" class="headerlink" title="半球光(HemisphereLight)"></a>半球光(HemisphereLight)</h1><p>光源直接放置于场景之上，光照颜色从天空光线颜色渐变到地面光线颜色。半球光不能投射阴影。</p>
<h2 id="创建半球光"><a href="#创建半球光" class="headerlink" title="创建半球光"></a>创建半球光</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">HemisphereLight</span>( <span class="attr">skyColor</span>: <span class="title class_">Integer</span>, <span class="attr">groundColor</span>: <span class="title class_">Integer</span>, <span class="attr">intensity</span>: <span class="title class_">Float</span> )</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>skyColor</code>：(可选参数) 天空中发出光线的颜色。缺省值<code>0xffffff</code>。</li>
<li><code>groundColor</code>：(可选参数) 地面发出光线的颜色。缺省值<code>0xffffff</code>。</li>
<li><code>intensity</code>：(可选参数) 光照强度。缺省值 1。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hemiLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">HemisphereLight</span>(<span class="number">0x0000ff</span>, <span class="number">0x00ff00</span>, <span class="number">0.6</span>)</span><br><span class="line">hemiLight.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">500</span>, <span class="number">0</span>)</span><br><span class="line">scene.<span class="title function_">add</span>(hemiLight)</span><br></pre></td></tr></table></figure>
<h1 id="平面光光源（RectAreaLight）"><a href="#平面光光源（RectAreaLight）" class="headerlink" title="平面光光源（RectAreaLight）"></a>平面光光源（RectAreaLight）</h1><p>平面光光源从一个矩形平面上均匀地发射光线。这种光源可以用来模拟像明亮的窗户或者条状灯光光源。</p>
<p>注意事项:</p>
<ul>
<li>不支持阴影。</li>
<li>只支持<code>MeshStandardMaterial</code>和<code>MeshPhysicalMaterial</code>两种材质。</li>
<li>你必须在你的场景中加入<code>RectAreaLightUniformsLib</code>，并调用<code>init()</code>。</li>
</ul>
<h2 id="创建平面光"><a href="#创建平面光" class="headerlink" title="创建平面光"></a>创建平面光</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">RectAreaLight</span>( color : <span class="title class_">Integer</span>, intensity : <span class="title class_">Float</span>, width : <span class="title class_">Float</span>, height : <span class="title class_">Float</span> )</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>color</code>：(可选参数) 十六进制数字表示的光照颜色。缺省值为<code>0xffffff</code>。</li>
<li><code>intensity</code>：(可选参数) 光源强度／亮度。缺省值为 1。</li>
<li><code>width</code>：(可选参数) 光源宽度。缺省值为 10。</li>
<li><code>height</code>：(可选参数) 光源高度。缺省值为 10。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> areaLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">RectAreaLight</span>(<span class="number">0xff0000</span>, <span class="number">3</span>)</span><br><span class="line">areaLight.<span class="property">position</span>.<span class="title function_">set</span>(-<span class="number">10</span>, <span class="number">10</span>, -<span class="number">35</span>)</span><br><span class="line">areaLight.<span class="property">rotation</span>.<span class="title function_">set</span>(-<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">areaLight.<span class="property">width</span> = <span class="number">4</span></span><br><span class="line">areaLight.<span class="property">height</span> = <span class="number">9.9</span></span><br><span class="line">scene.<span class="title function_">add</span>(areaLight)</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/防火墙"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/"
    >防火墙</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/" class="article-date">
  <time datetime="2023-04-09T11:51:22.000Z" itemprop="datePublished">2023-04-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>防火墙是一种安全设备，保护一个网络区域免受另一个网络区域的攻击和入侵，通常被部署在网络边界，例如：企业互联网出口。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/1.png" class="">

<p>简单讲防火墙作为网络中的设备，它的作用也是对网络起到安全保护的作用，对进出网络的流量进行安全管理，保证内网的安全性。</p>
<h1 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h1><p>按照硬件形态，防火墙可以分为盒式防火墙、框式防护墙。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2.png" class="">

<p>按照软硬件区分：防火墙可以分为软件防火墙和硬件防火墙。软件防火墙又可分为个人防火墙和网关防火墙。</p>
<p>按照防火墙技术原理：防火墙可以分为包过滤防火墙、状态检测防火墙，AI 防火墙。</p>
<h2 id="软件防火墙"><a href="#软件防火墙" class="headerlink" title="软件防火墙"></a>软件防火墙</h2><h3 id="个人防火墙"><a href="#个人防火墙" class="headerlink" title="个人防火墙"></a>个人防火墙</h3><p>个人防火墙运行在 PC 上，用于监控 PC 和外网的通信信息。在 Windows 操作系统中集成了 Windows 防火墙。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-1.png" class="">

<p>杀毒软件产品厂家的个人防火墙一般包含在安全软件套件里。</p>
<table>
<thead>
<tr>
<th align="center">个人防火墙产品的功能</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">确认连接请求</td>
<td align="center">向用户确认是否阻止特定的连接请求</td>
</tr>
<tr>
<td align="center">安全日志</td>
<td align="center">根据需要生成安全日志，记录 PC 正常连接与错误连接的信息。在做故障分析时，日志起到了很大的作用</td>
</tr>
<tr>
<td align="center">反病毒功能</td>
<td align="center">阻止 PC 接收病毒和蠕虫信息</td>
</tr>
<tr>
<td align="center">反间谍功能</td>
<td align="center">阻止 PC 接收间谍软件或程序的通信</td>
</tr>
<tr>
<td align="center">个人信息保护功能</td>
<td align="center">设置保护策略，防止个人信息被窃取、浏览恶意网站以及钓鱼诈骗等</td>
</tr>
</tbody></table>
<h3 id="网关防火墙"><a href="#网关防火墙" class="headerlink" title="网关防火墙"></a>网关防火墙</h3><p>在网络中的网关上配置防火墙的功能，能对网络中的流量进行策略控制，这就是网关防火墙。</p>
<p>网关防火墙分为两种，一种是在 Windows、Linux 等操作系统上安装并运行防火墙软件的软件网关防火墙，另一种是使用专用设备的硬件网关防火墙。</p>
<p>个人防火墙主要监控 PC 的通信流量，网关防火墙是监控网络中所有终端的通信流量，在网关处进行策略控制。</p>
<table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">个人防火墙</th>
<th align="center">网关防火墙</th>
</tr>
</thead>
<tbody><tr>
<td align="center">安装位置</td>
<td align="center">用户的 PC 上</td>
<td align="center">Windows或Linux等服务器上</td>
</tr>
<tr>
<td align="center">网络中的位置</td>
<td align="center">终端</td>
<td align="center">网关</td>
</tr>
<tr>
<td align="center">安装监控对象</td>
<td align="center">流入终端的流量</td>
<td align="center">经过网关的流量</td>
</tr>
<tr>
<td align="center">加密通信</td>
<td align="center">在终端上解密后检查</td>
<td align="center">不能检查</td>
</tr>
<tr>
<td align="center">压缩文件检查</td>
<td align="center">解压后检查</td>
<td align="center">对解压方式、解压基本有限制</td>
</tr>
<tr>
<td align="center">口令文件检查</td>
<td align="center">输入口令后解压检查</td>
<td align="center">不能检查</td>
</tr>
</tbody></table>
<h2 id="硬件防火墙"><a href="#硬件防火墙" class="headerlink" title="硬件防火墙"></a>硬件防火墙</h2><p>通过硬件设备实现的防火墙叫做硬件防火墙，外形跟路由器相似，接口类型通常有千兆网口、万兆光口。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-2.png" class="">

<h1 id="防火墙技术类型"><a href="#防火墙技术类型" class="headerlink" title="防火墙技术类型"></a>防火墙技术类型</h1><p>防火墙在网络边界判断允许进行的通信和不允许的通信作为其判断依据的技术类型的演进：</p>
<ul>
<li>分组过滤型：没有防火墙设备时，可以由路由器实现。根据网络中的传输的 IP 分组头部和 TCP&#x2F;IP 分组头部，获得源 IP 地址和端口号、目的 IP 地址和端口号，以这些信息作为过滤条件，决定是否转发这个分组。分组过滤会用到访问控制列表。</li>
<li>应用网关型：不以分组为单位进行通信过滤，而是特定的应用程序会话。</li>
<li>电路层网关型：在传输层进行连接中继，也就是第四层代理，通过 SOCKS 协议实现。内网终端连接外部网络时，终端与网关建立 TCP 连接，网关和外部服务器建立新的 TCP 连接。使用电路层网关，不用设置安全认证端口和 NAT，就可以让私有地址的内网终端访问外部网络。</li>
<li>状态检测型：动态分组过滤的一种，通过检测 TCP 的连接状态阻挡来路不明的分组，简称 SPI。可以抵抗下面类型的攻击：伪装 IP 地址或端口，发送附带 TCP 的 RST 或 FIN 标志位的分组，随意终止正常通信的攻击；在允许通信的范围内发送附带 TCP 的 ACK 标志位的分组，从而入侵内部网络；在 FTP 通信时，无论是否建立控制连接，都会创建数据连接进而入侵内部网络</li>
<li>新一代防火墙：根据上面的所有信息执行安全策略来进行防御，不仅根据端口号或协议号识别应用程序，还根据 IP 地址识别用户信息</li>
</ul>
<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器是应用网关防火墙的一种。假设客户端和 HTTP 服务器通信时，客户端发送请求报文时，代理服务器会替代客户端向 HTTP 服务器发送请求；HTTP 服务器回复响应报文时，代理服务器会代替 HTTP 服务器向客户端回复。对于客户端来说，代理服务器就是 HTTP 服务器。客户端和代理服务器、代理服务器和 HTTP 服务器分别建立两个会话。</p>
<p>从客户端收到的请求报文、从服务器收到响应报文，代理服务器都会在应用层进行检查，如果有异常就放弃通信或发送出错信息。</p>
<p>由于代理服务器是会话的起点，对互联网的服务器来说，是看不到客户端的 IP 地址。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-3.png" class="">

<p>报文过滤防火墙是以 IP 或 TCP&#x2F;UDP 为对象，判断是否允许通信。而应用网关防火墙是以应用程序为对象，也就是将 FTP、HTTP、Telnet、DNS 等为对象进行判断。</p>
<h1 id="防火墙的接口模式"><a href="#防火墙的接口模式" class="headerlink" title="防火墙的接口模式"></a>防火墙的接口模式</h1><p>防火墙有四种接口模式，分别是 L3 模式、L2 模式、L1 模式和 TAP 模式。</p>
<table>
<thead>
<tr>
<th align="center">接口模式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">L3 模式</td>
<td align="center">也叫做 NAT 模式，和路由器接口一样，是拥有 IP 地址的接口。使用路由选择、NAT 以及连接 IPSec VPN 或 SSL VPN 时，必须使用 L3 模式接口。接口可配置静态 IP 地址，也可通过 PPPoE、DHCP动态获取 IP 地址</td>
</tr>
<tr>
<td align="center">L2 模式</td>
<td align="center">也叫做透传模式或透明模式，和交换机一样，是进行交接的接口。进行 IP 地址分配时，需要使用 VLAN</td>
</tr>
<tr>
<td align="center">L1 模式</td>
<td align="center">也叫做虚拟线缆模式。把两个接口组成一组，流量在一个接口输入，在另一个接口输出。这种模式下无法进行路由和桥接</td>
</tr>
<tr>
<td align="center">TAP 模式</td>
<td align="center">与交换机镜像端口连接的模式。对交换机的数据帧进行检测。由于不是串联，无法阻止非法通信</td>
</tr>
</tbody></table>
<p>L1 ~ L3 模式是将防火墙进行串连，TAP 模式是防火墙进行旁挂。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-4.png" class="">

<h1 id="防火墙能防范的威胁"><a href="#防火墙能防范的威胁" class="headerlink" title="防火墙能防范的威胁"></a>防火墙能防范的威胁</h1><ul>
<li>窃听：通过窃听网络数据获取银行卡号、密码等重要信息<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-5.png" class=""></li>
<li>篡改：将网站主页、邮件等通信内容恶意修改<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-6.png" class=""></li>
<li>破坏：通过电脑病毒或DoS攻击等破坏系统的正常工作<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-7.png" class=""></li>
<li>冒充：冒充他人发送邮件，对接收方进行钓鱼、诈骗等行为<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-8.png" class=""></li>
<li>信息泄露：电脑或服务器上的重要信息或文档泄露<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-9.png" class=""></li>
<li>攻击跳板：作为病毒部署或DoS攻击的跳板<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-10.png" class=""></li>
<li>垃圾邮件：以营利为目的发送大量邮件</li>
</ul>
<h1 id="防火墙功能"><a href="#防火墙功能" class="headerlink" title="防火墙功能"></a>防火墙功能</h1><p>防火墙常见的功能有：会话管理、报文结构解析、安全区域、安全策略、NAT、VPN、DoS 防御、报文攻击防御、内容扫描、监控和报告、报文抓包。</p>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>会话是两个终端系统之间的逻辑连接，从开始到结束的通信过程。</p>
<p>在 TCP 中，客户端和服务器通信，使用 3 次握手建立 1 个 TCP 连接，客户端发送请求（ request ），服务器进行回应（ response ），直至结束的过程就是进行了 1 个会话通信。</p>
<p>在 UDP 中，客户端和服务器的源端口和目的端口一致，之后的一系列通信都叫做会话。</p>
<p>在 ICMP 中，Echo request 和对应的 Echo reply 组成 1 个会话。</p>
<p>数据流是一组有序，有起点和终点的数据序列。一个会话有两个数据流（ flow ）：一个是 “ 客户端到服务器 ”（ client to server ），另一个是 “ 服务器到客户端 ”（ server to client ）。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-11.png" class="">

<h2 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h2><p>在数据通信前，客户端发送一个 SYN 包作为建立连接的请求。如果服务器发来回应，则认为可以开始数据通信。如果未收到服务器的回应，就不会进行数据通信。在通信结束时，会使用 FIN 包进行断开连接的处理。</p>
<p>SYN 包和 FIN 包是通过 TCP 头部的控制字段来管理 TCP 连接。一个连接的建立与断开，正常过程至少需要来回发送 7 个包才能完成。建立一个 TCP 连接需要发送 3 个包，这个过程叫作三次握手。断开一个 TCP 连接需要发送 4 个包，这个过程也称作四次挥手。创建一个 TCP 连接，会产生一个 32 位随机序列号，因为每一个新的连接使用一个新的随机序列号。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-12.png" class="">

<ul>
<li>SYN 检查<br>TCP 会话开始时，客户端会发送一个 SYN 消息。如果没有会话信息，或尚未建立会话，即非 SYN 消息的 TCP 数据段到达防火墙，防火墙会当做非法消息而丢弃。</li>
<li>ACK 检查<br>通过对 SYN-ACK 的 ACK 消息检查，确认进行中的 3 次握手是否是非法尝试，防范 SYN Flood 攻击。</li>
<li>重复数据段检查<br>防火墙收到重复数据段，也就是序列号相同的 TCP 数据段，可以选择接收或者丢弃。</li>
<li>窗口检查<br>防火墙可以检测 TCP 头部的序列号和滑动窗口大小，拦截超过滑动窗口容量数据的序列号。</li>
<li>数据段重组<br>防火墙可以验证 TCP 数据段序列号是否完整。</li>
</ul>
<h2 id="会话建立的处理"><a href="#会话建立的处理" class="headerlink" title="会话建立的处理"></a>会话建立的处理</h2><ol>
<li>防火墙收到报文后，首先检查会话表，确认是否有相同的会话。如果有相同会话，那么会禁止会话建立，确保会话都是唯一的。</li>
<li>如果是不同会话，那么检查报文，通常是查看路由表或 MAC 地址表来确定转发路径。如果可以转发，就确定对应的转发出接口和目的网段。如果不能转发，就丢弃这个数据。</li>
<li>报文检查目的地址是否需要进行 NAT。如果需要，就先完成 NAT，然后转发到相应出接口和目的网段。</li>
<li>对报文和目的信息进行安全策略检查，源信息是源接口、源区域和源地址，目的信息是目的接口、目的区域和目的地址。如果有匹配的安全策略，就根据策略进行处理，允许通信就进行转发，拒绝通信就进行丢弃。如果没有匹配的安全策略，就根据默认拒绝的策略丢弃数据。</li>
<li>当报文被允许通信时，防火墙的会话表中就会生成相应的会话信息。</li>
</ol>
<h2 id="会话的生存时间"><a href="#会话的生存时间" class="headerlink" title="会话的生存时间"></a>会话的生存时间</h2><p>自动生成的会话表信息，是有一定的生存时间。会话建立后，一段时间内一直没有进行通信，防火墙会删除生存时间到期的会话表项。如果长期保留会话表项，这些会话信息可能会被恶意攻击。同时，会话表是会占用防火墙资源，防火墙的会话表项的数量也是有限的，长期保留闲置的会话，会影响新会话的生成。</p>
<p>会话时间可以根据协议的不同，分别进行设置。</p>
<p>TCP 的话，会话的超时时间通常是 30 分钟到 1 小时，UDP 是 30 秒。比如，Telnet 连接在防火墙上建立会话后，如果在 1 个小时内没有任何数据通信，防火墙会自动删除这个会话表项。客户端无法再次使用这个 Telnet 会话了。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-13.png" class="">

<h2 id="会话终止处理"><a href="#会话终止处理" class="headerlink" title="会话终止处理"></a>会话终止处理</h2><p>客户端完成数据传输后，发送 FIN 消息，即使用 FIN 标志位的 TCP 数据段。</p>
<p>服务器收到 FIN 消息后，在回复消息中，使用 FIN 和 ACK 标志位，并将 ACK 编号设置为“接收的 Seq 编号 + 1 ” 。</p>
<p>客户端相同处理方式，在回复消息中，使用 ACK 标志位，并将 ACK 编号设置为“接收的 Seq 编号 + 1 ” 。</p>
<p>如果客户端或服务器在连接过程发生故障，只有一方是侦听状态，这叫做半侦听或半关闭。如果通信恢复，接收到故障前的数据段，那么会回复 RST 消息，强制终止 TCP 连接。</p>
<p>当防火墙收到 FIN 或 RST 消息时，会启动一个 30 秒的定时器。即使 FIN → FIN-ACK → ACK 的终止过程没完成，防火墙也会强制删除会话表项。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-14.png" class="">

<h2 id="UDP-数据流的管理"><a href="#UDP-数据流的管理" class="headerlink" title="UDP 数据流的管理"></a>UDP 数据流的管理</h2><p>UDP 不需要像 TCP 一样 3 次握手，客户端和服务器直接使用应用程序的 UDP 数据进行交互。</p>
<p>UDP 数据流是指源 IP 地址、源端口号、目的 IP 地址和目的端口号这 4 个参数都相同的一系列 UDP 数据。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-15.png" class="">

<p>DNS 和 SNMP 这类应用程序，只需要 1 个 UDP 数据，就能构成 1 个数据流。</p>
<p>音频和视频使用的 RTP，就需要多个 UDP 数据，来构成 1 个数据流。</p>
<h2 id="管理-ICMP-和-IP-数据流"><a href="#管理-ICMP-和-IP-数据流" class="headerlink" title="管理 ICMP 和 IP 数据流"></a>管理 ICMP 和 IP 数据流</h2><p>像 ICMP 这类没有端口号的协议，是直接根据 IP 头部的协议号来生成会话。</p>
<p>防火墙通过识别 ICMP 不同的请求消息和对应的响应消息，来判断这些消息序列是否属于同一个会话。</p>


<h2 id="会话同步"><a href="#会话同步" class="headerlink" title="会话同步"></a>会话同步</h2><p>通常两台防火墙会使用主备方式的冗余结构，对主防火墙和备防火墙的会话信息进行同步。主防火墙负责建立用户通信的会话，并把会话信息记录到会话表中，同时将信息转发到备防火墙。</p>
<h2 id="会话管理有什么防御功能？"><a href="#会话管理有什么防御功能？" class="headerlink" title="会话管理有什么防御功能？"></a>会话管理有什么防御功能？</h2><p>防火墙可以通过限制会话数量，能够防范 DoS 攻击，还能控制防火墙的负载，提高防火墙的性能。</p>
<p>防火墙可以以 TCP SYN 、UDP 、ICMP 等协议为单位，通过指定源与目的的组合方式，来限制这类会话的数目。</p>
<h3 id="分组结构解析"><a href="#分组结构解析" class="headerlink" title="分组结构解析"></a>分组结构解析</h3><p>为了防止非法报文的流入和流出，防火墙会对报文的头部和数据进行解析。常见的有：IP 头部解析、TCP 头部解析、UDP 头部解析。</p>
<h4 id="IP-头部解析"><a href="#IP-头部解析" class="headerlink" title="IP 头部解析"></a>IP 头部解析</h4><img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-17.png" class="">

<p>数据帧和 IPv4 头部的解析内容如下：</p>
<p>以太网类型与 IP 版本：以太网数据帧头部的类型字段为 0x0800 时表示 IPv4 ，同时 IPv4 头部的版本也是 4 。类型字段为 0x86DD 时表示 IPv6 ，IP 头部的版本也是 6 。</p>
<p>IP 头部：确认数据是否完整，并检查报文长度与实际长度是否一致。</p>
<p>IP 协议号、TTL ：检查字段值，如果值为 0 就丢弃报文。</p>
<p>源地址、目的地址：确认是否存在 LAND attack 。</p>
<p>数据总长度：确认是否存在 ping of death 攻击。</p>
<p>标志位、分片偏移：丢弃无法进行分片的报文。</p>
<p>可选项：丢弃无用可选项的报文。</p>
<h4 id="TCP-头部解析"><a href="#TCP-头部解析" class="headerlink" title="TCP 头部解析"></a>TCP 头部解析</h4><img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-18.png" class="">

<p>TCP 头部的解析内容如下：</p>
<p>TCP 头部：确认各个字段是否完整、是否有被中途截断。</p>
<p>数据偏移：确认数据偏移字段的值是否是 5 以下，TCP 头部长度最小是 5 字符 &#x3D; 20 字节。</p>
<p>校验和：确认校验和是否错误。</p>
<p>端口号：确认源端口号和目的端口号是否为 0 。</p>
<p>控制位：检查 SYN 、ACK 等字段是否存在组合不正确的情况。</p>
<h4 id="UDP-头部解析"><a href="#UDP-头部解析" class="headerlink" title="UDP 头部解析"></a>UDP 头部解析</h4><img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/2-19.png" class="">

<p>UDP 头部的解析内容如下：</p>
<p>UDP 头部：确认各个字段是否完整、是否有被中途截断。</p>
<p>校验和：确认校验和是否错误。</p>
<h1 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h1><p>防火墙有安全区域的概念。防火墙的物理接口和逻辑接口会分配到不同的区域中，也就是将防火墙的网段分别划分到不同的区域中。一个网络接口只能属于一个区域。</p>
<p>在同一个区域内，可以自由进行通信，但是跨区域通信，必须符合安全策略才行。当然，防火墙也可以设置安全策略，根据源或目的地址等条件，判断在同一区域内能否允许通信。</p>
<p>一个安全区域可以说就是若干个接口的集合，一个安全区域里面的接口具有相同的安全属性。</p>
<p>如下图所示：防火墙把不同的接口分成3个安全区域，出口区为<code>untrust</code>区域，内网区分为<code>trust</code>区和<code>DMZ</code>区。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/6.png" class="">

<h2 id="默认安全区域"><a href="#默认安全区域" class="headerlink" title="默认安全区域"></a>默认安全区域</h2><p>防火墙划分了 4 个默认的安全区域：</p>
<table>
<thead>
<tr>
<th align="center">安全区域</th>
<th align="center">说明</th>
<th align="center">优先级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">受信区域（<code>trust</code>）</td>
<td align="center">通常将内网终端用户所在区域划分为<code>trust</code>区域</td>
<td align="center">85</td>
</tr>
<tr>
<td align="center">非受信区域（<code>untrust</code>）</td>
<td align="center">通常将<code>Internet</code>等不安全的网络划分为<code>untrust</code>区域</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">非军事化区域（<code>dmz</code>）</td>
<td align="center">通常将内网服务器所在区域划分为<code>DMZ</code>区域</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">本地区域（<code>local</code>）</td>
<td align="center">设备本身，包括设备的各接口本身</td>
<td align="center">100</td>
</tr>
</tbody></table>
<p>默认的安全区域不能够删除，每个安全区域都设置了固定的优先级。优先级值越大，表示优先级越高。</p>
<p>除了这四个域之外，用户也可以根据自己的需求创建自定义域。自定义的域的优先级是可以自己调节的。</p>
<h1 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h1><p>防火墙的主要功能是访问控制，也就是判断特定源和特定目的之间是否允许进行特定的通信。访问控制是通过规则来实现，每一条规则都指定了源、目的和通信内容等信息。这些访问控制规则的集合，在路由器中，叫做访问控制列表，而在防火墙中，叫做安全策略或安全规则。</p>
<h2 id="什么是安全策略"><a href="#什么是安全策略" class="headerlink" title="什么是安全策略"></a>什么是安全策略</h2><p>安全策略是防火墙中对流量转发、以及对流量中的内容进行安全一体化检测的策略。</p>
<p>当防火墙收到流量后，会对流量的属性（包括五元组、用户、时间段等）进行识别，从而和安全策略进行匹配，如果能够匹配上，则执行相应的动作。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/8.png" class="">

<p>如上图所示：PC 访问<code>internet</code>，匹配到防火墙安全策略，动作为<code>permit</code>，因此流量可以通过防火墙。如果动作为<code>deny</code>，则流量不能够通过防火墙。</p>
<h2 id="防火墙的安全策略"><a href="#防火墙的安全策略" class="headerlink" title="防火墙的安全策略"></a>防火墙的安全策略</h2><p>防火墙的安全策略以区域作为对象，还可以以应用程序名称和用户名称等信息作为对象。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/21.png" class="">

<p>举个栗子：在上图的安全策略中，<code>192.168.2.1</code>从信任区域向不信任区域的 80 端口通信时，防火墙首先执行第 1 条安全策略，发现源地址不匹配，不执行<code>Allow</code>。接着执行第 2 条安全策略，发现地址和端口匹配，执行<code>Deny</code>，也就是拒绝通信。防火墙的安全策略从上往下依次执行的行为，也叫做安全策略查找（<code>policy lookup</code>）。</p>
<p><code>Any</code>表示任何值都与策略匹配。如果是安全策略中，出现未定义的通信，比如从信任区到 DMZ 区域的通信，防火墙默认执行拒绝，这个策略叫做 “ 默认拒绝 ”（<code>implicit deny</code>）。</p>
<p>如果需要在防火墙没有匹配的情况下，执行<code>Allow</code>，可以在安全策略的最后一行设置对象为<code>Any</code>，行为为<code>Allow</code>的策略。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/22.png" class="">

<p>当然，防火墙的安全策略是会有上限，上限由产品规格决定。而且当表项越多时，设备性能也会随之下降。</p>
<h2 id="安全策略组成"><a href="#安全策略组成" class="headerlink" title="安全策略组成"></a>安全策略组成</h2><p>安全策略由匹配条件、动作、安全配置文件组成。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/9.png" class="">

<ol>
<li>匹配条件：<br>匹配条件包括五元组（源地址、目的地址、源端口、目的端口、协议）、VLAN、源安全区域、目的安全区域、用户、时间段等。</li>
<li>动作：动作包括允许和禁止。<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/10.png" class="">
如果动作为“允许”：</li>
</ol>
<ul>
<li>如果没有配置内容安全检测，则允许流量通过。</li>
<li>如果配置内容安全检测，最终根据内容安全检测的结论来判断是否对流量进行放行。<br>禁止：表示拒绝符合条件的流量通过。</li>
<li>如果动作为“禁止”，防火墙不仅可以将报文丢弃；</li>
<li>还可以针对不同的报文类型选择发送对应的反馈报文。发起连接请求的客户端&#x2F;服务器收到防火墙发送的阻断报文后，可以快速结束会话并让用户感知到请求被阻断。</li>
</ul>
<ol start="3">
<li>安全配置文件：内容安全检测包括反病毒、入侵防御等，它是通过在安全策略中引用安全配置文件实现的。</li>
</ol>
<ul>
<li>如果其中一个安全配置文件阻断该流量，则防火墙阻断该流量。</li>
<li>如果所有的安全配置文件都允许该流量转发，则防火墙允许该流量转发。</li>
</ul>
<h2 id="安全策略匹配过程"><a href="#安全策略匹配过程" class="headerlink" title="安全策略匹配过程"></a>安全策略匹配过程</h2><p>防火墙的安全策略一般配置很多条，如果都可以匹配应该优先匹配哪一条呢?</p>
<p>安全策略的匹配按照策略列表顺序执行，从上往下逐条匹配，如果匹配了某条策略，将不再往下匹配。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/11.png" class="">

<p>因此，配置安全策略的顺序很重要，需要优先配置精确的安全策略，然后再配置粗略的安全策略。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/12.png" class="">

<p>系统默认存在一条缺省安全策略<code>default</code>。</p>
<p>缺省安全策略位于策略列表的最底部，优先级最低，所有匹配条件均为<code>any</code>，动作默认为禁止。如果所有配置的策略都未匹配，则将匹配缺省安全策略<code>default</code>。</p>
<h2 id="会话表"><a href="#会话表" class="headerlink" title="会话表"></a>会话表</h2><p>会话表用来记录 TCP、UDP、ICMP 等协议连接状态的表项，是防火墙转发报文的重要依据；</p>
<p>那么什么是基于连接状态转发报文呢？防火墙基于“状态”转发报文：</p>
<ol>
<li>只对首包或者少量报文进行检测然后确认一个连接状态；（会话表）</li>
<li>后续大量的报文根据连接状态进行控制；</li>
</ol>
<p>会话表就记录了大量的连接状态；这种机制大大的提升了防火墙的检测和转发效率。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/13.png" class="">

<p>如上图所示：客户端 PC1 访问服务器 PC2，PC1 向 PC2 发起 HTTP 连接；</p>
<ol>
<li>PC1发送报文；</li>
<li>首包达到防火墙，创建会话表项（如下）；防火墙会话表中标示出<code>http</code>协议和连接信息，并识别出此流量在公共路由表中被转发；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http VPN: public-&gt;public 192.168.1.254:10000-&gt;10.10.1.254:80</span><br></pre></td></tr></table></figure></li>
<li>防火墙放行报文；</li>
<li>PC2 回复报文；</li>
<li>回复报文匹配防火墙会话；</li>
<li>防火墙转发报文；</li>
</ol>
<h3 id="会话表的创建"><a href="#会话表的创建" class="headerlink" title="会话表的创建"></a>会话表的创建</h3><p>防火墙在开启状态检测情况下，只有首包会创建会话表项，后续报文匹配会话表即可转发。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/14.png" class="">

<h3 id="会话表老化时间"><a href="#会话表老化时间" class="headerlink" title="会话表老化时间"></a>会话表老化时间</h3><p>对于一个已经建立的会话表表项，只有当它不断被报文匹配才有存在的必要。如果长时间没有报文匹配，则说明可能通信双方已经断开了连接，不再需要该条会话表项了。</p>
<p>为了节约系统资源，系统会在一条表项连续未被匹配一段时间后，将其删除，即会话表项已经老化。</p>
<h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>对于某些特殊业务中，一条会话的两个连续报文可能间隔时间很长。</p>
<p>例如：</p>
<ul>
<li>用户通过 FTP 下载大文件，需要间隔很长时间才会在控制通道继续发送控制报文。</li>
<li>用户需要查询数据库服务器上的数据，这些查询操作的时间间隔远大于 TCP 的会话老化时间。</li>
</ul>
<p>如果只靠延长这些业务所属协议的老化时间来解决这个问题，会导致一些同样属于这个协议，但是其实并不需要这么长的老化时间的会话长时间不能得到老化。</p>
<p>这会导致系统资源被大量占用，性能下降，甚至无法再为其他业务建立会话。所以必须缩小延长老化时间的流量范围。</p>
<p>长连接功能可以解决这一问题。长连接功能可以为这些特殊流量设定超长的老化时间。</p>
<h2 id="Server-map"><a href="#Server-map" class="headerlink" title="Server-map"></a>Server-map</h2><h3 id="为什么会出现server-map表？"><a href="#为什么会出现server-map表？" class="headerlink" title="为什么会出现server-map表？"></a>为什么会出现server-map表？</h3><p>由于会话表对哪些报文属于同一条流量的标准过于严格，会导致一些特殊协议不能正确匹配会话表。</p>
<p>Server-map表可以解决这一问题。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/15.png" class="">

<p>例如使用 FTP 协议的<code>port</code>方式传输文件时：</p>
<ul>
<li>既需要客户端主动向服务器端发起控制连接；</li>
<li>又需要服务器端主动向客户端发起服务器数据连接；</li>
</ul>
<p>如果设备上配置的安全策略为允许单方向上报文主动通过，则 FTP 文件传输不能成功。</p>
<h3 id="server-map表原理"><a href="#server-map表原理" class="headerlink" title="server-map表原理"></a>server-map表原理</h3><p>通常情况下，如果在设备上配置严格的安全策略，那么设备将只允许内网用户单方向主动访问外网。</p>
<p>为了解决这一类问题，防火墙引入了<code>Server-map</code>表，<code>Server-map</code>用于存放一种映射关系。</p>
<ul>
<li>这种映射关系可以是控制数据协商出来的数据连接关系；</li>
<li>也可以是配置 NAT 中的地址映射关系；</li>
</ul>
<p>使得外部网络能透过设备主动访问内部网络。</p>
<p>生成<code>Server-map</code>表之后，如果一个数据连接匹配了<code>Server-map</code>表项，那么就能够被设备正常转发，并在匹配<code>Server-map</code>表后创建会话，保证后续报文能够按照会话表转发。</p>
<h3 id="server-map表报文转发过程"><a href="#server-map表报文转发过程" class="headerlink" title="server-map表报文转发过程"></a>server-map表报文转发过程</h3><p>防火墙收到报文后，如果没有命中会话表，防火墙则进入首包处理流程，查询是否命中<code>server-map</code>表。</p>
<ul>
<li>如果命中，则生成会话表，转发报文；</li>
<li>如果没有命中，则执行其他包处理流程。</li>
</ul>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/16.png" class="">

<h1 id="防火墙应用场景"><a href="#防火墙应用场景" class="headerlink" title="防火墙应用场景"></a>防火墙应用场景</h1><h3 id="1、企业边界防护"><a href="#1、企业边界防护" class="headerlink" title="1、企业边界防护"></a>1、企业边界防护</h3><p>如下图所示，企业内网业务部署在<code>trust</code>区，服务器部署在 DMZ。</p>
<ul>
<li>企业内网访问<code>internet</code>时经过防火墙，防火墙控制内外网流量，进行安全控制；</li>
<li>外网用户访问服务器时经过防火墙，对内网服务器进行保护；</li>
</ul>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/3.png" class="">

<h3 id="2、内网安全隔离"><a href="#2、内网安全隔离" class="headerlink" title="2、内网安全隔离"></a>2、内网安全隔离</h3><p>如下图所示：公司分为市场部、生产部，财经部，研发部，不同部分之间互访经过防火墙。通过防火墙进行安全控制。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/4.png" class="">

<h3 id="3、数据中心边界防护"><a href="#3、数据中心边界防护" class="headerlink" title="3、数据中心边界防护"></a>3、数据中心边界防护</h3><p>数据中心网络访问<code>internet</code>时，需要经过防火墙进行安全控制，对内网业务进行安全保护。</p>
<img src="/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%98%B2%E7%81%AB%E5%A2%99/5.png" class="">
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/二层交换机"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/"
    >二层交换机</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/" class="article-date">
  <time datetime="2023-04-06T12:46:11.000Z" itemprop="datePublished">2023-04-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="二层交换机的特点"><a href="#二层交换机的特点" class="headerlink" title="二层交换机的特点"></a>二层交换机的特点</h1><ul>
<li>二层交换机可以充当网桥，将计算机网络系统的各种终端设备连接在一个平台上。它们能够非常快速且有效地将数据从LAN 网络的源端传输到目标端。</li>
<li>二层交换机通过从交换机的地址表中学习目的节点的 MAC 地址，执行交换功能，将数据帧从源端重新排列到目的端。</li>
<li>MAC地址表为二层设备提供了唯一的地址，用于标识数据下发的终端设备和节点。</li>
<li>二层交换机将庞大复杂的 LAN 网络拆分为一个个小的 VLAN 网络。</li>
<li>通过在一个大型的 LAN 网络中配置多个 VLAN，在没有物理连接的情况下，交换变得更快。</li>
</ul>
<h1 id="二层交换机的应用"><a href="#二层交换机的应用" class="headerlink" title="二层交换机的应用"></a>二层交换机的应用</h1><ul>
<li>通过二层交换机，我们可以轻松地将位于同一 VLAN 内的数据帧从源端发送到目的端，而无需物理连接或位于同一位置。</li>
<li>因此，软件公司的服务器可以集中放置在一个位置，而分散在其他位置的客户端可以轻松访问数据而没有延迟，从而节省服务器成本和时间。</li>
<li>组织可以通过使用这些类型的交换机将主机配置在同一个 VLAN 中，而不需要任何互联网连接，从而实现内部通信。</li>
</ul>
<h1 id="交换机二层转发原理"><a href="#交换机二层转发原理" class="headerlink" title="交换机二层转发原理"></a>交换机二层转发原理</h1><p>交换机有多个网络端口，它通过识别数据帧的目标 MAC 地址，根据 MAC 地址表决定从哪个端口发送数据。MAC 地址表不需要在交换机上手工设置，而是可以自动生成的。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/4.png" class="">

<h2 id="交换机是如何添加、更新、删除-MAC-地址表条目的？"><a href="#交换机是如何添加、更新、删除-MAC-地址表条目的？" class="headerlink" title="交换机是如何添加、更新、删除 MAC 地址表条目的？"></a>交换机是如何添加、更新、删除 MAC 地址表条目的？</h2><p>在初始状态下，交换机的 MAC 地址表是空的，不包含任何条目。当交换机的某个端口接收到一个数据帧时，它就会将这个数据帧的源 MAC 地址、接收数据帧的端口号作为一个条目保存在自己的 MAC 地址表中，同时在接收到这个数据帧时重置这个条目的老化计时器时间。这就是交换机自动添加 MAC 地址表条目的方式。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/5.png" class="">

<p>在新增这一条 MAC 地址条目后，如果交换机再次从同一个端口收到相同 MAC 地址为源 MAC 地址的数据帧时，交换机就会更新这个条目的老化计时器，确保活跃的的条目不会老化。但是如果在老化时间内都没收到匹配这个条目的数据帧，交换机就会将这个老化的条目从自己的 MAC 地址表中删除。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/6.png" class="">

<p>还可以手动在交换机的 MAC 地址表中添加静态条目。静态添加的 MAC 地址条目优先动态学习的条目进行转发，而且静态条目没有老化时间，会一直保存在交换机的 MAC 地址表中。</p>
<h2 id="如何使用-MAC-地址表条目进行转发？"><a href="#如何使用-MAC-地址表条目进行转发？" class="headerlink" title="如何使用 MAC 地址表条目进行转发？"></a>如何使用 MAC 地址表条目进行转发？</h2><p>当交换机的某个端口收到一个单播数据帧时，它会查看这个数据帧的二层头部信息，并进行两个操作。一个操作是根据源 MAC 地址和端口信息添加或更新 MAC 地址表。另一个操作是查看数据帧的目的 MAC 地址，并根据数据帧的目的 MAC 地址查找自己的 MAC 地址表。在查找 MAC 地址表后，交换机会根据查找结果对数据帧进行处理，这里有 3 中情况：</p>
<ol>
<li>交换机没有在 MAC 地址表中找到这个数据帧的目的 MAC 地址，因此交换机不知道自己的端口是否有连接这个 MAC 地址的设备。于是，交换机将这个数据帧从除了接收端口之外的所有端口泛洪出去。<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/7.png" class=""></li>
<li>交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口不是接收到这个数据帧的端口，交换机知道目的设备连接在哪个端口上，因此交换机会根据 MAC 地址表中的条目将数据帧从对应端口单播转发出去，而其它与交换机相连的设备则不会收到这个数据帧。<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/8.png" class=""></li>
<li>交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口就是接收到这个数据帧的端口。这种情况下，交换机会认为数据帧的目的地址就在这个端口所连接的范围内，因此目的设备应该已经收到数据帧。这个数据帧与其它端口的设备无关，不会将数据帧从其它端口转发出去。于是，交换机会丢弃数据帧。</li>
</ol>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/9.png" class="">

<p>单播：主机一对一的发送数据。单播地址是主机的 MAC 地址。</p>
<p>广播：向局域网内所有设备发送数据。只有全 1 的 MAC 地址为广播 MAC 地址，即<code>FF-FF-FF-FF-FF-FF</code>。</p>
<p>泛洪：将某个端口收到的数据从除该端口之外的所有端口发送出去。泛洪操作广播的是普通数据帧而不是广播帧。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/10.png" class="">
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/11.png" class="">

<h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><h2 id="冲突和广播域"><a href="#冲突和广播域" class="headerlink" title="冲突和广播域"></a>冲突和广播域</h2><p>在二层交换中，当两个或多个主机试图在同一网络链路上以相同的时间间隔进行通信时，可能会发生冲突。当数据帧发生冲突，设备必须重新发送数据。冲突对网络性能有严重的负面影响，因此绝对要避免冲突。</p>
<p>广播是一种信息的传播方式，指网络中的某一设备同时向网络中所有的其他设备发送数据，这个数据所能广播到的范围即为广播域。简单点说，广播域就是指网络中所有能接收到同样广播消息的设备的集合。</p>
<p>使用一个或多个交换机组成的以太网，所有站点都在同一个广播域。随着交换机变多，这个广播域的范围也会变大，于是就会出现难以维护、广播风暴以及安全等问题。</p>
<p>一个主机想要获取另外一个网段的主机 MAC 地址，需要发送 ARP 广播请求获取对方主机的 MAC 地址。这个广播请求会广播到每一个主机身上，容易导致广播风暴。</p>
<p>在一个广播域内的任意两台主机之间可以任意通信，通信数据有被窃取的风险。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/12.png" class="">

<p>为了解决广播域扩大带来的性能问题和安全性降低问题， VLAN 技术应运而生。 VLAN 技术能够在逻辑上把一个物理局域网分隔为多个广播域，每个广播域称为一个虚拟局域网（即 VLAN）。每台主机只能属于一个 VLAN，同属一个 VLAN 的主机通过二层直接通信，属于不同 VLAN 的主机只能通过 IP 路由功能才能实现通信。通过划分多个 VLAN，从而减小广播域传播的范围，过滤多余的包，提高网络的传输效率，同时提高了网络的安全性。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/13.png" class="">

<h2 id="VLAN-原理"><a href="#VLAN-原理" class="headerlink" title="VLAN 原理"></a>VLAN 原理</h2><p>VLAN 技术通过给数据帧插入 VLAN 标签（又叫 VLAN TAG）的方式，让交换机能够分辨出各个数据帧所属的 VLAN。</p>
<p>VLAN 标签是用来区分数据帧所属 VLAN 的，是 4 个字节长度的字段，插入到以太网帧头部上。VLAN 标签会插入到源 MAC 地址后面，IEEE 802.1Q 标准有这个格式定义和字段构成说明。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/14.png" class="">

<ul>
<li>TPID（标签协议标识符）：长度 2 个字节，值为<code>0x8100</code>，用来表示这个数据帧携带了 802.1Q 标签。不支持 802.1Q 标准的设备收到这类数据帧，会把它丢弃。</li>
<li>TCI（标签控制信息）：长度 2 个字节，又分为三个子字段，用来表示数据帧的控制信息：</li>
<li>优先级：长度为 3 比特，取值范围 0 ~ 7，用来表示数据帧的优先级。取值越大，优先级越高。当交换机发送拥塞是，优先转发优先级高的数据帧。</li>
<li>CFI（规范格式指示器）：长度为 1 比特，取值非 0 即 1。</li>
<li>VLAN ID（VLAN 标识符）：长度为 12 比特，用来表示 VLAN 标签的数值。取值范围是 1 ~ 4094。</li>
</ul>
<h2 id="划分-VLAN-后，交换机如何处理广播报文？"><a href="#划分-VLAN-后，交换机如何处理广播报文？" class="headerlink" title="划分 VLAN 后，交换机如何处理广播报文？"></a>划分 VLAN 后，交换机如何处理广播报文？</h2><p>交换机上划分了多个 VLAN 时，在交换机接收到广播数据帧时，只会将这个数据帧在相同 VLAN 的端口进行广播。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/15.png" class="">

<h2 id="划分-VLAN-后，交换机如何处理目的-MAC-地址不在-MAC-地址表中的单播数据帧？"><a href="#划分-VLAN-后，交换机如何处理目的-MAC-地址不在-MAC-地址表中的单播数据帧？" class="headerlink" title="划分 VLAN 后，交换机如何处理目的 MAC 地址不在 MAC 地址表中的单播数据帧？"></a>划分 VLAN 后，交换机如何处理目的 MAC 地址不在 MAC 地址表中的单播数据帧？</h2><p>交换机上划分了多个 VLAN 时，当交换机接收到一个目的 MAC 地址不存在于自己 MAC 地址表中的单播数据帧时，只会将这个数据帧在相同 VLAN 的端口进行泛洪。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/16.png" class="">

<h2 id="划分-VLAN-后，不同-VLAN-的主机能否通信？"><a href="#划分-VLAN-后，不同-VLAN-的主机能否通信？" class="headerlink" title="划分 VLAN 后，不同 VLAN 的主机能否通信？"></a>划分 VLAN 后，不同 VLAN 的主机能否通信？</h2><p>划分多 VLAN 的环境中，即使交换机 MAC 地址表里保存了某个数据帧的目的 MAC 地址条目，若这个目的 MAC 地址所对应的端口与数据帧的入端口在不同的 VLAN 中，交换机也不会通过 MAC 地址表中的端口发送数据帧。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/17.png" class="">

<p>小结：在不使用路由转发的前提下，交换机不会从一个 VLAN 的端口中接收到的数据帧，转发给其它 VLAN 的端口。</p>
<h2 id="怎么区分不同的-VLAN-？"><a href="#怎么区分不同的-VLAN-？" class="headerlink" title="怎么区分不同的 VLAN ？"></a>怎么区分不同的 VLAN ？</h2><p>通过 VLAN ID 进行区分，例如 VLAN 10 和 VLAN 20 就是不同的 VLAN。</p>
<h2 id="VLAN-技术好处"><a href="#VLAN-技术好处" class="headerlink" title="VLAN 技术好处"></a>VLAN 技术好处</h2><ul>
<li>增加了广播域的数量，减小了每个广播域的规模，也减少了每个广播域中终端设备的数量；</li>
<li>增强了网络安全性，保障网络安全的方法增加了；</li>
<li>提高了网络设计的逻辑性，可以规避地理、物理等因素对于网络设计的限制。</li>
</ul>
<h2 id="划分-VLAN"><a href="#划分-VLAN" class="headerlink" title="划分 VLAN"></a>划分 VLAN</h2><p>我们可以使用不同的方法，把交换机上的每个端口划分到某个 VLAN 中，以此在逻辑上分隔广播域。</p>
<p>交换机通常会使用基于端口划分 VLAN 的方法。在交换机上手动配置，绑定交换机端口和 VLAN ID 的关系。</p>
<p>优点：配置简单。想要把某个端口划分到某个 VLAN 中，只需要把端口的 PVID （端口 VLAN ID）配置到相应的 VLAN ID 即可。</p>
<p>缺点：当终端设备移动位置是，可能需要为终端设备连接的新端口重新划分 VLAN。</p>
<p>除了这种方法外，还可以使用基于 MAC 地址划分 VLAN、基于 IP 地址划分 VLAN、基于协议划分 VLAN、基于策略划分 VLAN 等方法来划分 VLAN。</p>
<p>PVID：接口默认 VLAN ID，是交换机端口配置的参数，默认值是 1。</p>
<h2 id="跨交换机-VLAN-原理"><a href="#跨交换机-VLAN-原理" class="headerlink" title="跨交换机 VLAN 原理"></a>跨交换机 VLAN 原理</h2><p>终端设备不会生成带 VLAN 标签的数据帧，它们发出的数据帧叫做无标记帧（<code>Untagged</code>）。它们连接的交换机会给无标记帧打上 VLAN 标签。交换机通过每个端口的 PVID，判断从这个接口收到的无标记帧属于哪个 VLAN，并在转发时，插入相应的 VLAN 标签，从而将无标记帧变为标记帧（<code>Tagged</code>）。</p>
<p>当两台交换机通过端口连接时，收到的数据帧是标记帧还是无标记帧？交换机端口会如何处理呢？</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/18.png" class="">

<p>交换机根据连接的设备类型，判断各个接口收到的数据帧是否打标，来配置交换机接口的类型。</p>
<ul>
<li>如果交换机接口收到无标记帧，由交换机根据这个接口所在 VLAN 为数据帧打上 VLAN 标签；同时接口发送数据帧时，也不携带 VLAN 标签。应该把这类接口配置为<code>Access</code>（接入）接口，<code>Access</code>接口连接的链路称为<code>Access</code>链路。</li>
<li>如果交换机接口收到多个 VLAN 的流量，也就是收到了标记帧；同时为了让对端设备能够区分不同 VLAN 的流量，通过接口发出的流量会打上 VLAN 标签。应该把这类接口配置为<code>Trunk</code>（干道）接口，相应的链路称为<code>Trunk</code>链路。</li>
</ul>
<h2 id="跨交换机发送数据"><a href="#跨交换机发送数据" class="headerlink" title="跨交换机发送数据"></a>跨交换机发送数据</h2><img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/19.png" class="">

<p>主机 A 以主机 F 的 MAC 地址作为目的 MAC 地址封装了一个数据帧，从网卡发送出去。</p>
<p>交换机 A 在<code>Access</code>接口收到数据帧。查询 MAC 地址表，发现数据帧的目的地址是与交换机 B 相连的<code>Trunk</code>接口。于是交换机给数据帧打上<code>Access</code>接口的 PVID 配置，即给数据帧打上 VLAN 10 的标签，并从<code>Trunk</code>接口转发给交换机 B。</p>
<p>交换机 B 在<code>trunk</code>接口收到数据帧。查看 MAC 地址表，发现是 VLAN 10 的数据帧，目的地址设备是连接在 VLAN 10 的一个<code>Access</code>接口上。于是去掉数据帧的 VLAN 标签，并从这个<code>Access</code>接口转发给主机 F。</p>
<h1 id="模拟实验"><a href="#模拟实验" class="headerlink" title="模拟实验"></a>模拟实验</h1><h2 id="Access-接口和-Trunk-接口的配置"><a href="#Access-接口和-Trunk-接口的配置" class="headerlink" title="Access 接口和 Trunk 接口的配置"></a>Access 接口和 Trunk 接口的配置</h2><h3 id="实验拓扑图"><a href="#实验拓扑图" class="headerlink" title="实验拓扑图"></a>实验拓扑图</h3><img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/20.png" class="">

<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ul>
<li>将 SW1（即交换机 1）和 SW2（即交换机 2）相连的接口配置为<code>Trunk</code>接口，允许传输 VLAN 5 的数据；</li>
<li>将 PC（即主机）与 SW 相连接口配置为<code>Access</code>接口，接口的 PVID 配置为 VLAN 5。</li>
</ul>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>SW 1 上的配置如下：</p>


<p>检查 SW1 的接口配置，使用命令<code>display vlan</code>查看接口 VLAN 情况。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/22.png" class="">

<h2 id="Hybrid-接口的配置"><a href="#Hybrid-接口的配置" class="headerlink" title="Hybrid 接口的配置"></a>Hybrid 接口的配置</h2><p>三种接口类型特点：</p>
<ul>
<li><code>Access</code>接口：这种接口只能属于一个 VLAN，只能接收和发送一个 VLAN 的数据。通常用于连接终端设备，比如主机或服务器等。</li>
<li><code>Trunk</code>接口：这种接口能够接收和发送多个 VLAN 的数据，通常用于连接交换机。</li>
<li><code>Hybrid</code>接口：这种接口能够接收和发送多个 VLAN 的数据，可用于交换机的链路，也可用于终端设备。与<code>Trunk</code>接口的区别是，发送数据时<code>Trunk</code>接口只会摘掉 PVID 标签，而<code>Hybrid</code>接口能够不携带 VLAN 标签发送多个 VLAN 数据。</li>
</ul>
<h3 id="实验拓扑图-1"><a href="#实验拓扑图-1" class="headerlink" title="实验拓扑图"></a>实验拓扑图</h3><img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/23.png" class="">

<h3 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h3><p>新建 3 个 VLAN，PC1 属于 VLAN 2，PC2 属于 VLAN 3，Server 1（即服务器 1）属于 VLAN 10；</p>
<p>通过<code>Hybrid</code>接口实现 VLAN 2 和 VLAN 3 不能互通，但 VLAN 2 和 VLAN 3 都能与 VLAN 10 进行通信。</p>
<h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>SW1 的<code>E0/0/2</code>接口，只允许通过 VLAN 2，PC1 又需要访问 VLAN 10，但是无法识别 VLAN 标签信息，因此配置<code>Hybrid</code>的 PVID 为 VLAN 2，同时放通 VLAN 2 和 VLAN 10。<code>E0/0/3</code>接口配置同理。<code>E0/0/1</code>接口需要放通 VLAN 2、VLAN 3 和 VLAN 10 的流量，对端交换机又需要识别 VLAN 标签，因此以带 VLAN 标签的形式放通 VLAN 2、VLAN 3 和 VLAN 10 的流量。SW1 上的配置如下：</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/24.png" class="">

<p>SW2 的<code>E0/0/1</code>接口配置和 SW1 的 E0&#x2F;0&#x2F;1 接口同理。SW2 的<code>E0/0/10</code>接口，只允许通过 VLAN 10，Server1 又需要放通 VLAN 2 和 VLAN 3 的流量，因此配置<code>Hybrid</code>的 PVID 为 VLAN 10，同时放通 VLAN 2、VLAN 3 和 VLAN 10。SW2 上的配置如下：</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/25.png" class="">

<p>检查 VLAN 10 信息，分别在 SW1 和 SW2 上使用命令<code>display vlan 10</code>查看配置是否正确。</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/26.png" class="">
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/27.png" class="">

<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p><code>Access</code>接口接收数据帧处理过程：</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/28.png" class="">

<p><code>Access</code>接口发送数据帧处理过程：</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/29.png" class="">

<p><code>Trunk</code>接口接收数据帧处理过程：</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/30.png" class="">

<p><code>Trunk</code>接口发送数据帧处理过程：</p>
<img src="/2023/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/31.png" class=""> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/交换机基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/"
    >交换机基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2023-03-26T11:36:11.000Z" itemprop="datePublished">2023-03-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="常见网络设备"><a href="#常见网络设备" class="headerlink" title="常见网络设备"></a>常见网络设备</h1><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p>中继器（<code>repeater</code>）是一种信号增强设备，运行在 OSI 参考模型的第一层。它的功能仅仅是将信号重新输出，延迟网络的传输距离，不进行其它的数据控制，也无法识别数据链路层的 MAC 地址和网络层的 IP 地址。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/1.png" class="">

<h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>网桥（<code>bridge</code>）是具有两个端口的二层网络设备，可隔离冲突域。作用相当于 OSI 模型中的数据链路层，能够根据 MAC 地址进行数据转发。只能连接同构网络(同一网段)，不能连接异构网络（不同网段）。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/2.png" class="">

<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>集线器（<code>hub</code>）是工作在物理层、具有信号放大功能、以它为中心的网络设备。即一个多端口的中继器，以集线器为中心，连接多个节点。广播方式发送数据，也就是说，当它要发送数据时，会发送到与集线器相连的所有节点。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/3.png" class="">

<p>由于集线器没有控制功能，因此所有终端共享带宽，同一时刻只能一个终端发送数据，多个终端同时发送数据就会产生冲突。这时，集线器、连接线缆以及连接在集线器上的终端设备构成了一个冲突域。于是采用 CSMA&#x2F;CD 方式决定终端能否发送数据。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>集线器是从接收方收到的数据，会转发给所有非发送方端口，也就是简单的通过复制电气信号来实现发送。</p>
<p>但是交换机是通过学习连接的每个终端的 MAC 地址，将数据发送给对应的目的终端上，避免将数据发送到无关端口，提供网络利用率。这里说的交换机都是二层交换机。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/4.png" class="">

<p>如果是没有学习到的 MAC 地址，或者想跟网段内所有终端进行通信，交换机会使用广播方式，将数据帧进行泛洪。</p>
<h2 id="对比集线器，交换机有哪些优点"><a href="#对比集线器，交换机有哪些优点" class="headerlink" title="对比集线器，交换机有哪些优点"></a>对比集线器，交换机有哪些优点</h2><table>
<thead>
<tr>
<th align="center">优点</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">隔离冲突域</td>
<td align="center">冲突域只在交换机端口和主机之间</td>
</tr>
<tr>
<td align="center">全双工通信</td>
<td align="center">冲突域没有其它主机，主机能够同时发送和接收数据帧</td>
</tr>
<tr>
<td align="center">丢弃错误帧</td>
<td align="center">交换机能够检测数据帧是否有错误，并丢弃错误的数据帧</td>
</tr>
<tr>
<td align="center">独享带宽</td>
<td align="center">发送和接收分别是不同的交换机端口，每个端口独享带宽</td>
</tr>
</tbody></table>
<h1 id="交换机如何转发数据帧"><a href="#交换机如何转发数据帧" class="headerlink" title="交换机如何转发数据帧"></a>交换机如何转发数据帧</h1><p>交换机收到数据帧后，会有三种处理方法：直通转发、碎片隔离和存储转发。</p>
<h2 id="直通转发"><a href="#直通转发" class="headerlink" title="直通转发"></a>直通转发</h2><p>直通转发是交换机只读取数据帧的前 14 个字节就进行转发。由于读取的数据量固定，发送方和接收方的速度需要一致，导致无法桥接不同速率的以太网。另外，只读取前 14 个字节，会跳过了 FCS 域，因此无法检测并丢弃 CRC 校验错误的数据帧。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/5.png" class="">

<h2 id="碎片隔离"><a href="#碎片隔离" class="headerlink" title="碎片隔离"></a>碎片隔离</h2><p>碎片隔离是读取数据帧的前 64 个字节就进行转发，可以防止转发小于 64 字节的残帧。但是如果出现 CRC 错误，还是会转发数据帧。也无法桥接不同速率的以太网。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/6.png" class="">

<h2 id="存储转发"><a href="#存储转发" class="headerlink" title="存储转发"></a>存储转发</h2><p>存在转发会读取数据帧全部内容再进行转发。这样就可以识别残帧和 CRC 校验错误帧，并将它们丢弃。交换机还能对数据帧进行缓存，因此可以桥接不同速率的以太网。</p>
<table>
<thead>
<tr>
<th align="center">转发方式</th>
<th align="center">读取字节数</th>
<th align="center">通信时延</th>
<th align="center">丢弃错误数据帧</th>
</tr>
</thead>
<tbody><tr>
<td align="center">直通转发</td>
<td align="center">14字节</td>
<td align="center">最短</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">碎片隔离</td>
<td align="center">64字节</td>
<td align="center">短</td>
<td align="center">只丢弃残帧</td>
</tr>
<tr>
<td align="center">存储转发</td>
<td align="center">全部</td>
<td align="center">最长</td>
<td align="center">全部</td>
</tr>
</tbody></table>
<h1 id="交换机功能"><a href="#交换机功能" class="headerlink" title="交换机功能"></a>交换机功能</h1><h2 id="MAC-地址数"><a href="#MAC-地址数" class="headerlink" title="MAC 地址数"></a>MAC 地址数</h2><p>MAC 地址数是指一台交换机最大可以学习到的 MAC 地址表数量。</p>
<h2 id="生成树功能"><a href="#生成树功能" class="headerlink" title="生成树功能"></a>生成树功能</h2><p>为了避免二层环路，我们使用生成树协议（STP），让交换机知道对方的存在，具体做法是在交换机之间交换 BPDU 数据帧。</p>
<h2 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h2><p>链路聚合是将交换机的多条线路汇聚成一条逻辑线路在网络中使用。有多个称呼：端口聚合、链路捆绑、绑定等。</p>
<p>如果不使用链路聚合功能，直接将交换机的多个物理端口连接起来，可能会导致网络环路。如果使用生成树协议，又会避开某些链路，导致只有一条物理链路可用。如果使用链路聚合，把几条物理链路聚合成一条逻辑链路，即使某一条物理链路断开，由于逻辑线路还有其它物理链路在维持，因此通信也不会中断，到达线路冗余的效果。</p>
<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>将广播域分割成一个个逻辑网段的功能叫做 VLAN。</p>
<h2 id="端口镜像"><a href="#端口镜像" class="headerlink" title="端口镜像"></a>端口镜像</h2><p>将某个端口接收和发送的数据帧复制到镜像端口的功能叫做端口镜像，被复制的源端口叫做监控端口。</p>
<p>为了分析网络故障或检测网络中的流量，交换机会将收到的数据帧复制一份并转发到网络分析设备或流量监控设备中。</p>
<h2 id="QoS-优先级队列"><a href="#QoS-优先级队列" class="headerlink" title="QoS 优先级队列"></a>QoS 优先级队列</h2><p>QoS 是<code>Quality of Service</code>的缩写，也叫做服务质量。当数据通过网络设备时，根据通信种类控制通信优先级和带宽的功能。通常是将声音、视频等数据定义为高优先级，高优先数据优先处理，保障这类数据的稳定和低延迟。</p>
<p>除了交换机在二层进行的 QoS 控制外，还有路由器和三层交换机的三层（IP）的 QoS 控制，以及 TCP 进行的四层的 QoS 控制。</p>
<p>IEEE 802.1p 标准完成了对二层的 QoS 优先级控制的标准化工作。通过 3bit 长度的优先级控制信息，定义了从 0 到 7 的 8 个优先级，即 CoS 值（服务等级值），交换机会优先转发值大的数据帧。</p>
<h2 id="MAC-地址过滤"><a href="#MAC-地址过滤" class="headerlink" title="MAC 地址过滤"></a>MAC 地址过滤</h2><p>为了网络安全，只让指定的设备接入网络。二层交换机提供了以数据帧的头部信息进行过滤的功能。具体过程是，先设置一个过滤条件，比如目的 MAC 地址、源 MAC 地址等，满足条件的数据帧通过，阻断不满足条件的数据帧。</p>
<p>考虑到伪造 MAC 地址的情况发生，还可以跟 802.1X 一起使用。三层交换机或路由器可以根据 IP 头部信息完成 IP 通信过滤的功能。</p>
<h2 id="基于端口的认证"><a href="#基于端口的认证" class="headerlink" title="基于端口的认证"></a>基于端口的认证</h2><p>在交换机中，只有通过认证的客户端才能使用有线端口。这个功能由 IEEE 802.1X 完成标准化，对接入 LAN 的客户端进行认证的机制。</p>
<p>当 PC 连接交换机时，认证过程启动。根据发送方的 MAC 地址信息进行客户端识别，通过用户名、口令或证书等认证信息进行用户认证。对于没有认证的客户端发来的数据帧，交换机只接收包含认证信息的数据帧，其余的全部丢弃。对于认证失败的客户端发来的数据帧，交换机就直接丢弃不会进行转发。</p>
<p>要使用基于端口的认证功能，客户端的电脑和交换机都要支持 802.1X 认证功能，缺一不可。</p>
<p>802.1X 认证中使用 PPP 的扩展协议 EAP，通过 EAPOL 协议封装 EAP 认证消息，然后在 LAN 中进行传输。认证结束之前，客户端电脑只能进行 EAPOL 通信。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/7.png" class="">
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>远程管理、监控和配置网络设备可以使用 SNMP 协议。SNMP 协议可以对整个网络结构内的交换机和其它网络设备进行集中统一的管理。</p>
<p>被 SNMP 管理的网络设备叫做<code>Agent</code>，管理网络的设备叫做<code>Manager</code>。</p>
<h1 id="交换机的架构"><a href="#交换机的架构" class="headerlink" title="交换机的架构"></a>交换机的架构</h1><p>交换机的基本架构是由 RJ-45 接口、PHY 、MAC 等模块的 NIC 和管理由 NIC 收发帧缓存、转发表的软件组成，通过查看转发表信息，在 NIC 之间进行数据帧交互。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/8.png" class="">

<h1 id="交换机分类"><a href="#交换机分类" class="headerlink" title="交换机分类"></a>交换机分类</h1><h2 id="根据功能分类"><a href="#根据功能分类" class="headerlink" title="根据功能分类"></a>根据功能分类</h2><p>交换机按照功能可以分为二层交换机和三层交换机。</p>
<ul>
<li>二层交换机：没有 IP 路由功能、仅处理数据链路层的交换机叫做二层交换机。</li>
<li>三层交换机：带有 IP 路由功能的交换机叫做三层交换机，但它是二者的有机结合，并不是简单地把路由器设备的硬件及软件叠加在局域网交换机上。三层交换机工作在网络层，可以处理数据包。</li>
</ul>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/8-1.png" class="">
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/8-2.png" class="">

<h2 id="根据外形分类"><a href="#根据外形分类" class="headerlink" title="根据外形分类"></a>根据外形分类</h2><p>根据外形，交换机可分为桌面式交换机、箱式交换机和机框式交换机。</p>
<h3 id="桌面式交换机"><a href="#桌面式交换机" class="headerlink" title="桌面式交换机"></a>桌面式交换机</h3><p>桌面式交换机是指放在桌面上使用的交换机。它体积不大，只能连接几台网络设备，通常用于家庭网络中，主要有 3 端口、5 端口、8 端口和 16 端口的产品。</p>
<p>桌面式交换机通常不安装风扇，采用无风扇设计，运行噪声小。</p>
<h3 id="箱式交换机"><a href="#箱式交换机" class="headerlink" title="箱式交换机"></a>箱式交换机</h3><p>箱式交换机通常高度是 1U 或 2U，可以安装在 19 英寸的机柜内。通常采用金属外壳、内置电源，并配置冷却风扇。下行有 24 千兆网口或 48 千兆网口，上行有 2 万兆光口或 4 万兆光口的配置较多。下行使用 RJ-45 的网线接口，上行使用 SFP+ 槽进行连接。</p>
<p>主要作为企业中作为接入交换机使用，支持电源冗余。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/9.png" class="">

<h3 id="框式交换机"><a href="#框式交换机" class="headerlink" title="框式交换机"></a>框式交换机</h3><p>框式交换机是指在机框内组合多个接口模块的交换机。可以根据需要选择端口数量和不同类型的接口模块，扩展性好，端口数量多。</p>
<p>在机框中可以添加电源、风扇等组成部分，再插入管理模块和接口模块。接口模块和管理模块叫做线卡。机框上总线的主板叫做背板，可以插入线卡。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/10.png" class="">

<h2 id="根据用途分类"><a href="#根据用途分类" class="headerlink" title="根据用途分类"></a>根据用途分类</h2><p>根据交换机在网络中的位置和用途，可分为三类：核心交换机（核心层）、汇聚交换机（汇聚层）和接入交换机（接入层）。</p>
<p>核心交换机不是某种网络交换机，它是指位于网络主干或物理核心的数据交换机，因此，它必须是一个大容量的交换机，以作为通往广域网（WAN）或互联网的网关，总之，它为网络提供了最终的聚合点，并允许各种聚合模块协同工作。</p>
<p>汇聚交换机位于汇聚层，向上连接核心交换机，向下连接到接入交换机，也称为分布交换机，作为核心层交换机和接入层交换机之间的桥梁。</p>
<p>此外，汇聚交换机确保数据包在企业网络中的子网和 VLAN 之间正确路由。</p>
<p>接入交换机一般位于接入层，用于将大多数设备连接到网络，因此通常具有高密度端口，它是最常用的千兆以太网交换机，直接与公共互联网通信，主要用于办公室、小型服务器机房和媒体制作中心，托管和非托管交换机都可以部署为接入层交换机。</p>
<p>交换机可以共存于同一网络中，并相互协调以实现不受限制的网络速度，每个层交换机执行自己的职责。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">核心交换机</td>
<td align="center">当网络分布在多个大楼时，各个大楼的汇聚交换机通过大楼间的核心交换机完成高速交换，通常使用三层交换机</td>
</tr>
<tr>
<td align="center">汇聚交换机</td>
<td align="center">汇聚交换机将接入交换机按照楼层为单位进行集中，使用三层交换机完成 VLAN 间的交换，有时会省去这一层，仅使用核心层和接入层搭建网络</td>
</tr>
<tr>
<td align="center">接入交换机</td>
<td align="center">直接连接用户的电脑、话机等终端的交换机，通常部署在各个楼层中</td>
</tr>
</tbody></table>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/11.png" class="">

<h1 id="交换机端口类型"><a href="#交换机端口类型" class="headerlink" title="交换机端口类型"></a>交换机端口类型</h1><h2 id="千兆以太网端口"><a href="#千兆以太网端口" class="headerlink" title="千兆以太网端口"></a>千兆以太网端口</h2><p>大部分交换机都配置了 RJ-45 的千兆以太网接口，连接千兆接口要使用增强型 5 类双绞线。通过自适应功能，还可以连接百兆接口。</p>
<h2 id="光纤端口"><a href="#光纤端口" class="headerlink" title="光纤端口"></a>光纤端口</h2><p>箱式交换机会配置光纤端口，主要是用于连接上行链路。为了连接万兆以太网的上行链路，通常会搭载 SFP+ 接口。</p>
<p>框式交换机中，一般会配置多个千兆以太网 SFP 或万兆以太网 SFP+ 接口的接口卡。</p>
<h2 id="PoE-端口"><a href="#PoE-端口" class="headerlink" title="PoE 端口"></a>PoE 端口</h2><p>接入交换机还会配 PoE 端口。PoE 端口使用网线连接 IP 电话或无线 AP，并通过网线对设备进行供电。</p>
<p>为了让 IP 电话或无线 AP 无需外接电源也能接入网络，通过一根网线给设备供电的技术就是 PoE 技术。</p>
<h2 id="上行链路端口"><a href="#上行链路端口" class="headerlink" title="上行链路端口"></a>上行链路端口</h2><p>接入交换机和汇聚交换机要集中下行连接的所有设备流量，并将流量传输到上行的网关或核心交换机中，向网关、核心交换机传输流量的端口叫做上行链路端口，反向就叫做下行链路端口。在箱式交换机中一般会配置 2~4 个万兆上行链路端口。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/12.png" class="">

<h2 id="下行链路端口"><a href="#下行链路端口" class="headerlink" title="下行链路端口"></a>下行链路端口</h2><p>通常下行链路是 RJ-45 的接口，也有使用光纤接口的。一台交换机或一块板块，能提供 24 或 48 个接口。</p>
<img src="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/13.png" class="">

<h1 id="交换机的处理能力的指标"><a href="#交换机的处理能力的指标" class="headerlink" title="交换机的处理能力的指标"></a>交换机的处理能力的指标</h1><p>交换机的处理能力也叫做背板容量或交换机容量。容量单位是<code>bit/s</code>（比特每秒），值越大，说明交换机在单位时间内传输的数据越多。</p>
<p>当交换机的所有端口的总带宽小于交换机的容量时，交换结构为非阻塞，即带宽充裕，没有等待处理的情况。反之，当所有端口总带宽超过交换机的容量时，叫做交换机结构过载。</p>
<p>交换机是千兆端口时，处理能力达到端口数 × 2 × <code>1Gbit/s</code>的数值，就是非阻塞。其中<code>×2</code>表示上行和下行都是<code>1Gbit/s</code>的全双工通信。假如交换机有 24 个端口，背板容量到达<code>24 × 2 × 1G = 48Gbit/s</code>，就是非阻塞。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/OSPF详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/"
    >OSPF详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2023-03-22T12:36:11.000Z" itemprop="datePublished">2023-03-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="RIP-缺陷"><a href="#RIP-缺陷" class="headerlink" title="RIP 缺陷"></a>RIP 缺陷</h1><p>提及 OSFP 时，还得先从 RIP 说起。</p>
<p>RIP 以跳数来计算到达目的网络的最优路径，在实际应用时并不合适，以网络带宽和链路时延来衡量网络质量会更合理。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>RIP 支持的最大跳数是 16，无法用于搭建大规模的网络。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/2.png" class="">

<p>RIP 的收敛速度慢，RIP 会对不可达路由的信息更新进行抑制，原路由失效，新路由要等到抑制时间结束后，才能更新。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/3.png" class="">

<p>RIP 的更新周期长，一个路由器突然离线，其它路由器要很长时间才能发现。</p>
<p>RIP 使用广播发送全部路由信息，网络规模越大，路由信息占用的网络资源也越大。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/4.png" class="">

<p>因此，RIP 路由并不适合大规模的网络，而 OSPF 协议解决了这些问题，得到了广泛的使用。</p>
<h1 id="OSPF-原理"><a href="#OSPF-原理" class="headerlink" title="OSPF 原理"></a>OSPF 原理</h1><p>OSPF，是<code>Open Shortest Path First</code>的缩写，译为开放最短路径优先。OSPF 是基于链路状态（<code>Link State</code>）的自治系统内部路由协议，用来替代 RIP 协议，通用的是 OSPFv2。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/5.png" class="">

<p>与距离矢量协议不同，链路状态协议使用最短路径优先算法（<code>Shortest Path First，SPF</code>）计算和选择路由。这类路由协议关系网络链路或接口的状态，比如 up、down、IP 地址、掩码、带宽、利用率和时延等。每台路由器将已知的链路状态向其它路由器通告，让网络上每台路由器对网络结构有相同的了解。然后，路由器以此为依据，使用 SPF 算法计算和选择路由。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/6.png" class="">

<p>OSPF 协议使用组播发送协议包，节约资源，又减少对其它网络设备的干扰。</p>
<p>OSPF 将协议包封装在 IP 包中，协议号 89。由于 IP 协议是无连接的，OSPF 定义了一些机制保证协议包安全可靠的传输。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/7.png" class="">

<p>总之，OSPF 协议比 RIP 有更大的扩展、快速收敛和安全可靠等特性，采用路由增量更新保证路由同步，减少对网络资源的浪费。</p>
<h1 id="OSPF-协议简介"><a href="#OSPF-协议简介" class="headerlink" title="OSPF 协议简介"></a>OSPF 协议简介</h1><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/8.png" class="">

<p>OSPF 协议有四个主要过程：</p>
<ul>
<li>寻找邻居<br>OSPF 协议启动后，先寻找网络中的邻居，也就是通过<code>Hello</code>报文确认可以双向通信。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/9.png" class=""></li>
<li>建立邻接关系<br>一部分路由器形成邻居关系后，就开始进行建立邻接关系。建立了邻居关系的路由器才能互相传递链路状态信息。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/10.png" class=""></li>
<li>链路状态信息同步<br>建立邻接关系的 OSPF 路由器在网络中交互 LSA（链路状态通告），最后形成包含网络完整链路状态信息的 LSDB（链路状态数据库）。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/11.png" class=""></li>
<li>计算路由<br>LSDB 同步完成后，OSPF 区域内的每个路由器对网络结构有相同的认识，邻居路由器之间形成完全的邻接关系。然后，每台路由器根据 LSDB 的信息使用 SPF（最短路径优先）算法独立计算出路由。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/12.png" class=""></li>
</ul>
<h1 id="OSPF-协议过程"><a href="#OSPF-协议过程" class="headerlink" title="OSPF 协议过程"></a>OSPF 协议过程</h1><p>将 OSPF 的四个过程展开来讲，就是一个个邻居状态的切换，不同的邻居状态有不同的行为。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/13.png" class="">

<h3 id="Down（失效）"><a href="#Down（失效）" class="headerlink" title="Down（失效）"></a>Down（失效）</h3><p>OSPF 邻居的初始状态，表示接口没有收到邻居发来的<code>Hello</code>报文。</p>
<h3 id="Init（初始）"><a href="#Init（初始）" class="headerlink" title="Init（初始）"></a>Init（初始）</h3><p>收到邻居发送的<code>Hello</code>报文，但是报文内没有自己的<code>Router-ID</code>，邻居状态就是<code>Init</code>。这个状态表示，直连链路上有一个 OSPF 路由器，但是还未确认双向通信。接下来，路由器会把对方的<code>Router-ID</code>添加到发送的<code>Hello</code>报文中。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/14.png" class="">

<h3 id="Attempt（尝试）"><a href="#Attempt（尝试）" class="headerlink" title="Attempt（尝试）"></a>Attempt（尝试）</h3><p>只在 NBMA 网络中出现。当路由器的 NBMA 接口启动后，邻居状态从<code>Down</code>切换到<code>Attempt</code>。这种状态下，路由器周期性的向邻居发送<code>Hello</code>报文，但是未收到邻居的有效<code>Hello</code>报文。当路由器收到邻居发送的没有自己<code>Router-ID</code>的<code>Hello</code>报文后，就将邻居状态切换到<code>Init</code>。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/15.png" class="">

<h3 id="2-Way（双向通信）"><a href="#2-Way（双向通信）" class="headerlink" title="2-Way（双向通信）"></a>2-Way（双向通信）</h3><p>路由器收到邻居的<code>Hello</code>报文，报文里有自己的<code>Router-ID</code>时，状态切换成<code>2-Way</code>，表示两个路由器形成了可以双向通信的邻居关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/16.png" class="">

<h3 id="选举-DR-和-BDR"><a href="#选举-DR-和-BDR" class="headerlink" title="选举 DR 和 BDR"></a>选举 DR 和 BDR</h3><p>如果路由器是在一个 MA 网络，邻居状态在<code>2-Way</code>后，会进行 DR 和 BDR 选举。</p>
<h3 id="ExSart（交换开始）"><a href="#ExSart（交换开始）" class="headerlink" title="ExSart（交换开始）"></a>ExSart（交换开始）</h3><p>接来下，路由器会进入<code>ExStart</code>状态，发送空的 DD 报文，用于协商<code>Master/Slave</code>，<code>Router-ID</code>最大的路由器成为<code>Master</code>路由器，DD 报文的序列号由<code>Master</code>路由器决定。协商<code>Master/Slave</code>的报文是空的、不携带 LSA 头部的 DD 报文，这时报文的 I 位被设置成 1。</p>
<h3 id="Exchange（交换）"><a href="#Exchange（交换）" class="headerlink" title="Exchange（交换）"></a>Exchange（交换）</h3><p>接下来，路由器进入<code>Exchange</code>状态，向邻居发送描述自己 LSDB 的 DD 报文，DD 报文中包含 LSA 头部。DD 报文逐个发送，每个报文中都有 DD 序列号，DD 序列号由<code>Master</code>路由器决定，序列号在 DD 报文的交互过程中递增，确保交互过程的有序性和可靠性。</p>
<h3 id="Loading（加载）"><a href="#Loading（加载）" class="headerlink" title="Loading（加载）"></a>Loading（加载）</h3><p>接下来，路由器进入<code>Loading</code>状态，路由器向邻居发送 LSR 请求 LSA 的完整信息。邻居使用 LSU 进行回应，LSU 报文里有 LSA 的完整信息。在收到 LSU 报文后，路由器需要发送 LSAck 对 LSA 进行确认。</p>
<h3 id="Full（完整）"><a href="#Full（完整）" class="headerlink" title="Full（完整）"></a>Full（完整）</h3><p>当接口上需要请求的 LSA 列表为空时，表示路由器已经完成了和邻居的 LSDB 同步，没有再需要请求的 LSA 了，这时邻居的状态就是<code>Full</code>。</p>
<p>路由计算<br>接下来，路由器开始计算路由。先评估一台路由器到另一台路由器需要的度量值。OSPF 协议是根据路由器的每一个接口的度量值决定最短路径的。一条路由的开销是指到达目的网络的路径上所有路由器接口的度量值总和。</p>
<p>度量值和接口带宽有关，路由器的接口度量值是根据公式 100&#x2F;带宽（Mbps）计算出来的，它作为评估路由器之间网络资源的参考值。另外也可以通过命令手工指定路由器的度量值。</p>
<h1 id="MA-和-NBMA-网络"><a href="#MA-和-NBMA-网络" class="headerlink" title="MA 和 NBMA 网络"></a>MA 和 NBMA 网络</h1><p>MA 网络，即多路访问网络，是在同一个共享介质中连接多个设备的网络。网络中的任意两台设备都能直接进行二层通信。MA 网络有两种，一种是 BMA 网络，即广播型多路访问网络，比如以太网，典型场景就是一台以太网交换机连接着多台路由器，如果有一个广播数据发出来，整个网络中的路由器都能收到。另一种是 NBMA 网络，即非广播型多路访问网络，NBMA 类型的网络已经看不到了，它允许多台路由器接入，但是没有广播能力，无法使用组播或广播，只能配置成单播发送 OSPF 报文。帧中继、X.25 都是这类网络。</p>
<h1 id="DR-和-BDR"><a href="#DR-和-BDR" class="headerlink" title="DR 和 BDR"></a>DR 和 BDR</h1><p>在 MA 网络中，<code>n</code>台路由器都两两建立邻接关系，那么就有<code>n(n-1)/2</code>个邻接关系，会消耗大量的路由器资源，增加网络中 LSA 的泛洪数量。为了优化邻接关系数量，减少不必要的协议流量，OSPF 会在每一个 MA 网络中选举一个 DR（指定路由器）和一个 BDR（备用指定路由器）。</p>
<p>既不是 DR 也不是 BDR 的路由器叫做 DROther，MA网络中所有 DROther 只和 DR 及 BDR 建立 OSPF 邻接关系，BDR 也和 DR 建立邻接关系，DROther 之间只停留在<code>2-Way</code>状态。这样，就有<code>2(n-2)+1</code>个邻接关系，数量得到优化。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/17.png" class="">

<p>DR 在 LSDB 同步方面有关键性的作用，会侦听网络中的拓扑变化信息，并将变更信息通知给其它路由器。DR 会生成一种 Type-2 LSA，这个 LSA 包含个 MA 网络中所有 OSPF 路由器的<code>Router-ID</code>，也包括 DR 自己的。BDR 会监控 DR 状态，当 DR 发生故障时就接替它的工作。</p>
<p>DR、BDR 的选举通过<code>Hello</code>报文实现，发生在<code>2-Way</code>状态之后。<code>Hello</code>报文有路由器接口的 DR 优先级，取值范围是<code>0~255</code>，默认值为 1，DR 优先级为 0 的接口没有 DR 和 BDR 的选举资格。</p>
<p>当接口激活 OSPF 后，它会查看网络中是否存在 DR，如果有就使用已经存在的 DR，也就是 DR 不可抢占，否则选择最高优先级的路由器成为 DR，当优先级相等时，选择<code>Router-ID</code>最大的路由器成为 DR。之后还会进行 BDR 的选举，选举过程与 DR 类似。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/38.png" class="">

<p>需要注意的是，DR 和 BDR 是一个接口级别的概念。某台路由器是 DR，这种说法不准确，严谨的说法是：某台路由器的某个接口在这个 MA 网络中是 DR。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/18.png" class="">

<p>在一个 MA 网络中，DR 要确保接入到网络中的所有路由器有相同的 LSDB，也就是确保 LSDB 同步。DR 使用组播地址<code>224.0.0.5</code>向网络中发送 LSU 报文，所有 OSPF 路由器都会侦听这个组播地址，并与 DR 同步 LSDB。而 DROther 感知到拓扑变化时，向<code>224.0.0.6</code>发送 LSU 报文通告这个变化，DR 和 BDR 会侦听这个组播地址。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/19.png" class="">

<h1 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h1><p>每种路由协议对度量值的定义是不同的，OSPF 使用<code>Cost</code>（开销）作为路由度量值，<code>Cost</code>值越小，则路径（路由）越优。每一个激活 OSPF 的接口都有一个接口的<code>Cost</code>值，值等于 100&#x2F;接口带宽 Mbit&#x2F;s，计算结果取整数部分，当结果小于 1 时，值取 1。这个值也可以人为修改，修改值会直接影响<code>Cost</code>值的计算，从而影响网络中 OSPF 路由的选择。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/21-0.png" class="">

<p>同步 OSPF 区域内每台路由器的 LSDB，路由器通过交互 LSA 实现 LSDB 的同步。LSA 不但携带了网络连接状况信息，而且携带各接口的<code>Cost</code>信息。</p>
<p>由于一条 LSA 是对一台路由器或一个网段拓扑结构的描述，整个 LSDB 就形成了对整个网络的拓扑结构的描述。所有路由器得到一张完全相同的图。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/21.png" class="">

<p>使用 SPF（最短路径优先算法）计算出路由。OSPF 路由器用 SPF 算法以自己为根节点，计算出一棵最短路径树。这棵树上，由根到各个节点的累计开销最小，也就是从根到各个节点的路径都是最优的，这样就获得了由根去往各个节点的路由。计算完成后，路由器将路由加入到 OSPF 路由表。当 SPF 算法发现有两条到达目的网络的路由的<code>Cost</code>值相同，会将这两条路由都加入到 OSPF 路由表中，形成等价路由。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/22.png" class="">
<h1 id="Router-ID"><a href="#Router-ID" class="headerlink" title="Router-ID"></a>Router-ID</h1><p><code>Router-ID</code>用于标识 OSPF 路由器，是一个 32 位的数值，跟 IPv4 地址格式一样。连续的 OSPF 路由器组成的网络叫做 OSPF 域，域内<code>Router-ID</code>必须唯一，也就是在同一个域内不允许出现两台相同<code>Router-ID</code>的路由器。<code>Router-ID</code>可以手动设置，也可以自动生成，常见的做法是把设备的<code>Router-ID</code>指定为设备的<code>Loopback</code>接口的 IP 地址。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/15-1.png" class="">

<h2 id="Loopback-接口"><a href="#Loopback-接口" class="headerlink" title="Loopback 接口"></a>Loopback 接口</h2><p><code>Loopback</code>接口也就是本地回环接口，是一种软件的、逻辑的接口，不只网络设备支持<code>Loopback</code>接口，Windows 主机或 Linux 主机也支持。根据业务需求，在网络设备上创建<code>Loopback</code>接口，并配置 IP 地址。<code>Loopback</code>接口非常稳定，除非手动进行关闭或删除，否则是永远不会失效的。正因如此，<code>Loopback</code>接口常用于设备网管、网络测试、网络协议应用等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为设备创建一个 Loopback 接口，并配置接口的 IP 地址</span></span><br><span class="line">[router]interface loopback 0</span><br><span class="line">[router-loopback0]ip address 1.1.1.1 32</span><br><span class="line">[router-loopback0]quit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 OSPF 进程，并配置设备的 Router-ID 为 1.1.1.1</span></span><br><span class="line">[router]ospf 1 router-id 1.1.1.1</span><br></pre></td></tr></table></figure>
<h1 id="报文类型及格式"><a href="#报文类型及格式" class="headerlink" title="报文类型及格式"></a>报文类型及格式</h1><p>OSPF 协议的报文直接使用 IP 封装，在 IP 报文头部对应的协议号是 89。通常 OSPF 的协议报文使用组播地址作为目的 IP 地址，有两个组播 IP 地址是 OSPF 专用。</p>
<ul>
<li><code>224.0.0.5</code>：这个组播 IP 地址是指所有的 OSPF 路由器。</li>
<li><code>224.0.0.6</code>：这个组播 IP 地址是指所有的 OSPF DR 路由器。</li>
</ul>
<p>OSPF 一共定义了五种报文，各有各的用途。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">报文名称</th>
<th align="center">报文说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Hello</td>
<td align="center">用于发现直连链路上的 OSPF 邻居，以及维护 OSPF 邻居关系</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">DD<br>Database Description<br>数据库描述</td>
<td align="center">用于描述LSDB，报文中携带的是 LSA 的头部数据，不是完整的 LSA 内容</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">LSR<br>Link State Request<br>链路状态请求</td>
<td align="center">向 OSPF 邻居请求 LSA</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">LSU<br>Link State Update<br>链路状态更新</td>
<td align="center">用于发送 LSA，报文中携带的是完整的 LSA 数据</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">LSAck<br>Link State Acknowledgment<br>链路状态确认</td>
<td align="center">设备收到 LSU 后，LSAck对接收的 LSA 进行确认</td>
</tr>
</tbody></table>
<p>路由器的接口一旦激活 OSPF，就会开始发送<code>Hello</code>报文。<code>Hello</code>报文的一个重要功能就是发现直连链路上的 OSPF 邻居。发现邻居后，就开始邻接关系的建立。这个过程中，DD 报文用于发送 LSA 的头部摘要。通过 DD 报文的交互，路由器知道了对方所有的 LSA，而 LSR 向对方请求完整的 LSA。LSU 对 LSR 进行回应，或者主动更新 LSA，LSU 包含完整的 LSA 数据。LSAck 保证 OSPF 更新机制的可靠性。此外，<code>Hello</code>报文负责 OSPF 邻居关系的维护，两台直连路由器形成邻接关系后，双方仍然周期性的发送<code>Hello</code>报文，告知对方自己是在线状态。</p>
<p>所有 OSPF 报文是相同的头部，这个头部的长度是 24 字节。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/24.png" class="">

<ul>
<li>版本：OSPFv2 的值为 2。</li>
<li>类型：表示 OSPF 报文的类型。值与报文类型对应关系是：<code>1–Hello；2–DD；3–LSR；4–LSU；5–LSAck</code>。</li>
<li>报文长度：整个 OSPF 报文的长度，单位是字节。</li>
<li>路由器 ID：路由器的 OSPF <code>Router-ID</code>。</li>
<li>区域 ID：表示所属的区域 ID，是一个 4 字节的数值。</li>
<li>校验和：用来校验报文有效性。</li>
<li>认证类型：表示报文使用的认证类型。</li>
<li>认证数据：用于报文认证的内容。</li>
</ul>
<h2 id="Hello-报文"><a href="#Hello-报文" class="headerlink" title="Hello 报文"></a>Hello 报文</h2><p><code>Hello</code>报文用于发现直连链路上的邻居，以及维护邻居关系。<code>Hello</code>报文携带邻居关系建立的各项参数，建立邻居关系的过程中，会检查这些参数，只有参数匹配，才能正确建立邻居关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/25.png" class="">

<ul>
<li>网络掩码：这个字段表示接口的网络掩码。如果两台路由器是通过以太网接口连接，那么直连的两个接口必须配置相同的网络掩码。如果收到的<code>Hello</code>报文中“网络掩码”字段与自己接口的不同，就忽略这个<code>Hello</code>报文，不会建立邻居关系。</li>
<li><code>Hello</code>间隔：接口周期性发送<code>Hello</code>报文的时间间隔，单位是秒。两台路由器要建立邻居关系，需要接口的<code>Hello</code>间隔相同，否则邻居关系无法建立。默认情况下，OSPF 路由器在 P2P 或 Broadcast 类型的接口上，<code>Hello</code>间隔是 10 秒，在 NBMA 及 P2MP 类型的接口上，<code>Hello</code>间隔是 30 秒。</li>
<li>选项：这个字段一共 8 比特，每个比特位都表示路由器的某个特性。路由器通过设置相应的「选项」比特位来通告自己支持某种特性或拥有某种能力。</li>
<li>路由器优先级：路由器优先级，也叫做 DR 优先级，用于 DR 和 BDR 的选举。默认情况下，OSPF 接口的 DR 优先级是 1，这个值也可以通过命令进行修改。</li>
<li>路由器失效时间：路由器等待对方发送<code>Hello</code>报文的时间，超过这个时间就认为是路由器已离线。路由器建立邻居关系，也需要双方接口的路由器失效时间相同。默认情况下，路由器失效时间是<code>Hello</code>间隔的 4 倍。</li>
<li>指定路由器：网络中 DR 的接口 IP 地址。如果值为<code>0.0.0.0</code>，表示没有 DR&#96;，或 DR 还未选举出来。</li>
<li>备份指定路由器：网络中 BDR 的接口 IP 地址。如果值为<code>0.0.0.0</code>，表示没有 BDR，或 BDR 还未选举出来。</li>
<li>邻居：表示邻居的<code>Router-ID</code>，是在直连链路上发现的有效邻居，如果发现多个邻居，就包含多个邻居字段。</li>
</ul>
<h2 id="DD-报文"><a href="#DD-报文" class="headerlink" title="DD 报文"></a>DD 报文</h2><p>DD 报文用于描述 LSDB，这个报文携带的是 LSDB 中 LSA 的头部数据，并非完整的 LSA 内容。互为邻居的路由器使用空的 DD 报文来协商主&#x2F;从（<code>Master/Slave</code>），空的 DD 报文不包含任何 LSA 头部信息。<code>Router-ID</code>更大的路由器成为<code>Master</code>路由器。</p>
<p><code>Master/Slave</code>确定后，双方开始使用 DD 报文描述各自的 LSDB，这时的 DD 报文包含 LSDB 里的 LSA 头部信息。路由器可以使用多个 DD 报文来描述 LSDB，为了确保 DD 报文传输的有序和可靠，<code>Master</code>路由器使用“DD Sequence Number（DD 序列号）”字段主导整个 LSDB 交互过程。比如：<code>Master</code>路由器发送一个 DD 序列号是 100 的 DD 报文给<code>Slave</code>路由器，<code>Slave</code>收到这个报文后，才发送自己的 DD 报文，而 DD 序列号也使用 100。<code>Master</code>路由器发送下一个 DD 报文（DD 序列号是 101），<code>Slave</code>路由器才会发送 DD 报文。这个过程一直持续，直到 LSDB 同步完成。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/20.png" class="">

<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/26.png" class="">

<ul>
<li>接口最大传输单元（<code>Interface Maximum Transmission Unit</code>）：接口的 MTU。默认情况下，接口发送的 DD 报文中，无论接口实际的 MTU 值是多少，值都为 0。</li>
<li>选项：路由器支持的 OSPF 可选项。</li>
<li>I 位（<code>Initial Bit</code>）：初始化位，协商<code>Master/Slave</code>路由器时，值为 1，<code>Master/Slave</code>选举完成后，值为 0。</li>
<li>M 位（<code>More Bit</code>）：如果值为 1，表示后续还有 DD 报文；如果值为 0，表示这是最后一个 DD 报文。</li>
<li>MS 位（<code>Master Bit</code>）：<code>Master</code>路由器发送的 DD 报文中，值为 1，<code>Slave</code>路由器则值为 0。</li>
<li>DD 序列号：DD 报文的序列号，在 DD 报 文交互过程中，逐次加 1，确保传输的有序和可靠。DD 序列号必须由<code>Master</code>路由器决定，而<code>Slave</code>路由器只能使用<code>Master</code>路由器发送的 DD 序列号来发送自己的 DD 报文。</li>
<li>LSA 头部：当路由器使用 DD 报文描述自己的 LSDB 时，LSA 头部信息就在这里。一个 DD 报文可能包含一条或多条 LSA 头部信息。</li>
</ul>
<h2 id="LSR-报文"><a href="#LSR-报文" class="headerlink" title="LSR 报文"></a>LSR 报文</h2><p>在与 OSPF 邻居交换 DD 报文后，路由器就知道了邻居的 LSDB 摘要，向邻居发送 LSR 报文请求所需 LSA 的完整数据。LSR 报文的链路状态类型（<code>Link-State Type</code>）、链路状态 ID（<code>Link-State ID</code>）、通告路由器（<code>Advertising Router</code>）三个字段表示路由器请求的 LSA。如果请求多个 LSA，那么 LSR 可能包含多个三元组。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/27.png" class="">

<ul>
<li>链路状态类型：表示 LSA 类型。OSPF 有多种 LSA 类型，每种 LSA 描述 OSPF 网络的某个部分，使用不同的类型编号。常见的 LSA 类型值和 LSA 名称是：<code>1–Router LSA，2–Network LSA，3–Network Summary LSA，4–ASBR Summary LSA，5–AS External LSA</code>。</li>
<li>链路状态标识：LSA 的标识。不同的 LSA 类型，字段的定义不同。</li>
<li>通告路由器：生成这条 LSA 的路由器的<code>Router-ID</code>。</li>
</ul>
<h2 id="LSU-报文"><a href="#LSU-报文" class="headerlink" title="LSU 报文"></a>LSU 报文</h2><p>路由器收到邻居发送的 LSR 后，会使用 LSU 报文进行回应，在 LSU 报文中包含请求 LSA 的完整信息，一个 LSU 报文可以包含多个 LSA。另外，当路由器感知到网络发生变化时，也会触发 LSU 报文的泛洪，及时把网络变化通告给其它路由器。在 BMA 网络中，非 DR、BDR 路由器向组播地址<code>224.0.0.6</code>发送 LSU 报文，而 DR 和 BDR 会侦听这个组播地址，DR 在接收 LSU 报文后向<code>224.0.0.5</code>发送 LSU 报文，从而将更新信息泛洪到整个 OSPF 区域，所有的 OSPF 路由器都会侦听<code>224.0.0.5</code>这个组播地址。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/28.png" class="">

<h2 id="LSAck-报文"><a href="#LSAck-报文" class="headerlink" title="LSAck 报文"></a>LSAck 报文</h2><p>当一台路由器收到邻居发送的 LSU 报文时，为了确认 LSA 已经送达，需要对报文中的 LSA 进行确认，就是回复一个 LSAck 报文。LSAck 报文包含路由器确认的 LSA 头部信息。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/29.png" class="">

<h1 id="OSPF-三张表"><a href="#OSPF-三张表" class="headerlink" title="OSPF 三张表"></a>OSPF 三张表</h1><p>OSPF 使用三种表格确保能正常运行。</p>
<h2 id="邻居表（Peer-Table）"><a href="#邻居表（Peer-Table）" class="headerlink" title="邻居表（Peer Table）"></a>邻居表（Peer Table）</h2><p>在 OSPF 交互 LSA 之前，两台直连路由器需要建立 OSPF 邻居关系。当一个接口激活 OSPF 后，就会周期性的发送 OSPF <code>Hello</code>报文，同时侦听<code>Hello</code>报文从而发现直连链路上的邻居。在接口上发现邻居后，邻居的信息会写入路由器的 OSPF 邻居表，随后一个邻接关系的建立过程也开始了。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/30.png" class="">

<h2 id="链路状态数据库（Link-State-Database-，LSDB）"><a href="#链路状态数据库（Link-State-Database-，LSDB）" class="headerlink" title="链路状态数据库（Link-State Database ，LSDB）"></a>链路状态数据库（Link-State Database ，LSDB）</h2><p>OSPF 路由器在网络中泛洪的链路状态信息，叫做 LSA（<code>Link-State Advertisement</code>，链路状态通告）。路由器搜集 LSA 并添加到自己的 LSDB 中，路由器通过 LSDB 获取网络的完整信息。OSPF 定义了多种类型的 LSA ，这些 LSA 各有用途，最终目的是让路由器知道网络的拓扑结构以及网段信息，并计算出最短路径树，从而发现到达全网各个网段的路由。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/31.png" class="">

<h2 id="OSPF-路由表（Routing-Table）"><a href="#OSPF-路由表（Routing-Table）" class="headerlink" title="OSPF 路由表（Routing Table）"></a>OSPF 路由表（Routing Table）</h2><p>OSPF 根据 LSDB 中的数据，运行 SPF 算法，得到一棵以自己为根、无环的最短路径树，基于这棵树，OSPF 能够发现到达网络中各个网段的最佳路径，从而得到路由信息，并添加到 OSPF 路由表中。当然，这些 OSPF 路由表中的路由最终是否被添加到全局路由器，还需要经过比较路由优先级等过程。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/32.png" class="">

<h1 id="邻接关系"><a href="#邻接关系" class="headerlink" title="邻接关系"></a>邻接关系</h1><p>OSPF 有两个概念：邻居关系和邻接关系。假如两台路由器通过网线直连，在双方互联的接口上激活 OSPF，路由器接口开始发送和侦听<code>Hello</code>报文，通过<code>Hello</code>报文发现彼此，并确认双向通信后，就形成了邻居关系。</p>
<p>之后，两台路由器会开始交互空的 DD 报文协商<code>Master/Slave</code>，再交互包含 LSA 头部信息的 DD 报文，以便同步自己的 LSDB，然后通过 LSR 和 LSU 报文交互双方的 LSA。当两者的 LSDB 同步完成后，两台路由器形成对网络拓扑的一致认知，并开始独立计算路由。这时，两台路由器形成了邻接关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/33.png" class="">

<h1 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h1><p>OSPF 的许多功能或特性都是基于接口实现的，当一个接口激活 OSPF 后，这个接口会维护很多 OSPF 变量，比如：接入的区域 ID 、接口 Cost 值、DR 优先级、邻居列表、认证类型等，其中接口的网络类型（ Network-Type ）是非常重要的一个变量。OSPF 接口的网络类型跟接口的数据链路层封装有关，在不同网络类型的接口上，OSPF 的操作有所不同。</p>
<h2 id="1、点对点类型（-Point-to-Point-，P2P-）"><a href="#1、点对点类型（-Point-to-Point-，P2P-）" class="headerlink" title="1、点对点类型（ Point-to-Point ，P2P ）"></a>1、点对点类型（ Point-to-Point ，P2P ）</h2><p>P2P 网络是在一条链路上只能连接两台路由器的环境。典型的例子就是 PPP 链路，当两台路由器通过 PPP 链路直连时，接口的封装协议就是 PPP ，接口激活 OSPF 后，网络类型就是 P2P 。OSPF 在 P2P 网络类型中，接口以组播方式发送协议报文，组播地址是 224.0.0.5 ，报文类型包括 Hello 报文、DD 报文、LSR 报文、LSU 报文和 LSAck 报文。默认情况下，P2P 类型接口的 Hello 报文发送间隔是 10 秒。P2P 类型的网络中，不会选举 DR 和 BDR 。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/34.png" class="">

<h2 id="2、广播型多路访问类型（Broadcast-Multi-Access-，BMA）"><a href="#2、广播型多路访问类型（Broadcast-Multi-Access-，BMA）" class="headerlink" title="2、广播型多路访问类型（Broadcast Multi-Access ，BMA）"></a>2、广播型多路访问类型（Broadcast Multi-Access ，BMA）</h2><p>BMA 网络中可以多台路由器接入，任意两台路由器之间都能进行二层通信，一台路由器发送出去的广播数据，其它所有路由器都能收到，是一个支持广播的网络环境。以太网就是典型的 BMA 网络。当多台路由器接入到 BMA 网络时，比如多台路由器连接在同一台二层交换机上，这些路由器的接口激活 OSPF 就会开始发送组播的<code>Hello</code>报文，从而发现网络中的其它路由器。BMA 网络中，会选举 DR 和 BDR，所有非 DR、BDR 路由器仅与 DR 和 BDR 建立邻接关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/35.png" class="">

<p>OSPF 在 BMA 网络中，接口以组播方式发送<code>Hello</code>报文、LSU 报文以及 LSAck 报文，单播方式发送 DD 报文及 LSR 报文。当路由器需要向 DR 和 BDR 发送 OSPF 报文时，使用<code>224.0.0.6</code>这个组播地址作为目的 IP 地址；当需要向所有的 OSPF 路由器发送报文时，使用<code>224.0.0.5</code>。默认情况下，广播类型接口的<code>Hello</code>报文发送间隔是 10 秒。</p>
<h2 id="3、非广播型多路访问类型（Non-Broadcast-Multi-Access-，NBMA）"><a href="#3、非广播型多路访问类型（Non-Broadcast-Multi-Access-，NBMA）" class="headerlink" title="3、非广播型多路访问类型（Non-Broadcast Multi-Access ，NBMA）"></a>3、非广播型多路访问类型（Non-Broadcast Multi-Access ，NBMA）</h2><p>NBMA 网络也允许多台路由器接入，但是不具备广播能力，这时组播发送的<code>Hello</code>报文在 NBMA 网络中可能会有问题。为了让 OSPF 路由器之间能够顺利发现彼此，并正确建立邻接关系，还需要手动配置，比如使用单播方式发送 OSPF 报文等。帧中继、X.25 就是 NBMA 网络，不过现在已经几乎看不到这类型网络了。NBMA 网络中，也会进行 DR 和 BDR 选举。默认情况下，NBMA 类型接口的<code>Hello</code>报文发送间隔是 30 秒。</p>
<h2 id="4、点对多点类型（Point-to-Multipoint-，P2MP）"><a href="#4、点对多点类型（Point-to-Multipoint-，P2MP）" class="headerlink" title="4、点对多点类型（Point-to-Multipoint ，P2MP）"></a>4、点对多点类型（Point-to-Multipoint ，P2MP）</h2><p>P2MP 网络中，路由器接口的数据链路层封装不会自动设置，必须手动指定。P2MP 类似将多条 P2P 链路的一头进行捆绑的网络。在 P2MP 网络中无需选举 DR、BDR。OSPF 在 P2MP 类型的接口上以组播方式发送<code>Hello</code>报文，以单播方式发送其它报文。默认情况下，<code>Hello</code>报文发送间隔是 30 秒。</p>
<p>了解了这么多的网络类型，即使两个路由器的直连接口的网络类型不同，也能建立 OSPF 邻接关系，但是 OSPF 路由计算容易出现问题，因为网络类型会影响 LSA 对接口的描述，关系到路由器对网络拓扑的理解和路由计算。因此，OSPF 邻接的路由器，互联接口的网络类型必须一致。</p>
<p>即使在以太网中只有两台路由器，OSPF 也会选举 DR 和 BDR，实际上没必要且浪费时间，因为从逻辑上看是点对点的连接，选举 DR 和 BDR 实在是画蛇添足。因此，为了提高 OSPF 的效率，加快邻接关系的建立过程，可以把互联接口的网络类型修改为 P2P。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/36.png" class="">


<h1 id="区域和多区域"><a href="#区域和多区域" class="headerlink" title="区域和多区域"></a>区域和多区域</h1><p>连续的 OSPF 路由器组成的网络叫做 OSPF 域（<code>Domain</code>），为了保证每台路由器都能正常的计算路由，就要求域内所有的路由器同步 LSDB，才能达到对整个 OSPF 网络的一致认知。当网络规模越来越大时，每台路由器维护的 LSDB 变得臃肿，计算庞大的 LSDB 需要消耗更多的设备资源，加重设备的负担。另外，网络拓扑的变化，引起所有域内的路由器重新计算，而域内路由无法进行汇总，每台路由器需要维护的路由表也越来越大，又是一个不能忽略的资源消耗。</p>
<p>因此，OSPF 引入了区域（<code>Area</code>）的概念。在一个大规模的网络中，会把 OSPF 域分成多个区域。某些 LSA 的泛洪只在单个区域内部，同一个区域内的路由器维护一套相同的 LSDB ，对区域内的网络有一致的认知。每个区域独立进行 SPF 计算，区域内的拓扑结构对区域外是不可见的，而且区域内部的拓扑变化通知被限制在区域内，避免对区域外部造成影响。如果一台路由器的多个接口分别接入多个不同的区域，那么它会为每个区域分别维护一套 LSDB 。多区域的设计极大程度的限制了 LSA 的泛洪，有效的把拓扑变化的影响控制在区域内，另外在区域边界路由器上可以进行路由汇总，减少网络中的路由条目数量。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/40.png" class="">

<p>OSPF 的每一个区域都由一个编号，不同的编号表示不同的区域，这个区域编号也叫做区域 ID（<code>Area-ID</code>）。区域 ID 是一个 32 位二进制数，与 IPv4 地址的格式一样，比如<code>Area 0.0.0.1</code>，为了方便起见，也会用十进制数表示，<code>Area 0.0.0.1</code>简化成<code>Area1</code>，<code>Area 0.0.0.255</code>简化成<code>Area255</code>，<code>Area 0.0.1.0</code>简化成<code>Area256</code>。</p>
<p>一个 OSPF 域中，允许存在多个区域，其中有一个中心区域，也就是骨干区域<code>Area0</code>（或<code>Area 0.0.0.0</code>）。OSPF 要求域内的所有非骨干区域（区域 ID 不是 0 的区域）必须与<code>Area0</code>相连。如果一个域内有多个区域，那么有且只有一个<code>Area0</code>，<code>Area0</code>负责在区域之间发布区域间的路由。因此，所有的 ABR（<code>Area Border Router</code>，区域边界路由器）至少有一个接口属于<code>Area0</code>，所以<code>Area0</code>包含所有的 ABR。有点类似星型结构，骨干区域在中间，每个非骨干区域是分支。</p>
<p>任何一个非骨干区域都必须与<code>Area0</code>相连，当网络中某个区域没有与<code>Area0</code>相连时，这个区域的路由计算就会出问题。OSPF 的区域间路由都由<code>Area0</code>中转，任何两个非骨干区域之间是不能直接交互路由的。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/41.png" class="">

<p>解决方法是修改 OSPF 的网络设计，与<code>Area0</code>直接相连。如果不能改或改动成本大等问题，可以考虑使用 OSPF 虚链路（<code>Virtual Link</code>）。<code>Virtual Link</code>是一种逻辑的链路，不是一条真实的链路。通过搭建一条<code>Virtual Link</code>，可以把原来没有与骨干区域直连的区域给连接起来。</p>
<p>另一个可能的问题是，骨干区域不连续或被分隔开。非骨干区域交互区域路由时，容易引发路由环路。因此，OSPF 要求 ABR 只能将自己直连的区域内部路由通告给<code>Area0</code>，而不能将自己到达其它区域的域间路由通告给<code>Area0</code>。另外，ABR 可以将自己直连区域的内部路由和到达其它区域的域间路由通告给非骨干区域。这样就能规避网络规划不合理导致的路由环路。解决问题最好的办法是修改 OSPF 的规划，当然建立<code>Virtual Link</code>也可以临时解决这个问题。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/42.png" class="">

<p>实际部署中，Virtual Link 并不是一种常规的技术，而是一种临时方案，合理的 OSPF 网络规划依然是一个最佳的选择。</p>
<h1 id="OSPF-路由器角色"><a href="#OSPF-路由器角色" class="headerlink" title="OSPF 路由器角色"></a>OSPF 路由器角色</h1><p>在 OSPF 中，有多种路由器角色，在 OSPF 网络中都发挥着不同的作用。实际上，OSPF 不仅在路由器上使用，许多交换机、防火墙，甚至 Linux 主机都能实现。这里说的 OSPF 路由器，实际上是以路由器为代表。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/43.png" class="">

<p>内部路由器（<code>Internal Router，IR</code>）：所有接口都在同一个 OSPF 区域内的路由器。图中 R1、R4、R5 是 IR。</p>
<p>区域边界路由器（<code>Area Border Router，ABR</code>）：接入多个区域的路由器，并非所有接入多个区域的路由器都是 ABR。它至少有一个接口在<code>Area0</code>中，同时还有其它接口在其它区域中。ABR 负责在区域之间传递路由信息，因此必须连接到<code>Area0</code>，同时连接着其它区域。图中 R2、R3 是 ABR。</p>
<p>骨干路由器（<code>Backbone Router，BR</code>）：至少有一个接口接入<code>Area0</code>的路由器，那它就是一台骨干路由器，另外 ABR 也是骨干路由器。图中 R1、R2、R3、R6 是 BR。</p>
<p>AS 边界路由器（<code>AS Boundary Router，ASBR</code>）：工作在 OSPF 自治系统（<code>Autonomous System ，AS</code>）边界的路由器。ASBR 将 OSPF 域外的路由引入到本域，外部路由在整个 OSPF 域内传递。并不是同时运行多种路由协议的路由器就一定是 ASBR，ASBR 一定是将外部路由重分发到 OSPF，或者执行了路由重分发操作的路由器。图中 R6 是 ASBR。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>