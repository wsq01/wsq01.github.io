<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/js/基础/Canvas API"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/15/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/Canvas%20API/"
    >Canvas API</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/15/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/Canvas%20API/" class="article-date">
  <time datetime="2022-07-15T09:02:11.000Z" itemprop="datePublished">2022-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>&lt;canvas&gt;</code>元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上<code>&lt;canvas&gt;</code>是一个可以用 JavaScript 操作的位图（<code>bitmap</code>）。</p>
<p>它与 SVG 图像的区别在于，<code>&lt;canvas&gt;</code>是脚本调用各种方法生成图像，SVG 则是一个 XML 文件，通过各种子元素生成图像。</p>
<p>使用 Canvas API 之前，需要在网页里面新建一个<code>&lt;canvas&gt;</code>元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;250&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 Canvas</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果浏览器不支持这个 API，就会显示<code>&lt;canvas&gt;</code>标签中间的文字。</p>
<p>每个<code>&lt;canvas&gt;</code>元素都有一个对应的<code>CanvasRenderingContext2D</code>对象（上下文对象）。Canvas API 就定义在这个对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;canvas&gt;</code>元素节点对象的<code>getContext()</code>方法，返回的就是<code>CanvasRenderingContext2D</code>对象。</p>
<p>注意，Canvas API 需要<code>getContext</code>方法指定参数<code>2d</code>，表示该<code>&lt;canvas&gt;</code>节点生成 2D 的平面图像。如果参数是<code>webgl</code>，就表示用于生成 3D 的立体图案，这部分属于 WebGL API。</p>
<p>按照用途，Canvas API 分成两大部分：绘制图形和图像处理。</p>
<h1 id="Canvas-API：绘制图形"><a href="#Canvas-API：绘制图形" class="headerlink" title="Canvas API：绘制图形"></a>Canvas API：绘制图形</h1><p>Canvas 画布提供了一个作图的平面空间，该空间的每个点都有自己的坐标。原点<code>(0, 0)</code>位于图像左上角，<code>x</code>轴的正向是原点向右，<code>y</code>轴的正向是原点向下。</p>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>以下方法和属性用来绘制路径。</p>
<ul>
<li><code>ctx.beginPath()</code>：开始绘制路径。</li>
<li><code>ctx.closePath()</code>：结束路径，返回到当前路径的起始点，会从当前点到起始点绘制一条直线。如果图形已经封闭，或者只有一个点，那么此方法不会产生任何效果。</li>
<li><code>ctx.moveTo()</code>：设置路径的起点，即将一个新路径的起始点移动到(x，y)坐标。</li>
<li><code>ctx.lineTo()</code>：使用直线从当前点连接到(x, y)坐标。</li>
<li><code>ctx.fill()</code>：在路径内部填充颜色（默认为黑色）。</li>
<li><code>ctx.stroke()</code>：路径线条着色（默认为黑色）。</li>
<li><code>ctx.fillStyle</code>：指定路径填充的颜色和样式（默认为黑色）。</li>
<li><code>ctx.strokeStyle</code>：指定路径线条的颜色和样式（默认为黑色）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码只是确定了路径的形状，画布上还看不出来，因为没有颜色。所以还需要着色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">fill</span>()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ctx.<span class="title function_">stroke</span>()</span><br></pre></td></tr></table></figure>
<p>上面代码中，这两个方法都可以使得路径可见。<code>fill()</code>在路径内部填充颜色，使之变成一个实心的图形；<code>stroke()</code>只对路径线条着色。</p>
<p>这两个方法默认都是使用黑色，可以使用<code>fillStyle</code>和<code>strokeStyle</code>属性指定其他颜色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fill</span>();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>
<h2 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h2><p>以下的方法和属性控制线条的视觉特征。</p>
<ul>
<li><code>ctx.lineWidth</code>：指定线条的宽度，默认为 1.0。</li>
<li><code>ctx.lineCap</code>：指定线条末端的样式，有三个可能的值：<code>butt</code>（默认值，末端为矩形）、<code>round</code>（末端为圆形）、<code>square</code>（末端为突出的矩形，矩形宽度不变，高度为线条宽度的一半）。</li>
<li><code>ctx.lineJoin</code>：指定线段交点的样式，有三个可能的值：<code>round</code>（交点为扇形）、<code>bevel</code>（交点为三角形底边）、<code>miter</code>（默认值，交点为菱形)。</li>
<li><code>ctx.miterLimit</code>：指定交点菱形的长度，默认为 10。该属性只在<code>lineJoin</code>属性的值等于<code>miter</code>时有效。</li>
<li><code>ctx.getLineDash()</code>：返回一个数组，表示虚线里面线段和间距的长度。</li>
<li><code>ctx.setLineDash()</code>：数组，用于指定虚线里面线段和间距的长度。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">lineWidth</span> = <span class="number">3</span>;</span><br><span class="line">ctx.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">ctx.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">setLineDash</span>([<span class="number">15</span>, <span class="number">5</span>]);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码中，线条的宽度为 3，线条的末端和交点都改成圆角，并且设置为虚线。</p>
<h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><p>以下方法用来绘制矩形。</p>
<ul>
<li><code>ctx.rect()</code>：绘制矩形路径。</li>
<li><code>ctx.fillRect()</code>：填充一个矩形。</li>
<li><code>ctx.strokeRect()</code>：绘制矩形边框。</li>
<li><code>ctx.clearRect()</code>：指定矩形区域的像素都变成透明。</li>
</ul>
<p>上面四个方法的格式都一样，都接受四个参数，分别是矩形左上角的横坐标和纵坐标、矩形的宽和高。</p>
<p><code>ctx.rect()</code>方法用于绘制矩形路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">rect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">fill</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码绘制一个正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为 100。</p>
<p><code>ctx.fillRect()</code>用来向一个矩形区域填充颜色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码绘制一个绿色的正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为 100。</p>
<p><code>ctx.strokeRect()</code>用来绘制一个矩形区域的边框。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">strokeRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码绘制一个绿色的空心正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为 100。</p>
<p><code>ctx.clearRect()</code>用于擦除指定矩形区域的像素颜色，等同于把早先的绘制效果都去除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">clearRect</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">90</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码先绘制一个 100 x 100 的正方形，然后在它的内部擦除 90 x 90 的区域，等同于形成了一个 5 像素宽度的边框。</p>
<h2 id="弧线"><a href="#弧线" class="headerlink" title="弧线"></a>弧线</h2><p>以下方法用于绘制弧形。</p>
<ul>
<li><code>ctx.arc()</code>：通过指定圆心和半径绘制弧形。</li>
<li><code>ctx.arcTo()</code>：通过指定两根切线和半径绘制弧形。</li>
</ul>
<p><code>ctx.arc()</code>主要用来绘制圆形或扇形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">ctx.<span class="title function_">arc</span>(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><code>arc()</code>方法的<code>x</code>和<code>y</code>参数是圆心坐标，<code>radius</code>是半径，<code>startAngle</code>和<code>endAngle</code>则是扇形的起始角度和终止角度（以弧度表示），<code>anticlockwise</code>表示做图时应该逆时针画（<code>true</code>）还是顺时针画（<code>false</code>），这个参数用来控制扇形的方向（比如上半圆还是下半圆）。</p>
<p>下面是绘制实心圆形的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">60</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>); </span><br><span class="line">ctx.<span class="title function_">fill</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码绘制了一个半径 50，起始角度为 0，终止角度为<code>2 * PI</code>的完整的圆。</p>
<p>绘制空心半圆的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">50</span>, <span class="number">20</span>);</span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>
<p><code>ctx.arcTo()</code>方法主要用来绘制圆弧，需要给出两个点的坐标，当前点与第一个点形成一条直线，第一个点与第二个点形成另一条直线，然后画出与这两根直线相切的弧线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ctx.<span class="title function_">arcTo</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">25</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arcTo()</code>有 5 个参数，前两个参数是第一个点的坐标，第三个参数和第四个参数是第二个点的坐标，第五个参数是半径。然后，<code>(0, 0)</code>与<code>(50, 50)</code>形成一条直线，然后<code>(50, 50)</code>与<code>(100, 0)</code>形成第二条直线。弧线就是与这两根直线相切的部分。</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>以下方法和属性用于绘制文本。</p>
<ul>
<li><code>ctx.fillText()</code>：在指定位置绘制实心字符。</li>
<li><code>ctx.strokeText()</code>：在指定位置绘制空心字符。</li>
<li><code>ctx.measureText()</code>：返回一个<code>TextMetrics</code>对象。</li>
<li><code>ctx.font</code>：指定字型大小和字体，默认值为<code>10px sans-serif</code>。</li>
<li><code>ctx.textAlign</code>：文本的对齐方式，默认值为<code>start</code>。</li>
<li><code>ctx.direction</code>：文本的方向，默认值为<code>inherit</code>。</li>
<li><code>ctx.textBaseline</code>：文本的垂直位置，默认值为<code>alphabetic</code>。</li>
</ul>
<p><code>fillText()</code>方法用来在指定位置绘制实心字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">fillText</span>(text, x, y [, maxWidth])</span><br></pre></td></tr></table></figure>
<p>该方法接受四个参数。</p>
<ul>
<li><code>text</code>：所要填充的字符串。</li>
<li><code>x</code>：文字起点的横坐标，单位像素。</li>
<li><code>y</code>：文字起点的纵坐标，单位像素。</li>
<li><code>maxWidth</code>：文本的最大像素宽度。该参数可选，如果省略，则表示宽度没有限制。如果文本实际长度超过这个参数指定的值，那么浏览器将尝试用较小的字体填充。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>(50, 50)</code>位置写入字符串<code>Hello world</code>。</p>
<p>注意，<code>fillText()</code>方法不支持文本断行，所有文本一定出现在一行内。如果要生成多行文本，只有调用多次<code>fillText()</code>方法。</p>
<p><code>strokeText()</code>方法用来添加空心字符，它的参数与<code>fillText()</code>一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">strokeText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上面这两种方法绘制的文本，默认都是<code>10px</code>大小、<code>sans-serif</code>字体，<code>font</code>属性可以改变字体设置。该属性的值是一个字符串，使用 CSS 的<code>font</code>属性即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&#x27;Bold 20px Arial&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p><code>textAlign</code>属性用来指定文本的对齐方式。它可以取以下几个值。</p>
<ul>
<li><code>left</code>：左对齐</li>
<li><code>right</code>：右对齐</li>
<li><code>center</code>：居中</li>
<li><code>start</code>：默认值，起点对齐（从左到右的文本为左对齐，从右到左的文本为右对齐）。</li>
<li><code>end</code>：结尾对齐（从左到右的文本为右对齐，从右到左的文本为左对齐）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&#x27;Bold 20px Arial&#x27;</span>;</span><br><span class="line">ctx.<span class="property">textAlign</span> = <span class="string">&#x27;center&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p><code>direction</code>属性指定文本的方向，默认值为<code>inherit</code>，表示继承<code>&lt;canvas&gt;</code>或<code>document</code>的设置。其他值包括<code>ltr</code>（从左到右）和<code>rtl</code>（从右到左）。</p>
<p><code>textBaseline</code>属性指定文本的垂直位置，可以取以下值。</p>
<ul>
<li><code>top</code>：上部对齐（字母的基线是整体上移）。</li>
<li><code>hanging</code>：悬挂对齐（字母的上沿在一根直线上），适用于印度文和藏文。</li>
<li><code>middle</code>：中部对齐（字母的中线在一根直线上）。</li>
<li><code>alphabetic</code>：默认值，表示字母位于字母表的正常位置（四线格的第三根线）。</li>
<li><code>ideographic</code>：下沿对齐（字母的下沿在一根直线上），使用于东亚文字。</li>
<li><code>bottom</code>：底部对齐（字母的基线下移）。对于英文字母，这个设置与<code>ideographic</code>没有差异。</li>
</ul>
<p><code>measureText()</code>方法接受一个字符串作为参数，返回一个<code>TextMetrics</code>对象，可以从这个对象上面获取参数字符串的信息，目前主要是文本渲染后的宽度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text1 = ctx.<span class="title function_">measureText</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">text1.<span class="property">width</span> <span class="comment">// 49.46</span></span><br><span class="line"></span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&#x27;Bold 20px Arial&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> text2 = ctx.<span class="title function_">measureText</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">text2.<span class="property">width</span> <span class="comment">// 107.78</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>10px</code>大小的字符串<code>Hello world</code>，渲染后宽度为 49.46。放大到<code>20px</code>以后，宽度为 107.78。</p>
<h2 id="渐变色和图像填充"><a href="#渐变色和图像填充" class="headerlink" title="渐变色和图像填充"></a>渐变色和图像填充</h2><p>以下方法用于设置渐变效果和图像填充效果。</p>
<ul>
<li><code>ctx.createLinearGradient()</code>：定义线性渐变样式。</li>
<li><code>ctx.createRadialGradient()</code>：定义辐射渐变样式。</li>
<li><code>ctx.createPattern()</code>：定义图像填充样式。</li>
</ul>
<p><code>createLinearGradient()</code>方法按照给定直线，生成线性渐变的样式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createLinearGradient</span>(x0, y0, x1, y1)</span><br></pre></td></tr></table></figure>
<p><code>ctx.createLinearGradient(x0, y0, x1, y1)</code>方法接受四个参数：<code>x0</code>和<code>y0</code>是起点的横坐标和纵坐标，<code>x1</code>和<code>y1</code>是终点的横坐标和纵坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。</p>
<p>该方法的返回值是一个<code>CanvasGradient</code>对象，该对象只有一个<code>addColorStop()</code>方向，用来指定渐变点的颜色。<code>addColorStop()</code>方法接受两个参数，第一个参数是0到1之间的一个位置量，0表示起点，1表示终点，第二个参数是一个字符串，表示 CSS 颜色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gradient = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">ctx.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，定义了渐变样式<code>gradient</code>以后，将这个样式指定给<code>fillStyle</code>属性，然后<code>fillRect()</code>就会生成以这个样式填充的矩形区域。</p>
<p><code>createRadialGradient()</code>方法定义一个辐射渐变，需要指定两个圆。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createRadialGradient</span>(x0, y0, r0, x1, y1, r1)</span><br></pre></td></tr></table></figure>
<p><code>createRadialGradient()</code>方法接受六个参数，<code>x0</code>和<code>y0</code>是辐射起始的圆的圆心坐标，<code>r0</code>是起始圆的半径，<code>x1</code>和<code>y1</code>是辐射终止的圆的圆心坐标，<code>r1</code>是终止圆的半径。</p>
<p>该方法的返回值也是一个<code>CanvasGradient</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gradient = ctx.<span class="title function_">createRadialGradient</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">ctx.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，生成辐射样式以后，用这个样式填充一个矩形。</p>
<p><code>createPattern()</code>方法定义一个图像填充样式，在指定方向上不断重复该图像，填充指定的区域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createPattern</span>(image, repetition)</span><br></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个参数是图像数据，它可以是<code>&lt;img&gt;</code>元素，也可以是另一个<code>&lt;canvas&gt;</code>元素，或者一个表示图像的<code>Blob</code>对象。第二个参数是一个字符串，有四个可能的值，分别是<code>repeat</code>（双向重复）、<code>repeat-x</code>(水平重复)、<code>repeat-y</code>(垂直重复)、<code>no-repeat</code>(不重复)。如果第二个参数是空字符串或<code>null</code>，则等同于<code>null</code>。</p>
<p>该方法的返回值是一个<code>CanvasPattern</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;https://example.com/pattern.png&#x27;</span>;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"> </span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> pattern = ctx.<span class="title function_">createPattern</span>(img, <span class="string">&#x27;repeat&#x27;</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = pattern;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，图像加载成功以后，使用<code>createPattern()</code>生成图像样式，然后使用这个样式填充指定区域。</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>以下属性用于设置阴影。</p>
<ul>
<li><code>ctx.shadowBlur</code>：阴影的模糊程度，默认为0。</li>
<li><code>ctx.shadowColor</code>：阴影的颜色，默认为<code>black</code>。</li>
<li><code>ctx.shadowOffsetX</code>：阴影的水平位移，默认为0。</li>
<li><code>ctx.shadowOffsetY</code>：阴影的垂直位移，默认为0。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">shadowOffsetX</span> = <span class="number">10</span>;</span><br><span class="line">ctx.<span class="property">shadowOffsetY</span> = <span class="number">10</span>;</span><br><span class="line">ctx.<span class="property">shadowBlur</span> = <span class="number">5</span>;</span><br><span class="line">ctx.<span class="property">shadowColor</span> = <span class="string">&#x27;rgba(0,0,0,0.5)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h1 id="Canvas-API：图像处理"><a href="#Canvas-API：图像处理" class="headerlink" title="Canvas API：图像处理"></a>Canvas API：图像处理</h1><h2 id="ctx-drawImage"><a href="#ctx-drawImage" class="headerlink" title="ctx.drawImage()"></a>ctx.drawImage()</h2><p>Canvas API 允许将图像文件写入画布，做法是读取图片后，使用<code>drawImage()</code>方法将这张图片放上画布。</p>
<p><code>ctx.drawImage()</code>有三种使用格式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">drawImage</span>(image, dx, dy);</span><br><span class="line">ctx.<span class="title function_">drawImage</span>(image, dx, dy, dWidth, dHeight);</span><br><span class="line">ctx.<span class="title function_">drawImage</span>(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure>
<p>各个参数的含义：</p>
<ul>
<li><code>image</code>：图像元素</li>
<li><code>sx</code>：图像内部的横坐标，用于映射到画布的放置点上。</li>
<li><code>sy</code>：图像内部的纵坐标，用于映射到画布的放置点上。</li>
<li><code>sWidth</code>：图像在画布上的宽度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的宽度。</li>
<li><code>sHeight</code>：图像在画布上的高度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的高度。</li>
<li><code>dx</code>：画布内部的横坐标，用于放置图像的左上角</li>
<li><code>dy</code>：画布内部的纵坐标，用于放置图像的右上角</li>
<li><code>dWidth</code>：图像在画布内部的宽度，会产生缩放效果。</li>
<li><code>dHeight</code>：图像在画布内部的高度，会产生缩放效果。</li>
</ul>
<p>下面是最简单的使用场景，将图像放在画布上，两者左上角对齐。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;image.png&#x27;</span>;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码将一个 PNG 图像放入画布。这时，图像将是原始大小，如果画布小于图像，就会只显示出图像左上角，正好等于画布大小的那一块。</p>
<p>如果要显示完整的图片，可以用图像的宽和高，设置成画布的宽和高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>(<span class="number">60</span>, <span class="number">45</span>);</span><br><span class="line">image.<span class="property">onload</span> = drawImageActualSize;</span><br><span class="line">image.<span class="property">src</span> = <span class="string">&#x27;https://example.com/image.jpg&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawImageActualSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  canvas.<span class="property">width</span> = <span class="variable language_">this</span>.<span class="property">naturalWidth</span>;</span><br><span class="line">  canvas.<span class="property">height</span> = <span class="variable language_">this</span>.<span class="property">naturalHeight</span>;</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(<span class="variable language_">this</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">naturalWidth</span>, <span class="variable language_">this</span>.<span class="property">naturalHeight</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;canvas&gt;</code>元素的大小设置成图像的本来大小，就能保证完整展示图像。由于图像的本来大小，只有图像加载成功以后才能拿到，因此调整画布的大小，必须放在<code>image.onload</code>这个监听函数里面。</p>
<h2 id="像素读写"><a href="#像素读写" class="headerlink" title="像素读写"></a>像素读写</h2><p>以下三个方法与像素读写相关。</p>
<ul>
<li><code>ctx.getImageData()</code>：将画布读取成一个<code>ImageData</code>对象</li>
<li><code>ctx.putImageData()</code>：将<code>ImageData</code>对象写入画布</li>
<li><code>ctx.createImageData()</code>：生成<code>ImageData</code>对象</li>
</ul>
<h4 id="getImageData"><a href="#getImageData" class="headerlink" title="getImageData()"></a>getImageData()</h4><p><code>ctx.getImageData()</code>方法用来读取<code>&lt;canvas&gt;</code>的内容，返回一个<code>ImageData</code>对象，包含了每个像素的信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">getImageData</span>(sx, sy, sw, sh)</span><br></pre></td></tr></table></figure>
<p><code>getImageData()</code>方法接受四个参数。<code>sx</code>和<code>sy</code>是读取区域的左上角坐标，<code>sw</code>和<code>sh</code>是读取区域的宽度和高度。如果想要读取整个<code>&lt;canvas&gt;</code>区域，可以写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageData = ctx.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br></pre></td></tr></table></figure>
<p><code>getImageData()</code>方法返回的是一个<code>ImageData</code>对象。该对象有三个属性。</p>
<ul>
<li><code>ImageData.data</code>：一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、<code>alpha</code>通道值（每个值的范围是 0～255），因此该数组的长度等于图像的像素宽度 x 图像的像素高度 x 4。这个数组不仅可读，而且可写，因此通过操作这个数组，就可以达到操作图像的目的。</li>
<li><code>ImageData.width</code>：浮点数，表示<code>ImageData</code>的像素宽度。</li>
<li><code>ImageData.height</code>：浮点数，表示<code>ImageData</code>的像素高度。</li>
</ul>
<h4 id="putImageData"><a href="#putImageData" class="headerlink" title="putImageData()"></a>putImageData()</h4><p><code>ctx.putImageData()</code>方法将<code>ImageData</code>对象的像素绘制在<code>&lt;canvas&gt;</code>画布上。该方法有两种使用格式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">putImageData</span>(imagedata, dx, dy)</span><br><span class="line">ctx.<span class="title function_">putImageData</span>(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)</span><br></pre></td></tr></table></figure>
<p>该方法有如下参数。</p>
<ul>
<li><code>imagedata</code>：包含像素信息的<code>ImageData</code>对象。</li>
<li><code>dx</code>：<code>&lt;canvas&gt;</code>元素内部的横坐标，用于放置<code>ImageData</code>图像的左上角。</li>
<li><code>dy</code>：<code>&lt;canvas&gt;</code>元素内部的纵坐标，用于放置<code>ImageData</code>图像的左上角。</li>
<li><code>dirtyX</code>：<code>ImageData</code>图像内部的横坐标，用于作为放置到<code>&lt;canvas&gt;</code>的矩形区域的左上角的横坐标，默认为 0。</li>
<li><code>dirtyY</code>：<code>ImageData</code>图像内部的纵坐标，用于作为放置到<code>&lt;canvas&gt;</code>的矩形区域的左上角的纵坐标，默认为 0。</li>
<li><code>dirtyWidth</code>：放置到<code>&lt;canvas&gt;</code>的矩形区域的宽度，默认为<code>ImageData</code>图像的宽度。</li>
<li><code>dirtyHeight</code>：放置到<code>&lt;canvas&gt;</code>的矩形区域的高度，默认为<code>ImageData</code>图像的高度。</li>
</ul>
<p>下面是将<code>ImageData</code>对象绘制到<code>&lt;canvas&gt;</code>的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="createImageData"><a href="#createImageData" class="headerlink" title="createImageData()"></a>createImageData()</h4><p><code>ctx.createImageData()</code>方法用于生成一个空的<code>ImageData</code>对象，所有像素都是透明的黑色（即每个值都是0）。该方法有两种使用格式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createImageData</span>(width, height)</span><br><span class="line">ctx.<span class="title function_">createImageData</span>(imagedata)</span><br></pre></td></tr></table></figure>
<p><code>createImageData()</code>方法的参数如下。</p>
<ul>
<li><code>width</code>：<code>ImageData</code>对象的宽度，单位为像素。</li>
<li><code>height</code>：<code>ImageData</code>对象的高度，单位为像素。</li>
<li><code>imagedata</code>：一个现有的<code>ImageData</code>对象，返回值将是这个对象的拷贝。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageData = ctx.<span class="title function_">createImageData</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>imageData</code>是一个 100 x 100 的像素区域，其中每个像素都是透明的黑色。</p>
<h2 id="ctx-save-，ctx-restore"><a href="#ctx-save-，ctx-restore" class="headerlink" title="ctx.save()，ctx.restore()"></a>ctx.save()，ctx.restore()</h2><p><code>ctx.save()</code>方法用于将画布的当前样式保存到堆栈，相当于在内存之中产生一个样式快照。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>save()</code>会为画布的默认样式产生一个快照。</p>
<p><code>ctx.restore()</code>方法将画布的样式恢复到上一个保存的快照，如果没有已保存的快照，则不产生任何效果。</p>
<p>上下文环境，<code>restore</code>方法用于恢复到上一次保存的上下文环境。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">save</span>();</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码画一个矩形。矩形的填充色本来设为绿色，但是<code>restore()</code>方法撤销了这个设置，将样式恢复上一次保存的状态（即默认样式），所以实际的填充色是黑色（默认颜色）。</p>
<h2 id="ctx-canvas"><a href="#ctx-canvas" class="headerlink" title="ctx.canvas"></a>ctx.canvas</h2><p><code>ctx.canvas</code>属性指向当前<code>CanvasRenderingContext2D</code>对象所在的<code>&lt;canvas&gt;</code>元素。该属性只读。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">canvas</span> === canvas <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h2><p>以下方法用于图像变换。</p>
<ul>
<li><code>ctx.rotate()</code>：图像旋转</li>
<li><code>ctx.scale()</code>：图像缩放</li>
<li><code>ctx.translate()</code>：图像平移</li>
<li><code>ctx.transform()</code>：通过一个变换矩阵完成图像变换</li>
<li><code>ctx.setTransform()</code>：取消前面的图像变换</li>
</ul>
<h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate()"></a>rotate()</h4><p><code>ctx.rotate()</code>方法用于图像旋转。它接受一个弧度值作为参数，表示顺时针旋转的度数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">rotate</span>(<span class="number">45</span> * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">70</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码会显示一个顺时针倾斜45度的矩形。注意，<code>rotate()</code>方法必须在<code>fillRect()</code>方法之前调用，否则是不起作用的。</p>
<p>旋转中心点始终是画布左上角的原点。如果要更改中心点，需要使用<code>translate()</code>方法移动画布。</p>
<h4 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h4><p><code>ctx.scale()</code>方法用于缩放图像。它接受两个参数，分别是<code>x</code>轴方向的缩放因子和<code>y</code>轴方向的缩放因子。默认情况下，一个单位就是一个像素，缩放因子可以缩放单位，比如缩放因子 0.5 表示将大小缩小为原来的 50%，缩放因子 10 表示放大十倍。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">scale</span>(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，原来的矩形是 10 x 10，缩放后展示出来是 100 x 30。</p>
<p>如果缩放因子为1，就表示图像没有任何缩放。如果为-1，则表示方向翻转。<code>ctx.scale(-1, 1)</code>为水平翻转，<code>ctx.scale(1, -1)</code>表示垂直翻转。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">scale</span>(<span class="number">1</span>, -<span class="number">2</span>);</span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&quot;16px serif&quot;</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world!&#x27;</span>, <span class="number">20</span>, -<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码会显示一个水平倒转的、高度放大2倍的<code>Hello World!</code>。</p>
<p>注意，负向缩放本质是坐标翻转，所针对的坐标轴就是画布左上角原点的坐标轴。</p>
<h4 id="translate"><a href="#translate" class="headerlink" title="translate()"></a>translate()</h4><p><code>ctx.translate()</code>方法用于平移图像。它接受两个参数，分别是 x 轴和 y 轴移动的距离（单位像素）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">translate</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform()"></a>transform()</h4><p><code>ctx.transform()</code>方法接受一个变换矩阵的六个元素作为参数，完成缩放、旋转、移动和倾斜等变形。</p>
<p>它的使用格式如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">transform</span>(a, b, c, d, e, f);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a:水平缩放(默认值1，单位倍数)</span></span><br><span class="line"><span class="comment">b:水平倾斜(默认值0，单位弧度)</span></span><br><span class="line"><span class="comment">c:垂直倾斜(默认值0，单位弧度)</span></span><br><span class="line"><span class="comment">d:垂直缩放(默认值1，单位倍数)</span></span><br><span class="line"><span class="comment">e:水平位移(默认值0，单位像素)</span></span><br><span class="line"><span class="comment">f:垂直位移(默认值0，单位像素)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">transform</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，原始图形是 100 x 100 的矩形，结果缩放成 200 x 100 的矩形，并且左上角从(0, 0)移动到(50, 50)。</p>
<p>注意，多个<code>transform()</code>方法具有叠加效果。</p>
<h4 id="setTransform"><a href="#setTransform" class="headerlink" title="setTransform()"></a>setTransform()</h4><p><code>ctx.setTransform()</code>方法取消前面的图形变换，将画布恢复到该方法指定的状态。该方法的参数与<code>transform()</code>方法完全一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">translate</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">setTransform</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个<code>fillRect()</code>方法绘制的矩形，左上角从(0, 0)平移到(50, 50)。<code>setTransform()</code>方法取消了这个变换（已绘制的图形不受影响），将画布恢复到默认状态（变换矩形1, 0, 0, 1, 0, 0），所以第二个矩形的左上角回到(0, 0)。</p>
<h1 id="lt-canvas-gt-元素的方法"><a href="#lt-canvas-gt-元素的方法" class="headerlink" title="&lt;canvas&gt;元素的方法"></a><code>&lt;canvas&gt;</code>元素的方法</h1><p>除了<code>CanvasRenderingContext2D</code>对象提供的方法，<code>&lt;canvas&gt;</code>元素本身也有自己的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">HTMLCanvasElement</span>.<span class="title function_">toDataURL</span>()</span><br></pre></td></tr></table></figure>
<p><code>&lt;canvas&gt;</code>元素的<code>toDataURL()</code>方法，可以将 Canvas 数据转为 Data URI 格式的图像。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.<span class="title function_">toDataURL</span>(type, quality)</span><br></pre></td></tr></table></figure>
<p><code>toDataURL()</code>方法接受两个参数。</p>
<ul>
<li><code>type</code>：字符串，表示图像的格式。默认为<code>image/png</code>，另一个可用的值是<code>image/jpeg</code>，Chrome 浏览器还可以使用<code>image/webp</code>。</li>
<li><code>quality</code>：浮点数，0到1之间，表示 JPEG 和 WebP 图像的质量系数，默认值为0.92。</li>
</ul>
<p>该方法的返回值是一个 Data URI 格式的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertCanvasToImage</span>(<span class="params">canvas</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  image.<span class="property">src</span> = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将<code>&lt;canvas&gt;</code>元素，转化成 PNG Data URI。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fullQuality = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.9</span>);</span><br><span class="line"><span class="keyword">var</span> mediumQuality = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.6</span>);</span><br><span class="line"><span class="keyword">var</span> lowQuality = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码将<code>&lt;canvas&gt;</code>元素转成高画质、中画质、低画质三种 JPEG 图像。</p>
<h2 id="HTMLCanvasElement-toBlob"><a href="#HTMLCanvasElement-toBlob" class="headerlink" title="HTMLCanvasElement.toBlob()"></a>HTMLCanvasElement.toBlob()</h2><p><code>HTMLCanvasElement.toBlob()</code>方法用于将<code>&lt;canvas&gt;</code>图像转成一个<code>Blob</code>对象，默认类型是<code>image/png</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">canvas.<span class="title function_">toBlob</span>(callback, mimeType, quality)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">canvas.<span class="title function_">toBlob</span>(<span class="keyword">function</span> (<span class="params">blob</span>) &#123;...&#125;, <span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.95</span>)</span><br></pre></td></tr></table></figure>
<p><code>toBlob()</code>方法可以接受三个参数。</p>
<ul>
<li><code>callback</code>：回调函数。它接受生成的 Blob 对象作为参数。</li>
<li><code>mimeType</code>：字符串，图像的 MIMEType 类型，默认是<code>image/png</code>。</li>
<li><code>quality</code>：浮点数，0到1之间，表示图像的质量，只对<code>image/jpeg</code>和<code>image/webp</code>类型的图像有效。</li>
</ul>
<p>注意，该方法没有返回值。</p>
<p>下面的例子将<code>&lt;canvas&gt;</code>图像复制成<code>&lt;img&gt;</code>图像。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">blobToImg</span>(<span class="params">blob</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newImg = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line"></span><br><span class="line">  newImg.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用完毕，释放 URL 对象</span></span><br><span class="line">    <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  newImg.<span class="property">src</span> = url;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newImg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.<span class="title function_">toBlob</span>(blobToImg);</span><br></pre></td></tr></table></figure>
<h1 id="Canvas-使用实例"><a href="#Canvas-使用实例" class="headerlink" title="Canvas 使用实例"></a>Canvas 使用实例</h1><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>通过改变坐标，很容易在画布<code>Canvas</code>元素上产生动画效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> posX = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> posY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line"></span><br><span class="line">  posX += <span class="number">1</span>;</span><br><span class="line">  posY += <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">arc</span>(posX, posY, <span class="number">10</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">closePath</span>();</span><br><span class="line">  ctx.<span class="title function_">fill</span>();</span><br><span class="line">&#125;, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码会产生一个小圆点，每隔30毫秒就向右下方移动的效果。<code>setInterval()</code>函数的一开始，之所以要将画布重新渲染黑色底色，是为了抹去上一步的小圆点。</p>
<p>在这个例子的基础上，通过设置圆心坐标，可以产生各种运动轨迹。下面是先上升后下降的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vx = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> vy = -<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> gravity = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  posX += vx;</span><br><span class="line">  posY += vy;</span><br><span class="line">  vy += gravity;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，x坐标始终增大，表示持续向右运动。y坐标先变小，然后在重力作用下，不断增大，表示先上升后下降。</p>
<h2 id="像素处理"><a href="#像素处理" class="headerlink" title="像素处理"></a>像素处理</h2><p>通过<code>getImageData()</code>方法和<code>putImageData()</code>方法，可以处理每个像素，进而操作图像内容，因此可以改写图像。</p>
<p>下面是图像处理的通用写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (canvas.<span class="property">width</span> &gt; <span class="number">0</span> &amp;&amp; canvas.<span class="property">height</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> imageData = context.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">  <span class="title function_">filter</span>(imageData);</span><br><span class="line">  context.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>filter</code>是一个处理像素的函数。以下是几种常见的<code>filter</code>。</p>
<h4 id="灰度效果"><a href="#灰度效果" class="headerlink" title="灰度效果"></a>灰度效果</h4><p>灰度图（<code>grayscale</code>）就是取红、绿、蓝三个像素值的算术平均值，这实际上将图像转成了黑白形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grayscale = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r = d[i];</span><br><span class="line">    <span class="keyword">var</span> g = d[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> b = d[i + <span class="number">2</span>];</span><br><span class="line">    d[i] = d[i + <span class="number">1</span>] = d[i + <span class="number">2</span>] = (r + g + b) / <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，d[i]是红色值，d[i+1]是绿色值，d[i+2]是蓝色值，d[i+3]是 alpha 通道值。转成灰度的算法，就是将红、绿、蓝三个值相加后除以3，再将结果写回数组。</p>
<h4 id="复古效果"><a href="#复古效果" class="headerlink" title="复古效果"></a>复古效果</h4><p>复古效果（<code>sepia</code>）是将红、绿、蓝三种值，分别取这三个值的某种加权平均值，使得图像有一种古旧的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sepia = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> r = d[i];</span><br><span class="line">      <span class="keyword">var</span> g = d[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">var</span> b = d[i + <span class="number">2</span>];</span><br><span class="line">      d[i]     = (r * <span class="number">0.393</span>) + (g * <span class="number">0.769</span>) + (b * <span class="number">0.189</span>); <span class="comment">// red</span></span><br><span class="line">      d[i + <span class="number">1</span>] = (r * <span class="number">0.349</span>) + (g * <span class="number">0.686</span>) + (b * <span class="number">0.168</span>); <span class="comment">// green</span></span><br><span class="line">      d[i + <span class="number">2</span>] = (r * <span class="number">0.272</span>) + (g * <span class="number">0.534</span>) + (b * <span class="number">0.131</span>); <span class="comment">// blue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="红色蒙版效果"><a href="#红色蒙版效果" class="headerlink" title="红色蒙版效果"></a>红色蒙版效果</h4><p>红色蒙版指的是，让图像呈现一种偏红的效果。算法是将红色通道设为红、绿、蓝三个值的平均值，而将绿色通道和蓝色通道都设为0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r = d[i];</span><br><span class="line">    <span class="keyword">var</span> g = d[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> b = d[i + <span class="number">2</span>];</span><br><span class="line">    d[i] = (r + g + b)/<span class="number">3</span>;        <span class="comment">// 红色通道取平均值</span></span><br><span class="line">    d[i + <span class="number">1</span>] = d[i + <span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 绿色通道和蓝色通道都设为0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="亮度效果"><a href="#亮度效果" class="headerlink" title="亮度效果"></a>亮度效果</h4><p>亮度效果（<code>brightness</code>）是指让图像变得更亮或更暗。算法将红色通道、绿色通道、蓝色通道，同时加上一个正值或负值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brightness = <span class="keyword">function</span> (<span class="params">pixels, delta</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    d[i] += delta;     <span class="comment">// red</span></span><br><span class="line">    d[i + <span class="number">1</span>] += delta; <span class="comment">// green</span></span><br><span class="line">    d[i + <span class="number">2</span>] += delta; <span class="comment">// blue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="反转效果"><a href="#反转效果" class="headerlink" title="反转效果"></a>反转效果</h4><p>反转效果（<code>invert</code>）是指图片呈现一种色彩颠倒的效果。算法为红、绿、蓝通道都取各自的相反值（255 - 原值）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">invert = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    d[i] = <span class="number">255</span> - d[i];</span><br><span class="line">    d[i + <span class="number">1</span>] = <span class="number">255</span> - d[i + <span class="number">1</span>];</span><br><span class="line">    d[i + <span class="number">2</span>] = <span class="number">255</span> - d[i + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/Fetch API"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/11/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/Fetch%20API/"
    >Fetch API</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/11/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/Fetch%20API/" class="article-date">
  <time datetime="2022-07-11T08:48:27.000Z" itemprop="datePublished">2022-07-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>fetch()</code>是<code>XMLHttpRequest</code>的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。浏览器原生提供这个对象。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p><code>fetch()</code>的功能与<code>XMLHttpRequest</code>基本相同，但有三个主要的差异。</p>
<ol>
<li><code>fetch()</code>使用<code>Promise</code>，不使用回调函数，因此大大简化了写法，写起来更简洁。</li>
<li><code>fetch()</code>采用模块化设计，API 分散在多个对象上（<code>Response</code>对象、<code>Request</code>对象、<code>Headers</code>对象），更合理一些；相比之下，<code>XMLHttpRequest</code>的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</li>
<li><code>fetch()</code>通过数据流（<code>Stream</code>对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。<code>XMLHTTPRequest</code>对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</li>
</ol>
<p>在用法上，<code>fetch()</code>接受一个<code>URL</code>字符串作为参数，默认向该网址发出<code>GET</code>请求，返回一个<code>Promise</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure>
<p>下面是一个例子，从服务器获取 JSON 数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, err)); </span><br></pre></td></tr></table></figure>
<p>上面示例中，<code>fetch()</code>接收到的<code>response</code>是一个<code>Stream</code>对象，<code>response.json()</code>是一个异步操作，取出所有内容，并将其转为 JSON 对象。</p>
<p><code>Promise</code>可以使用<code>await</code>语法改写，使得语义更清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，<code>await</code>语句必须放在<code>try...catch</code>里面，这样才能捕捉异步操作中可能发生的错误。</p>
<h1 id="Response-对象：处理-HTTP-回应"><a href="#Response-对象：处理-HTTP-回应" class="headerlink" title="Response 对象：处理 HTTP 回应"></a>Response 对象：处理 HTTP 回应</h1><h2 id="Response-对象的同步属性"><a href="#Response-对象的同步属性" class="headerlink" title="Response 对象的同步属性"></a>Response 对象的同步属性</h2><p><code>fetch()</code>请求成功以后，得到的是一个<code>Response</code>对象。它对应服务器的 HTTP 回应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br></pre></td></tr></table></figure>
<p><code>Response</code>包含的数据通过<code>Stream</code>接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（<code>Headers</code>），可以立即读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/readme.txt&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，<code>response.status</code>和<code>response.statusText</code>就是<code>Response</code>的同步属性，可以立即读取。</p>
<p>标头信息属性有下面这些。</p>
<ul>
<li><code>Response.ok</code><br><code>Response.ok</code>属性返回一个布尔值，表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码。</li>
<li><code>Response.status</code><br><code>Response.status</code>属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。</li>
<li><code>Response.statusText</code><br><code>Response.statusText</code>属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回“OK”）。</li>
<li><code>Response.url</code><br><code>Response.url</code>属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</li>
<li><code>Response.type</code><br><code>Response.type</code>属性返回请求的类型。可能的值如下：</li>
<li><code>basic</code>：普通请求，即同源请求。</li>
<li><code>cors</code>：跨域请求。</li>
<li><code>error</code>：网络错误，主要用于 Service Worker。</li>
<li><code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值。表示发出的是简单的跨域请求，类似<code>&lt;form&gt;</code>表单的那种跨域请求。</li>
<li><code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值，详见请求部分。</li>
<li><code>Response.redirected</code><br><code>Response.redirected</code>属性返回一个布尔值，表示请求是否发生过跳转。</li>
</ul>
<h2 id="判断请求是否成功"><a href="#判断请求是否成功" class="headerlink" title="判断请求是否成功"></a>判断请求是否成功</h2><p><code>fetch()</code>发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。</p>
<p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，<code>fetch()</code>也不会报错（即<code>Promise</code>不会变为<code>rejected</code>状态）。</p>
<p>只有通过<code>Response.status</code>属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/readme.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; response.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(response.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，<code>response.status</code>属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为<code>fetch()</code>会将跳转的状态码自动转为 200。</p>
<p>另一种方法是判断<code>response.ok</code>是否为<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 请求失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Response-headers-属性"><a href="#Response-headers-属性" class="headerlink" title="Response.headers 属性"></a>Response.headers 属性</h2><p><code>Response</code>对象还有一个<code>Response.headers</code>属性，指向一个<code>Headers</code>对象，对应 HTTP 回应的所有标头。</p>
<p><code>Headers</code>对象可以使用<code>for...of</code>循环进行遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.<span class="property">headers</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> : <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.<span class="property">headers</span>.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> : <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Headers</code>对象提供了以下方法，用来操作标头。</p>
<ul>
<li><code>Headers.get()</code>：根据指定的键名，返回键值。</li>
<li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头。</li>
<li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加。</li>
<li><code>Headers.append()</code>：添加标头。</li>
<li><code>Headers.delete()</code>：删除标头。</li>
<li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名。</li>
<li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值。</li>
<li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（[key, value]）。</li>
<li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数。</li>
</ul>
<p>上面的有些方法可以修改标头，那是因为继承自<code>Headers</code>接口。对于 HTTP 回应来说，修改标头意义不大，况且很多标头是只读的，浏览器不允许修改。</p>
<p>这些方法中，最常用的是<code>response.headers.get()</code>，用于读取某个标头的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response =  <span class="keyword">await</span>  <span class="title function_">fetch</span>(url);</span><br><span class="line">response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Content-Type&#x27;</span>)</span><br><span class="line"><span class="comment">// application/json; charset=utf-8</span></span><br></pre></td></tr></table></figure>
<p>Headers.keys()和Headers.values()方法用来分别遍历标头的键名和键值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键名</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> myHeaders.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myHeaders.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Headers</span>.<span class="title function_">forEach</span>()方法也可以遍历所有的键值和键名。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">response.<span class="property">headers</span>.<span class="title function_">forEach</span>(</span><br><span class="line">  <span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;:&#x27;</span>, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="读取内容的方法"><a href="#读取内容的方法" class="headerlink" title="读取内容的方法"></a>读取内容的方法</h2><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p>
<ul>
<li><code>response.text()</code>：得到文本字符串。</li>
<li><code>response.json()</code>：得到 JSON 对象。</li>
<li><code>response.blob()</code>：得到二进制<code>Blob</code>对象。</li>
<li><code>response.formData()</code>：得到<code>FormData</code>表单对象。</li>
<li><code>response.arrayBuffer()</code>：得到二进制<code>ArrayBuffer</code>对象。</li>
</ul>
<p>上面5个读取方法都是异步的，返回的都是<code>Promise</code>对象。必须等到异步操作结束，才能得到服务器返回的完整数据。</p>
<h4 id="response-text"><a href="#response-text" class="headerlink" title="response.text()"></a>response.text()</h4><p><code>response.text()</code>可以用于获取文本数据，比如 HTML 文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users.html&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> body = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = body</span><br></pre></td></tr></table></figure>
<h4 id="response-json"><a href="#response-json" class="headerlink" title="response.json()"></a>response.json()</h4><p><code>response.json()</code>主要用于获取服务器返回的 JSON 数据。</p>
<h4 id="response-formData"><a href="#response-formData" class="headerlink" title="response.formData()"></a>response.formData()</h4><p><code>response.formData()</code>主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。</p>
<h4 id="response-blob"><a href="#response-blob" class="headerlink" title="response.blob()"></a>response.blob()</h4><p><code>response.blob()</code>用于获取二进制文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>();</span><br><span class="line"><span class="keyword">const</span> objectURL = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">myImage.<span class="property">src</span> = objectURL;</span><br></pre></td></tr></table></figure>
<p>上面示例读取图片文件<code>flower.jpg</code>，显示在网页上。</p>
<h4 id="response-arrayBuffer"><a href="#response-arrayBuffer" class="headerlink" title="response.arrayBuffer()"></a>response.arrayBuffer()</h4><p><code>response.arrayBuffer()</code>主要用于获取流媒体文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioCtx = <span class="keyword">new</span> <span class="variable language_">window</span>.<span class="title class_">AudioContext</span>();</span><br><span class="line"><span class="keyword">const</span> source = audioCtx.<span class="title function_">createBufferSource</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;song.ogg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodeData = <span class="keyword">await</span> audioCtx.<span class="title function_">decodeAudioData</span>(buffer);</span><br><span class="line">source.<span class="property">buffer</span> = buffer;</span><br><span class="line">source.<span class="title function_">connect</span>(audioCtx.<span class="property">destination</span>);</span><br><span class="line">source.<span class="property">loop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>上面示例是<code>response.arrayBuffer()</code>获取音频文件<code>song.ogg</code>，然后在线播放的例子。</p>
<h2 id="Response-clone"><a href="#Response-clone" class="headerlink" title="Response.clone()"></a>Response.clone()</h2><p><code>Stream</code>对象只能读取一次，读取完就没了。这意味着，前面的五个读取方法，只能使用一个，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text =  <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line"><span class="keyword">let</span> json =  <span class="keyword">await</span> response.<span class="title function_">json</span>();  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面示例先使用了<code>response.text()</code>，就把<code>Stream</code>读完了。后面再调用<code>response.json()</code>，就没有内容可读了，所以报错。</p>
<p><code>Response</code>对象提供<code>Response.clone()</code>方法，创建<code>Response</code>对象的副本，实现多次读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flowers.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> response2 = response1.<span class="title function_">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBlob1 = <span class="keyword">await</span> response1.<span class="title function_">blob</span>();</span><br><span class="line"><span class="keyword">const</span> myBlob2 = <span class="keyword">await</span> response2.<span class="title function_">blob</span>();</span><br><span class="line"></span><br><span class="line">image1.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob1);</span><br><span class="line">image2.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob2);</span><br></pre></td></tr></table></figure>
<p>上面示例中，<code>response.clone()</code>复制了一份<code>Response</code>对象，然后将同一张图片读取了两次。</p>
<p><code>Response</code>对象还有一个<code>Response.redirect()</code>方法，用于将<code>Response</code>结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面。</p>
<h2 id="Response-body-属性"><a href="#Response-body-属性" class="headerlink" title="Response.body 属性"></a>Response.body 属性</h2><p><code>Response.body</code>属性是<code>Response</code>对象暴露出的底层接口，返回一个<code>ReadableStream</code>对象，供用户操作。</p>
<p>它可以用来分块读取内容，应用之一就是显示下载的进度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，<code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块。</p>
<p>这个对象的<code>done</code>属性是一个布尔值，用来判断有没有读完；<code>value</code>属性是一个<code>arrayBuffer</code>数组，表示内容块的内容，而<code>value.length</code>属性是当前块的大小。</p>
<h1 id="fetch-的第二个参数：定制-HTTP-请求"><a href="#fetch-的第二个参数：定制-HTTP-请求" class="headerlink" title="fetch()的第二个参数：定制 HTTP 请求"></a>fetch()的第二个参数：定制 HTTP 请求</h1><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, optionObj)</span><br></pre></td></tr></table></figure>
<p>上面命令的<code>optionObj</code>就是第二个参数。</p>
<p>HTTP 请求的方法、标头、数据体都在这个对象里面设置。下面是一些示例。</p>
<h2 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br></pre></td></tr></table></figure>
<p>上面示例中，配置对象用到了三个属性。</p>
<ul>
<li><code>method</code>：HTTP 请求的方法，POST、DELETE、PUT 都在这个属性设置。</li>
<li><code>headers</code>：一个对象，用来定制 HTTP 请求的标头。</li>
<li><code>body</code>：POST 请求的数据体。</li>
</ul>
<p>注意，有些标头不能通过<code>headers</code>属性设置，比如<code>Content-Length、Cookie、Host</code>等等。它们是由浏览器自动生成，无法修改。</p>
<h2 id="提交-JSON-数据"><a href="#提交-JSON-数据" class="headerlink" title="提交 JSON 数据"></a>提交 JSON 数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user =  &#123; <span class="attr">name</span>:  <span class="string">&#x27;John&#x27;</span>, <span class="attr">surname</span>:  <span class="string">&#x27;Smith&#x27;</span>  &#125;;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面示例中，标头<code>Content-Type</code>要设成<code>&#39;application/json;charset=utf-8&#39;</code>。因为默认发送的是纯文本，<code>Content-Type</code>的默认值是<code>&#39;text/plain;charset=UTF-8&#39;</code>。</p>
<h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">FormData</span>(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。</p>
<p>另一种方法是用脚本添加文件，构造出一个表单，进行上传。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, input.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/avatars&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上传二进制文件时，不用修改标头的<code>Content-Type</code>，浏览器会自动设置。</p>
<h2 id="直接上传二进制数据"><a href="#直接上传二进制数据" class="headerlink" title="直接上传二进制数据"></a>直接上传二进制数据</h2><p><code>fetch()</code>也可以直接上传二进制数据，将<code>Blob</code>或<code>arrayBuffer</code>数据放在<code>body</code>属性里面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span></span><br><span class="line">  canvasElem.<span class="title function_">toBlob</span>(resolve,  <span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/image&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>:  <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: blob</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="fetch-配置对象的完整-API"><a href="#fetch-配置对象的完整-API" class="headerlink" title="fetch()配置对象的完整 API"></a>fetch()配置对象的完整 API</h1><p><code>fetch()</code>第二个参数的完整 API 如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&quot;about:client&quot;</span>,</span><br><span class="line">  <span class="attr">referrerPolicy</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&quot;follow&quot;</span>,</span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">keepalive</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">signal</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>fetch()</code>请求的底层用的是<code>Request()</code>对象的接口，参数完全一样，因此上面的 API 也是<code>Request()</code>的 API。</p>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p><code>cache</code>属性指定如何处理缓存。可能的取值如下：</p>
<ul>
<li><code>default</code>：默认值，先在缓存里面寻找匹配的请求。</li>
<li><code>no-store</code>：直接请求远程服务器，并且不更新缓存。</li>
<li><code>reload</code>：直接请求远程服务器，并且更新缓存。</li>
<li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。</li>
<li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器。</li>
<li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误。</li>
</ul>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p><code>mode</code>属性指定请求的模式。可能的取值如下：</p>
<ul>
<li><code>cors</code>：默认值，允许跨域请求。</li>
<li><code>same-origin</code>：只允许同源请求。</li>
<li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单、<code>&lt;script&gt;</code>加载脚本、<code>&lt;img&gt;</code>加载图片等传统的跨域请求方法。</li>
</ul>
<h2 id="credentials"><a href="#credentials" class="headerlink" title="credentials"></a>credentials</h2><p><code>credentials</code>属性指定是否发送 Cookie。可能的取值如下：</p>
<ul>
<li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨域请求时不发送。</li>
<li><code>include</code>：不管同源请求，还是跨域请求，一律发送 Cookie。</li>
<li><code>omit</code>：一律不发送。</li>
</ul>
<p>跨域请求发送 Cookie，需要将<code>credentials</code>属性设为<code>include</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://another.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p><code>signal</code>属性指定一个<code>AbortSignal</code>实例，用于取消<code>fetch()</code>请求。</p>
<h2 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h2><p><code>keepalive</code>属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</p>
<p>一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用<code>keepalive</code>属性，数据可能无法发送，因为浏览器已经把页面卸载了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/analytics&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">some</span>: <span class="string">&#x27;data&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">keepalive</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h2><p><code>redirect</code>属性指定 HTTP 跳转的处理方法。可能的取值如下：</p>
<ul>
<li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转。</li>
<li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错。</li>
<li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转。</li>
</ul>
<h2 id="integrity"><a href="#integrity" class="headerlink" title="integrity"></a>integrity</h2><p><code>integrity</code>属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。</p>
<p>比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://site.com/file&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&#x27;sha256-abcdef&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="referrer"><a href="#referrer" class="headerlink" title="referrer"></a>referrer</h2><p><code>referrer</code>属性用于设定<code>fetch()</code>请求的<code>referer</code>标头。</p>
<p>这个属性可以为任意字符串，也可以设为空字符串（即不发送<code>referer</code>标头）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/page&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="referrerPolicy"><a href="#referrerPolicy" class="headerlink" title="referrerPolicy"></a>referrerPolicy</h2><p><code>referrerPolicy</code>属性用于设定<code>Referer</code>标头的规则。可能的取值如下：</p>
<ul>
<li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。</li>
<li><code>no-referrer</code>：不发送<code>Referer</code>标头。</li>
<li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径。</li>
<li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨域请求只包含域名。</li>
<li><code>same-origin</code>：跨域请求不发送<code>Referer</code>，同源请求发送。</li>
<li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头。</li>
<li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头。</li>
<li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头。</li>
</ul>
<h1 id="取消fetch-请求"><a href="#取消fetch-请求" class="headerlink" title="取消fetch()请求"></a>取消fetch()请求</h1><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abort!&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>(); <span class="comment">// 取消</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(signal.<span class="property">aborted</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面示例中，首先新建<code>AbortController</code>实例，然后发送<code>fetch()</code>请求，配置对象的<code>signal</code>属性必须指定接收<code>AbortController</code>实例发送的信号<code>controller.signal</code>。</p>
<p><code>controller.abort()</code>方法用于发出取消信号。这时会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出。</p>
<p>下面是一个1秒后自动取消请求的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/long-operation&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">name</span> == <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Aborted!&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/ES6/ES6 运算符"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/01/%E5%89%8D%E7%AB%AF/ES6/ES6%20%E8%BF%90%E7%AE%97%E7%AC%A6/"
    >ES6 运算符</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/01/%E5%89%8D%E7%AB%AF/ES6/ES6%20%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time datetime="2022-07-01T03:55:09.000Z" itemprop="datePublished">2022-07-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/ES6/">ES6</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h1><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line"><span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p>
<p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.5</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">b **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 等同于 b = b * b * b;</span></span><br></pre></td></tr></table></figure>
<h1 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h1><p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。比如，读取<code>message.body.user.firstName</code>这个属性，安全的写法是写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">const</span>  firstName = message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">  &amp;&amp; message.<span class="property">body</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span>) || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p>
<p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooInput = myForm.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=foo]&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fooValue = fooInput ? fooInput.<span class="property">value</span> : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p>
<p>这样的层层判断非常麻烦，因此 ES2020 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> fooValue = myForm.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[name=foo]&#x27;</span>)?.<span class="property">value</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>
<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator.<span class="property">return</span>?.()</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分。</p>
<p>对于那些可能没有实现的方法，这个运算符尤其有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myForm.<span class="property">checkValidity</span>?.() === <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="comment">// 表单校验失败</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，老式浏览器的表单对象可能没有<code>checkValidity()</code>这个方法，这时<code>?.</code>运算符就会返回<code>undefined</code>，判断语句就变成了<code>undefined === false</code>，所以就会跳过下面的代码。</p>
<p>链判断运算符?<code>.</code>有三种写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj?.<span class="property">prop</span> <span class="comment">// 对象属性是否存在</span></span><br><span class="line">obj?.[expr] <span class="comment">// 同上</span></span><br><span class="line">func?.(...args) <span class="comment">// 函数或对象方法是否存在</span></span><br></pre></td></tr></table></figure>
<p>下面是<code>obj?.[expr]</code>用法的一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hex = <span class="string">&quot;#C0FFEE&quot;</span>.<span class="title function_">match</span>(<span class="regexp">/#([A-Z]+)/i</span>)?.[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>上面例子中，字符串的<code>match()</code>方法，如果没有发现匹配会返回<code>null</code>，如果发现匹配会返回一个数组，<code>?.</code>运算符起到了判断作用。</p>
<p>下面是<code>?.</code>运算符常见形式，以及不使用该运算符时的等价形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a?.<span class="property">b</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="property">b</span></span><br><span class="line"></span><br><span class="line">a?.[x]</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[x]</span><br><span class="line"></span><br><span class="line">a?.<span class="title function_">b</span>()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="title function_">b</span>()</span><br><span class="line"></span><br><span class="line">a?.()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : <span class="title function_">a</span>()</span><br></pre></td></tr></table></figure>
<p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>和<code>a?.()</code>。如果<code>a?.b()</code>里面的a.b有值，但不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</p>
<p>使用这个运算符，有几个注意点。</p>
<h2 id="1-短路机制"><a href="#1-短路机制" class="headerlink" title="1. 短路机制"></a>1. 短路机制</h2><p>本质上，<code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a?.[++x]</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[++x]</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p>
<h2 id="2-括号的影响"><a href="#2-括号的影响" class="headerlink" title="2. 括号的影响"></a>2. 括号的影响</h2><p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a?.<span class="property">b</span>).<span class="property">c</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="property">b</span>).<span class="property">c</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p>
<p>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</p>
<h2 id="3-报错场合"><a href="#3-报错场合" class="headerlink" title="3. 报错场合"></a>3. 报错场合</h2><p>以下写法是禁止的，会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">new</span> a?.()</span><br><span class="line"><span class="keyword">new</span> a?.<span class="title function_">b</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链判断运算符的右侧有模板字符串</span></span><br><span class="line">a?.<span class="string">`&#123;b&#125;`</span></span><br><span class="line">a?.<span class="property">b</span><span class="string">`&#123;c&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链判断运算符的左侧是 super</span></span><br><span class="line"><span class="variable language_">super</span>?.()</span><br><span class="line"><span class="variable language_">super</span>?.<span class="property">foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链运算符用于赋值运算符左侧</span></span><br><span class="line">a?.<span class="property">b</span> = c</span><br></pre></td></tr></table></figure>
<h2 id="4-右侧不得为十进制数值"><a href="#4-右侧不得为十进制数值" class="headerlink" title="4. 右侧不得为十进制数值"></a>4. 右侧不得为十进制数值</h2><p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p>
<h1 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h1><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.<span class="property">settings</span>.<span class="property">headerText</span> || <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>.<span class="property">animationDuration</span> || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.<span class="property">settings</span>.<span class="property">showSplashScreen</span> || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或 0，默认值也会生效。</p>
<p>为了避免这种情况，ES2020 引入了一个新的<code>Null</code>判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.<span class="property">settings</span>.<span class="property">headerText</span> ?? <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>.<span class="property">animationDuration</span> ?? <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.<span class="property">settings</span>.<span class="property">showSplashScreen</span> ?? <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p>
<p>这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>?.<span class="property">animationDuration</span> ?? <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值 300。也就是说，这一行代码包括了两级属性的判断。</p>
<p>这个运算符很适合判断函数参数是否赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> enable = props.<span class="property">enabled</span> ?? <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，基本等同于下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">enabled</span>: enable = <span class="literal">true</span>,</span><br><span class="line">  &#125; = props;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>??</code>本质上是逻辑运算，它与其他两个逻辑运算符<code>&amp;&amp;</code>和<code>||</code>有一个优先级问题，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同。</p>
<p>现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">lhs &amp;&amp; middle ?? rhs</span><br><span class="line">lhs ?? middle &amp;&amp; rhs</span><br><span class="line">lhs || middle ?? rhs</span><br><span class="line">lhs ?? middle || rhs</span><br></pre></td></tr></table></figure>
<p>上面四个表达式都会报错，必须加入表明优先级的括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(lhs &amp;&amp; middle) ?? rhs;</span><br><span class="line">lhs &amp;&amp; (middle ?? rhs);</span><br><span class="line"></span><br><span class="line">(lhs ?? middle) &amp;&amp; rhs;</span><br><span class="line">lhs ?? (middle &amp;&amp; rhs);</span><br><span class="line"></span><br><span class="line">(lhs || middle) ?? rhs;</span><br><span class="line">lhs || (middle ?? rhs);</span><br><span class="line"></span><br><span class="line">(lhs ?? middle) || rhs;</span><br><span class="line">lhs ?? (middle || rhs);</span><br></pre></td></tr></table></figure>
<h1 id="逻辑赋值运算符"><a href="#逻辑赋值运算符" class="headerlink" title="逻辑赋值运算符"></a>逻辑赋值运算符</h1><p>ES2021 引入了三个新的逻辑赋值运算符，将逻辑运算符与赋值运算符进行结合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或赋值运算符</span></span><br><span class="line">x ||= y</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x || (x = y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与赋值运算符</span></span><br><span class="line">x &amp;&amp;= y</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x &amp;&amp; (x = y)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Null 赋值运算符</span></span><br><span class="line">x ??= y</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">x ?? (x = y)</span><br></pre></td></tr></table></figure>
<p>这三个运算符<code>||=、&amp;&amp;=、??=</code>相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。</p>
<p>它们的一个用途是，为变量或属性设置默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老的写法</span></span><br><span class="line">user.<span class="property">id</span> = user.<span class="property">id</span> || <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的写法</span></span><br><span class="line">user.<span class="property">id</span> ||= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上面示例中，<code>user.id</code>属性如果不存在，则设为 1，新的写法比老的写法更紧凑一些。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">opts</span>) &#123;</span><br><span class="line">  opts.<span class="property">foo</span> = opts.<span class="property">foo</span> ?? <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  opts.<span class="property">baz</span> ?? (opts.<span class="property">baz</span> = <span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面示例中，参数对象<code>opts</code>如果不存在属性<code>foo</code>和属性<code>baz</code>，则为这两个属性设置默认值。有了“<code>Null</code>赋值运算符”以后，就可以统一写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">opts</span>) &#123;</span><br><span class="line">  opts.<span class="property">foo</span> ??= <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  opts.<span class="property">baz</span> ??= <span class="string">&#x27;qux&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/SpringBoot注解分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/"
    >SpringBoot注解分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2022-01-25T09:17:16.000Z" itemprop="datePublished">2022-01-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Boot/">Spring Boot</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>首先，先看 SpringBoot 的主配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进<code>@SpringBootApplication</code>来看，发现<code>@SpringBootApplication</code>是一个组合注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先来看<code>@SpringBootConfiguration</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个注解除了元注解以外，就只有一个<code>@Configuration</code>，那也就是说这个注解相当于<code>@Configuration</code>，所以这两个注解作用是一样的，它让我们能够去注册一些额外的<code>Bean</code>，并且导入一些额外的配置。</p>
<p><code>@Configuration</code>还有一个作用就是把该类变成一个配置类，不需要额外的 XML 进行配置。所以<code>@SpringBootConfiguration</code>就相当于<code>@Configuration</code>。进入<code>@Configuration</code>，发现<code>@Configuration</code>核心是<code>@Component</code>，说明 Spring 的配置类也是 Spring 的一个组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">  <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">  String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看下一个<code>@EnableAutoConfiguration</code>，这个注解是开启自动配置的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它是由<code>@AutoConfigurationPackage</code>，<code>@Import</code>这两个而组成的，我们先说<code>@AutoConfigurationPackage</code>，他是说：让包中的类以及子包中的类能够被自动扫描到 Spring 容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>@Import</code>来给 Spring 容器中导入一个组件 ，这里导入的是<code>Registrar.class</code>。来看下这个<code>Registrar</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Registrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class="line">  Registrar() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    AutoConfigurationPackages.register(registry, (<span class="keyword">new</span> <span class="title class_">AutoConfigurationPackages</span>.PackageImport(metadata)).getPackageName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">AutoConfigurationPackages</span>.PackageImport(metadata));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是通过以上这个方法获取扫描的包路径。</p>
<p>那<code>metadata</code>是什么呢，可以看到是标注在<code>@SpringBootApplication</code>注解上的<code>DemoApplication</code>，也就是我们的主配置类<code>Application</code>：</p>
<img src="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/1.png" class="">

<p>其实就是将主配置类（即<code>@SpringBootApplication</code>标注的类）的所在包及子包里面所有组件扫描加载到 Spring 容器。因此我们要把<code>DemoApplication</code>放在项目的最高级中（最外层目录）。</p>
<p>看看注解<code>@Import</code>，<code>@Import</code>注解就是给 Spring 容器中导入一些组件，这里传入了一个组件的选择器:<code>AutoConfigurationImportSelector</code>。</p>
<img src="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/2.png" class="">

<p>可以从图中看出<code>AutoConfigurationImportSelector</code>继承了<code>DeferredImportSelector</code>继承了<code>ImportSelector</code>，<code>ImportSelector</code>有一个方法为：<code>selectImports</code>。将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">    <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">AutoConfigurationMetadata</span> <span class="variable">autoConfigurationMetadata</span> <span class="operator">=</span> AutoConfigurationMetadataLoader.loadMetadata(<span class="built_in">this</span>.beanClassLoader);</span><br><span class="line">    AutoConfigurationImportSelector.<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span></span><br><span class="line">    <span class="built_in">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会给容器中导入非常多的自动配置类（<code>xxxAutoConfiguration</code>）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件。</p>
<img src="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/3.png" class="">

<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。那是如何获取到这些配置类的呢，看看下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry</span><br><span class="line">  <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="built_in">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>getCandidateConfigurations()</code>这个方法，他的作用就是引入系统已经加载好的一些类，到底是那些类呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">  List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="built_in">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="built_in">this</span>.getBeanClassLoader());</span><br><span class="line">  Assert.notEmpty(configurations,</span><br><span class="line">  <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> factoryClass.getName();</span><br><span class="line">  <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会从<code>META-INF/spring.factories</code>中获取资源，然后通过<code>Properties</code>加载资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">  MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Enumeration&lt;URL&gt; urls = classLoader !=</span><br><span class="line">        <span class="literal">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">      <span class="type">LinkedMultiValueMap</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> (URL)urls.nextElement();</span><br><span class="line">        <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">          Map.Entry&lt;?, ?&gt; entry = (Map.Entry)var6.next();</span><br><span class="line">          <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> ((String)entry.getKey()).trim();</span><br><span class="line">          String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">          <span class="type">int</span> <span class="variable">var10</span> <span class="operator">=</span> var9.length;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var11</span> <span class="operator">=</span> <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">factoryName</span> <span class="operator">=</span> var9[var11];</span><br><span class="line">            result.add(factoryClassName, factoryName.trim());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cache.put(classLoader, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以知道 SpringBoot 在启动的时候从类路径下的<code>META-INF/spring.factories</code>中获取<code>EnableAutoConfiguration</code>指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。如下图可以发现 Spring 常见的一些类已经自动导入。</p>
<img src="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/4.png" class="">

<p>接下来看<code>@ComponentScan</code>注解，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">  excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">  type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">  classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">  type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">  classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<p>这个注解就是扫描包，然后放入 Spring 容器。</p>
<p>总结下<code>@SpringbootApplication</code>：就是说，他已经把很多东西准备好，具体是否使用取决于我们的程序或者说配置。</p>
<p>接下来继续看<code>run</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下在执行<code>run</code>方法到底有没有用到哪些自动配置的东西，我们点进<code>run</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">  <span class="comment">//计时器</span></span><br><span class="line">  <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">  <span class="built_in">this</span>.configureHeadlessProperty();</span><br><span class="line">  <span class="comment">//监听器</span></span><br><span class="line">  <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args);</span><br><span class="line">  listeners.starting();</span><br><span class="line"></span><br><span class="line">  Collection exceptionReporters;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">    <span class="built_in">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">    <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment);</span><br><span class="line">    <span class="comment">//准备上下文</span></span><br><span class="line">    context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line">    exceptionReporters = <span class="built_in">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">    <span class="comment">//预刷新context</span></span><br><span class="line">    <span class="built_in">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">    <span class="comment">//刷新context</span></span><br><span class="line">    <span class="built_in">this</span>.refreshContext(context);</span><br><span class="line">    <span class="comment">//刷新之后的context</span></span><br><span class="line">    <span class="built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">      (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listeners.started(context);</span><br><span class="line">    <span class="built_in">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">    <span class="built_in">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    listeners.running(context);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">    <span class="built_in">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们关注的就是<code>this.refreshContext(context)</code>; 刷新<code>context</code>，我们点进来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">  refresh(context);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">      <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续点进<code>refresh(context)</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">  Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">  ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他会调用<code>((AbstractApplicationContext) applicationContext).refresh();</code>方法，我们点进来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      initMessageSource();</span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      registerListeners();</span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">      destroyBeans();</span><br><span class="line">      <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line">      <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知，就是一个 Spring 的<code>bean</code>的加载过程。继续来看一个方法叫做<code>onRefresh()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="comment">// For subclasses: do nothing by default.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他在这里并没有直接实现，但是我们找他的具体实现：</p>
<img src="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/5.png" class="">

<p>比如 Tomcat 跟 web 有关，我们可以看到有个<code>ServletWebServerApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onRefresh();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    createWebServer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有一个<code>createWebServer();</code>方法，他是创建 web 容器的，而 Tomcat 不就是 web 容器，那是如何创建的呢，我们继续看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line">  <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">  <span class="keyword">if</span> (webServer == <span class="literal">null</span> &amp;&amp; servletContext == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line">    <span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getSelfInitializer().onStartup(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>factory.getWebServer(getSelfInitializer());</code>他是通过工厂的方式创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ServletWebServerFactory</span> &#123;</span><br><span class="line">  WebServer <span class="title function_">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它是一个接口，为什么会是接口。因为我们不止是 Tomcat 一种 web 容器。</p>
<img src="/2022/01/25/java/SpringBoot/SpringBoot%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90/6.png" class="">

<p>我们看到还有 Jetty，那我们来看<code>TomcatServletWebServerFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> WebServer <span class="title function_">getWebServer</span><span class="params">(ServletContextInitializer... initializers)</span> &#123;</span><br><span class="line">  <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">  <span class="type">File</span> <span class="variable">baseDir</span> <span class="operator">=</span> (<span class="built_in">this</span>.baseDirectory != <span class="literal">null</span>) ? <span class="built_in">this</span>.baseDirectory</span><br><span class="line">      : createTempDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">  tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">  <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="built_in">this</span>.protocol);</span><br><span class="line">  tomcat.getService().addConnector(connector);</span><br><span class="line">  customizeConnector(connector);</span><br><span class="line">  tomcat.setConnector(connector);</span><br><span class="line">  tomcat.getHost().setAutoDeploy(<span class="literal">false</span>);</span><br><span class="line">  configureEngine(tomcat.getEngine());</span><br><span class="line">  <span class="keyword">for</span> (Connector additionalConnector : <span class="built_in">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">    tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">  &#125;</span><br><span class="line">  prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">  <span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这块代码，就是我们要寻找的内置 Tomcat，在这个过程当中，我们可以看到创建 Tomcat 的一个流程。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux/Linux系统服务管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/24/Linux/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"
    >Linux系统服务管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/24/Linux/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-01-24T05:24:31.000Z" itemprop="datePublished">2022-01-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="系统服务及其分类"><a href="#系统服务及其分类" class="headerlink" title="系统服务及其分类"></a>系统服务及其分类</h1><p>系统服务是在后台运行的应用程序，并且可以提供一些本地系统或网络的功能。我们把这些应用程序称作服务。不过，我们有时会看到<code>Daemon</code>的叫法，<code>Daemon</code>的英文原意是”守护神”，在这里是”守护进程”的意思。</p>
<p>守护进程就是为了实现服务、功能的进程。比如，我们的 apache 服务就是服务，它是用来实现 Web 服务的。启动 apache 服务的进程就是<code>httpd</code>这个守护进程（<code>Daemon</code>）。也就是说，守护进程就是服务在后台运行的真实进程。</p>
<h2 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h2><p>Linux 中的服务按照安装方法不同可以分为 RPM 包默认安装的服务和源码包安装的服务两大类。其中，RPM 包默认安装的服务又因为启动与自启动管理方法不同分为独立的服务和基于 xinetd 的服务。</p>
<img src="/2022/01/24/Linux/Linux%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/1.jpg" class="" title="服务分类的关系图">

<p>Linux 中常见的软件包有两种：一种是 RPM 包；另一种是源码包。那么，通过 RPM 包安装的系统服务就是 RPM 包默认安装的服务（Linux 系统也是通过 RPM 包安装的，所以我们把 RPM 包又叫作系统默认包），通过源码包安装的系统服务就是源码包安装的服务。</p>
<p>源码包是开源的，自定义性强，通过编译安装更加适合系统，但是安装速度较慢，编译时容易报错。RPM 包是经过编译的软件包，安装更快速，不易报错，但不再是开源的。</p>
<p>以上这些特点都是软件包本身的特点，但是软件包一旦安装到 Linux 系统上，它们的区别是什么呢？</p>
<p>最主要的区别就是安装位置不同，源码包安装到我们手工指定的位置当中，而 RPM 包安装到系统默认位置当中（可以通过<code>rpm -ql 包名</code>命令查询）。也就是说，RPM 包安装到系统默认位置，可以被服务管理命令识别；但是源码包安装到手工指定位置，当然就不能被服务管理命令识别了（可以手工修改为被服务管理命令识别）。</p>
<p>所以，RPM 包默认安装的服务和源码包安装的服务的管理方法不同，我们把它们当成不同的服务分类。服务分类说明如下。</p>
<p>RPM 包默认安装的服务。这些服务是通过 RPM 包安装的，可以被服务管理命令识别。</p>
<p>这些服务又可以分为两种：</p>
<ul>
<li>独立的服务：就是独立启动的意思，这种服务可以自行启动，而不用依赖其他的管理服务。因为不依赖其他的管理服务，所以，当客户端请求访问时，独立的服务响应请求更快速。目前，Linux 中的大多数服务都是独立的服务，如 apache 服务、FTP 服务、Samba 服务等。</li>
<li>基于 xinetd 的服务：这种服务就不能独立启动了，而要依靠管理服务来调用。这个负责管理的服务就是 xinetd 服务。xinetd 服务是系统的超级守护进程，其作用就是管理不能独立启动的服务。当有客户端请求时，先请求 xinetd 服务，由 xinetd 服务去唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动 xinetd 服务，而其他基于 xinetd 的服务只有在需要时才被启动，不会占用过多的服务器资源。但是这种服务由于在有客户端请求时才会被唤醒，所以响应时间相对较长。</li>
</ul>
<p>源码包安装的服务。这些服务是通过源码包安装的，所以安装位置都是手工指定的。由于不能被系统中的服务管理命令直接识别，所以这些服务的启动与自启动方法一般都是源码包设计好的。每个源码包的启动脚本都不一样，一般需要查看说明文档才能确定。</p>
<h2 id="查询已经安装的服务和区分服务"><a href="#查询已经安装的服务和区分服务" class="headerlink" title="查询已经安装的服务和区分服务"></a>查询已经安装的服务和区分服务</h2><p>首先要区分 RPM 包默认安装的服务和源码包安装的服务。源码包安装的服务是不能被服务管理命令直接找到的，而且一般会安装到<code>/usr/local/</code>目录中。</p>
<p>也就是说，在<code>/usr/local/</code>目录中的服务都应该是通过源码包安装的服务。RPM 包默认安装的服务都会安装到系统默认位置，所以是可以被服务管理命令（如<code>service、chkconfig</code>）识别的。</p>
<p>其次，在 RPM 包默认安装的服务中怎么区分独立的服务和基于 xinetd 的服务？这就要依靠<code>chkconfig</code>命令了。<code>chkconfig</code>是管理 RPM 包默认安装的服务的自启动的命令。使用这条命令还能看到 RPM 包默认安装的所有服务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list [服务名]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>--list</code>：列出 RPM 包默认安装的所有服务的自启动状态；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig -list</span><br><span class="line">#列出系统中RPM包默认安装的所有服务的自启动状态</span><br><span class="line">abrt-ccpp 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭</span><br><span class="line">abrt-oops 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭</span><br><span class="line">…省略部分输出…</span><br><span class="line">udev-post 0:关闭 1:启用 2:启用 3:启用 4:启用 5:启用 6:关闭</span><br><span class="line">ypbind 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭</span><br></pre></td></tr></table></figure>
<p>这条命令的第一列为服务的名称，后面的<code>0~6</code>代表在不同的运行级别中这个服务是否开启时自动启动。这些服务都是独立的服务，因为它们不需要依赖其他任何服务就可以在相应的运行级别启动或自启动。但是没有看到基于 xinetd 的服务，那是因为系统中默认没有安装 xinetd 这个超级守护进程，需要我们手工安装。 </p>
<p>安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -ivh /mnt/cdrom/Packages/xinetd-2.3.14-34.el6.i686.rpm</span><br><span class="line">Preparing...</span><br><span class="line">###############</span><br><span class="line">[100%]</span><br><span class="line">1:xinetd</span><br><span class="line">###############</span><br><span class="line">[100%]</span><br><span class="line">#xinetd超级守护进程</span><br></pre></td></tr></table></figure>
<p>在 Linux 中基于 xinetd 的服务越来越少，原先很多基于 xinetd 的服务在新版本的 Linux 中已经变成了独立的服务。安装完 xinetd 超级守护进程之后，我们再查看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list</span><br><span class="line">abrt-ccpp 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭</span><br><span class="line">abrt-oops 0:关闭 1:关闭 2:关闭 3:启用 4:关闭 5:启用 6:关闭</span><br><span class="line">…省略部分输出…</span><br><span class="line">udev-post 0:关闭 1:启用 2:启用 3：启用 4:启用 5:启用 6:关闭</span><br><span class="line">xinetd 0:关闭 1:关闭 2:关闭 3:启用 4:启用 5:启用 6:关闭</span><br><span class="line">ypbind 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭</span><br><span class="line">基于 xinetd 的服务：</span><br><span class="line">chargen-dgram：关闭</span><br><span class="line">chargen-stream：关闭</span><br><span class="line">cvs：关闭</span><br><span class="line">daytime-dgram：关闭</span><br><span class="line">daytime-stream：关闭</span><br><span class="line">discard-dgram：关闭</span><br><span class="line">discard-stream：关闭</span><br><span class="line">echo-dgram：关闭</span><br><span class="line">echo-stream：关闭</span><br><span class="line">rsync：关闭</span><br><span class="line">tcpmux-server：关闭</span><br><span class="line">time-dgram：关闭</span><br><span class="line">time-stream：关闭</span><br></pre></td></tr></table></figure>
<p>在刚刚的独立的服务之下出现了一些基于 xinetd 的服务，这些服务没有自己的运行级别，因为它们不是独立的服务，到底在哪个运行级别可以自启动，则要看 xinetd 服务是在哪个运行级别自启动的。</p>
<h1 id="linux端口"><a href="#linux端口" class="headerlink" title="linux端口"></a>linux端口</h1><p>服务是给系统提供功能的，在系统中除了有系统服务，还有网络服务。而每个网络服务都有自己的端口，一般端口号都是固定的。</p>
<p>计算机中的协议主要分为两大类：</p>
<ul>
<li>面向连接的可靠的TCP协议；</li>
<li>面向无连接的不可靠的UDP协议；</li>
</ul>
<p>这两种协议都支持 $2^{16}$，也就是 65535 个端口。系统给我们提供了服务与端口的对应文件<code>/etc/services</code>。</p>
<h2 id="查询系统中已经启动的服务"><a href="#查询系统中已经启动的服务" class="headerlink" title="查询系统中已经启动的服务"></a>查询系统中已经启动的服务</h2><p>既然每个网络服务对应的端口是固定的，那么就可以通过查询服务器中开启的端口，来判断当前服务器开启了哪些服务。</p>
<p>虽然判断服务器中开启的服务还有其他方法（如通过<code>ps</code>命令），但是通过端口的方法查看最为准确。命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># netstat 选项</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-a</code>：列出系统中所有网络连接，包括已经连接的网络服务、监听的网络服务和 Socket 套接字；</li>
<li><code>-t</code>：列出 TCP 数据；</li>
<li><code>-u</code>：列出 UDP 数据；</li>
<li><code>-l</code>：列出正在监听的网络服务（不包含已经连接的网络服务）；</li>
<li><code>-n</code>：用端口号来显示而不用服务名；</li>
<li><code>-p</code>：列出该服务的进程 ID (PID)；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># netstat -tlunp</span></span><br><span class="line"><span class="comment">#列出系统中所有已经启动的服务（已经监听的端口），但不包含已经连接的网络服务</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      1204/redis-server 1 </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      1257/nginx: master  </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1191/sshd           </span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      1606/mysqld         </span><br><span class="line">tcp6       0      0 ::1:6379                :::*                    LISTEN      1204/redis-server 1 </span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      1253/java           </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN      1191/sshd           </span><br><span class="line">udp        0      0 127.0.0.1:323           0.0.0.0:*                           898/chronyd         </span><br><span class="line">udp6       0      0 ::1:323                 :::*                                898/chronyd     </span><br></pre></td></tr></table></figure>
<p>执行这条命令会看到服务器上所有已经开启的端口，也就是说，通过这些端口就可以知道当前服务器上开启了哪些服务。</p>
<p>命令的执行结果：</p>
<ul>
<li><code>Proto</code>：数据包的协议。分为 TCP 和 UDP 数据包；</li>
<li><code>Recv-Q</code>：表示收到的数据已经在本地接收缓冲，但是还没有被进程取走的数据包数量；</li>
<li><code>Send-Q</code>：对方没有收到的数据包数量；或者没有<code>Ack</code>回复的，还在本地缓冲区的数据包数量；</li>
<li><code>Local Address</code>：本地 IP: 端口。通过端口可以知道本机开启了哪些服务；</li>
<li><code>Foreign Address</code>：远程主机：端口。也就是远程是哪个 IP、使用哪个端口连接到本机。由于这条命令只能查看监听端口，所以没有 IP 连接到到本机；</li>
<li><code>State</code>：连接状态。主要有已经建立连接（<code>ESTABLISED</code>）和监听（<code>LISTEN</code>）两种状态，当前只能查看监听状态；</li>
<li><code>PID/Program name</code>：进程 ID 和进程命令；</li>
</ul>
<h1 id="独立服务管理（RPM包的启动与自启动）"><a href="#独立服务管理（RPM包的启动与自启动）" class="headerlink" title="独立服务管理（RPM包的启动与自启动）"></a>独立服务管理（RPM包的启动与自启动）</h1><p>RPM 包默认安装的服务分为独立的服务和基于 xinetd 的服务。</p>
<h2 id="独立服务的启动管理"><a href="#独立服务的启动管理" class="headerlink" title="独立服务的启动管理"></a>独立服务的启动管理</h2><p>独立的服务要想启动，主要有两种方法。</p>
<h3 id="1-使用-x2F-etc-x2F-init-d-x2F-目录中的启动脚本来启动独立的服务"><a href="#1-使用-x2F-etc-x2F-init-d-x2F-目录中的启动脚本来启动独立的服务" class="headerlink" title="1.使用&#x2F;etc&#x2F;init.d&#x2F;目录中的启动脚本来启动独立的服务"></a>1.使用&#x2F;etc&#x2F;init.d&#x2F;目录中的启动脚本来启动独立的服务</h3><p>所有独立服务的启动脚本都存放在<code>/etc/init.d/</code>目录中，那么，调用这些脚本就可以启动独立的服务了。这种启动方式是推荐启动方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#/etc/init.d独立服务名 start| stop|status|restart|...</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><code>start</code>：启动服务；</li>
<li><code>stop</code>：停止服务；</li>
<li><code>status</code>：查看服务状态；</li>
<li><code>restart</code>：重启动服务；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /etc/init.d/httpd start</span><br><span class="line">正在启动httpd:</span><br><span class="line">[确定]</span><br><span class="line">#启动httpd服务</span><br><span class="line">[root@localhost ~]# /etc/init.d/httpd status</span><br><span class="line">httpd (pid 13313)正在运行…</span><br><span class="line">#查询httpd服务状态，并能够看到httpd服务的PID</span><br><span class="line">[root@localhost ~]#/etc/init.d/httpd stop</span><br><span class="line">停止 httpd:</span><br><span class="line">[确定]</span><br><span class="line">#停止httpd服务</span><br><span class="line">[root@localhost ~]#/etc/init.d/httpd restart</span><br><span class="line">停止httpd:</span><br><span class="line">[失败]</span><br><span class="line">正在启动httpd:</span><br><span class="line">[确定]</span><br><span class="line">重启动httpd服务</span><br></pre></td></tr></table></figure>
<h3 id="2-使用service命令来启动独立的服务"><a href="#2-使用service命令来启动独立的服务" class="headerlink" title="2.使用service命令来启动独立的服务"></a>2.使用service命令来启动独立的服务</h3><p>在 CentOS 系统中，我们还可以依赖<code>service</code>命令来启动独立的服务。<code>service</code>命令实际上只是一个脚本，这个脚本仍然需要调用<code>/etc/init.d/</code>中的启动脚本来启动独立的服务。而且<code>service</code>命令是红帽系列 Linux 的专有命令，其他的 Linux 发行版本不一定拥有这条命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service 独立服务名 start|stop|restart|...</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service httpd restart</span><br><span class="line">停止httpd:</span><br><span class="line">[确定]</span><br><span class="line">正在启动httpd:</span><br><span class="line">[确定]</span><br></pre></td></tr></table></figure>
<p>命令比输入<code>/etc/init.d/</code>目录要稍微简单。<code>service</code>命令还可以查看所有独立服务的启动状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service --status-all</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>--status-all</code>：列出所有独立服务的启动状态;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abrtd(pid 1505)正在运行…</span><br><span class="line">abrt-dumpoops(pid 1513)正在运行…</span><br><span class="line">acpid(pid 1312)正在运行...</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
<p>随着<code>httpd</code>服务的启动和停止，使用<code>netstat -tlun</code>命令就会看到 80 端口出现和消失。这也就说明 apache 服务绑定的口就是 80，所以我们可以端口是否在服务器中出现来判断 apache 服务是否启动。</p>
<h2 id="独立服务的自启动管理"><a href="#独立服务的自启动管理" class="headerlink" title="独立服务的自启动管理"></a>独立服务的自启动管理</h2><p>自启动指的是在系统之后，服务是否随着系统的启动而自动启动。如果启动了某个服务，那么这个服务会在系统重启之后启动吗？</p>
<p>答案是不知道，因为启动命令只负责启动服务，而和服务的自启动完全没有关系。同样地，自启动命令只管服务是否会在系统重启之后启动，而和当前系统中的服务是否启动没有关系。</p>
<p>独立服务的自启动方法有三种。</p>
<h3 id="1-使用-chkconfig-服务自启动管理命令"><a href="#1-使用-chkconfig-服务自启动管理命令" class="headerlink" title="1.使用 chkconfig 服务自启动管理命令"></a>1.使用 chkconfig 服务自启动管理命令</h3><p>第一种方法是利用<code>chkconfig</code>服务自启动管理命令来管理独立服务的自启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list</span><br></pre></td></tr></table></figure>
<p>使用<code>chkconfig</code>命令除了可以查看所有 RPM 包默认安装服务的自启动状态，也可以修改和设置 RPM 包默认安装服务的自启动状态，只是独立的服务和基于 xinetd 的服务的设定方法稍有不同。我们先来看看独立的服务如何设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig [--level 运行级别][独立服务名][on|off]</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>--level</code>: 设定在哪个运行级别中开机自启动（<code>on</code>），或者关闭自启动（<code>off</code>）；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list | grep httpd</span><br><span class="line">httpd 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭</span><br><span class="line">#查询httpd的自启动状态。所有的级别都是不自启动的</span><br><span class="line">[root@localhost ~]# chkconfig --level 2345 httpd on</span><br><span class="line">#设置apache服务在进入2、3、4、5级别时自启动</span><br><span class="line">[root@localhost ~]# chkconfig --list | grep httpd</span><br><span class="line">httpd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭</span><br><span class="line">#查询apache服务的自启动状态。发现在2、3、4、5这4个运行级别中变为了&quot;启用&quot;</span><br></pre></td></tr></table></figure>
<p>如果在<code>0~6</code>这 7 个运行级别中服务都显示”关闭”，则该服务不自启动。如果在某个运行级别中显示”启用”，则代表在进入这个运行级别时，该服务开机自启动。</p>
<p>服务的自启动方法和服务的启动方法是不通用的。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /etc/init.d/httpd status</span><br><span class="line">httpd已停</span><br><span class="line">#查询apache服务状态，是已经停止的</span><br><span class="line">[root@localhost ~]# chkconfig --level 2345 httpd on</span><br><span class="line">#设置apache服务在进入2、3、4、5级别时自启动</span><br><span class="line">[root@localhost ~]# chkconfig --list|grep httpd</span><br><span class="line">httpd 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭</span><br><span class="line">#查看一下，自启动已经生效</span><br><span class="line">[root@localhost ~]#/etc/init.d/httpd status</span><br><span class="line">httpd已停</span><br><span class="line">#但是apache服务在当前系统中还是关闭的</span><br></pre></td></tr></table></figure>
<p>虽然 apache 被设置为自启动，但是当前系统中的 apache 是没有启动的，所以启动和自启动是独立的。</p>
<h3 id="2-修改-x2F-etc-x2F-rc-d-x2F-rc-local-文件，设置服务自启动"><a href="#2-修改-x2F-etc-x2F-rc-d-x2F-rc-local-文件，设置服务自启动" class="headerlink" title="2.修改 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 文件，设置服务自启动"></a>2.修改 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 文件，设置服务自启动</h3><p>第二种方法就是修改<code>/etc/rc.d/rc.local</code>文件，在文件中加入服务的启动命令。这个文件是在系统启动时，在输入用户名和密码之前最后读取的文件（注意：<code>/etc/rc.d/rc.loca</code>和<code>/etc/rc.local</code>文件是软链接，修改哪个文件都可以）。这个文件中有什么命令，都会在系统启动时调用。</p>
<p>如果我们把服务的启动命令放入这个文件，这个服务就会在开机时自启动。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vi /etc/rc.d/rc.local</span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line">#This script will be executed *after* all the other init scripts.</span><br><span class="line">#You can put your own initialization stuff in here if you don&#x27;t want to do the full Sys V style init stuff.</span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br><span class="line">#在文件中加入apache的启动命令</span><br></pre></td></tr></table></figure>
<p>这样，只要重启之后，apache 服务就会开机自启动了。推荐大家使用这种方法管理服务的自启动，有两点好处：</p>
<ul>
<li>第一，如果大家都采用这种方法管理服务的自启动，当我们碰到一台陌生的服务器时，只要查看这个文件就知道这台服务器到底自启动了哪些服务，便于集中管理。</li>
<li>第二，<code>chkconfig</code>命令只能识别 RPM 包默认安装的服务，而不能识别源码包安装的服务。 源码包安装的服务的自启动也是通过<code>/etc/rc.d/rc.local</code>文件实现的，所以不会出现同一台服务器自启动了两种安装方法的同一个服务。</li>
</ul>
<p>还要注意一下，修改<code>/etc/rc.d/rc.local</code>配置文件的自启动方法和<code>chkconfig</code>命令的自启动方法是两种不同的自启动方法。所以，就算通过修改<code>/etc/rc.d/rc.local</code>配置文件的方法让某个独立的服务自启动了，执行<code>chkconfig --list</code>命令并不到有什么变化。</p>
<h1 id="源码包服务管理"><a href="#源码包服务管理" class="headerlink" title="源码包服务管理"></a>源码包服务管理</h1><h2 id="源码包服务的启动管理"><a href="#源码包服务的启动管理" class="headerlink" title="源码包服务的启动管理"></a>源码包服务的启动管理</h2><p>源码包服务中所有的文件都会安装到指定目录当中，并且没有任何垃圾文件产生（Linux 的特性），所以服务的管理脚本程序也会安装到指定目录中。源码包服务的启动管理方式就是在服务的安装目录中找到管理脚本，然后执行这个脚本。</p>
<p>我们用 apache 服务来举例。一般 apache 服务的安装位置是<code>/usr/local/apache2/</code>目录，那么 apache 服务的启动脚本就是<code>/usr/local/apache2/bin/apachectl</code>文件（查询 apache 说明文档得知）。启动命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...</span><br><span class="line">#源码包服务的启动管理</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachectl start</span><br><span class="line">#会启动源码包安装的apache服务</span><br></pre></td></tr></table></figure>
<p>注意，不管是源码包安装的 apache，还是 RPM 包默认安装的 apache，虽然在一台服务器中都可以安装，但是只能启动一个，因为它们都会占用 80 端口。</p>
<p>源码包服务的启动方法就这一种，比 RPM 包默认安装的服务要简单一些。</p>
<h2 id="源码包服务的自启动管理"><a href="#源码包服务的自启动管理" class="headerlink" title="源码包服务的自启动管理"></a>源码包服务的自启动管理</h2><p>源码包服务的白启动管理也不能依靠系统的服务管理命令，而只能把标准启动命令写入<code>/etc/rc.d/rc.local</code>文件中。系统在启动过程中读取<code>/etc/rc.d/rc.local</code>文件时，就会调用源码包服务的启动脚本，从而让该服务开机自启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/rc.d/rc.local</span><br><span class="line">#修改自启动文件</span><br><span class="line">#!/bin/sh</span><br><span class="line">#This script will be executed *after* all the other init scripts.</span><br><span class="line">#You can put your own initialization stuff in here if you don11</span><br><span class="line">#want to do the full Sys V style init stuff.</span><br><span class="line">touch /var/lock/subsys/local /usr/local/apache2/bin/apachectl start</span><br><span class="line">#加入源码包服务的标准启动命令，保存退出，源码包安装的apache服务就被设为自启动了</span><br></pre></td></tr></table></figure>
<h2 id="让源码包服务被服务管理命令识别"><a href="#让源码包服务被服务管理命令识别" class="headerlink" title="让源码包服务被服务管理命令识别"></a>让源码包服务被服务管理命令识别</h2><p>在默认情况下，源码包服务是不能被系统的服务管理命令所识别和管理的，但是如果我们做一些设定，则也是可以让源码包服务被系统的服务管理命令所识别和管理的。不过并不推荐这样做，因为这会让本来区别很明确的源码包服务和 RPM 包服务变得容易混淆，不利于系统维护和管理。</p>
<p>我们做一个实验，看看如何把源码包安装的 apache 服务变为和 RPM 包默认安装的 apache 服务一样，可以被<code>service、chkconfig、ntsysv</code>命令所识别。实验如下：</p>
<ol>
<li>卸载RPM包默认安装的apache服务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y remove httpd</span><br><span class="line">#卸载RPM包默认安装的apache服务,避免对实验产生影响（在生产服务器上慎用yum卸载，因为这有可能造成服务器崩溃)</span><br><span class="line">[root@localhost ~]# service httpd start httpd:未被识别的服务</span><br><span class="line">#因为服务被卸载,所以service命令不能识别httpd服务</span><br></pre></td></tr></table></figure></li>
<li>安装源码包的apache服务，并启动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#安装源码包的apache服务</span><br><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachect1 start</span><br><span class="line">[root@localhost ~]# netstat -tlun | grep 80</span><br><span class="line">tcp 0 0 :::80 :::* LISTEN</span><br><span class="line">#启动源码包安装的apache服务，查看端口确定已经启动</span><br></pre></td></tr></table></figure></li>
<li>让源码包安装的apache服务能被<code>service</code>命令管理启动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache</span><br><span class="line">#service命令其实只是在/etc/init.d/目录中查找是否有服务的启动脚本，所以我们只需要做一个软链接,</span><br><span class="line">#把源码包的启动脚本链接到/etc/init.d/目录中,就能被service命令所管理了。</span><br><span class="line">#为了照顾大家的习惯，我把软链接文件命名为apache,注意这不是RPM包默认安装的apache服务</span><br><span class="line">[root@localhost ~]# service apache restart</span><br><span class="line">#虽然RPM包默认安装的apache服务被卸载了,但是service命令也能够生效</span><br></pre></td></tr></table></figure></li>
<li>让源码包安装的apache服务能被<code>chkconfig</code>命令管理自启动<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/init.d/apache</span><br><span class="line">#修改源码包安装的apache服务的启动脚本(注意此文件是软链接,所以修改的还是源码包启动脚本)</span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line">#chkconfig: 35 86 76</span><br><span class="line">#指定httpd脚本可以被chkconfig命令所管理</span><br><span class="line">#格式是：chkconfig：运行级别 启动顺序 关闭顺序</span><br><span class="line">#这里我们让apache服务在3和5级别中能被chkconfig命令所管理，启动顺序是S86，关闭顺序是K76</span><br><span class="line">#(自定顺序，不要和系统中已有的启动顺序冲突)</span><br><span class="line">#description: source package apache</span><br><span class="line">#说明，内容随意</span><br><span class="line">#以上两句话必须加入,才能被chkconfig命令所识别 ...省略部分输出...</span><br><span class="line">[root@localhost ~]# chkconfig --add apache</span><br><span class="line">#让chkconfig命令能够管理源码包安装的apache服务</span><br><span class="line">[root01ocalhost ~]# chkconfig --list | grep apache</span><br><span class="line">apache 0:关闭 1:关闭 2:关闭 3:关闭 4:关闭 5:关闭 6:关闭</span><br><span class="line">#很神奇吧,虽然RPM包默认安装的apache服务被删除了,但是chkconfig命令可以管理源码包安装的tapache服务</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结一下，如果想让源码包服务被<code>service</code>命令所识别和管理，则只需做一个软链接把启动脚本链接到<code>/etc/init.d/</code>目录中即可。要想让源码包服务被<code>chkconfig</code>命令所识别，除了需要把服务的启动脚本链接到<code>/etc/init.d/</code>目录中，还要修改这个启动脚本，在启动脚本的开头加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#chkconfig:运行级别 启动顺序 关闭</span><br><span class="line">#description:说明</span><br></pre></td></tr></table></figure>
<p>然后需要使用<code>chkconfig --add 服务名</code>的方式把服务加入<code>chkconfig</code>命令的管理中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig [选项][服务名]</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li><code>-add</code>：把服务加入<code>chkconfig</code>命令的管理中；</li>
<li><code>-del</code>：把服务从<code>chkconfig</code>命令的管理中删除；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig -del httpd</span><br><span class="line">#把apache服务从chkconfig命令的管理中删除</span><br></pre></td></tr></table></figure>
<h1 id="常见服务类别及功能"><a href="#常见服务类别及功能" class="headerlink" title="常见服务类别及功能"></a>常见服务类别及功能</h1><p>在生产服务器上，安装完 Linux 之后有一步重要的工作，就是服务优化。也就是关闭不需要的服务，只开启需要的服务。因为服务启动得越多，占用的系统资源就越多，而且被攻击的可能性也増加了。如果要进行服务优化，就需要知道这些服务都有什么作用。</p>
<p>Linux中常见服务的作用：</p>
<table>
<thead>
<tr>
<th align="center">服务名称</th>
<th align="center">功能简介</th>
<th align="center">建议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">acpid</td>
<td align="center">电源管理接口。如果是笔记本电脑用户，则建议开启，可以监听内核层的相关电源事件</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">anacron</td>
<td align="center">系统的定时任务程序。是 cron 的一个子系统，如果定时任务错过了执行时间，则可以通过 anacron 继续唤醒执行</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">alsasound</td>
<td align="center">alsa 声卡驱动。如果使用 alsa 声卡，则开启</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">apmd</td>
<td align="center">电源管理模块。如果支持 acpid，就不需要 apmd，可以关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">atd</td>
<td align="center">指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用 crond 来执行循环定时任务</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">auditd</td>
<td align="center">审核子系统。如果开启了此服务，那么 SELinux 的审核信息会写入 &#x2F;var&#x2F;log&#x2F;audit&#x2F; audit.log 文件；如果不开启，那么审核信息会记录在 syslog 中</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">autofs</td>
<td align="center">让服务器可以自动挂载网络中其他服务器的共享数据,一般用来自动挂载 NFS 服务。如果没有 NFS 服务，则建议关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">avahi-daemon</td>
<td align="center">avahi 是 zeroconf 协议的实现，它可以在没有 DNS 服务的局域网里发现基于 zeroconf 协议的设备和服务。除非有兼容设备或使用 zeroconf 协议，否则关闭	关闭</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">bluetooth</td>
<td align="center">蓝牙设备支持。一般不会在服务器上启用蓝牙设备，关闭它</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">capi</td>
<td align="center">仅对使用 ISND 设备的用户有用</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">chargen-dgram</td>
<td align="center">使用 UDP 协议的 chargen server。其主要提供类似远程打字的功能</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">chargen-stream</td>
<td align="center">同上</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">cpuspeed</td>
<td align="center">可以用来调整 CPU 的频率。当闲置时，可以自动降低 CPU 频率来节省电量</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">crond</td>
<td align="center">系统的定时任务，一般的 Linux 服务器都需要定时任务来协助系统维护。建议开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">cvs</td>
<td align="center">一个版本控制系统</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">daytime-dgram</td>
<td align="center">使用 TCP 协议的 daytime 守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">daytime-slream</td>
<td align="center">同上</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">dovecot</td>
<td align="center">邮件服务中 POP3&#x2F;IMAP 服务的守护进程，主要用来接收信件。如果启动了邮件服务则开启：否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">echo-dgram</td>
<td align="center">服务器回显客户服务的进程</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">echo-stream</td>
<td align="center">同上</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">firstboot</td>
<td align="center">系统安装完成后，有一个欢迎界面，需要对系统进行初始设定，这就是这个服务的作用。既然不是第一次启动了，则建议关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">gpm</td>
<td align="center">在字符终端 (ttyl~tty6) 中可以使用鼠标复制和粘贴，这就是这个服务的功能</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">haldaemon</td>
<td align="center">检测和支持 USB 设备。如果是服务器则可以关闭，个人机则建议开启</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">hidd</td>
<td align="center">蓝牙鼠标、键盘等蓝牙设备检测。必须启动 bluetooth 服务</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">hplip</td>
<td align="center">HP 打印机支持，如果没有 HP 打印机则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">httpd</td>
<td align="center">apache 服务的守护进程。如果需要启动 apache，就开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">ip6tables</td>
<td align="center">IPv6 的防火墙。目前 IPv6 协议并没有使用，可以关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">iptables</td>
<td align="center">防火墙功能。Linux 中的防火墙是内核支持功能。这是服务器的主要防护手段，必须开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">irda</td>
<td align="center">IrDA 提供红外线设备（笔记本电脑、PDA’s、手机、计算器等）间的通信支持。建议关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">irqbalance</td>
<td align="center">支持多核处理器，让 CPU 可以自动分配系统中断（IRQ)，提高系统性能。目前服务器多是多核 CPU，请开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">isdn</td>
<td align="center">使用 ISDN 设备连接网络。目前主流的联网方式是光纤接入和 ADSL，ISDN 己经非常少见，请关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">kudzu</td>
<td align="center">该服务可以在开机时进行硬件检测，并会调用相关的设置软件。建议关闭，仅在需要时开启</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">lvm2-monitor</td>
<td align="center">该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启。建议开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">mcstrans</td>
<td align="center">SELinux 的支持服务。建议开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">mdmonitor</td>
<td align="center">该服务用来监测 Software RAID 或 LVM 的信息。不是必需服务，建议关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">mdmpd</td>
<td align="center">该服务用来监测 Multi-Path 设备。不是必需服务，建议关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">messagebus</td>
<td align="center">这是 Linux 的 IPC (Interprocess Communication，进程间通信）服务，用来在各个软件中交换信息。建议关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">microcode _ctl</td>
<td align="center">Intel 系列的 CPU 可以通过这个服务支持额外的微指令集。建议关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">mysqld</td>
<td align="center">MySQL 数据库服务器。如果需要就开启；否则关闭</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">named</td>
<td align="center">DNS 服务的守护进程，用来进行域名解析。如果是 DNS 服务器则开启；否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">netfs</td>
<td align="center">该服务用于在系统启动时自动挂载网络中的共享文件空间，比如 NFS、Samba 等。 需要就开启，否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">network</td>
<td align="center">提供网络设罝功能。通过这个服务来管理网络，建议开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">nfs</td>
<td align="center">NFS (Network File System) 服务，Linux 与 Linux 之间的文件共享服务。需要就开启，否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">nfslock</td>
<td align="center">在 Linux 中如果使用了 NFS 服务，那么，为了避免同一个文件被不同的用户同时编辑，所以有这个锁服务。有 NFS 时开启，否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">ntpd</td>
<td align="center">该服务可以通过互联网自动更新系统时间.使系统时间永远准确。需要则开启，但不是必需服务</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">pcscd</td>
<td align="center">智能卡检测服务，可以关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">portmap</td>
<td align="center">用在远程过程调用 (RPC) 的服务，如果没有任何 RPC 服务，则可以关闭。主要是 NFS 和 NIS 服务需要</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">psacct</td>
<td align="center">该守护进程支持几个监控进程活动的工具</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">rdisc</td>
<td align="center">客户端 ICMP 路由协议</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">readahead_early</td>
<td align="center">在系统开启的时候，先将某些进程加载入内存整理，可以加快启动速度</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">readahead_later</td>
<td align="center">同上</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">restorecond</td>
<td align="center">用于给 SELinux 监测和重新加载正确的文件上下文。如果开启 SELinux，则需要开启</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">rpcgssd</td>
<td align="center">与 NFS 有关的客户端功能。如果没有 NFS 就关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">rpcidmapd</td>
<td align="center">同上</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">rsync</td>
<td align="center">远程数据备份守护进程</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">sendmail</td>
<td align="center">sendmail 邮件服务的守护进程。如果有邮件服务就开启；否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">setroubleshoot</td>
<td align="center">该服务用于将 SELinux 相关信息记录在日志 &#x2F;var&#x2F;log&#x2F;messages 中。建议开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">smartd</td>
<td align="center">该服务用于自动检测硬盘状态。建议开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">smb</td>
<td align="center">网络服务 samba 的守护进程。可以让 Linux 和 Windows 之间共享数据。如果需要则开启</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">squid</td>
<td align="center">代理服务的守护进程。如果需要则开启：否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">sshd</td>
<td align="center">ssh 加密远程登录管理的服务。服务器的远程管理必须使用此服务，不要关闭</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">syslog</td>
<td align="center">日志的守护进程</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">vsftpd</td>
<td align="center">vsftp 服务的守护进程。如果需要 FTP 服务则开启；否则关闭</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">xfs</td>
<td align="center">这是 X Window 的字体守护进程，为图形界面提供字体服务。如果不启动图形界面，就不用开启</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">xinetd</td>
<td align="center">超级守护进程。如果有依赖 xinetd 的服务，就必须开启</td>
<td align="center">开启</td>
</tr>
<tr>
<td align="center">ypbind</td>
<td align="center">为 NIS (网络信息系统）客户机激活 ypbind 服务进程</td>
<td align="center">关闭</td>
</tr>
<tr>
<td align="center">yum-updatesd</td>
<td align="center">yum 的在线升级服务</td>
<td align="center">关闭</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux/权限管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"
    >Linux 权限管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-01-22T03:24:15.000Z" itemprop="datePublished">2022-01-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="chgrp命令：修改文件和目录的所属组"><a href="#chgrp命令：修改文件和目录的所属组" class="headerlink" title="chgrp命令：修改文件和目录的所属组"></a>chgrp命令：修改文件和目录的所属组</h1><p><code>chgrp</code>命令用于修改文件或目录的所属组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chgrp [-R] 所属组 文件名（目录名）</span></span><br></pre></td></tr></table></figure>
<p><code>-R</code>（注意是大写）选项常作用于更改目录的所属组，表示更改连同子目录中所有文件的所属组信息。</p>
<p>使用此命令需要注意的一点是，要被改变的群组名必须是真实存在的，否则命令无法正确执行，会提示<code>invaild group name</code>。</p>
<p>当以<code>root</code>身份登录 Linux 系统时，主目录中会存在一个名为<code>install.log</code>的文件，我们可以使用如下方法修改此文件的所属组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupadd group1</span></span><br><span class="line"><span class="comment">#新建用于测试的群组 group1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chgrp group1 install.log</span></span><br><span class="line"><span class="comment">#修改install.log文件的所属组为group1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll install.log</span></span><br><span class="line">-rw-r--r--. 1 root group1 78495 Nov 17 05:54 install.log</span><br><span class="line"><span class="comment">#修改生效</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chgrp testgroup install.log</span></span><br><span class="line"><span class="built_in">chgrp</span>: invaild group name <span class="string">&#x27;testgroup&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="chown命令：修改文件和目录的所有者和所属组"><a href="#chown命令：修改文件和目录的所有者和所属组" class="headerlink" title="chown命令：修改文件和目录的所有者和所属组"></a>chown命令：修改文件和目录的所有者和所属组</h1><p><code>chown</code>命令，<code>change owner</code>的缩写，主要用于修改文件或目录的所有者，也可以修改文件或目录的所属组。</p>
<p>当只需要修改所有者时，可使用如下<code>chown</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chown [-R] 所有者 文件或目录</span><br></pre></td></tr></table></figure>
<p><code>-R</code>（大写）选项表示连同子目录中的所有文件，都更改所有者。</p>
<p>如果需要同时更改所有者和所属组，<code>chown</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chown [-R] 所有者:所属组 文件或目录</span><br></pre></td></tr></table></figure>
<p>当然，<code>chown</code>命令也支持单纯的修改文件或目录的所属组，例如<code>chown:group install.log</code>就表示修改<code>install.log</code>文件的所属组，但修改所属组通常使用<code>chgrp</code>命令，因此并不推荐大家使用<code>chown</code>命令。</p>
<p>另外需要注意的一点是，使用<code>chown</code>命令修改文件或目录的所有者（或所属者）时，要保证使用者用户（或用户组）存在，否则该命令无法正确执行，会提示<code>invalid user</code>或者<code>invaild group</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch file</span></span><br><span class="line"><span class="comment">#由root用户创建file文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:12 file</span><br><span class="line"><span class="comment">#文件的所有者是root，普通用户user对这个文件拥有只读权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chown user file</span></span><br><span class="line"><span class="comment">#修改文件的所有者</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 user root 0 Apr 17 05:12 file</span><br><span class="line"><span class="comment">#所有者变成了user用户，这时user用户对这个文件就拥有了读、写权限</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过修改<code>file</code>文件的所有者，<code>user</code>用户从其他人身份（只对此文件有读取权限）转变成了所有者身份，对此文件拥有读和写权限。</p>
<p>Linux 系统中，用户等级权限的划分是非常清楚的，<code>root</code>用户拥有最高权限，可以修改任何文件的权限，而普通用户只能修改自己文件的权限（所有者是自己的文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /home/user</span></span><br><span class="line"><span class="comment">#进入user用户的家目录</span></span><br><span class="line">[root@localhost user]<span class="comment"># touch test</span></span><br><span class="line"><span class="comment">#由root用户新建文件test</span></span><br><span class="line">[root@localhost user]<span class="comment"># ll test</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 17 05:37 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#文件所有者和所属组都是root用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># su - user</span></span><br><span class="line"><span class="comment">#切换为user用户</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">chmod</span> 755 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">chmod</span>:更改<span class="string">&quot;test&quot;</span>的权限：不允许的操作 <span class="comment">#user用户不能修改test文件的权限</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment">#退回到root身份</span></span><br><span class="line">[root@localhost user]<span class="comment"># chown user test</span></span><br><span class="line"><span class="comment">#由root用户把test文件的所有者改为user用户</span></span><br><span class="line">[root@localhost user]<span class="comment"># su - user</span></span><br><span class="line"><span class="comment">#切换为user用户</span></span><br><span class="line">[user@localhost ~]$ <span class="built_in">chmod</span> 755 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#user用户由于是test文件的所有者，所以可以修改文件的权限</span></span><br><span class="line">[user@localhost ~]$ ll <span class="built_in">test</span></span><br><span class="line">-rwxr-xr-x. 1 user root 0 Apr 17 05:37 <span class="built_in">test</span></span><br><span class="line"><span class="comment">#查看权限</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>user</code>用户无权更改所有者为<code>root</code>用户文件的权限，只有普通用户是这个文件的所有者，才可以修改文件的权限。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chown user:group file</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll file</span></span><br><span class="line">-rw-r--r--. 1 user group 0 Apr 17 05:12 file</span><br></pre></td></tr></table></figure>
<h1 id="权限位"><a href="#权限位" class="headerlink" title="权限位"></a>权限位</h1><p>最常见的文件权限有 3 种，即对文件的读（用<code>r</code>表示）、写（用<code>w</code>表示）和执行（用<code>x</code>表示，针对可执行文件或目录）权限。在 Linux 系统中，每个文件都明确规定了不同身份用户的访问权限，通过<code>ls</code>命令即可看到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -al</span></span><br><span class="line">total 156</span><br><span class="line">drwxr-x---.   4    root   root     4096   Sep  8 14:06 .</span><br><span class="line">drwxr-xr-x.  23    root   root     4096   Sep  8 14:21 ..</span><br><span class="line">-rw-------.   1    root   root     1474   Sep  4 18:27 anaconda-ks.cfg</span><br><span class="line">-rw-------.   1    root   root      199   Sep  8 17:14 .bash_history</span><br><span class="line">-rw-r--r--.   1    root   root       24   Jan  6  2007 .bash_logout</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，每行的第一列表示的就是各文件针对不同用户设定的权限，一共 11 位，但第 1 位用于表示文件的具体类型，最后一位此文件受 SELinux 的安全规则管理。</p>
<p>因此，为文件设定不同用户的读、写和执行权限，仅涉及到 9 位字符，以<code>ls</code>命令输出信息中的<code>.bash_logout</code>文件为例，设定不同用户的访问权限是<code>rw-r--r--</code>，各权限位的含义如图所示。</p>
<img src="/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/1.gif" class="" title="文件权限位">

<p>从图中可以看到，Linux 将访问文件的用户分为 3 类，分别是文件的所有者，所属组（也就是文件所属的群组）以及其他人。</p>
<p>除了所有者，以及所属群组中的用户可以访问文件外，其他用户（其他群组中的用户）也可以访问文件，这部分用户都归为其他人范畴。</p>
<p>很显然，Linux 系统为 3 种不同的用户身份，分别规定了是否对文件有读、写和执行权限。</p>
<h1 id="chmod命令：修改文件或目录的权限"><a href="#chmod命令：修改文件或目录的权限" class="headerlink" title="chmod命令：修改文件或目录的权限"></a>chmod命令：修改文件或目录的权限</h1><p><code>chmod</code>命令设定文件权限的方式有 2 种，分别可以使用数字或者符号来进行权限的变更。</p>
<h2 id="使用数字修改文件权限"><a href="#使用数字修改文件权限" class="headerlink" title="使用数字修改文件权限"></a>使用数字修改文件权限</h2><p>文件的基本权限由 9 个字符组成，以<code>rwxrw-r-x</code>为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r --&gt; 4</span><br><span class="line">w --&gt; 2</span><br><span class="line">x --&gt; 1</span><br></pre></td></tr></table></figure>
<p>由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（<code>r、w、x</code>），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。</p>
<p>拿<code>rwxrw-r-x</code>来说，所有者、所属组和其他人分别对应的权限值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有者 = rwx = 4+2+1 = 7</span><br><span class="line">所属组 = rw- = 4+2 = 6</span><br><span class="line">其他人 = r-x = 4+1 = 5</span><br></pre></td></tr></table></figure>
<p>所以，此权限对应的权限值就是 765。</p>
<p>使用数字修改文件权限的<code>chmod</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chmod [-R] 权限值 文件名</span></span><br></pre></td></tr></table></figure>
<p><code>-R</code>（注意是大写）选项表示连同子目录中的所有文件，也都修改设定的权限。</p>
<p>例如，使用如下命令，即可完成对<code>.bashrc</code>目录文件的权限修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rw-r--r--. 1 root root 176 Sep 22 2004 .bashrc</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 777 .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure>
<p>通常我们以 Vim 编辑 Shell 文件批处理文件后，文件权限通常是<code>rw-rw-r--（644）</code>，那么，如果要将该文件变成可执行文件，并且不让其他人修改此文件，则只需将此文件的权限该为<code>rwxr-xr-x（755）</code>即可。</p>
<h2 id="chmod命令使用字母修改文件权限"><a href="#chmod命令使用字母修改文件权限" class="headerlink" title="chmod命令使用字母修改文件权限"></a>chmod命令使用字母修改文件权限</h2><p>既然文件的基本权限就是 3 种用户身份（所有者、所属组和其他人）搭配 3 种权限（<code>rwx</code>），<code>chmod</code>命令中用<code>u、g、o</code>分别代表 3 种身份，还用<code>a</code>表示全部的身份（<code>all</code>的缩写）。另外，<code>chmod</code>命令仍使用<code>r、w、x</code>分别表示读、写、执行权限。</p>
<p>使用字母修改文件权限的<code>chmod</code>命令，其基本格式如图所示。</p>
<img src="/2022/01/22/Linux/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/2.gif" class="" title="chmod 命令基本格式">

<p>例如，如果我们要设定<code>.bashrc</code>文件的权限为<code>rwxr-xr-x</code>，则可执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># chmod u=rwx,go=rx .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure>
<p>如果想要增加<code>.bashrc</code>文件的每种用户都可做写操作的权限，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxr-xr-x. 1 root root 176 Sep 22 2004 .bashrc</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod a+w .bashrc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -al .bashrc</span></span><br><span class="line">-rwxrwxrwx. 1 root root 176 Sep 22 2004 .bashrc</span><br></pre></td></tr></table></figure>
<h1 id="umask详解：默认权限的设定和修改"><a href="#umask详解：默认权限的设定和修改" class="headerlink" title="umask详解：默认权限的设定和修改"></a>umask详解：默认权限的设定和修改</h1><p>Windows 系统中，新建的文件和目录时通过继承上级目录的权限获得的初始权限，而 Linux 不同，它是通过使用<code>umask</code>默认权限来给所有新建的文件和目录赋予初始权限的。</p>
<p>直接通过<code>umask</code>命令可得知<code>umask</code>默认权限的值即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line"><span class="comment">#root用户默认是0022，普通用户默认是 0002</span></span><br></pre></td></tr></table></figure>
<p><code>umask</code>默认权限确实由 4 个八进制数组成，但第 1 个数代表的是文件所具有的特殊权限（SetUID、SetGID、Sticky BIT）。也就是说，后 3 位数字 “022” 才是真正要用到的<code>umask</code>权限值，将其转变为字母形式为<code>----w--w-</code>。</p>
<p>注意，虽然<code>umask</code>默认权限是用来设定文件或目录的初始权限，但并不是直接将<code>umask</code>默认权限作为文件或目录的初始权限，还要对其进行”再加工”。</p>
<p>文件和目录的真正初始权限，可通过以下的计算得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件（或目录）的初始权限 = 文件（或目录）的最大默认权限 - umask权限</span><br></pre></td></tr></table></figure>
<p>如果按照官方的标准算法，需要将<code>umask</code>默认权限使用二进制并经过逻辑与和逻辑非运算后，才能得到最终文件或目录的初始权限，计算过程比较复杂，且容易出错。</p>
<p>显然，如果想最终得到文件或目录的初始权限值，我们还需要了解文件和目录的最大默认权限值。在 Linux 系统中，文件和目录的最大默认权限是不一样的：</p>
<ul>
<li>对文件来讲，其可拥有的最大默认权限是 666，即<code>rw-rw-rw-</code>。也就是说，使用文件的任何用户都没有执行（<code>x</code>）权限。原因很简单，执行权限是文件的最高权限，赋予时绝对要慎重，因此绝不能在新建文件的时候就默认赋予，只能通过用户手工赋予。</li>
<li>对目录来讲，其可拥有的最大默认权限是 777，即<code>rwxrwxrwx</code>。</li>
</ul>
<p>接下来，我们利用字母权限的方式计算文件或目录的初始权限。以<code>umask</code>值为 022 为例，分别计算新建文件和目录的初始权限：</p>
<ul>
<li>文件的最大默认权限是 666，换算成字母就是<code>-rw-rw-rw-</code>，<code>umask</code>的值是 022，换算成字母为<code>-----w--w-</code>。把两个字母权限相减，得到<code>(-rw-rw-rw-) - (-----w--w-) = (-rw-r--r--)</code>，这就是新建文件的初始权限。我们测试一下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line"><span class="comment">#默认umask的值是0022</span></span><br><span class="line">[root@localhost ~]<span class="comment"># touch file  &lt;--新建file空文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -d file</span></span><br><span class="line">-rw-r--r--. 1 root root 0 Apr 18 02:36 file</span><br></pre></td></tr></table></figure></li>
<li>目录的默认权限最大可以是 777，换算成字母就是<code>drwxrwxrwx</code>，<code>umask</code>的值是 022，也就是<code>-----w--w-</code>。把两个字母权限相减，得到的就是新建目录的默认权限，即<code>(drwxrwxrwx) - (-----w--w-) = (drwxr-xr-x)</code>。我们再来测试一下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir catalog  &lt;--新建catalog目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -d catalog</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Apr 18 02:36 catalog</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，在计算文件或目录的初始权限时，不能直接使用最大默认权限和<code>umask</code>权限的数字形式做减法，这是不对的。例如，若<code>umask</code>默认权限的值为 033，按照数字形式计算文件的初始权限，666-033&#x3D;633，但我们按照字母的形式计算会得到<code>（rw-rw-rw-) - (----wx-wx) = (rw-r--r--)</code>，换算成数字形式是 644。</p>
<p>这里的减法，其实是“遮盖”的意思，也就是说，最大默认权限中和<code>umask</code>权限公共的部分，通过减法运算会被遮盖掉，最终剩下的“最大默认权限”，才是最终赋予文件或目录的初始权限。</p>
<h2 id="umask默认权限的修改方法"><a href="#umask默认权限的修改方法" class="headerlink" title="umask默认权限的修改方法"></a>umask默认权限的修改方法</h2><p><code>umask</code>权限值可以通过如下命令直接修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># umask 002</span></span><br><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0002</span><br><span class="line">[root@localhost ~]<span class="comment"># umask 033</span></span><br><span class="line">[root@localhost ~]<span class="comment"># umask</span></span><br><span class="line">0033</span><br></pre></td></tr></table></figure>
<p>不过，这种方式修改的<code>umask</code>只是临时有效，一旦重启或重新登陆系统，就会失效。如果想让修改永久生效，则需要修改对应的环境变量配置文件<code>/etc/profile</code>。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/profile</span></span><br><span class="line">...省略部分内容...</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199]&amp;&amp;[ <span class="string">&quot;&#x27;id -gn&#x27;&quot;</span> = <span class="string">&quot;&#x27;id -un&#x27;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">umask</span> 002</span><br><span class="line">    <span class="comment">#如果UID大于199（普通用户），则使用此umask值</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">umask</span> 022</span><br><span class="line">    <span class="comment">#如果UID小于199（超级用户），则使用此umask值</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">…省略部分内容…</span><br></pre></td></tr></table></figure>
<p>普通用户的<code>umask</code>由<code>if</code>语句的第一段定义，而超级用户<code>root</code>的<code>umask</code>值由<code>else</code>语句定义即可。 修改此文件，则<code>umask</code>值就会永久生效。</p>
<h1 id="ACL访问控制权限"><a href="#ACL访问控制权限" class="headerlink" title="ACL访问控制权限"></a>ACL访问控制权限</h1><p>Linux 系统传统的权限控制方式，无非是利用 3 种身份（文件所有者，所属群组，其他用户），并分别搭配 3 种权限（读<code>r</code>，写<code>w</code>，访问<code>x</code>）。比如，我们可以通过<code>ls -l</code>命令查看当前目录中所有文件的详细信息，其中就包含对各文件的权限设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -l</span></span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Apr 15 16:33 Desktop</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Apr 15 16:33 Documents</span><br><span class="line">...</span><br><span class="line">-rwxr-xr-x. 2 root root 4096 Apr 15 16:33 post-install</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以上输出信息中，<code>rwxr-xr-x</code>就指明了不同用户访问文件的权限，即文件所有者拥有对文件的读、写、访问权限（<code>rwx</code>），文件所属群组拥有对文件的读、访问权限（<code>r-x</code>），其他用户拥有对文件的读、访问权限（<code>r-x</code>）。</p>
<p>权限前的字符，表示文件的具体类型，比如<code>d</code>表示目录，<code>-</code>表示普通文件，<code>l</code>表示连接文件，<code>b</code>表示设备文件，等等。</p>
<p>ACL，是<code>Access Control List</code>（访问控制列表）的缩写，在 Linux 系统中， ACL 可实现对单一用户设定访问文件的权限。也可以这么说，设定文件的访问权限，除了用传统方式（3 种身份搭配 3 种权限），还可以使用 ACL 进行设定。</p>
<h2 id="开启-ACL-权限"><a href="#开启-ACL-权限" class="headerlink" title="开启 ACL 权限"></a>开启 ACL 权限</h2><p>CentOS 6.x 系统中，ACL 权限默认处于开启状态，无需手工开启。但如果你的操作系统不是 CentOS 6.x，可以通过如下方式查看ACL权限是否开启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mount</span></span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">/dev/sda3 on I <span class="built_in">type</span> ext4 (rw)</span><br><span class="line">…省略部分输出…</span><br><span class="line"><span class="comment">#使用mount命令可以看到系统中已经挂载的分区，但是并没有看到ACL权限的设置</span></span><br><span class="line">[root@localhost ~]<span class="comment"># dumpe2fs -h /dev/sda3</span></span><br><span class="line"><span class="comment">#dumpe2fs是查询指定分区文件系统详细信息的命令</span></span><br><span class="line">…省略部分输出…</span><br><span class="line">Default mount options: user_xattr acl</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
<p>其中，<code>dumpe2fs</code>命令的<code>-h</code>选项表示仅显示超级块中的信息，而不显示磁盘块组的详细信息；</p>
<p>使用<code>mount</code>命令可以查看到系统中已经挂载的分区，而使用<code>dumpe2fs</code>命令可以查看到这个分区文件系统的详细信息。大家可以看到，我们的 ACL 权限是<code>/dev/sda3</code>分区的默认挂载选项，所以不需要手工挂载。</p>
<p>如果 Linux 系统如果没有默认挂载，可以执行如下命令实现手动挂载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mount -o remount,acl /</span></span><br><span class="line"><span class="comment">#重新挂载根分区，并加入ACL权限</span></span><br></pre></td></tr></table></figure>
<p>使用<code>mount</code>命令重新挂载，并加入 ACL 权限。但使用此命令只是临时生效，要想永久生效，需要修改<code>/etc/fstab</code>文件，修改方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#vi /etc/fstab</span></span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 /ext4 defaults,acl 1 1</span><br><span class="line"><span class="comment">#加入ACL权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount -o remount /</span></span><br><span class="line"><span class="comment">#重新挂载文件系统或重启系统，使修改生效</span></span><br></pre></td></tr></table></figure>
<p>在你需要开启 ACL 权限的分区行上（也就是说 ACL 权限针对的是分区），手工在<code>defaults</code>后面加入<code>&quot;，acl&quot;</code>即可永久在此分区中开启 ACL 权限。</p>
<h1 id="ACL权限设置"><a href="#ACL权限设置" class="headerlink" title="ACL权限设置"></a>ACL权限设置</h1><p>设定 ACl 权限，常用命令有 2 个，分别是<code>setfacl</code>和<code>getfacl</code>命令，前者用于给指定文件或目录设定 ACL 权限，后者用于查看是否配置成功。</p>
<p><code>getfacl</code>命令用于查看文件或目录当前设定的 ACL 权限信息。该命令的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# getfacl 文件名</span><br></pre></td></tr></table></figure>
<p><code>getfacl</code>命令的使用非常简单，且常和<code>setfacl</code>命令一起搭配使用。</p>
<p><code>setfacl</code>命令可直接设定用户或群组对指定文件的访问权限。此命令的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# setfacl 选项 文件名</span><br></pre></td></tr></table></figure>
<p>setfacl 命令选项及用法</p>
<p>选项	功能<br>-m 参数	设定 ACL 权限。如果是给予用户 ACL 权限，参数则使用 “u:用户名:权限” 的格式，例如 setfacl -m u:st:rx &#x2F;project 表示设定 st 用户对 project 目录具有 rx 权限；如果是给予组 ACL 权限，参数则使用 “g:组名:权限” 格式，例如 setfacl -m g:tgroup:rx &#x2F;project 表示设定群组 tgroup 对 project 目录具有 rx 权限。<br>-x 参数	删除指定用户（参数使用 u:用户名）或群组（参数使用 g:群组名）的 ACL 权限，例如 setfacl -x u:st &#x2F;project 表示删除 st 用户对 project 目录的 ACL 权限。<br>-b	删除所有的 ACL 权限，例如 setfacl -b &#x2F;project 表示删除有关 project 目录的所有 ACL 权限。<br>-d	设定默认 ACL 权限，命令格式为 “setfacl -m d:u:用户名:权限 文件名”（如果是群组，则使用 d:g:群组名:权限），只对目录生效，指目录中新建立的文件拥有此默认权限，例如 setfacl -m d:u:st:rx &#x2F;project 表示 st 用户对 project 目录中新建立的文件拥有 rx 权限。<br>-R	递归设定 ACL 权限，指设定的 ACL 权限会对目录下的所有子文件生效，命令格式为 “setfacl -m u:用户名:权限 -R 文件名”（群组使用 g:群组名:权限），例如 setfacl -m u:st:rx -R &#x2F;project 表示 st 用户对已存在于 project 目录中的子文件和子目录拥有 rx 权限。<br>-k	删除默认 ACL 权限。<br>setfacl -m：给用户或群组添加 ACL 权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># useradd zhangsan</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd lisi</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd st</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupadd tgroup &lt;-- 添加需要试验的用户和用户组，省略设定密码的过程</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir /project &lt;-- 建立需要分配权限的目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chown root:tgroup /project &lt;-- 改变/project目录的所有者和所属组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 770 /project  &lt;-- 指定/project目录的权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -d /project</span></span><br><span class="line">drwxrwx---. 2 root tgroup 4096 Apr 16 12:55 /project</span><br><span class="line"><span class="comment">#这时st学员来试听了，如何给她分配权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># setfacl -m u:st:rx /project</span></span><br><span class="line"><span class="comment">#给用户st赋予r-x权限，使用&quot;u:用户名：权限&quot; 格式</span></span><br><span class="line">[root@localhost /]<span class="comment"># cd /</span></span><br><span class="line">[root@localhost /]<span class="comment"># ll -d /project</span></span><br><span class="line">drwxrwx---+ 2 root tgroup 4096 Apr 16 12:55 /project</span><br><span class="line"><span class="comment">#如果查询时会发现，在权限位后面多了一个&quot;+&quot;，表示此目录拥有ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment">#查看/prpject目录的ACL权限</span></span><br><span class="line"><span class="comment">#file:project &lt;--文件名</span></span><br><span class="line"><span class="comment">#owner:root &lt;--文件的所有者</span></span><br><span class="line"><span class="comment">#group:tgroup &lt;--文件的所属组</span></span><br><span class="line">user::rwx &lt;--用户名栏是空的，说明是所有者的权限</span><br><span class="line">user:st:r-x &lt;--用户st的权限</span><br><span class="line">group::rwx &lt;--组名栏是空的，说明是所属组的权限</span><br><span class="line">mask::rwx &lt;--mask权限</span><br><span class="line">other::--- &lt;--其他人的权限</span><br></pre></td></tr></table></figure>
<p>可以看到，通过设定 ACL 权限，我们可以单独给 st 用户分配 r-x 权限，而无需给 st 用户设定任何身份。</p>
<p>同样的道理，也可以给用户组设定 ACL 权限，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># groupadd tgroup2</span></span><br><span class="line"><span class="comment">#添加新群组</span></span><br><span class="line">[root@localhost /]<span class="comment"># setfacl -m g:tgroup2:rwx project</span></span><br><span class="line"><span class="comment">#为组tgroup2纷配ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># ll -d project</span></span><br><span class="line">drwxrwx---+ 2 root tgroup 4096 1月19 04:21 project</span><br><span class="line"><span class="comment">#属组并没有更改</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment">#file: project</span></span><br><span class="line"><span class="comment">#owner: root</span></span><br><span class="line"><span class="comment">#group: tgroup</span></span><br><span class="line">user::rwx</span><br><span class="line">user:st:r-x</span><br><span class="line">group::rwx</span><br><span class="line">group:tgroup2:rwx &lt;-用户组tgroup2拥有了rwx权限</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>
<h2 id="setfacl-d：设定默认-ACL-权限"><a href="#setfacl-d：设定默认-ACL-权限" class="headerlink" title="setfacl -d：设定默认 ACL 权限"></a>setfacl -d：设定默认 ACL 权限</h2><p>既然已经对<code>project</code>目录设定了 ACL 权限，那么，如果在这个目录中新建一些子文件和子目录，这些文件是否会继承父目录的 ACL 权限呢？执行以下命令进行验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># cd project</span></span><br><span class="line">[root@localhost project]<span class="comment"># touch abc</span></span><br><span class="line">[root@localhost project]<span class="comment"># mkdir d1</span></span><br><span class="line"><span class="comment">#在/project目录中新建了abc文件和d1目录</span></span><br><span class="line">[root@localhost project]<span class="comment">#ll</span></span><br><span class="line">总用量4</span><br><span class="line">-rw-r--r-- 1 root root 01月19 05:20 abc</span><br><span class="line">drwxr-xr-x 2 root root 4096 1月19 05:20 d1</span><br></pre></td></tr></table></figure>
<p>可以看到，这两个新建立的文件权限位后面并没有 “+”，表示它们没有继承 ACL 权限。这说明，后建立的子文件或子目录，并不会继承父目录的 ACL 权限。</p>
<p>当然，我们可以手工给这两个文件分配 ACL 权限，但是如果在目录中再新建文件，都要手工指定，则显得过于麻烦。这时就需要用到默认 ACL 权限。</p>
<p>默认 ACL 权限的作用是，如果给父目录设定了默认 ACL 权限，那么父目录中所有新建的子文件都会继承父目录的 ACL 权限。需要注意的是，默认 ACL 权限只对目录生效。</p>
<p>例如，给 project 文件设定 st 用户访问 rx 的默认 ACL 权限，可执行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># setfacl -m d:u:st:rx project</span></span><br><span class="line">[root@localhost project]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment"># file: project</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: tgroup</span></span><br><span class="line">user:: rwx</span><br><span class="line">user:st:r-x</span><br><span class="line">group::rwx</span><br><span class="line">group:tgroup2:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line">default:user::rwx &lt;--多出了default字段</span><br><span class="line">default:user:st:r-x</span><br><span class="line">default:group::rwx</span><br><span class="line">default:mask::rwx</span><br><span class="line">default:other::---</span><br><span class="line">[root@localhost /]<span class="comment"># cd project</span></span><br><span class="line">[root@localhost project]<span class="comment"># touch bcd</span></span><br><span class="line">[root@localhost project]<span class="comment"># mkdir d2</span></span><br><span class="line"><span class="comment">#新建子文件和子目录</span></span><br><span class="line">[root@localhost project]<span class="comment"># ll 总用量8</span></span><br><span class="line">-rw-r--r-- 1 root root 01月19 05:20 abc</span><br><span class="line">-rw-rw----+ 1 root root 01月19 05:33 bcd</span><br><span class="line">drwxr-xr-x 2 root root 4096 1月19 05:20 d1</span><br><span class="line">drwxrwx---+ 2 root root 4096 1月19 05:33 d2</span><br><span class="line"><span class="comment">#新建的bcd和d2已经继承了父目录的ACL权限</span></span><br></pre></td></tr></table></figure>
<p>大家发现了吗？原先的 abc 和 d1 还是没有 ACL 权限，因为默认 ACL 权限是针对新建立的文件生效的。</p>
<p>对目录设定的默认 ACL 权限，可直接使用<code>setfacl -k</code>命令删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# setfacl -k project</span><br></pre></td></tr></table></figure>
<p>通过此命令，即可删除 project 目录的默认 ACL 权限，读者可自行通过 getfacl 命令查看。</p>
<h2 id="setfacl-R：设定递归-ACL-权限"><a href="#setfacl-R：设定递归-ACL-权限" class="headerlink" title="setfacl -R：设定递归 ACL 权限"></a>setfacl -R：设定递归 ACL 权限</h2><p>递归 ACL 权限指的是父目录在设定 ACL 权限时，所有的子文件和子目录也会拥有相同的 ACL 权限。</p>
<p>例如，给 project 目录设定 st 用户访问权限为 rx 的递归 ACL 权限，执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost project]<span class="comment"># setfacl -m u:st:rx -R project</span></span><br><span class="line">[root@localhost project]<span class="comment"># ll</span></span><br><span class="line">总用量 8</span><br><span class="line">-rw-r-xr--+ 1 root root 01月19 05:20 abc</span><br><span class="line">-rw-rwx--+ 1 root root 01月19 05:33 bcd</span><br><span class="line">drwxr-xr-x+ 2 root root 4096 1月19 05:20 d1</span><br><span class="line">drwxrwx---+ 2 root root 4096 1月19 05:33 d2</span><br><span class="line"><span class="comment">#abc和d1也拥有了ACL权限</span></span><br></pre></td></tr></table></figure>
<p>注意，默认 ACL 权限指的是针对父目录中后续建立的文件和目录会继承父目录的 ACL 权限；递归 ACL 权限指的是针对父目录中已经存在的所有子文件和子目录会继承父目录的 ACL 权限。</p>
<h2 id="setfacl-x：删除指定的-ACL-权限"><a href="#setfacl-x：删除指定的-ACL-权限" class="headerlink" title="setfacl -x：删除指定的 ACL 权限"></a>setfacl -x：删除指定的 ACL 权限</h2><p>使用<code>setfacl -x</code>命令，可以删除指定的 ACL 权限，例如，删除前面建立的<code>st</code>用户对<code>project</code>目录的 ACL 权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># setfacl -x u:st project</span></span><br><span class="line"><span class="comment">#删除指定用户和用户组的ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment"># file:project</span></span><br><span class="line"><span class="comment"># owner: root</span></span><br><span class="line"><span class="comment"># group: tgroup</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">group:tgroup2:rwx</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br><span class="line"><span class="comment">#st用户的权限已被删除</span></span><br></pre></td></tr></table></figure>
<h2 id="setfacl-b：删除指定文件的所有-ACL-权限"><a href="#setfacl-b：删除指定文件的所有-ACL-权限" class="headerlink" title="setfacl -b：删除指定文件的所有 ACL 权限"></a>setfacl -b：删除指定文件的所有 ACL 权限</h2><p>此命令可删除所有与指定文件或目录相关的 ACL 权限。例如，现在我们删除一切与<code>project</code>目录相关的 ACL 权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># setfacl -b project</span></span><br><span class="line"><span class="comment">#会删除文件的所有ACL权限</span></span><br><span class="line">[root@localhost /]<span class="comment"># getfacl project</span></span><br><span class="line"><span class="comment">#file: project</span></span><br><span class="line"><span class="comment">#owner: root</span></span><br><span class="line"><span class="comment"># group: tgroup</span></span><br><span class="line">user::rwx</span><br><span class="line">group::rwx</span><br><span class="line">other::---</span><br><span class="line"><span class="comment">#所有ACL权限已被删除</span></span><br></pre></td></tr></table></figure>


<h1 id="sudo命令用法详解：系统权限管理"><a href="#sudo命令用法详解：系统权限管理" class="headerlink" title="sudo命令用法详解：系统权限管理"></a>sudo命令用法详解：系统权限管理</h1><p>使用<code>su</code>命令可以让普通用户切换到<code>root</code>身份去执行某些特权命令，但存在一些问题，比如说：</p>
<ul>
<li>仅仅为了一个特权操作就直接赋予普通用户控制系统的完整权限；</li>
<li>当多人使用同一台主机时，如果大家都要使用<code>su</code>命令切换到<code>root</code>身份，那势必就需要<code>root</code>的密码，这就导致很多人都知道<code>root</code>的密码；</li>
</ul>
<p>考虑到使用<code>su</code>命令可能对系统安装造成的隐患，最常见的解决方法是使用<code>sudo</code>命令，此命令也可以让你切换至其他用户的身份去执行命令。</p>
<p>相对于使用<code>su</code>命令还需要新切换用户的密码，<code>sudo</code>命令的运行只需要知道自己的密码即可，甚至于，我们可以通过手动修改<code>sudo</code>的配置文件，使其无需任何密码即可运行。</p>
<p><code>sudo</code>命令默认只有<code>root</code>用户可以运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># sudo [-b] [-u 新使用者账号] 要执行的命令</span></span><br></pre></td></tr></table></figure>
<p>常用的选项与参数：</p>
<ul>
<li><code>-b</code>：将后续的命令放到背景中让系统自行运行，不对当前的 shell 环境产生影响。</li>
<li><code>-u</code>：后面可以接欲切换的用户名，若无此项则代表切换身份为<code>root</code>。</li>
<li><code>-l</code>：此选项的用法为<code>sudo -l</code>，用于显示当前用户可以用<code>sudo</code>执行那些命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  grep sshd /etc/passwd</span></span><br><span class="line">sshd:x:74:74:privilege-separated SSH:/var/empty/sshd:/sbin.nologin</span><br><span class="line">[root@localhost ~]<span class="comment">#  sudo -u sshd touch /tmp/mysshd</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  ll /tmp/mysshd</span></span><br><span class="line">-rw-r--r-- 1 sshd sshd 0 Feb 28 17:42 /tmp/mysshd</span><br></pre></td></tr></table></figure>
<p>本例中，无法使用<code>su - sshd</code>的方式成功切换到<code>sshd</code>账户中，因为此用户的默认 Shell 是<code>/sbin/nologin</code>。这时就显现出<code>sudo</code>的优势，我们可以使用<code>sudo</code>以<code>sshd</code>的身份在<code>/tmp</code>目录下创建<code>mysshd</code>文件，可以看到，新创建的<code>mysshd</code>文件的所有者确实是<code>sshd</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#  sudo -u vbird1 sh -c &quot;mkdir ~vbird1/www; cd ~vbird1/www; \</span></span><br><span class="line">&gt;  <span class="built_in">echo</span> <span class="string">&#x27;This is index.html file&#x27;</span> &gt; index.html<span class="string">&quot;</span></span><br><span class="line"><span class="string">[root@localhost ~]#  ll -a ~vbird1/www</span></span><br><span class="line"><span class="string">drwxr-xr-x 2 vbird1 vbird1 4096 Feb 28 17:51 .</span></span><br><span class="line"><span class="string">drwx------ 5 vbird1 vbird1 4096 Feb 28 17:51 ..</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 vbird1 vbird1   24 Feb 28 17:51 index.html</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，使用<code>sudo</code>命令切换至<code>vbird1</code>身份，并运行<code>sh -c</code>的方式来运行一连串的命令。</p>
<p>默认情况下<code>sudo</code>命令只有<code>root</code>身份可以使用，那么，如何让普通用户也能使用它呢？</p>
<p>解决这个问题之前，先给大家分析一下<code>sudo</code>命令的执行过程。<code>sudo</code>命令的运行，需经历如下几步：</p>
<ul>
<li>当用户运行<code>sudo</code>命令时，系统会先通过<code>/etc/sudoers</code>文件，验证该用户是否有运行<code>sudo</code>的权限；</li>
<li>确定用户具有使用<code>sudo</code>命令的权限后，还要让用户输入自己的密码进行确认。出于对系统安全性的考虑，如果用户在默认时间内（默认是 5 分钟）不使用<code>sudo</code>命令，此后使用时需要再次输入密码；</li>
<li>密码输入成功后，才会执行<code>sudo</code>命令后接的命令。</li>
</ul>
<p>显然，能否使用<code>sudo</code>命令，取决于对<code>/etc/sudoers</code>文件的配置（默认情况下，此文件中只配置有<code>root</code>用户）。</p>
<h2 id="sudo命令的配置文件-x2F-etc-x2F-sudoers"><a href="#sudo命令的配置文件-x2F-etc-x2F-sudoers" class="headerlink" title="sudo命令的配置文件&#x2F;etc&#x2F;sudoers"></a>sudo命令的配置文件&#x2F;etc&#x2F;sudoers</h2><p>修改<code>/etc/sudoers</code>，不建议直接使用<code>vim</code>，而是使用<code>visudo</code>。因为修改<code>/etc/sudoers</code>文件需遵循一定的语法规则，使用<code>visudo</code>的好处就在于，当修改完毕<code>/etc/sudoers</code>文件，离开修改页面时，系统会自行检验<code>/etc/sudoers</code>文件的语法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># visudo</span></span><br><span class="line">…省略部分输出…</span><br><span class="line">root ALL=(ALL) ALL  &lt;--大约 76 行的位置</span><br><span class="line"><span class="comment"># %wheel ALL=(ALL) ALL   &lt;--大约84行的位置</span></span><br><span class="line"><span class="comment">#这两行是系统为我们提供的模板，我们参照它写自己的就可以了</span></span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
<p>通过<code>visudo</code>命令，我们就打开了<code>/etc/sudoers</code>文件，可以看到如上显示的 2 行信息，这是系统给我们提供的 2 个模板，分别用于添加用户和群组，使其能够使用<code>sudo</code>命令。</p>
<p>这两行模板的含义分为是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root ALL=(ALL) ALL</span><br><span class="line">#用户名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span><br><span class="line">#%wheel ALL=(ALL) ALL</span><br><span class="line">#%组名 被管理主机的地址=(可使用的身份) 授权命令(绝对路径)</span><br></pre></td></tr></table></figure>
<p><code>/etc/sudoers</code>用户和群组模板的含义：</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户名或群组名</td>
<td align="center">表示系统中的那个用户或群组，可以使用 sudo 这个命令。</td>
</tr>
<tr>
<td align="center">被管理主机的地址</td>
<td align="center">用户可以管理指定 IP 地址的服务器。这里如果写 ALL，则代表用户可以管理任何主机；如果写固定 IP，则代表用户可以管理指定的服务器。如果我们在这里写本机的 IP 地址，不代表只允许本机的用户使用指定命令，而是代表指定的用户可以从任何 IP 地址来管理当前服务器。</td>
</tr>
<tr>
<td align="center">可使用的身份</td>
<td align="center">就是把来源用户切换成什么身份使用，（ALL）代表可以切换成任意身份。这个字段可以省略。</td>
</tr>
<tr>
<td align="center">授权命令</td>
<td align="center">表示 root 把什么命令命令授权给用户，换句话说，可以用切换的身份执行什么命令。需要注意的是，此命令必须使用绝对路径写。默认值是 ALL，表示可以执行任何命令。</td>
</tr>
</tbody></table>
<p>授权用户<code>lamp</code>可以重启服务器，由<code>root</code>用户添加，可以在<code>/etc/sudoers</code>模板下添加如下语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># visudo</span></span><br><span class="line">lamp ALL=/sbin/shutdown -r now</span><br></pre></td></tr></table></figure>
<p>注意，这里也可以写多个授权命令，之间用逗号分隔。用户<code>lamp</code>可以使用<code>sudo -l</code>查看授权的命令列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># su - lamp</span></span><br><span class="line"><span class="comment">#切换成lamp用户</span></span><br><span class="line">[lamp@localhost ~]$ sudo -l</span><br><span class="line">[sudo] password <span class="keyword">for</span> lamp:</span><br><span class="line"><span class="comment">#需要输入lamp用户的密码</span></span><br><span class="line">User lamp may run the following commands on this host:</span><br><span class="line">(root) /sbin/shutdown -r now</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>lamp</code>用户拥有了<code>shutdown -r now</code>的权限。这时，<code>lamp</code>用户就可以使用<code>sudo</code>执行如下命令重启服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lamp@localhost ~]$ sudo /sbin/shutdown -r now</span><br></pre></td></tr></table></figure>
<p>再次强调，授权命令要使用绝对路径（或者把<code>/sbin</code>路径导入普通用户<code>PATH</code>路径中，不推荐使用此方式），否则无法执行。</p>
<p>假设现在有<code>pro1，pro2，pro3</code>这 3 个用户，还有一个<code>group</code>群组，我们可以通过在<code>/etc/sudoers</code>文件配置<code>wheel</code>群组信息，令这 3 个用户同时拥有管理系统的权限。</p>
<p>首先，向<code>/etc/sudoers</code>文件中添加群组配置信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># visudo</span></span><br><span class="line">....(前面省略)....</span><br><span class="line">%group     ALL=(ALL)    ALL</span><br><span class="line"><span class="comment">#在 84 行#wheel这一行后面写入</span></span><br></pre></td></tr></table></figure>
<p>此配置信息表示，<code>group</code>这个群组中的所有用户都能够使用<code>sudo</code>切换任何身份，执行任何命令。接下来，我们使用<code>usermod</code>命令将<code>pro1</code>加入<code>group</code> 群组，看看有什么效果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># usermod -a -G group pro1</span></span><br><span class="line">[pro1@localhost ~]<span class="comment"># sudo tail -n 1 /etc/shadow &lt;==注意身份是 pro1</span></span><br><span class="line">....(前面省略)....</span><br><span class="line">Password:  &lt;==输入 pro1 的口令喔！</span><br><span class="line">pro3:$1$GfinyJgZ<span class="variable">$9J8IdrBXXMwZIauANg7tW0</span>:14302:0:99999:7:::</span><br><span class="line">[pro2@localhost ~]<span class="comment"># sudo tail -n 1 /etc/shadow &lt;==注意身份是 pro2</span></span><br><span class="line">Password:</span><br><span class="line">pro2 is not <span class="keyword">in</span> the sudoers file.  This incident will be reported.</span><br><span class="line"><span class="comment">#此错误信息表示 pro2 不在 /etc/sudoers 的配置中。</span></span><br></pre></td></tr></table></figure>
<p>可以看到，由于<code>pro1</code>加入到了<code>group</code>群组，因此<code>pro1</code>就可以使用<code>sudo</code>命令，而<code>pro2</code>不行。同样的道理，如果我们想让<code>pro3</code>也可以使用<code>sudo</code>命令，不用再修改<code>/etc/sudoers</code>文件，只需要将<code>pro3</code>加入<code>group</code>群组即可。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux/用户和用户组管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/20/Linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"
    >Linux用户和用户组管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/20/Linux/%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-01-20T08:24:15.000Z" itemprop="datePublished">2022-01-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h1><p>Linux 是多用户多任务操作系统，换句话说，Linux 系统支持多个用户在同一时间内登陆，不同用户可以执行不同的任务，并且互不影响。</p>
<p>例如，某台 Linux 服务器上有 4 个用户，分别是<code>root、www、ftp</code>和<code>mysql</code>，在同一时间内，<code>root</code>用户可能在查看系统日志、管理维护系统；<code>www</code>用户可能在修改自己的网页程序；<code>ftp</code>用户可能在上传软件到服务器；<code>mysql</code>用户可能在执行自己的 SQL 查询，每个用户互不干扰，有条不紊地进行着自己的工作。与此同时，每个用户之间不能越权访问，比如<code>www</code>用户不能执行<code>mysql</code>用户的 SQL 查询操作，<code>ftp</code>用户也不能修改<code>www</code>用户的网页程序。</p>
<p>不同用户具有不同的权限，毎个用户在权限允许的范围内完成不间的任务，Linux 正是通过这种权限的划分与管理，实现了多用户多任务的运行机制。</p>
<p>因此，如果要使用 Linux 系统的资源，就必须向系统管理员申请一个账户，然后通过这个账户进入系统（账户和用户是一个概念）。通过建立不同属性的用户，一方面可以合理地利用和控制系统资源，另一方面也可以帮助用户组织文件，提供对用户文件的安全性保护。</p>
<p>用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户，就需要授权 10 次，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。</p>
<p>将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。</p>
<h2 id="Linux用户和组的关系"><a href="#Linux用户和组的关系" class="headerlink" title="Linux用户和组的关系"></a>Linux用户和组的关系</h2><p>用户和用户组的对应关系有以下 4 种：</p>
<ul>
<li>一对一：一个用户可以存在一个组中，是组中的唯一成员；</li>
<li>一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；</li>
<li>多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；</li>
<li>多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。</li>
</ul>
<h1 id="UID和GID"><a href="#UID和GID" class="headerlink" title="UID和GID"></a>UID和GID</h1><p>登陆 Linux 系统时，虽然输入的是自己的用户名和密码，但其实 Linux 并不认识你的用户名称，它只认识用户名对应的 ID 号。Linux 系统将所有用户的名称与 ID 的对应关系都存储在<code>/etc/passwd</code>文件中。</p>
<p>说白了，用户名并无实际作用，仅是为了方便用户的记忆而已。</p>
<p>每个用户的 ID 细分为 2 种，分别是用户 ID（<code>User ID</code>，简称 UID）和组 ID（<code>Group ID</code>，简称 GID），这与文件有拥有者和拥有群组两种属性相对应。</p>
<p>每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据<code>/etc/passwd</code>和<code>/etc/group</code>文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来。</p>
<h1 id="x2F-etc-x2F-passwd"><a href="#x2F-etc-x2F-passwd" class="headerlink" title="&#x2F;etc&#x2F;passwd"></a>&#x2F;etc&#x2F;passwd</h1><p><code>/etc/passwd</code>是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vi /etc/passwd</span></span><br><span class="line"><span class="comment">#查看一下文件内容</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">...省略部分输出...</span><br></pre></td></tr></table></figure>
<p>每行记录对应一个用户。这些用户中的绝大多数是系统或服务正常运行所必需的用户，这种用户通常称为系统用户或伪用户。系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。</p>
<p>每行用户信息都以<code>:</code>作为分隔符，划分为 7 个字段，每个字段所表示的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:密码:UID(用户ID):GID(组ID):描述性信息:主目录:默认Shell</span><br></pre></td></tr></table></figure>
<h2 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h2><p>用户名，就是一串代表用户身份的字符串。用户名仅是为了方便用户记忆，Linux 系统是通过<code>UID</code>来识别用户身份，分配用户权限的。<code>/etc/passwd</code>文件中就定义了用户名和<code>UID</code>之间的对应关系。</p>
<h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><p><code>x</code>表示此用户设有密码，但不是真正的密码，真正的密码保存在<code>/etc/shadow</code>文件中。此文件只有<code>root</code>用户可以浏览和操作，这样就最大限度地保证了密码的安全。</p>
<p>需要注意的是，虽然<code>x</code>并不表示真正的密码，但也不能删除，如果删除了<code>x</code>，那么系统会认为这个用户没有密码，从而导致只输入用户名而不用输入密码就可以登陆（只能在本地使用无密码登录，远程是不可以的）。</p>
<h2 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h2><p><code>UID</code>，也就是用户<code>ID</code>。每个用户都有唯一的一个<code>UID</code>，Linux 系统通过<code>UID</code>来识别不同的用户。</p>
<p>实际上，<code>UID</code>就是一个<code>0~65535</code>之间的数，不同范围的数字表示不同的用户身份。</p>
<table>
<thead>
<tr>
<th align="center">UID 范围</th>
<th align="center">用户身份</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">超级用户。UID 为 0 就代表这个账号是管理员账号。如果想把普通用户升级成管理员，只需把其他用户的 UID 修改为 0 就可以了。不过不建议建立多个管理员账号。</td>
</tr>
<tr>
<td align="center"><code>1~499</code></td>
<td align="center">系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，<code>1~99</code>用于系统自行创建的账号；<code>100~499</code>分配给有系统账号需求的用户。<br>其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td>
</tr>
<tr>
<td align="center"><code>500~65535</code></td>
<td align="center">普通用户。通常这些 UID 已经足够用户使用了。2.6.x 内核之后的 Linux 系统已经可以支持 2<sup>32</sup> 个 UID 了。</td>
</tr>
</tbody></table>
<h2 id="GID"><a href="#GID" class="headerlink" title="GID"></a>GID</h2><p>组ID(<code>Group ID</code>)表示用户初始组的组 ID 号。</p>
<p>初始组，指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。比如说，我们手工添加用户<code>lamp</code>，在建立用户<code>lamp</code>的同时，就会建立<code>lamp</code>组作为<code>lamp</code>用户的初始组。</p>
<p>附加组，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。</p>
<p>举例来说，刚刚的<code>lamp</code>用户除属于初始组<code>lamp</code>外，我又把它加入了<code>users</code>组，那么<code>lamp</code>用户同时属于<code>lamp</code>组和<code>users</code>组，其中<code>lamp</code>是初始组，<code>users</code>是附加组。</p>
<p>当然，初始组和附加组的身份是可以修改的，但是我们在工作中不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱。</p>
<p>需要注意的是，在<code>/etc/passwd</code>文件的第四个字段中看到的<code>ID</code>是这个用户的初始组。</p>
<h2 id="描述性信息"><a href="#描述性信息" class="headerlink" title="描述性信息"></a>描述性信息</h2><p>这个字段并没有什么重要的用途，只是用来解释这个用户的意义而已。</p>
<h2 id="主目录"><a href="#主目录" class="headerlink" title="主目录"></a>主目录</h2><p>也就是用户登录后有操作权限的访问目录，通常称为用户的主目录。</p>
<p>例如，<code>root</code>超级管理员账户的主目录为<code>/root</code>，普通用户的主目录为<code>/home/yourIDname</code>，即在<code>/home/</code>目录下建立和用户名相同的目录作为主目录，如<code>lamp</code>用户的主目录就是<code>/home/lamp/</code>目录。</p>
<h2 id="默认的Shell"><a href="#默认的Shell" class="headerlink" title="默认的Shell"></a>默认的Shell</h2><p>Shell 就是 Linux 的命令解释器，是用户和 Linux 内核之间沟通的桥梁。</p>
<p>用户登陆 Linux 系统后，通过使用 Linux 命令完成操作任务，但系统只认识类似 0101 的机器语言，这里就需要使用命令解释器。也就是说，Shell 命令解释器的功能就是将用户输入的命令转换成系统可以识别的机器语言。</p>
<p>通常情况下，Linux 系统默认使用的命令解释器是<code>bash（/bin/bash）</code>，当然还有其他命令解释器，例如<code>sh、csh</code>等。</p>
<p>在<code>/etc/passwd</code>文件中，大家可以把这个字段理解为用户登录之后所拥有的权限。如果这里使用的是<code>bash</code>命令解释器，就代表这个用户拥有权限范围内的所有权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/passwd</span><br><span class="line">lamp:x:502:502::/home/lamp:/bin/bash</span><br></pre></td></tr></table></figure>
<p><code>lamp</code>用户使用的是<code>bash</code>命令解释器，那么这个用户就可以使用普通用户的所有权限。</p>
<p>如果把<code>lamp</code>用户的 Shell 命令解释器修改为<code>/sbin/nologin</code>，那么，这个用户就不能登录了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/passwd</span><br><span class="line">lamp:x:502:502::/home/lamp:/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>因为<code>/sbin/nologin</code>就是禁止登录的 Shell。同样，如果我在这里放入的系统命令，如<code>/usr/bin/passwd</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vi /etc/passwd</span><br><span class="line">lamp:x:502:502::/home/lamp:/usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p>那么这个用户可以登录，但登录之后就只能修改自己的密码。但是，这里不能随便写入和登陆没有关系的命令（如<code>ls</code>），系统不会识别这些命令，同时也就意味着这个用户不能登录。</p>
<h1 id="x2F-etc-x2F-shadow（影子文件）"><a href="#x2F-etc-x2F-shadow（影子文件）" class="headerlink" title="&#x2F;etc&#x2F;shadow（影子文件）"></a>&#x2F;etc&#x2F;shadow（影子文件）</h1><p><code>/etc/shadow</code>文件用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。</p>
<p>由于<code>/etc/passwd</code>文件允许所有用户读取，易导致用户密码泄露，因此 Linux 系统将用户的密码信息从<code>/etc/passwd</code>文件中分离出来，并单独放到了此文件中。</p>
<p><code>/etc/shadow</code>文件只有<code>root</code>用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。</p>
<p>注意，如果这个文件的权限发生了改变，则需要注意是否是恶意攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vim /etc/shadow</span><br><span class="line">root:$6$Qjmhuu4JIs3vwcTE$ZJdbAxLbBRrQxYKWMMZpVVmVRegCk33Siq4AKQg6eKojFQFCj6kC8LUxqW1cnr9AvNZUiV1.7E0oyMSc9.WSc.::0:99999:7:::</span><br><span class="line">bin:*:18353:0:99999:7:::</span><br><span class="line">daemon:*:18353:0:99999:7:::</span><br><span class="line">…省略部分输出…</span><br></pre></td></tr></table></figure>
<p>文件中每行代表一个用户，使用<code>:</code>作为分隔符，每行用户信息被划分为 9 个字段。每个字段的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:加密密码:最后一次修改时间:最小修改时间间隔:密码有效期:密码需要变更前的警告天数:密码过期后的宽限时间:账号失效时间:保留字段</span><br></pre></td></tr></table></figure>
<h3 id="用户名-1"><a href="#用户名-1" class="headerlink" title="用户名"></a>用户名</h3><p>同<code>/etc/passwd</code>文件的用户名有相同的含义。</p>
<h3 id="加密密码"><a href="#加密密码" class="headerlink" title="加密密码"></a>加密密码</h3><p>这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。</p>
<p>注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件透过这个功能，在密码串前加上<code>!、*</code>或<code>x</code>使密码暂时失效。</p>
<p>所有伪用户的密码都是<code>!!</code>或<code>*</code>，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是<code>!!</code>，代表这个用户没有密码，不能登录。</p>
<h3 id="最后一次修改时间"><a href="#最后一次修改时间" class="headerlink" title="最后一次修改时间"></a>最后一次修改时间</h3><p>此字段表示最后一次修改密码的时间。Linux 计算日期的时间是以  1970 年 1 月 1 日作为 1 不断累加得到的时间，到 1971 年 1 月 1 日，则为 366 天。这里显示 15775 天，也就是说，此<code>root</code>账号在 1970 年 1 月 1 日之后的第 15775 天修改的<code>root</code>用户密码。</p>
<p>那么，到底 15775 代表的是哪一天呢？可以使用如下命令进行换算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# date -d &quot;1970-01-01 15775 days&quot;</span><br><span class="line">2013年03月11日 星期一 00:00:00 CST</span><br></pre></td></tr></table></figure>
<p>通过以上命令，即可将其换算为我们习惯的系统日期。</p>
<h3 id="最小修改时间间隔"><a href="#最小修改时间间隔" class="headerlink" title="最小修改时间间隔"></a>最小修改时间间隔</h3><p>最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。</p>
<p>该字段是为了针对某些人频繁更改账户密码而设计的。</p>
<h3 id="密码有效期"><a href="#密码有效期" class="headerlink" title="密码有效期"></a>密码有效期</h3><p>为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。</p>
<p>该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。</p>
<h3 id="密码需要变更前的警告天数"><a href="#密码需要变更前的警告天数" class="headerlink" title="密码需要变更前的警告天数"></a>密码需要变更前的警告天数</h3><p>与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 “再过 n 天你的密码就要过期了，请尽快重新设置你的密码！”。</p>
<p>该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出”修改密码”的警告信息。</p>
<h3 id="密码过期后的宽限天数"><a href="#密码过期后的宽限天数" class="headerlink" title="密码过期后的宽限天数"></a>密码过期后的宽限天数</h3><p>也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。</p>
<p>比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。</p>
<h3 id="账号失效时间"><a href="#账号失效时间" class="headerlink" title="账号失效时间"></a>账号失效时间</h3><p>同第 3 个字段一样，使用自 1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！</p>
<h3 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h3><p>这个字段目前没有使用，等待新功能的加入。</p>
<h3 id="忘记密码怎么办"><a href="#忘记密码怎么办" class="headerlink" title="忘记密码怎么办"></a>忘记密码怎么办</h3><p>对于普通账户的密码遗失，可以通过<code>root</code>账户解决，它会重新给你配置好指定账户的密码，而不需知道你原有的密码（利用<code>root</code>的身份使用<code>passwd</code>命令即可）。</p>
<p>如果<code>root</code>账号的密码遗失，则需要重新启动进入单用户模式，系统会提供<code>root</code>权限的<code>bash</code>接口，此时可以用<code>passwd</code>命令修改账户密码；也可以通过挂载根目录，修改<code>/etc/shadow</code>，将账户的<code>root</code>密码清空的方法，此方式可使用<code>root</code>无法密码即可登陆，建议登陆后使用<code>passwd</code>命令配置<code>root</code>密码。</p>
<h1 id="x2F-etc-x2F-group"><a href="#x2F-etc-x2F-group" class="headerlink" title="&#x2F;etc&#x2F;group"></a>&#x2F;etc&#x2F;group</h1><p><code>/ect/group</code>文件是用户组配置文件，即用户组的所有信息都存放在此文件中。</p>
<p>此文件是记录组 ID（GID）和组名相对应的文件。<code>etc/passwd</code>文件中每行用户信息的第四个字段记录的是用户的初始组 ID，那么，此 GID 的组名是从<code>/etc/group</code>文件中查找到的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vim /etc/group</span><br><span class="line">root:x:0:</span><br><span class="line">bin:x:1:bin,daemon</span><br><span class="line">daemon:x:2:bin,daemon</span><br><span class="line">…省略部分输出…</span><br><span class="line">lamp:x:502:</span><br></pre></td></tr></table></figure>
<p>此文件中每一行各代表一个用户组。</p>
<p>各用户组中，还是以<code>:</code>作为字段之间的分隔符，分为 4 个字段，每个字段对应的含义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:密码：GID：该用户组中的用户列表</span><br></pre></td></tr></table></figure>
<h2 id="组名"><a href="#组名" class="headerlink" title="组名"></a>组名</h2><p>也就是是用户组的名称，有字母或数字构成。同<code>/etc/passwd</code>中的用户名一样，组名也不能重复。</p>
<h2 id="组密码"><a href="#组密码" class="headerlink" title="组密码"></a>组密码</h2><p>和<code>/etc/passwd</code>文件一样，这里的<code>x</code>仅仅是密码标识，真正加密后的组密码默认保存在<code>/etc/gshadow</code>文件中。</p>
<p>不过，用户设置密码是为了验证用户的身份，那用户组设置密码是用来做什么的呢？用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，<code>root</code>用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，可以由该组的组管理员替代<code>root</code>进行管理。但是这项功能目前很少使用，我们也很少设置组密码。如果需要赋予某用户调整某个用户组的权限，则可以使用 sudo 命令代替。</p>
<h2 id="组ID-GID"><a href="#组ID-GID" class="headerlink" title="组ID (GID)"></a>组ID (GID)</h2><p>就是群组的 ID 号，Linux 系统就是通过 GID 来区分用户组的，同用户名一样，组名也只是为了便于管理员记忆。</p>
<p>这里的组 GID 与<code>/etc/passwd</code>文件中第 4 个字段的 GID 相对应，实际上，<code>/etc/passwd</code>文件中使用 GID 对应的群组名，就是通过此文件对应得到的。</p>
<h2 id="组中的用户"><a href="#组中的用户" class="headerlink" title="组中的用户"></a>组中的用户</h2><p>此字段列出每个群组包含的所有用户。需要注意的是，如果该用户组是这个用户的初始组，则该用户不会写入这个字段，可以这么理解，该字段显示的用户都是这个用户组的附加用户。</p>
<p>举个例子，<code>lamp</code>组的组信息为<code>lamp:x:502:</code>，可以看到，第四个字段没有写入<code>lamp</code>用户，因为<code>lamp</code>组是<code>lamp</code>用户的初始组。如果要查询这些用户的初始组，则需要先到<code>/etc/passwd</code>文件中查看 GID（第四个字段），然后到<code>/etc/group</code>文件中比对组名。</p>
<p>每个用户都可以加入多个附加组，但是只能属于一个初始组。所以我们在实际工作中，如果需要把用户加入其他组，则需要以附加组的形式添加。例如，我们想让<code>lamp</code>也加入<code>root</code>这个群组，那么只需要在第一行的最后一个字段加入<code>lamp</code>，即<code>root:x:0:lamp</code>就可以了。</p>
<p>一般情况下，用户的初始组就是在建立用户的同时建立的和用户名相同的组。</p>
<h1 id="x2F-etc-x2F-gshadow"><a href="#x2F-etc-x2F-gshadow" class="headerlink" title="&#x2F;etc&#x2F;gshadow"></a>&#x2F;etc&#x2F;gshadow</h1><p>组用户信息存储在<code>/etc/group</code>文件中，而组用户的密码信息存储在<code>/etc/gshadow</code>文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vim /etc/gshadow</span><br><span class="line">root:::</span><br><span class="line">bin:::bin, daemon</span><br><span class="line">daemon:::bin, daemon</span><br><span class="line">...省略部分输出...</span><br><span class="line">lamp:!::</span><br></pre></td></tr></table></figure>
<p>文件中，每行代表一个组用户的密码信息，各行信息用<code>:</code>作为分隔符分为 4 个字段，每个字段的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名：加密密码：组管理员：组附加用户列表</span><br></pre></td></tr></table></figure>
<h2 id="组名-1"><a href="#组名-1" class="headerlink" title="组名"></a>组名</h2><p>同<code>/etc/group</code>文件中的组名相对应。</p>
<h2 id="组密码-1"><a href="#组密码-1" class="headerlink" title="组密码"></a>组密码</h2><p>对于大多数用户来说，通常不设置组密码，因此该字段常为空，但有时为<code>!</code>，指的是该群组没有组密码，也不设有群组管理员。</p>
<h2 id="组管理员"><a href="#组管理员" class="headerlink" title="组管理员"></a>组管理员</h2><p>从系统管理员的角度来说，该文件最大的功能就是创建群组管理员。</p>
<p>考虑到 Linux 系统中账号太多，而超级管理员<code>root</code>可能比较忙碌，因此当有用户想要加入某群组时，<code>root</code>或许不能及时作出回应。这种情况下，如果有群组管理员，那么他就能将用户加入自己管理的群组中，也就免去麻烦<code>root</code>了。</p>
<p>不过，由于目前有<code>sudo</code>之类的工具，因此群组管理员的这个功能已经很少使用了。</p>
<h2 id="组中的附加用户"><a href="#组中的附加用户" class="headerlink" title="组中的附加用户"></a>组中的附加用户</h2><p>该字段显示这个用户组中有哪些附加用户，和<code>/etc/group</code>文件中附加组显示内容相同。</p>
<h1 id="初始组和附加组"><a href="#初始组和附加组" class="headerlink" title="初始组和附加组"></a>初始组和附加组</h1><p>群组可以让多个用户具有相同的权限，同时也可以这样理解，一个用户可以所属多个群组，并同时拥有这些群组的权限，这就引出了初始组（有时也称主组）和附加组。</p>
<p><code>/etc/passwd</code>文件中每个用户信息分为 7 个字段，其中第 4 字段（GID）指的就是每个用户所属的初始组，也就是说，当用户一登陆系统，立刻就会拥有这个群组的相关权限。</p>
<p>举个例子，我们新建一个用户<code>lamp</code>，并将其加入<code>users</code>群组中，执行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd lamp  &lt;--添加新用户</span><br><span class="line">[root@localhost ~]# groupadd users  &lt;--添加新群组</span><br><span class="line">[root@localhost ~]# usermod -G users lamp  &lt;--将用户lamp加入 users群组</span><br><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/passwd /etc/group /etc/gshadow</span><br><span class="line">/etc/passwd:lamp:x:501:501::/home/lamp:/bin/bash</span><br><span class="line">/etc/group:users:x:100:lamp</span><br><span class="line">/etc/group:lamp:x:501:</span><br><span class="line">/etc/gshadow:users:::lamp</span><br><span class="line">/etc/gshadow:lamp:!::</span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>etc/passwd</code>文件中，<code>lamp</code>用户所属的 GID（群组 ID）为 501，通过搜索<code>/etc/group</code>文件得知，对应此 GID 的是<code>lamp</code>群组，也就是说，<code>lamp</code>群组是<code>lamp</code>用户的初始组。</p>
<p><code>lamp</code>群组是添加<code>lamp</code>用户时默认创建的群组，在<code>root</code>管理员使用<code>useradd</code>命令创建新用户时，若未明确指定该命令所属的初始组，<code>useradd</code>命令会默认创建一个同用户名相同的群组，作为该用户的初始组。</p>
<p>正因为<code>lamp</code>群组是<code>lamp</code>用户的初始组，该用户一登陆就会自动获取相应权限，因此不需要在<code>/etc/group</code>的第 4 个字段额外标注。</p>
<p>但是，附加组就不一样了，从例子中可以看到，我们将<code>lamp</code>用户加入<code>users</code>群组中，由于<code>users</code>这个群组并不是<code>lamp</code>的初始组，因此必须要在<code>/etc/group</code>这个文件中找到<code>users</code>那一行，将<code>lamp</code>这个用户加入第 4 段中（群组包含的所有用户），这样<code>lamp</code>用户才算是真正加入到<code>users</code>这个群组中。</p>
<p>在这个例子中，因为<code>lamp</code>用户同时属于<code>lamp</code>和<code>users</code>两个群组，所在，在读取\写入\运行文件时，只要是<code>user</code>和<code>lamp</code>群组拥有的功能，<code>lamp</code>用户都拥有。</p>
<p>一个用户可以所属多个附加组，但只能有一个初始组。如果要知道某用户所属哪些群组，使用<code>groups</code>命令即可。</p>
<p>例如，我们现在以<code>lamp</code>用户的身份登录系统，通过执行如下命令即可知晓当前用户所属的全部群组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groups</span><br><span class="line">lamp users</span><br></pre></td></tr></table></figure>
<p>第一个出现的为用户的初始组，后面的都是附加组。</p>
<h1 id="x2F-etc-x2F-login-defs：创建用户的默认设置文件"><a href="#x2F-etc-x2F-login-defs：创建用户的默认设置文件" class="headerlink" title="&#x2F;etc&#x2F;login.defs：创建用户的默认设置文件"></a>&#x2F;etc&#x2F;login.defs：创建用户的默认设置文件</h1><p><code>/etc/login.defs</code>文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等。</p>
<p>需要注意的是，该文件的用户默认配置对<code>root</code>用户无效。并且，当此文件中的配置与<code>/etc/passwd</code>和<code>/etc/shadow</code>文件中的用户信息有冲突时，系统会以<code>/etc/passwd</code>和<code>/etc/shadow</code>为准。</p>
<p><code>/etc/login.defs</code>文件内容：</p>
<table>
<thead>
<tr>
<th align="center">设置项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MAIL_DIR &#x2F;var&#x2F;spool&#x2F;mail</td>
<td align="center">创建用户时，系统会在目录 &#x2F;var&#x2F;spool&#x2F;mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是 &#x2F;var&#x2F;spool&#x2F;mail&#x2F;lamp。</td>
</tr>
<tr>
<td align="center">PASS_MAX_DAYS 99999</td>
<td align="center">密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。</td>
</tr>
<tr>
<td align="center">PASS_MIN_DAYS 0</td>
<td align="center">表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。</td>
</tr>
<tr>
<td align="center">PASS_MIN_LEN 5</td>
<td align="center">指定密码的最小长度，默认不小于 5 位，但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效。</td>
</tr>
<tr>
<td align="center">PASS_WARN_AGE 7</td>
<td align="center">指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。</td>
</tr>
<tr>
<td align="center">UID_MIN 500</td>
<td align="center">指定最小 UID 为 500，也就是说，添加用户时，默认 UID 从 500 开始。注意，如果手工指定了一个用户的 UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500~549 之间的 UID 没有使用。</td>
</tr>
<tr>
<td align="center">UID_MAX 60000</td>
<td align="center">指定用户最大的 UID 为 60000。</td>
</tr>
<tr>
<td align="center">GID_MIN 500</td>
<td align="center">指定最小 GID 为 500，也就是在添加组时，组的 GID 从 500 开始。</td>
</tr>
<tr>
<td align="center">GID_MAX 60000</td>
<td align="center">用户 GID 最大为 60000。</td>
</tr>
<tr>
<td align="center">CREATE_HOME yes</td>
<td align="center">指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。</td>
</tr>
<tr>
<td align="center">UMASK 077</td>
<td align="center">用户主目录的权限默认设置为 077。</td>
</tr>
<tr>
<td align="center">USERGROUPS_ENAB yes</td>
<td align="center">指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。</td>
</tr>
<tr>
<td align="center">ENCRYPT_METHOD SHA512</td>
<td align="center">指定用户密码采用的加密规则，默认采用 SHA512，这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5 加密。</td>
</tr>
</tbody></table>
<h1 id="useradd：添加新的系统用户"><a href="#useradd：添加新的系统用户" class="headerlink" title="useradd：添加新的系统用户"></a>useradd：添加新的系统用户</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#useradd [选项] 用户名</span><br></pre></td></tr></table></figure>
<p><code>useradd</code>命令常用选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-u</td>
<td align="center">UID	手工指定用户的 UID，注意 UID 的范围（不要小于 500）。</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="center">主目录	手工指定用户的主目录。主目录必须写绝对路径，而且如果需要手工指定主目录，则一定要注意权限；</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">用户说明	手工指定&#x2F;etc&#x2F;passwd文件中各用户信息中第 5 个字段的描述性内容，可随意配置；</td>
</tr>
<tr>
<td align="center">-g</td>
<td align="center">组名	手工指定用户的初始组。一般以和用户名相同的组作为用户的初始组，在创建用户时会默认建立初始组。一旦手动指定，则系统将不会在创建此默认的初始组目录。</td>
</tr>
<tr>
<td align="center">-G</td>
<td align="center">组名	指定用户的附加组。我们把用户加入其他组，一般都使用附加组；</td>
</tr>
<tr>
<td align="center">-s</td>
<td align="center">shell	手工指定用户的登录 Shell，默认是 &#x2F;bin&#x2F;bash；</td>
</tr>
<tr>
<td align="center">-e</td>
<td align="center">曰期	指定用户的失效曰期，格式为 “YYYY-MM-DD”。也就是 &#x2F;etc&#x2F;shadow 文件的第八个字段；</td>
</tr>
<tr>
<td align="center">-o</td>
<td align="center">允许创建的用户的 UID 相同。例如，执行 “useradd -u 0 -o usertest” 命令建立用户 usertest，它的 UID 和 root 用户的 UID 相同，都是 0；</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">建立用户时强制建立用户的家目录。在建立系统用户时，该选项是默认的；</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">创建系统用户，也就是 UID 在 1~499 之间，供系统程序使用的用户。由于系统用户主要用于运行系统所需服务的权限配置，因此系统用户的创建默认不会创建主目录。</td>
</tr>
</tbody></table>
<p>其实，系统已经帮我们规定了非常多的默认值，在没有特殊要求下，无需使用任何选项即可成功创建用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd lamp</span><br></pre></td></tr></table></figure>
<p>此行命令就表示创建<code>lamp</code>普通用户。</p>
<p>不要小看这条简单的命令，它会完成以下几项操作：</p>
<ol>
<li>在<code>/etc/passwd</code>文件中创建一行与<code>lamp</code>用户相关的数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/passwd</span><br><span class="line">lamp:x:500:500::/home/lamp:/bin/bash</span><br></pre></td></tr></table></figure>
可以看到，用户的 UID 是从 500 开始计算的。同时默认指定了用户的家目录为<code>/home/lamp/</code>，用户的登录 Shell 为<code>/bin/bash</code>。</li>
<li>在<code>/etc/shadow</code>文件中新增了一行与<code>lamp</code>用户密码相关的数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/shadow</span><br><span class="line">lamp:!!:15710:0:99999:7:::</span><br></pre></td></tr></table></figure>
当然，这个用户还没有设置密码，所以密码字段是<code>!!</code>，代表这个用户没有合理密码，不能正常登录。同时会按照默认值设定时间字段，例如密码有效期有 99999 天，距离密码过期 7 天系统会提示用户“密码即将过期”等。</li>
<li>在<code>/etc/group</code>文件中创建一行与用户名一模一样的群组：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/group</span><br><span class="line">lamp:x:500:</span><br></pre></td></tr></table></figure>
该群组会作为新建用户的初始组。</li>
<li>在<code>/etc/gshadow</code>文件中新增一行与新增群组相关的密码信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/gshadow</span><br><span class="line">lamp:!::</span><br></pre></td></tr></table></figure>
当然，我们没有设定组密码，所以这里没有密码，也没有组管理员。</li>
<li>默认创建用户的主目录和邮箱：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#ll -d /home/lamp/</span><br><span class="line">drwx------ 3 lamp lamp 4096 1月6 00:19 /home/lamp/</span><br><span class="line">[root@localhost ~]#ll /var/spod/mail/lamp</span><br><span class="line">-rw-rw---- 1 lamp mail 0 1月6 00:19 /var/spool/mail/lamp</span><br></pre></td></tr></table></figure>
注意这两个文件的权限，都要让<code>lamp</code>用户拥有相应的权限。</li>
<li>将<code>/etc/skel</code>目录中的配置文件复制到新用户的主目录中。</li>
</ol>
<p>可以看到，<code>useradd</code>命令创建用户的过程，其实就是修改了与用户相关的几个文件或目录。</p>
<p>除了默认创建用户，我们还可以利用<code>useradd</code>命令的各种选项亲自定制要创建的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd lamp1</span><br><span class="line">#先手工添加lamp1用户组，因为我一会儿要把lamp1用户的初始迎指定过来，如果不事先建立，则会报告用户组不存在</span><br><span class="line">[root@localhost ~]# useradd -u 550 -g lamp1 -G root -d /home/lamp1 -c &quot;test user&quot; -s /bin/bash lamp1</span><br><span class="line">#在建立用户lamp1的同时，指定了UID（550）、初始组（lamp1）、附加组（root）、家目录（/home/lamp1/）、用户说明（test user）和用户登录Shell（/bin/bash）</span><br><span class="line">[root@localhost ~]# grep &quot;lamp1&quot; /etc/passwd /etc/shadow /etc/group</span><br><span class="line">#同时查看三个文件</span><br><span class="line">/etc/passwd:lamp1:x:550:502:test user:/home/lamp1:/bin/bash</span><br><span class="line">#用户的UID、初始组、用户说明、家目录和登录Shell都和命令手工指定的一致</span><br><span class="line">/etc/shadow:lamp1:!!:15710:0:99999:7:::</span><br><span class="line">#lamp1用户还没有设定密码</span><br><span class="line">/etc/group:root:x:0:lamp1</span><br><span class="line">#lamp1用户加入了root组，root组是lamp1用户的附加组</span><br><span class="line">/etc/group:lampl:x:502:</span><br><span class="line">#GID为502的组是lamp1组</span><br><span class="line">[root@localhost ~]#ll -d /home/lamp1/</span><br><span class="line">drwx------ 3 lamp1 lamp1 4096 1月6 01:13 /home/lamp1/</span><br><span class="line">#家目录也建立了，不需要手工建立</span><br></pre></td></tr></table></figure>
<p>通过以上 2 种方式，都可以成功创建用户。通常情况下，根本不需要手工指定任何内容，因为使用默认值就可以满足我们的要求。那你有没有想过，<code>useradd</code>命令的这些默认值保存哪里，能否手工修改呢？</p>
<p>答案是肯定的。<code>useradd</code>命令在添加用户时参考的默认值文件主要有两个，分别是<code>/etc/default/useradd</code>和<code>/etc/login.defs</code>。</p>
<h2 id="x2F-etc-x2F-default-x2F-useradd-文件"><a href="#x2F-etc-x2F-default-x2F-useradd-文件" class="headerlink" title="&#x2F;etc&#x2F;default&#x2F;useradd 文件"></a>&#x2F;etc&#x2F;default&#x2F;useradd 文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#vim /etc/default/useradd</span><br><span class="line"># useradd defaults file</span><br><span class="line">GR0UP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure>
<p>另外，也可以直接通过命令进行查看，结果是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd -D</span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure>
<p><code>-D</code>选项指的就是查看新建用户的默认值。</p>
<p><code>/etc/default/useradd</code>文件内容：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GR0UP&#x3D;100</td>
<td align="center">这个选项用于建立用户的默认组，也就是说，在添加每个用户时，用户的初始组就是 GID 为 100 的这个用户组。但 CentOS 并不是这样的，而是在添加用户时会自动建立和用户名相同的组作为此用户的初始组。也就是说这个选项并不会生效。<br>Linux 中默认用户组有两种机制：一种是私有用户组机制，系统会创建一个和用户名相同的用户组作为用户的初始组；另一种是公共用户组机制，系统用 GID 是 100 的用户组作为所有新建用户的初始组。目前我们采用的是私有用户组机制。</td>
</tr>
<tr>
<td align="center">HOME&#x3D;&#x2F;home</td>
<td align="center">指的是用户主目录的默认位置，所有新建用户的主目录默认都在<code>/home/</code>下，刚刚新建的 lamp1 用户的主目录就为<code>/home/lamp1/</code>。</td>
</tr>
<tr>
<td align="center">INACTIVE&#x3D;-1</td>
<td align="center">指的是密码过期后的宽限天数，也就是<code>/etc/shadow</code>文件的第七个字段。这里默认值是 -1，代表所有新建立的用户密码永远不会失效。</td>
</tr>
<tr>
<td align="center">EXPIRE&#x3D;</td>
<td align="center">表示密码失效时间，也就是<code>/etc/shadow</code>文件的第八个字段。默认值是空，代表所有新建用户没有失效时间，永久有效。</td>
</tr>
<tr>
<td align="center"><code>SHELL=/bin/bash</code></td>
<td align="center">表示所有新建立的用户默认 Shell 都是<code>/bin/bash</code>。</td>
</tr>
<tr>
<td align="center"><code>SKEL=/etc/skel</code></td>
<td align="center">在创建一个新用户后，你会发现，该用户主目录并不是空目录，而是有<code>.bash_profile、.bashrc</code>等文件，这些文件都是从<code>/etc/skel</code>目录中自动复制过来的。因此，更改<code>/etc/skel</code>目录下的内容就可以改变新建用户默认主目录中的配置文件信息。</td>
</tr>
<tr>
<td align="center">CREATE_MAIL_SPOOL&#x3D;yes</td>
<td align="center">指的是给新建用户建立邮箱，默认是创建。也就是说，对于所有的新建用户，系统都会新建一个邮箱，放在<code>/var/spool/mail/</code>目录下，和用户名相同。例如，<code>lamp1</code>的邮箱位于<code>/var/spool/mail/lamp1</code>。</td>
</tr>
</tbody></table>
<p>注意，此文件中各选项值的修改方式有 2 种，一种是通过 Vim 文本编辑器手动修改，另一种就是使用 useradd 命令，不过所用的命令格式发生了改变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -D [选项] 参数</span><br></pre></td></tr></table></figure>
<p>用此命令修改<code>/etc/default/useradd</code>文件，<code>useradd -D</code>命令可用选项：</p>
<table>
<thead>
<tr>
<th align="center">选项+参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-b HOME</td>
<td align="center">设置所创建的主目录所在的默认目录，只需用目录名替换 HOME 即可，例如 useradd -D -b &#x2F;gargae。</td>
</tr>
<tr>
<td align="center">-e EXPIRE</td>
<td align="center">设置密码失效时间，EXPIRE 参数应使用 YYYY-MM-DD 格式，例如 useradd -D -e 2019-10-17。</td>
</tr>
<tr>
<td align="center">-f INACTIVE</td>
<td align="center">设置密码过期的宽限天数，例如 useradd -D -f 7。</td>
</tr>
<tr>
<td align="center">-g GROUP</td>
<td align="center">设置新用户所在的初始组，例如 useradd -D -g bear。</td>
</tr>
<tr>
<td align="center">-s SHELL</td>
<td align="center">设置新用户的默认 shell，SHELL 必须是完整路径，例如 useradd -D -s &#x2F;usr&#x2F;bin&#x2F;csh。</td>
</tr>
</tbody></table>
<p>例如，要修改新用户的默认 Shell 为<code>/bin/csh</code>，可以使用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd -D -s /bin/csh</span><br><span class="line">[root@localhost ~]# useradd -D</span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/csh</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure>
<p>通过<code>/etc/default/useradd</code>文件，大家仅能修改有关新用户的部分默认值，有一些内容并没有在这个文件中，例如修改用户默认的 UID、GID，以及对用户密码的默认设置，对这些默认值的修改就需要在<code>/etc/login.defs</code>文件中进行。</p>
<p>其实，<code>useradd</code>命令创建用户的过程是这样的，系统首先读取<code>/etc/login.defs</code>和<code>/etc/default/useradd</code>，根据这两个配置文件中定义的规则添加用户，也就是向<code>/etc/passwd、/etc/group、/etc/shadow、/etc/gshadow</code>文件中添加用户数据，接着系统会自动在<code>/etc/default/useradd</code>文件设定的目录下建立用户主目录，最后复制<code>/etc/skel</code>目录中的所有文件到此主目录中，由此，一个新的用户就创建完成了。</p>
<p>当然，如果你能彻底掌握<code>useradd</code>命令创建用户的整个过程，完全可以手动创建用户。</p>
<h1 id="passwd命令：修改用户密码"><a href="#passwd命令：修改用户密码" class="headerlink" title="passwd命令：修改用户密码"></a>passwd命令：修改用户密码</h1><p>使用<code>useradd</code>命令创建新用户时，并没有设定用户密码，因此还无法用来登陆系统，需要使用<code>passwd</code>密码配置命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#passwd [选项] 用户名</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-S</code>：查询用户密码的状态，也就是<code>/etc/shadow</code>文件中此用户密码的内容。仅<code>root</code>用户可用；</li>
<li><code>-l</code>：暂时锁定用户，该选项会在<code>/etc/shadow</code>文件中指定用户的加密密码串前添加”!”，使密码失效。仅<code>root</code>用户可用；</li>
<li><code>-u</code>：解锁用户，和<code>-l</code>选项相对应，也是只能<code>root</code>用户使用；</li>
<li><code>--stdin</code>：可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用；</li>
<li><code>-n</code> 天数：设置该用户修改密码后，多长时间不能再次修改密码，也就是修改<code>/etc/shadow</code>文件中各行密码的第 4 个字段；</li>
<li><code>-x</code> 天数：设置该用户的密码有效期，对应<code>/etc/shadow</code>文件中各行密码的第 5 个字段；</li>
<li><code>-w</code> 天数：设置用户密码过期前的警告天数，对于<code>/etc/shadow</code>文件中各行密码的第 6 个字段；</li>
<li><code>-i</code> 日期：设置用户密码失效日期，对应<code>/etc/shadow</code>文件中各行密码的第 7 个字段。</li>
</ul>
<p>例如，我们使用<code>root</code>账户修改<code>lamp</code>普通用户的密码，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#passwd lamp</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">New password: &lt;==直接输入新的口令，但屏幕不会有任何反应</span><br><span class="line">BAD PASSWORD: it is WAY too short &lt;==口令太简单或过短的错误！这里只是警告信息，输入的密码依旧能用</span><br><span class="line">Retype new password:  &lt;==再次验证输入的密码，再输入一次即可</span><br><span class="line">passwd: all authentication tokens updated successfully.  &lt;==提示修改密码成功</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用<code>passwd</code>命令修改当前系统已登录用户的密码，但要注意的是，需省略掉”选项”和”用户名”。例如，我们登陆<code>lamp</code>用户，并使用<code>passwd</code>命令修改<code>lamp</code>的登陆密码，执行过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#passwd</span><br><span class="line">#passwd直接回车代表修改当前用户的密码</span><br><span class="line">Changing password for user vbird2.</span><br><span class="line">Changing password for vbird2</span><br><span class="line">(current) UNIX password: &lt;==这里输入『原有的旧口令』</span><br><span class="line">New password: &lt;==这里输入新口令</span><br><span class="line">BAD PASSWORD: it is WAY too short &lt;==口令检验不通过，请再想个新口令</span><br><span class="line">New password: &lt;==这里再想个来输入吧</span><br><span class="line">Retype new password: &lt;==通过口令验证！所以重复这个口令的输入</span><br><span class="line">passwd: all authentication tokens updated successfully. &lt;==成功修改用户密码</span><br></pre></td></tr></table></figure>
<p>注意，普通用户只能使用<code>passwd</code>命令修改自己的密码，而不能修改其他用户的密码。</p>
<p>可以看到，与使用<code>root</code>账户修改普通用户的密码不同，普通用户修改自己的密码需要先输入自己的旧密码，只有旧密码输入正确才能输入新密码。不仅如此，此种修改方式对密码的复杂度有严格的要求，新密码太短、太简单，都会被系统检测出来并禁止用户使用。</p>
<p>而使用<code>root</code>用户，无论是修改普通用户的密码，还是修改自己的密码，都可以不遵守 PAM 模块设定的规则，就比如我刚刚给<code>lamp</code>用户设定的密码是”123”，系统虽然会提示密码过短和过于简单，但依然可以设置成功。当然，在实际应用中，就算是<code>root</code>身份，在设定密码时也要严格遵守密码规范，因为只有好的密码规范才是服务器安全的基础。</p>
<p><code>passwd</code>命令还提供了一些选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看用户密码的状态</span><br><span class="line">[root@localhost ~]# passwd -S lamp</span><br><span class="line">lamp PS 2013-01-06 0 99999 7 -1 (Password set, SHA512 crypt.)</span><br><span class="line">#上面这行代码的意思依次是：用户名 密码 设定时间(2013*01-06) 密码修改间隔时间(0) 密码有效期(99999) 警告时间(7) 密码不失效(-1)，密码已使用</span><br></pre></td></tr></table></figure>
<p><code>-S</code>选项会显示出密码状态，这里的密码修改间隔时间、密码有效期、警告时间、密码宽限时间其实分别是<code>/etc/shadow</code>文件的第四、五、六、七个字段的内容。当然，<code>passwd</code>命令是可以通过命令选项修改这几个字段的值的，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#修改 lamp的密码，使其具有 60 天变更、10 天密码失效</span><br><span class="line">[root@localhost ~]# passwd -x 60 -i 10 lamp</span><br><span class="line">[root@localhost ~]# passwd -S lamp</span><br><span class="line">lamp PS 2013-01-06 0 60 7 10 (Password set, SHA512 crypt.)</span><br></pre></td></tr></table></figure>
<p>但我个人认为，还是直接修改<code>/etc/shadow</code>文件简单一些。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#锁定 lamp 用户</span><br><span class="line">[root@localhost ~]# passwd -I lamp</span><br><span class="line">Locking password for user lamp.</span><br><span class="line">passwd:Successg</span><br><span class="line">#用&quot;-S&quot;选项査看状态，很清楚地提示密码已被锁定</span><br><span class="line">[root@localhost ~]# passwd -S lamp</span><br><span class="line">lamp LK 2013-01-06 0 99999 7 -1 (Password locked.)</span><br><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/shadow</span><br><span class="line">lamp:!! $6$ZTq7o/9o $lj07iZ0bzW.D1zBa9CsY43d04onskUCzjwiFMNt8PX4GXJoHX9zA1S C9.i Yzh9LZA4fEM2lg92hM9w/p6NS50.:15711:0:99999:7:::</span><br><span class="line">#可以看到，锁定其实就是在加密密码之前加入了&quot;!!&quot;，让密码失效而已</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#解锁 lamp 用户</span><br><span class="line">[root@localhost ~]# passwd -u lamp</span><br><span class="line">Unlocking password for user lamp.</span><br><span class="line">passwd:Success</span><br><span class="line">[root@localhost ~]# passwd -S lamp</span><br><span class="line">lamp PS 2013-01-06 0 99999 7 -1 (Password set, SHA512 crypt.)</span><br><span class="line">#可以看到，锁定状态消失</span><br><span class="line">[root@localhost ~]# grep &quot;lamp&quot; /etc/shadow</span><br><span class="line">lamp: $6$ZTq7cV9o $lj07iZ0bzW.D1zBa9CsY43d04onskUCzjwiFMNt8PX4GXJoHX9zA1S C9.iYz h9LZA4fEM2lg92hM9w/p6NS50.:15711:0:99999:7:::</span><br><span class="line">#密码前面的 &quot;!!&quot; 删除了</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#调用管道符，给 lamp 用户设置密码 &quot;123&quot;</span><br><span class="line">[root@localhost ~]# echo &quot;123&quot; | passwd --stdin lamp</span><br><span class="line">Changing password for user lamp.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
<p>为了方便系统管理，<code>passwd</code>命令提供了<code>--stdin</code>选项，用于批量给用户设置初始密码。</p>
<p>使用此方式批量给用户设置初始密码，当然好处就是方便快捷，但需要注意的是，这样设定的密码会把密码明文保存在历史命令中，如果系统被攻破，别人可以在<code>/root/.bash_history</code>中找到设置密码的这个命令，存在安全隐患。</p>
<p>注意，并非所有 Linux 发行版都支持使用此选项，使用之前可以使用<code>man passwd</code>命令确认当前系统是否支持。</p>
<h1 id="usermod命令：修改用户信息"><a href="#usermod命令：修改用户信息" class="headerlink" title="usermod命令：修改用户信息"></a>usermod命令：修改用户信息</h1><p>修改用户信息办法有两个，一个是使用 Vim 文本编辑器手动修改涉及用户信息的相关文件（<code>/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow</code>），另一个方法就是使用<code>usermod</code>命令，该命令专门用于修改用户信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#usermod [选项] 用户名</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-c</code> 用户说明：修改用户的说明信息，即修改<code>/etc/passwd</code>文件目标用户信息的第 5 个字段；</li>
<li><code>-d</code> 主目录：修改用户的主目录，即修改<code>/etc/passwd</code>文件中目标用户信息的第 6 个字段，需要注意的是，主目录必须写绝对路径；</li>
<li><code>-e</code> 日期：修改用户的失效曰期，格式为<code>YYYY-MM-DD</code>，即修改<code>/etc/shadow</code>文件目标用户密码信息的第 8 个字段；</li>
<li><code>-g</code> 组名：修改用户的初始组，即修改<code>/etc/passwd</code>文件目标用户信息的第 4 个字段（GID）；</li>
<li><code>-u</code> UID：修改用户的UID，即修改<code>/etc/passwd</code>文件目标用户信息的第 3 个字段（UID）；</li>
<li><code>-G</code> 组名：修改用户的附加组，其实就是把用户加入其他用户组，即修改<code>/etc/group</code>文件；</li>
<li><code>-l</code> 用户名：修改用户名称；</li>
<li><code>-L</code>：临时锁定用户（<code>Lock</code>）；</li>
<li><code>-U</code>：解锁用户（<code>Unlock</code>），和<code>-L</code>对应；</li>
<li><code>-s shell</code>：修改用户的登录 Shell，默认是<code>/bin/bash</code>。</li>
</ul>
<p>其实<code>usermod</code>命令提供的选项和<code>useradd</code>命令的选项相似，因为<code>usermod</code>命令就是用来调整使用<code>useradd</code>命令添加的用户信息的。</p>
<p>不过，相比<code>useradd</code>命令，<code>usermod</code>命令还多出了几个选项，即<code>-L</code>和<code>-U</code>，作用分别与<code>passwd</code>命令的<code>-l</code>和<code>-u</code>相同。需要注意的是，并不是所有的 Linux 发行版都包含这个命令，因此，使用前可以使用<code>man usermod</code>命令确定系统是否支持。</p>
<p>此命令对用户的临时锁定，同<code>passwd</code>命令一样，都是在<code>/etc/passwd</code>文件目标用户的加密密码字段前添加<code>!</code>，使密码失效；反之，解锁用户就是将添加的<code>!</code>去掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#锁定用户</span></span><br><span class="line">[root@localhost ~]<span class="comment"># usermod -L lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;lamp&quot; /etc/shadow</span></span><br><span class="line">lamp:!$6$YrPj8g0w<span class="variable">$ChRVASybEncU24hkYFqxREH3NnzhAVDJSQLwRwTSbcA2N8UbPD9bBKVQSky</span> xlaMGs/Eg5AQwO.UokOnKqaHFa/:15711:0:99999:7:::</span><br><span class="line"><span class="comment">#其实锁定就是在密码字段前加入&quot;!&quot;，这时lamp用户就暂时不能登录了</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解锁用户</span></span><br><span class="line">[root@localhost ~]<span class="comment"># usermod -U lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;lamp&quot; /etc/shadow</span></span><br><span class="line">lamp:$6$YrPj8g0w<span class="variable">$ChRVASybEncU24hkYFqxREH3NnzhAVDJSQLwRwTSbcA2N8UbPD9bBKVQSkyx</span> laMGs/Eg5AQwO.UokOnKqaHFa/:15711:0:99999:7:::</span><br><span class="line"><span class="comment">#取消了密码字段前的 &quot;!&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把lamp用户加入root组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># usermod -G root lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;lamp&quot; /etc/group</span></span><br><span class="line">root:x:0:lamp</span><br><span class="line"><span class="comment">#lamp用户已经加入了root组</span></span><br><span class="line">lamp:x:501:</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改用户说明</span></span><br><span class="line">[root@localhost ~]<span class="comment"># usermod -c &quot;test user&quot; lamp </span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;lamp&quot; /etc/passwd</span></span><br><span class="line">lamp:x:501:501:<span class="built_in">test</span> user:/home/lamp:/bin/bash</span><br><span class="line"><span class="comment">#查看一下，用户说明已经被修改了</span></span><br></pre></td></tr></table></figure>
<h1 id="chage用法：修改用户密码状态"><a href="#chage用法：修改用户密码状态" class="headerlink" title="chage用法：修改用户密码状态"></a>chage用法：修改用户密码状态</h1><p>除了<code>passwd -S</code>命令可以查看用户的密码信息外，还可以利用<code>chage</code>命令，它可以显示更加详细的用户密码信息，并且和<code>passwd</code>命令一样，提供了修改用户密码信息的功能。</p>
<p>如果你要修改用户的密码信息，我个人建议，还是直接修改<code>/etc/shadow</code>文件更加方便。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#chage [选项] 用户名</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-l</code>：列出用户的详细密码状态;</li>
<li><code>-d</code> 日期：修改<code>/etc/shadow</code>文件中指定用户密码信息的第 3 个字段，也就是最后一次修改密码的日期，格式为<code>YYYY-MM-DD</code>；</li>
<li><code>-m</code> 天数：修改密码最短保留的天数，也就是<code>/etc/shadow</code>文件中的第 4 个字段；</li>
<li><code>-M</code> 天数：修改密码的有效期，也就是<code>/etc/shadow</code>文件中的第 5 个字段；</li>
<li><code>-W</code> 天数：修改密码到期前的警告天数，也就是<code>/etc/shadow</code>文件中的第 6 个字段；</li>
<li><code>-i</code> 天数：修改密码过期后的宽限天数，也就是<code>/etc/shadow</code>文件中的第 7 个字段；</li>
<li><code>-E</code> 日期：修改账号失效日期，格式为<code>YYYY-MM-DD</code>，也就是<code>/etc/shadow</code>文件中的第 8 个字段。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看一下用户密码状态</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chage -l lamp</span></span><br><span class="line">Last password change:Jan 06, 2013</span><br><span class="line">Password expires:never</span><br><span class="line">Password inactive :never</span><br><span class="line">Account expires :never</span><br><span class="line">Minimum number of days between password change :0</span><br><span class="line">Maximum number of days between password change :99999</span><br><span class="line">Number of days of warning before password expires :7</span><br></pre></td></tr></table></figure>
<p>既然直接修改用户密码文件更方便，为什么还要用<code>chage</code>命令呢？因为<code>chage</code>命令除了修改密码信息的功能外，还可以强制用户在第一次登录后，必须先修改密码，并利用新密码重新登陆系统，此用户才能正常使用。</p>
<p>例如，我们创建<code>lamp</code>用户，并让其首次登陆系统后立即修改密码，执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建新用户 lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment">#useradd lamp</span></span><br><span class="line"><span class="comment">#设置用户初始密码为 lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment">#echo &quot;lamp&quot; | passwd --stdin lamp</span></span><br><span class="line"><span class="comment">#通过chage命令设置此账号密码创建的日期为 1970 年 1 月 1 日（0 就表示这一天），这样用户登陆后就必须修改密码</span></span><br><span class="line">[root@localhost ~]<span class="comment">#chage -d 0 lamp</span></span><br></pre></td></tr></table></figure>
<p>这样修改完<code>lamp</code>用户后，我们尝试用<code>lamp</code>用户登陆系统（初始密码也是<code>lamp</code>）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> host login:lamp</span><br><span class="line">Password:     &lt;--输入密码登陆</span><br><span class="line">You are required to change your password immediately (root enforced)</span><br><span class="line">changing password <span class="keyword">for</span> lamp.     &lt;--有一些提示，就是说明 root 强制你登录后修改密码</span><br><span class="line">(current)UNIX password:</span><br><span class="line"><span class="comment">#输入旧密码</span></span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line"><span class="comment">#输入两次新密码</span></span><br></pre></td></tr></table></figure>
<p><code>chage</code>的这个功能常和<code>passwd</code>批量初始化用户密码功能合用，且对学校老师帮助比较大，因为老师不想知道学生账号的密码，他们在初次上课时就使用与学号相同的账号和密码给学生，让他们登陆时自行设置他们的密码。这样一来，既能避免学生之间随意使用别人的账号，也能保证学生知道如何修改自己的密码。</p>
<h1 id="userdel命令：删除用户"><a href="#userdel命令：删除用户" class="headerlink" title="userdel命令：删除用户"></a>userdel命令：删除用户</h1><p><code>userdel</code>命令就是删除用户的相关数据。此命令只有<code>root</code>用户才能使用。</p>
<p>用户的相关数据包含如下几项：</p>
<ul>
<li>用户基本信息：存储在<code>/etc/passwd</code>文件中；</li>
<li>用户密码信息：存储在<code>/etc/shadow</code>文件中；</li>
<li>用户群组基本信息：存储在<code>/etc/group</code>文件中；</li>
<li>用户群组信息信息：存储在<code>/etc/gshadow</code>文件中；</li>
<li>用户个人文件：主目录默认位于<code>/home/</code>用户名，邮箱位于<code>/var/spool/mail/</code>用户名。</li>
</ul>
<p>其实，<code>userdel</code>命令的作用就是从以上文件中，删除与指定用户有关的数据信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># userdel -r 用户名</span></span><br></pre></td></tr></table></figure>
<p><code>-r</code>选项表示在删除用户的同时删除用户的家目录。</p>
<p>注意，在删除用户的同时如果不删除用户的家目录，那么家目录就会变成没有属主和属组的目录，也就是垃圾文件。</p>
<p>除了使用<code>userdel</code>命令删除用户，还可以手动方式删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立新 lamp 用户</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># passwd lamp</span></span><br><span class="line"><span class="comment">#为 lamp 用户设置密码，由此 lamp 用户才算是创建成功</span></span><br><span class="line"><span class="comment">#下面开始手动删除 lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vi /etc/passwd</span></span><br><span class="line">lamp:x:501:501::/home/lamp:/bin/bash   &lt;--删除此行</span><br><span class="line"><span class="comment">#修改用户信息文件，删除lamp用户行</span></span><br><span class="line">[root@localhost ~]<span class="comment">#vi /etc/shadow</span></span><br><span class="line">lamp:$6<span class="variable">$KoOYtcOJ</span> <span class="variable">$56Xk9vp3D2vMRBxibNOn</span>.21cVJ9onbW8IHx4WrOx6qBqfGa9U3mjMsGjqYnj L/4t3zt3YxElce2X8rbb12x4a0:15716:0:99999:7:::   &lt;--删除此行</span><br><span class="line"><span class="comment">#修改影子文件，删除lamp用户密码行，注意，这个文件的权限是000，所以要强制保存</span></span><br><span class="line">[root@localhost ~]<span class="comment">#vi /etc/group</span></span><br><span class="line">lamp:x:501:  &lt;--删除此行</span><br><span class="line"><span class="comment">#修改组信息文件，删除lamp群组信息</span></span><br><span class="line">[root@localhost ~]<span class="comment">#vi /etc/gshadow</span></span><br><span class="line">lamp:!::  &lt;--删除此行</span><br><span class="line"><span class="comment">#修改组影子文件，删除lamp群组密码信息。同样注意需要强制保存</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf /var/spod/mail/lamp  #删除用户邮箱</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf/home/lamp/  #删除用户的家目录</span></span><br><span class="line"><span class="comment">#至此，用户彻底删除，再新建用户lamp。如果可以正常建立，则说明我们手工删除干净了</span></span><br><span class="line">[root@localhost ~]<span class="comment"># useradd lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># passwd lamp</span></span><br><span class="line"><span class="comment">#重新建立同名用户，没有报错，说明前面的手工删除是可以完全删除用户的</span></span><br></pre></td></tr></table></figure>
<p>实际使用中，使用<code>userdel</code>删除用户更方便。</p>
<p>最后需要大家注意的是，如果要删除的用户已经使用过系统一段时间，那么此用户可能在系统中留有其他文件，因此，如果我们想要从系统中彻底的删除某个用户，最好在使用<code>userdel</code>命令之前，先通过<code>find -user用户名</code>命令查出系统中属于该用户的文件，然后在加以删除。</p>
<h1 id="id命令：查看用户的UID和GID"><a href="#id命令：查看用户的UID和GID" class="headerlink" title="id命令：查看用户的UID和GID"></a>id命令：查看用户的UID和GID</h1><p><code>id</code>命令可以查询用户的 UID、GID 和附加组的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># id 用户名</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># id lamp</span></span><br><span class="line">uid=501(lamp) gid=501(lamp) <span class="built_in">groups</span>=501(lamp)</span><br><span class="line"><span class="comment">#能看到uid(用户ID)、gid(初始组ID), groups是用户所在组，这里既可以看到初始组，如果有附加组，则也能看到附加组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># usermod -G root lamp</span></span><br><span class="line"><span class="comment">#把用户加入root组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># id lamp</span></span><br><span class="line">uid=501(lamp) gid=501(lamp) <span class="built_in">groups</span>=501(lamp),0(root)</span><br><span class="line"><span class="comment">#大家发现root组中加入了lamp用户的附加组信息</span></span><br></pre></td></tr></table></figure>
<h1 id="su命令：用户间切换"><a href="#su命令：用户间切换" class="headerlink" title="su命令：用户间切换"></a>su命令：用户间切换</h1><p><code>su</code>是最简单的用户切换命令，通过该命令可以实现任何身份的切换，包括从普通用户切换为<code>root</code>用户、从<code>root</code>用户切换为普通用户以及普通用户之间的切换。</p>
<p>普通用户之间切换以及普通用户切换至<code>root</code>用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从<code>root</code>用户切换至其他用户，无需知晓对方密码，直接可切换成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># su [选项] 用户名</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-</code>：当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境（包括 PATH 变量、MAIL 变量等），使用 - 选项可省略用户名，默认会切换为<code>root</code>用户。</li>
<li><code>-l</code>：同<code>-</code>的使用类似，也就是在切换用户身份的同时，完整切换工作环境，但后面需要添加欲切换的使用者账号。</li>
<li><code>-p</code>：表示切换为指定用户的身份，但不改变当前的工作环境（不使用切换用户的配置文件）。</li>
<li><code>-m</code>：和<code>-p</code>一样；</li>
<li><code>-c</code> 命令：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lamp@localhost ~]$ su -root</span><br><span class="line">密码： &lt;-- 输入 root 用户的密码</span><br><span class="line"><span class="comment">#&quot;-&quot;代表连带环境变量一起切换，不能省略</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[lamp@localhost ~]$ <span class="built_in">whoami</span></span><br><span class="line">lamp</span><br><span class="line"><span class="comment">#当前我是lamp</span></span><br><span class="line">[lamp@localhost ~]$ su - -c <span class="string">&quot;useradd user1&quot;</span> root</span><br><span class="line">密码：</span><br><span class="line"><span class="comment">#不切换成root，但是执行useradd命令添加user1用户</span></span><br><span class="line">[lamp@localhost ~]$ <span class="built_in">whoami</span></span><br><span class="line">lamp</span><br><span class="line"><span class="comment">#我还是lamp</span></span><br><span class="line">[lamp@localhost ~]$ grep <span class="string">&quot;user1&#x27; /etc/passwd</span></span><br><span class="line"><span class="string">userl:x:502:504::/home/user1:/bin/bash</span></span><br><span class="line"><span class="string">#user用户已经添加了</span></span><br></pre></td></tr></table></figure>
<h2 id="su-和-su-的区别"><a href="#su-和-su-的区别" class="headerlink" title="su 和 su - 的区别"></a>su 和 su - 的区别</h2><p>注意，使用<code>su</code>命令时，有<code>-</code>和没有<code>-</code>是完全不同的，<code>-</code>选项表示在切换用户身份的同时，连当前使用的环境变量也切换成指定用户的。我们知道，环境变量是用来定义操作系统环境的，因此如果系统环境没有随用户身份切换，很多命令无法正确执行。</p>
<p>举个例子，普通用户<code>lamp</code>通过<code>su</code>命令切换成<code>root</code>用户，但没有使用<code>-</code>选项，这样情况下，虽然看似是<code>root</code>用户，但系统中的<code>$PATH</code>环境变量依然是<code>lamp</code>的（而不是<code>root</code>的），因此当前工作环境中，并不包含<code>/sbin、/usr/sbin</code>等超级用户命令的保存路径，这就导致很多管理员命令根本无法使用。不仅如此，当<code>root</code>用户接受邮件时，会发现收到的是<code>lamp</code>用户的邮件，因为环境变量<code>$MAIL</code>也没有切换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[lamp@localhost ~]$ <span class="built_in">whoami</span></span><br><span class="line">lamp</span><br><span class="line"><span class="comment">#查询用户身份，我是lamp</span></span><br><span class="line">[lamp@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">&lt;-输入root密码</span><br><span class="line"><span class="comment">#切换到root，但是没有切换环境变量。注意：普通用户切换到root需要密码</span></span><br><span class="line">[root@localhost ~]<span class="comment"># env | grep lamp</span></span><br><span class="line"><span class="comment">#查看环境变量，提取包含lamp的行</span></span><br><span class="line">USER=lamp</span><br><span class="line"><span class="comment">#用户名还是lamp，而不是root</span></span><br><span class="line">PATH=/usr/lib/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/lamp/bin</span><br><span class="line"><span class="comment">#命令査找的路径不包含超级用户路径</span></span><br><span class="line">MAIL=/var/spool/mail/lamp</span><br><span class="line">PWD=/home/lamp</span><br><span class="line">LOGNAME=lamp</span><br><span class="line"><span class="comment">#邮箱、主目录、目前用户名还是lamp</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在不使用<code>su -</code>的情况下，虽然用户身份成功切换，但环境变量依旧用的是原用户的，切换并不完整。</p>
<h1 id="whoami和who-am-i命令用法和区别"><a href="#whoami和who-am-i命令用法和区别" class="headerlink" title="whoami和who am i命令用法和区别"></a>whoami和who am i命令用法和区别</h1><p><code>whoami</code>命令和<code>who am i</code>命令是不同的 2 个命令，前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 Linux 系统的用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Cyuyan@localhost ~]$ <span class="built_in">whoami</span></span><br><span class="line">Cyuyan</span><br><span class="line">[Cyuyan@localhost ~]$ <span class="built_in">who</span> am i</span><br><span class="line">Cyuyan    pts/0    2017-10-09 15:30 (:0.0)</span><br></pre></td></tr></table></figure>
<p>在此基础上，使用<code>su</code>命令切换到<code>root</code>用户下，再执行一遍上面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Cyuyan@localhost ~] su - root</span><br><span class="line">[root@localhost ~]$ <span class="built_in">whoami</span></span><br><span class="line">root</span><br><span class="line">[root@localhost ~]$ <span class="built_in">who</span> am i</span><br><span class="line">Cyuyan    pts/0    2017-10-09 15:30 (:0.0)</span><br></pre></td></tr></table></figure>
<p>在未切换用户身份之前，<code>whoami</code>和<code>who am i</code>命令的输出是一样的，但使用<code>su</code>命令切换用户身份后，使用<code>whoami</code>命令打印的是切换后的用户名，而<code>who am i</code>命令打印的仍旧是登陆系统时所用的用户名。</p>
<p>执行<code>whoami</code>命令，等同于执行<code>id -un</code>命令；执行<code>who am i</code>命令，等同于执行<code>who -m</code>命令。</p>
<p>也就是说，使用<code>su</code>或者<code>sudo</code>命令切换用户身份，骗得过<code>whoami</code>，但骗不过<code>who am i</code>。要解释这背后的运行机制，需要搞清楚什么是实际用户（UID）和有效用户（EUID，即<code>Effective UID</code>）。</p>
<p>所谓实际用户，指的是登陆 Linux 系统时所使用的用户，因此在整个登陆会话过程中，实际用户是不会发生变化的；而有效用户，指的是当前执行操作的用户，也就是说真正决定权限高低的用户，这个是能够利用<code>su</code>或者<code>sudo</code>命令进行任意切换的。</p>
<p>一般情况下，实际用户和有效用户是相同的，如果出现用户身份切换的情况，它们会出现差异。需要注意的是，实际用户和有效用户出现差异，切换用户并不是唯一的触发机制。</p>
<p>那么，<code>whoami</code>和<code>who am i</code>通常应用在哪些场景中呢？通常，对那些经常需要切换用户的系统管理员来说，经常需要明确当前使用的是什么身份；另外，对于某些 shell 脚本，或者需要特别的用户才能执行，这时就需要利用<code>whoami</code>命令来搞清楚执行它的用户是谁；甚至还有一些 shell 脚本，一定要某个特别用户才能执行，即便使用<code>su</code>或者<code>sudo</code>命令切换到此身份都不行，此时就需要利用<code>who am i</code>来确认。</p>
<h1 id="groupadd命令：添加用户组"><a href="#groupadd命令：添加用户组" class="headerlink" title="groupadd命令：添加用户组"></a>groupadd命令：添加用户组</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupadd [选项] 组名</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-g GID</code>：指定组 ID；</li>
<li><code>-r</code>：创建系统群组。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupadd group1</span></span><br><span class="line"><span class="comment">#添加group1组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;group1&quot; /etc/group</span></span><br><span class="line">/etc/group:group1:x:502:</span><br><span class="line">/etc/gshadow:group1:!::</span><br></pre></td></tr></table></figure>
<h1 id="groupmod命令详解：修改用户组"><a href="#groupmod命令详解：修改用户组" class="headerlink" title="groupmod命令详解：修改用户组"></a>groupmod命令详解：修改用户组</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupmod [选现] 组名</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-g GID</code>：修改组 ID；</li>
<li><code>-n</code> 新组名：修改组名；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupmod -n testgrp group1</span></span><br><span class="line"><span class="comment">#把组名group1修改为testgrp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;testgrp&quot; /etc/group</span></span><br><span class="line">testgrp:x:502:</span><br><span class="line"><span class="comment">#注意GID还是502，但是组名已经改变</span></span><br></pre></td></tr></table></figure>
<p>不过大家还是要注意，用户名不要随意修改，组名和 GID 也不要随意修改，因为非常容易导致管理员逻辑混乱。如果非要修改用户名或组名，则建议大家先删除旧的，再建立新的。</p>
<h1 id="groupdel命令：刪除用户组"><a href="#groupdel命令：刪除用户组" class="headerlink" title="groupdel命令：刪除用户组"></a>groupdel命令：刪除用户组</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#groupdel 组名</span></span><br></pre></td></tr></table></figure>
<p>使用<code>groupdel</code>命令删除群组，其实就是删除<code>/etc/group</code>文件和<code>/etc/gshadow</code>文件中有关目标群组的数据信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#grep &quot;group1&quot; /etc/group /etc/gshadow</span></span><br><span class="line">/etc/group:group1:x:505:</span><br><span class="line">/etc/gshadow:group1:!::</span><br><span class="line">[root@localhost ~]<span class="comment">#groupdel group1</span></span><br><span class="line">[root@localhost ~]<span class="comment">#grep &quot;group1&quot; /etc/group /etc/gshadow</span></span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>注意，不能使用<code>groupdel</code>命令随意删除群组。此命令仅适用于删除那些 “不是任何用户初始组” 的群组，换句话说，如果有群组还是某用户的初始群组，则无法使用<code>groupdel</code>命令成功删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># useradd temp</span></span><br><span class="line"><span class="comment">#运行如下命令，可以看到 temp 用户建立的同时，还创建了 temp 群组，且将其作为 temp用户的初始组（组ID都是 505）</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;temp&quot; /etc/passwd /etc/group /etc/gshadow</span></span><br><span class="line">/etc/passwd:temp:x:505:505::/home/temp:/bin/bash</span><br><span class="line">/etc/group:temp:x:505:</span><br><span class="line">/etc/gshadow:temp:!::</span><br><span class="line"><span class="comment">#下面尝试删除 temp 群组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupdel temp</span></span><br><span class="line">groupdel:cannot remove the primary group of user <span class="string">&#x27;temp&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>groupdel</code>命令删除<code>temp</code>群组失败，且提示“不能删除<code>temp</code>用户的初始组”。如果一定要删除<code>temp</code>群组，要么修改<code>temp</code>用户的 GID，也就是将其初始组改为其他群组，要么先删除<code>temp</code>用户。</p>
<p>切记，胡乱地删除群组可能会给其他用户造成不小的麻烦，因此更改文件数据要格外慎重。</p>
<h1 id="gpasswd命令：把用户添加进组或从组中删除"><a href="#gpasswd命令：把用户添加进组或从组中删除" class="headerlink" title="gpasswd命令：把用户添加进组或从组中删除"></a>gpasswd命令：把用户添加进组或从组中删除</h1><p>为了避免系统管理员（<code>root</code>）太忙碌，无法及时管理群组，我们可以使用<code>gpasswd</code>命令给群组设置一个群组管理员，代替<code>root</code>完成将用户加入或移出群组的操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># gpasswd 选项 组名</span></span><br></pre></td></tr></table></figure>
<p><code>gpasswd</code>命令各选项及其功能：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">选项为空时，表示给群组设置密码，仅 root 用户可用。</td>
</tr>
<tr>
<td align="center">-A user1,…</td>
<td align="center">将群组的控制权交给 user1,… 等用户管理，也就是说，设置 user1,… 等用户为群组的管理员，仅 root 用户可用。</td>
</tr>
<tr>
<td align="center">-M user1,…</td>
<td align="center">将 user1,… 加入到此群组中，仅 root 用户可用。</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">移除群组的密码，仅 root 用户可用。</td>
</tr>
<tr>
<td align="center">-R</td>
<td align="center">让群组的密码失效，仅 root 用户可用。</td>
</tr>
<tr>
<td align="center">-a user</td>
<td align="center">将 user 用户加入到群组中。</td>
</tr>
<tr>
<td align="center">-d user</td>
<td align="center">将 user 用户从群组中移除。</td>
</tr>
</tbody></table>
<p>除<code>root</code>可以管理群组外，可设置多个普通用户作为群组的管理员，但也只能做“将用户加入群组”和“将用户移出群组”的操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建新群组 group1，并将群组交给 lamp 管理</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupadd group1  &lt;-- 创建群组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># gpasswd group1   &lt;-- 设置密码吧！</span></span><br><span class="line">Changing the password <span class="keyword">for</span> group group1</span><br><span class="line">New Password:</span><br><span class="line">Re-enter new password:</span><br><span class="line">[root@localhost ~]<span class="comment"># gpasswd -A lamp group1  &lt;==加入群组管理员为 lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;group1&quot; /etc/group /etc/gshadow</span></span><br><span class="line">/etc/group:group1:x:506:</span><br><span class="line">/etc/gshadow:group1:$1<span class="variable">$I5ukIY1</span>.<span class="variable">$o5fmW</span>.cOsc8.K.FHAFLWg0:lamp:</span><br></pre></td></tr></table></figure>
<p>可以看到，此时<code>lamp</code>用户即为<code>group1</code>群组的管理员。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以lamp用户登陆系统，并将用户 lamp 和 lamp1 加入group1群组。</span></span><br><span class="line">[lamp@localhost ~]<span class="comment">#gpasswd -a lamp group1</span></span><br><span class="line">[lamp@localhost ~]<span class="comment">#gpasswd -a lamp1 group1</span></span><br><span class="line">[lamp@localhost ~]<span class="comment">#grep &quot;group1&quot; /etc/group</span></span><br><span class="line">group1:x:506:lamp,lamp1</span><br></pre></td></tr></table></figure>
<p>使用<code>usermod -G</code>命令也可以将用户加入群组，但会产生一个问题，即使用此命令将用户加入到新的群组后，该用户之前加入的那些群组都将被清空。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新创建一个群组group2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupadd group2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># usermod -G group2 lamp</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;group2&quot; /etc/group</span></span><br><span class="line">group2:x:509:lamp</span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;group1&quot; /etc/group</span></span><br><span class="line">group1:x:506:lamp1</span><br></pre></td></tr></table></figure>
<p>虽然使用<code>usermod</code>命令成功地将<code>lamp</code>用户加入在<code>group2</code>群组中，但<code>lamp</code>用户原本在<code>group1</code>群组中，此时却被移出，这就是使用<code>usermod</code>命令造成的。</p>
<p>因此，将用户加入或移出群组，最好使用<code>gpasswd</code>命令。</p>
<h1 id="newgrp命令：切换用户的有效组"><a href="#newgrp命令：切换用户的有效组" class="headerlink" title="newgrp命令：切换用户的有效组"></a>newgrp命令：切换用户的有效组</h1><p>我们知道，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？</p>
<p>当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。那么，既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令<code>newgrp</code>就可以。</p>
<p><code>newgrp</code>命令可以从用户的附加组中选择一个群组，作为用户新的初始组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># newgrp 组名</span></span><br></pre></td></tr></table></figure>
<p>首先，建立 3 个用户组<code>group1、group2</code>和<code>group3</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># groupadd group1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupadd group2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># groupadd group3</span></span><br></pre></td></tr></table></figure>
<p>创建一个用户<code>user1</code>，同时指定<code>user1</code>的初始组为<code>group1</code>，附加组为<code>group2</code>和<code>group3</code>，执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># useradd -g group1 -G group2,group3 user1</span></span><br><span class="line"><span class="comment">#由于指定了初始组，因此不会在创建 user1 默认群组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># more /etc/group | grep user1</span></span><br><span class="line">group2:x:501:user1</span><br><span class="line">group3:x:502:user1</span><br></pre></td></tr></table></figure>
<p>对用户<code>user1</code>设置密码，执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># passwd user1</span></span><br><span class="line">Changing password <span class="keyword">for</span> user user1.</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>
<p>切换至<code>user1</code>用户，通过<code>newgrp</code>切换用户组进行下列操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切换至 user1 用户</span></span><br><span class="line">[root@localhost ~]<span class="comment"># su - user1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># whoami</span></span><br><span class="line">user1</span><br><span class="line"><span class="comment">#使用 newgrp 命令一边切换 user1 的初始组，一边创建文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir user1_doc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># newgrp group2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir user2_doc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># newgrp group3</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir user3_doc</span></span><br><span class="line"><span class="comment">#查看各文件的详细信息</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll</span></span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 user1 group1 4096 Oct 24 01:18 user1_doc</span><br><span class="line">drwxr-xr-x 2 user1 group2 4096 Oct 24 01:18 user2_doc</span><br><span class="line">drwxr-xr-x 2 user1 group3 4096 Oct 24 01:19 user3_doc</span><br></pre></td></tr></table></figure>
<p>可以看到，通过使用<code>newgrp</code>命令切换用户的初始组，所创建的文件各自属于不同的群组，这就是<code>newgrp</code>所发挥的作用，即通过切换附加组成为新的初始组，从而让用户获得使用各个附加组的权限。</p>
<h2 id="newgrp命令的底层实现"><a href="#newgrp命令的底层实现" class="headerlink" title="newgrp命令的底层实现"></a>newgrp命令的底层实现</h2><p>其实，<code>newgrp</code>命令每一次切换用户的初始组，该用户都会以另外一个 shell（新进程，也可以说是子进程）登陆，只不过在新 shell 上登陆的该用户，其初始组改变了而已。</p>
<p>当然，如果你想回到原本的环境，需要通过<code>exit</code>命令不断回退到当前进程的父进程，最终才能回到初始组为<code>group1</code>时的<code>user1</code>运行的 shell 中。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-操作系统/存储器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/"
    >认识操作系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/" class="article-date">
  <time datetime="2022-01-20T06:51:32.000Z" itemprop="datePublished">2022-01-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h1><p>我们想象一个场景，大学期末准备考试了，你前去图书馆临时抱佛脚。那么，在看书的时候，我们的大脑会思考问题，也会记忆知识点，另外我们通常也会把常用的书放在自己的桌子上，当我们要找一本不常用的书，则会去图书馆的书架找。</p>
<p>就是这么一个小小的场景，已经把计算机的存储结构基本都涵盖了。</p>
<p>我们可以把 CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的寄存器，处理速度是最快的，但是能存储的数据也是最少的，毕竟我们也不能一下同时思考太多的事情，除非你练过。</p>
<p>我们大脑中的记忆，就好比 CPU Cache，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</p>
<p>CPU Cache 通常会分为 L1、L2、L3 三层，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。我们大脑中短期记忆，就好比 L1 Cache，而长期记忆就好比 L2&#x2F;L3 Cache。</p>
<p>寄存器和 CPU Cache 都是在 CPU 内部，跟 CPU 挨着很近，因此它们的读写速度都相当的快，但是能存储的数据很少，毕竟 CPU 就这么丁点大。</p>
<p>知道 CPU 内部的存储器的层次分布，我们放眼看看 CPU 外部的存储器。</p>
<p>当我们大脑记忆中没有资料的时候，可以从书桌或书架上拿书来阅读，那我们桌子上的书，就好比内存，我们虽然可以一伸手就可以拿到，但读写速度肯定远慢于寄存器，那图书馆书架上的书，就好比硬盘，能存储的数据非常大，但是读写速度相比内存差好几个数量级，更别说跟寄存器的差距了。</p>
<img src="/2022/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/1.png" class="">

<p>我们从图书馆书架取书，把书放到桌子上，再阅读书，我们大脑就会记忆知识点，然后再经过大脑思考，这一系列过程相当于，数据从硬盘加载到内存，再从内存加载到 CPU 的寄存器和 Cache 中，然后再通过 CPU 进行处理和计算。</p>
<p>对于存储器，它的速度越快、能耗会越高、而且材料的成本也是越贵的，以至于速度快的存储器的容量都比较小。</p>
<p>CPU 里的寄存器和 Cache，是整个计算机存储器中价格最贵的，虽然存储空间很小，但是读写速度是极快的，而相对比较便宜的内存和硬盘，速度肯定比不上 CPU 内部的存储器，但是能弥补存储空间的不足。</p>
<p>存储器通常可以分为这么几个级别：</p>
<img src="/2022/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/2.png" class="">

<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>最靠近 CPU 的控制单元和逻辑计算单元的存储器，就是寄存器了，它使用的材料速度也是最快的，因此价格也是最贵的，那么数量不能很多。</p>
<p>寄存器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（<code>byte</code>）的数据。比如：</p>
<ul>
<li>32 位 CPU 中大多数寄存器可以存储 4 个字节；</li>
<li>64 位 CPU 中大多数寄存器可以存储 8 个字节。</li>
</ul>
<p>寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写，CPU 时钟周期跟 CPU 主频息息相关，比如 2 GHz 主频的 CPU，那么它的时钟周期就是 1&#x2F;2G，也就是 0.5ns（纳秒）。</p>
<p>CPU 处理一条指令的时候，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户的感觉，就是电脑「很慢」。</p>
<h2 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h2><p>CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。</p>
<p>SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。</p>
<p>在 SRAM 里面，一个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。</p>
<p>CPU 的高速缓存，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。</p>
<img src="/2022/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/3.png" class="">

<h3 id="L1-高速缓存"><a href="#L1-高速缓存" class="headerlink" title="L1 高速缓存"></a>L1 高速缓存</h3><p>L1 高速缓存的访问速度几乎和寄存器一样快，通常只需要 2~4 个时钟周期，而大小在几十 KB 到几百 KB 不等。</p>
<p>每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成指令缓存和数据缓存。</p>
<p>在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L1 Cache 「数据」缓存的容量大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/devices/system/cpu/cpu0/cache/index0/size</span><br><span class="line">32K</span><br></pre></td></tr></table></figure>
<p>而查看 L1 Cache 「指令」缓存的容量大小，则是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/devices/system/cpu/cpu0/cache/index1/size</span><br><span class="line">32K</span><br></pre></td></tr></table></figure>
<h3 id="L2-高速缓存"><a href="#L2-高速缓存" class="headerlink" title="L2 高速缓存"></a>L2 高速缓存</h3><p>L2 高速缓存同样每个 CPU 核心都有，但是 L2 高速缓存位置比 L1 高速缓存距离 CPU 核心 更远，它大小比 L1 高速缓存更大，CPU 型号不同大小也就不同，通常大小在几百 KB 到几 MB 不等，访问速度则更慢，速度在 10~20 个时钟周期。</p>
<p>在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L2 Cache 的容量大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/devices/system/cpu/cpu0/cache/index2/size</span><br><span class="line">256K</span><br></pre></td></tr></table></figure>
<h3 id="L3-高速缓存"><a href="#L3-高速缓存" class="headerlink" title="L3 高速缓存"></a>L3 高速缓存</h3><p>L3 高速缓存通常是多个 CPU 核心共用的，位置比 L2 高速缓存距离 CPU 核心 更远，大小也会更大些，通常大小在几 MB 到几十 MB 不等，具体值根据 CPU 型号而定。</p>
<p>访问速度相对也比较慢一些，访问速度在 20~60 个时钟周期。</p>
<p>在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L3 Cache 的容量大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/devices/system/cpu/cpu0/cache/index3/size </span><br><span class="line">3072K</span><br></pre></td></tr></table></figure>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 DRAM（<code>Dynamic Random Access Memory</code>，动态随机存取存储器）的芯片。</p>
<p>相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。</p>
<p>DRAM 存储一个 bit 数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</p>
<p>DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问的速度会更慢，内存速度大概在 200~300 个 时钟周期之间。</p>
<h2 id="SSD-x2F-HDD-硬盘"><a href="#SSD-x2F-HDD-硬盘" class="headerlink" title="SSD&#x2F;HDD 硬盘"></a>SSD&#x2F;HDD 硬盘</h2><p>SSD（Solid-state disk） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 10~1000 倍。</p>
<p>当然，还有一款传统的硬盘，也就是机械硬盘（<code>Hard Disk Drive, HDD</code>），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 10W 倍左右。</p>
<p>由于 SSD 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 SSD 替代了。</p>
<h1 id="存储器的层次关系"><a href="#存储器的层次关系" class="headerlink" title="存储器的层次关系"></a>存储器的层次关系</h1><p>现代的一台计算机，都用上了 CPU Cahce、内存、到 SSD 或 HDD 硬盘这些存储器设备了。</p>
<p>其中，存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。</p>
<p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p>
<p>比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。</p>
<img src="/2022/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/4.png" class="">

<p>所以，每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\L2\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构。</p>
<p>另外，当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。</p>
<img src="/2022/01/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E5%99%A8/5.png" class="">

<p>所以，存储层次结构也形成了缓存的体系。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag">计算机组成</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/ICMP详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/"
    >ICMP详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2022-01-19T03:49:21.000Z" itemprop="datePublished">2022-01-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>ICMP 全称是<code>Internet Control Message Protocol</code>，也就是互联网控制报文协议。</p>
<p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死的不明不白。所以需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。</p>
<p>ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p>
<p>在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/1.jpg" class="">

<p>ICMP 的这种通知消息会使用 IP 进行发送。</p>
<p>因此，从路由器 2 返回的 ICMP 包会按照往常的路由控制先经过路由器 1 再转发给主机 A。收到该 ICMP 包的主机 A 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。</p>
<h1 id="ICMP-包头格式"><a href="#ICMP-包头格式" class="headerlink" title="ICMP 包头格式"></a>ICMP 包头格式</h1><p>ICMP 报文是封装在 IP 包里面，它⼯作在网络层，因而不保证可靠的提交。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/2.jpg" class="">

<p>ICMP 包头的类型字段，大致可以分为两大类：</p>
<ul>
<li>一类是用于诊断的查询消息，也就是「查询报文类型」</li>
<li>另一类是通知出错原因的错误消息，也就是「差错报文类型」</li>
</ul>
<p>常见的 ICMP 类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">内容</th>
<th align="center">种类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">回送应答</td>
<td align="center">查询报文</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">目标不可达</td>
<td align="center">差错报文</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">源端被关闭</td>
<td align="center">差错报文</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">重定向或改变路由</td>
<td align="center">差错报文</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">回送请求</td>
<td align="center">查询报文</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">超时</td>
<td align="center">差错报文</td>
</tr>
</tbody></table>
<h1 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h1><p>回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code>命令就是利用这个消息实现的。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/4.jpg" class="">

<p>可以向对端主机发送回送请求的消息（<code>ICMP Echo Request Message</code>，类型 8），也可以接收对端主机发回来的回送应答消息（<code>ICMP Echo Reply Message</code>，类型 0）。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/5.jpg" class="">

<p>相比原生的 ICMP，这里多了两个字段：</p>
<ul>
<li>标识符：用以区分是哪个应用程序发 ICMP 包，比如用进程 PID 作为标识符；</li>
<li>序号：序列号从 0 开始，每发送一次新的回送请求就会加 1， 可以用来确认网络包是否有丢失。</li>
</ul>
<p>在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p>
<h1 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h1><p>几个常用的 ICMP 差错报文的例子：</p>
<ul>
<li>目标不可达消息 —— 类型 为 3</li>
<li>原点抑制消息 —— 类型 4</li>
<li>重定向消息 —— 类型 5</li>
<li>超时消息 —— 类型 11</li>
</ul>
<h2 id="目标不可达消息"><a href="#目标不可达消息" class="headerlink" title="目标不可达消息"></a>目标不可达消息</h2><p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个目标不可达的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的代码字段。</p>
<p>由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送不可达的具体原因。</p>
<p>6 种常见的目标不可达类型的代码：</p>
<ul>
<li>0：网络不可达</li>
<li>1：主机不可达</li>
<li>2：协议不可达</li>
<li>3：端口不可达</li>
<li>4：需要进行分片但设置了不分片</li>
</ul>
<p>网络不可达代码为 0：</p>
<ul>
<li>IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收⽅ IP 的网络号，就通过 ICMP 协议以网络不可达（<code>Network Unreachable</code>）的原因告知主机。</li>
</ul>
<p>自从不再有网络分类以后，网络不可达也渐渐不再使用了。</p>
<p>主机不可达代码为 1：</p>
<ul>
<li>当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以主机不可达（<code>Host Unreachable</code>）的原因告知主机。</li>
</ul>
<p>协议不可达代码为 2：</p>
<ul>
<li>当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以协议不可达的原因告知主机。</li>
</ul>
<p>端口不可达代码为 3：</p>
<ul>
<li>当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以端口不可达的原因告知主机。</li>
</ul>
<p>需要进行分片但设置了不分片位代码为 4：</p>
<ul>
<li>发送端主机发送 IP 数据报时，将 IP 首部的分片禁止标志位设置为 1。根据这个标志位，途中的路由器遇到超过MTU 大小的数据包时，不会进行分片，而是直接抛弃。</li>
</ul>
<p>随后，通过一个 ICMP 的不可达消息类型，代码为 4 的报文，告知发送端主机。</p>
<h2 id="原点抑制消息"><a href="#原点抑制消息" class="headerlink" title="原点抑制消息"></a>原点抑制消息</h2><p>在使用低速⼴域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。ICMP 原点抑制消息的目的就是为了缓和这种拥堵情况。</p>
<p>当路由器向低速线路发送数据时，其发送队列的缓存变为零而⽆法发送出去时，可以向 IP 包的源地址发送一个 ICMP 原点抑制消息。</p>
<p>收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。</p>
<p>然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p>
<h2 id="重定向消息"><a href="#重定向消息" class="headerlink" title="重定向消息"></a>重定向消息</h2><p>如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP 重定向消息给这个主机。</p>
<p>在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。</p>
<h2 id="超时消息"><a href="#超时消息" class="headerlink" title="超时消息"></a>超时消息</h2><p>IP 包中有一个字段叫做 TTL（<code>Time To Live</code>，生存周期），它的值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</p>
<p>此时，路由器将会发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。</p>
<p>设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包⽆休止地在网络上被转发。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/7.jpg" class="">

<p>此外，有时可以用 TTL 控制包的到达范围，例如设置一个较小的 TTL 值。</p>
<h1 id="ping-—-查询报文类型的使用"><a href="#ping-—-查询报文类型的使用" class="headerlink" title="ping — 查询报文类型的使用"></a>ping — 查询报文类型的使用</h1><p>接下来，我们来看<code>ping</code>的发送和接收过程。</p>
<p>同个⼦网下的主机 A 和 主机 B，主机 A 执行<code>ping</code>主机 B 后，我们来看看其间发送了什么。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/8.jpg" class="">

<p><code>ping</code>命令执行的时候，源主机首先会构建一个 ICMP 回送请求消息数据包。</p>
<p>ICMP 数据包内包含多个字段，最重要的是两个：</p>
<ul>
<li>第一个是类型，对于回送请求消息而⾔该字段为 8；</li>
<li>另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包。</li>
</ul>
<p>每发出一个请求数据包，序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插⼊发送时间。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/9.jpg" class="">

<p>然后，由 ICMP 协议将这个数据包连同地址<code>192.168.1.2</code>一起交给 IP 层。IP 层将以<code>192.168.1.2</code>作为目的地址，本机 IP 地址作为源地址，协议字段设置为 1 表示是 ICMP 协议，再加上一些其他控制信息，构建一个 IP 数据包。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/10.jpg" class="">

<p>接下来，需要加入 MAC 头。如果在本地 ARP 映射表中查找出 IP 地址<code>192.168.1.2</code>所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/11.jpg" class="">

<p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p>
<p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p>
<p>主机 B 会构建一个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/12.jpg" class="">

<p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p>
<p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p>
<p>针对上面发送的事情，总结成了如下图：</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/13.png" class="">

<p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。</p>
<p>但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。</p>
<p>说了这么多，可以看出<code>ping</code>这个程序是使用了 ICMP 里面的 ECHO REQUEST（类型为 8） 和 ECHO REPLY（类型为 0）。</p>
<h2 id="ping-常用命令"><a href="#ping-常用命令" class="headerlink" title="ping 常用命令"></a>ping 常用命令</h2><p><code>ping</code>的作用主要为：</p>
<ol>
<li>用来检测网络的连通情况和分析网络速度</li>
<li>根据域名得到服务器 IP</li>
<li>根据<code>ping</code>返回的 TTL 值来判断对方所使用的操作系统及数据包经过路由器数量</li>
</ol>
<p>我们通常会用它来直接<code>ping ip</code>地址，来测试网络的连通情况。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>各值解释：</p>
<ul>
<li><code>bytes</code>值：数据包大小，也就是字节。</li>
<li><code>time</code>值：响应时间，这个时间越小，说明你连接这个地址速度越快。</li>
<li>TTL 值：<code>Time To Live</code>, 表示 DNS 记录在 DNS 服务器上存在的时间，它是 IP 协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过<code>Ping</code>返回的 TTL 值大小，粗略地判断目标系统类型是 Windows 系列还是 UNIX&#x2F;Linux 系列。</li>
</ul>
<p>默认情况下，Linux 系统的 TTL 值为 64 或 255，WindowsNT&#x2F;2000&#x2F;XP 系统的 TTL 值为 128，Windows98 系统的 TTL 值为 32，UNIX 主机的 TTL 值为 255。</p>
<p><code>ping</code>命令除了直接<code>ping</code>网络的<code>ip</code>地址，验证网络畅通和速度之外，它还有这些用法。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/2.png" class="">

<h4 id="ping-t"><a href="#ping-t" class="headerlink" title="ping -t"></a>ping -t</h4><p>不间断地<code>ping</code>指定计算机，直到管理员中断。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/3.png" class="">

<h4 id="ping-a"><a href="#ping-a" class="headerlink" title="ping -a"></a>ping -a</h4><p><code>ping -a</code>解析计算机名与 NetBios 名。就是可以通过<code>ping</code>它的<code>ip</code>地址，可以解析出主机名。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/4.png" class="">

<h4 id="ping-n-count"><a href="#ping-n-count" class="headerlink" title="ping -n count"></a>ping -n count</h4><p>在默认情况下，一般都只发送四个数据包，通过这个命令可以自己定义发送的个数，对衡量网络速度很有帮助，比如我想测试发送 10 个数据包的返回的平均时间为多少，最快时间为多少，最慢时间为多少。</p>
<h4 id="ping-l-size"><a href="#ping-l-size" class="headerlink" title="ping -l size"></a>ping -l size</h4><p>默认的情况下 Windows 的<code>ping</code>发送的数据包大小为<code>32byte</code>，最大能发送<code>65500byte</code>。当一次发送的数据包大于或等于<code>65500byte</code>时，将可能导致接收方计算机宕机。所以微软限制了这一数值；这个参数配合其它参数以后危害非常强大，比如攻击者可以结合<code>-t</code>参数实施 DOS 攻击。</p>
<h1 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h1><p>ping 工具只能测试目的设备的连通性，但是看不到数据包的传输路径。所以在网络不通的情况下，无法知道网络问题发生在哪个位置。<code>tracert</code>工具可以查看数据包的整条传输路径，包括途中经过的中间设备。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/14.png" class="">

<p>IP 头部的 TTL 字段是为避免数据包循环转发而设计的。每经过一个路由器，数据包头中的 TTL 值减 1。如果 TTL 值为 0 则丢弃报文，并向源设备回应一个<code>Time Exceeded</code>消息，告知错误类型。<code>tracert</code>就是基于 TTL 字段和 ICMP 协议实现的。在 Windows 中命令是<code>tracert</code>，在 Unix、MacOS 中命令是<code>traceroute</code>。</p>
<p>使用<code>tracert</code>命令时，源设备的<code>tracert</code>逐跳发送数据包，并等待每一个响应报文。发送第一个数据包时，TTL 值设为 1。第一个路由器收到数据包后 TTL 值减 1 ，随即丢弃数据包，并返回一个<code>Time Exceeded</code>消息。源设备的<code>tracert</code>收到响应报文后，取出源 IP 地址，即路径上的第一个路由器地址。然后<code>tracert</code>发送一个 TTL 值为 2 的数据包。第一个路由器将 TTL 值减 1，并转发数据包。第二个路由器再将 TTL 值减 1，丢弃数据包并返回一个<code>Time Exceeded</code>消息。<code>tracert</code>收到响应报文后，取出源 IP 地址，即路径上的第二个路由器地址。类似步骤，<code>tracert</code>逐跳获得每一个路由器的地址，并探测到目的设备的可达性。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/15.png" class="">

<p><code>tracert</code>过程也是双向的消息通信，只有双向都成功传输时，才能正确探测路径。另外主机安装了防火墙，也可能造成路径探测失败。</p>
<p>在 Windows 电脑上使用<code>tracert</code>命令，并查看返回信息。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/16.png" class="">

<p>同步抓包进行验证。</p>
<img src="/2022/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E8%AF%A6%E8%A7%A3/17.png" class="">
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Docker/Docker入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/18/Docker/Docker%E5%85%A5%E9%97%A8/"
    >Docker入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/18/Docker/Docker%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-01-18T08:24:41.000Z" itemprop="datePublished">2022-01-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><h3 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 安装需要的软件包， yum-utils 提供yum-config-manager功能</span><br><span class="line">$ yum install -y yum-utils</span><br><span class="line">// 添加yum软件源</span><br><span class="line">// 阿里云的</span><br><span class="line">$ yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">// 或ustc的</span><br><span class="line">$ yum-config-manager --add-repo http://mirrors.ustc.edu.cn/docker- ce/linux/centos/docker-ce.repo</span><br><span class="line">// 安装docker，出现输入的界面都按 y</span><br><span class="line">$ yum install -y docker-ce</span><br><span class="line">// 启动docker，刚下载会自动运行不用再启动</span><br><span class="line">$ systemctl enable docker</span><br><span class="line">$ systemctl start docker</span><br><span class="line">// 测试docker是否安装成功</span><br><span class="line">$ docker -v</span><br></pre></td></tr></table></figure>
<h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。</p>
<ul>
<li>阿里云加速器(点击管理控制台 -&gt; 登录账号(淘宝账号) -&gt; 右侧镜像工具 -&gt; 镜像加速器 -&gt; 复制加速器地址)</li>
<li>网易云加速器<code>https://hub-mirror.c.163.com</code></li>
<li>百度云加速器<code>https://mirror.baidubce.com</code></li>
<li>ustc镜像加速器<code>https://docker.mirrors.ustc.edu.cn</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 编辑文件/etc/docker/daemon.json</span><br><span class="line">$ mkdir /etc/docker</span><br><span class="line">$ vi /etc/docker/daemon.json</span><br><span class="line">// 在文件中加入下面内容</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">// 重新启动服务</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>可以通过<code>docker search</code>命令来查找官方仓库中的镜像，并利用<code>docker pull</code>命令来将它下载到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   6449      [OK]</span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with <span class="string">&quot;headless&quot;</span> VNC session…   126                  [OK]</span><br><span class="line">jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]</span><br><span class="line">centos/systemd                     systemd enabled base container.                 96                   [OK]</span><br></pre></td></tr></table></figure>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p>
<p>根据是否是官方提供，可将镜像分为两类。</p>
<ul>
<li>一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</li>
<li>还有一种类型，比如<code>ansible/centos7-ansible</code>镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀<code>username/</code>来指定使用某个用户提供的镜像，比如<code>ansible</code>用户。</li>
</ul>
<p>另外，在查找的时候通过<code>--filter=stars=N</code>参数可以指定仅显示收藏数量为<code>N</code>以上的镜像。</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>从 Docker 镜像仓库获取镜像的命令是<code>docker pull</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker 镜像仓库地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>具体的选项可以通过<code>docker pull --help</code>命令看到。</p>
<p>镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是<code>Docker Hub(docker.io)</code>。</li>
<li>仓库名：仓库名是两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为<code>library</code>，也就是官方镜像。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull centos:7</span><br><span class="line">7: Pulling from library/centos</span><br><span class="line">2d473b07cdd5: Pull complete </span><br><span class="line">Digest: sha256:c73f515d06b0fa07bb18d8202035e739a494ce760aa73129f60f4bf2bd22b407</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:7</span><br><span class="line">docker.io/library/centos:7</span><br></pre></td></tr></table></figure>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从<code>Docker Hub （docker.io）</code>获取镜像。而镜像名称是<code>centos:7</code>，因此将会获取官方镜像<code>library/centos</code>仓库中标签为 7 的镜像。<code>docker pull</code>命令的输出结果最后一行给出了镜像的完整名称，即：<code>docker.io/library/centos:7</code>。</p>
<p>从下载过程中可以看到镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>列出已经下载下来的镜像，可以使用<code>docker image ls</code>命令或<code>docker images</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 或docker images</span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">mysql        5.7       4181d485f650   4 days ago     448MB</span><br><span class="line">redis        latest    f1b6973564e9   3 weeks ago    113MB</span><br><span class="line">nginx        latest    c316d5a335a5   3 weeks ago    142MB</span><br><span class="line">centos       7         eeb6ee3f44bd   5 months ago   204MB</span><br></pre></td></tr></table></figure>
<p>列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。</p>
<p>镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。</p>
<h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>centos:7</code>镜像大小，在这里是 204MB，但是在 Docker Hub 显示的却是 103.35MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而<code>docker image ls</code>显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code>列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>可以通过<code>docker system df</code>命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker system <span class="built_in">df</span></span><br><span class="line"></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          4         0         826MB     826MB (100%)</span><br><span class="line">Containers      0         0         0B        0B</span><br><span class="line">Local Volumes   2         0         398.7MB   398.7MB (100%)</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure>
<h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下，<code>docker image ls</code>会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code>有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu              bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>
<p>列出特定的某个镜像，也就是说指定仓库名和标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ubuntu:18.04</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>
<p>除此以外，<code>docker image ls</code>还支持强大的过滤器参数<code>--filter</code>，或者简写<code>-f</code>。比如，我们希望看到在<code>mongo:3.2</code>之后建立的镜像，可以用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f since=mongo:3.2</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx               latest              05a60462f8ba        5 days ago          181 MB</span><br></pre></td></tr></table></figure>
<p>想查看某个位置之前的镜像也可以，只需要把<code>since</code>换成<code>before</code>即可。</p>
<p>此外，如果镜像构建时，定义了<code>LABEL</code>，还可以通过<code>LABEL</code>来过滤。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls -f label=com.example.version=0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>删除本地的镜像，可以使用<code>docker image rm</code>命令，其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br><span class="line">// 或docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code>可以是镜像短 ID、镜像长 ID、镜像名或者镜像摘要。</p>
<p>比如我们有这么一些镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span><br><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span><br><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span><br><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span><br></pre></td></tr></table></figure>
<p>我们可以用镜像的完整 ID，也称为长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用短 ID 来删除镜像。<code>docker image ls</code>默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>比如这里，如果我们要删除<code>redis:alpine</code>镜像，可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//或docker rmi 501</span><br><span class="line">$ docker image <span class="built_in">rm</span> 501</span><br><span class="line">Untagged: redis:alpine</span><br><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span><br><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span><br><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span><br><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span><br><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span><br><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span><br><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure>
<p>我们也可以用镜像名，也就是<code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> centos</span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure>
<p>当然，更精确的是使用镜像摘要删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> --digests</span><br><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span><br><span class="line"></span><br><span class="line">$ docker image <span class="built_in">rm</span> node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是<code>Dockerfile</code>。</p>
<p><code>Dockerfile</code>是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>以定制 nginx 镜像为例。在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mynginx</span><br><span class="line">$ <span class="built_in">cd</span> mynginx</span><br><span class="line">$ <span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure>
<p>其内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code>和<code>RUN</code>。</p>
<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个<code>nginx</code>镜像的容器，再进行修改一样，基础镜像是必须指定的。而<code>FROM</code>就是指定 基础镜像，因此一个 Dockerfile 中<code>FROM</code>是必备的指令，并且必须是第一条指令。</p>
<p>在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如<code>nginx、redis、mongo、mysql、httpd、php、tomcat</code>等；也有一些方便开发、构建、运行各种语言应用的镜像，如<code>node、openjdk、python、ruby、golang</code>等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如<code>ubuntu、debian、centos、fedora、alpine</code>等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为<code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果你以<code>scratch</code>为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接<code>FROM scratch</code>会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code>指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><code>shell</code>格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的<code>RUN</code>指令就是这种格式。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></li>
<li><code>exec</code>格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然<code>RUN</code>就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个<code>RUN</code>呢？比如这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make wget</span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span></span><br><span class="line">RUN <span class="built_in">mkdir</span> -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure>
<p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code>也不例外。每一个<code>RUN</code>的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p>
<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 Dockerfile 正确的写法应该是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:stretch</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">set</span> -x; buildDeps=<span class="string">&#x27;gcc libc6-dev make wget&#x27;</span> \</span><br><span class="line">    &amp;&amp; apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y <span class="variable">$buildDeps</span> \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> \</span><br><span class="line">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> redis.tar.gz \</span><br><span class="line">    &amp;&amp; <span class="built_in">rm</span> -r /usr/src/redis \</span><br><span class="line">    &amp;&amp; apt-get purge -y --auto-remove <span class="variable">$buildDeps</span></span><br></pre></td></tr></table></figure>
<p>首先，之前所有的命令只有一个目的，就是编译、安装<code>redis</code>可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个<code>RUN</code>一一对应不同的命令，而是仅仅使用一个<code>RUN</code>指令，并使用<code>&amp;&amp;</code>将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加<code>\</code>的命令换行方式，以及行首<code>#</code>进行注释的格式。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了<code>apt</code>缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。在 Dockerfile 文件所在目录执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nginx</span><br><span class="line"> ---&gt; e43d811ce2f4</span><br><span class="line">Step 2 : RUN <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9cdc27646c7b</span><br><span class="line"> ---&gt; 44aa4490ce2c</span><br><span class="line">Removing intermediate container 9cdc27646c7b</span><br><span class="line">Successfully built 44aa4490ce2c</span><br></pre></td></tr></table></figure>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在<code>Step 2</code>中，如同我们之前所说的那样，<code>RUN</code>指令启动了一个容器<code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层<code>44aa4490ce2c</code>，随后删除了所用到的这个容器<code>9cdc27646c7b</code>。</p>
<p>这里我们使用了<code>docker build</code>命令进行镜像构建。其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>
<p>在这里我们指定了最终镜像的名称<code>-t nginx:v3</code>，构建成功后，我们可以像之前运行<code>nginx:v2</code>那样来运行这个镜像，其结果会和<code>nginx:v2</code>一样。</p>
<h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>如果注意，会看到<code>docker build</code>命令最后有一个<code>.</code>。<code>.</code>表示当前目录，而<code>Dockerfile</code>就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p>
<p>首先我们要理解<code>docker build</code>的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C&#x2F;S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过<code>COPY</code>指令、<code>ADD</code>指令等。而<code>docker build</code>命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端&#x2F;服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure>
<p>这并不是要复制执行<code>docker build</code>命令所在的目录下的<code>package.json</code>，也不是复制 Dockerfile 所在目录下的<code>package.json</code>，而是复制 上下文（context） 目录下的<code>package.json</code>。</p>
<p>因此，<code>COPY</code>这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么<code>COPY ../package.json /app</code>或者<code>COPY /opt/xxxx /app</code>无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令<code>docker build -t nginx:v3 .</code>中的这个<code>.</code>，实际上是在指定上下文的目录，<code>docker build</code>命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察<code>docker build</code>输出，我们其实已经看到了这个发送上下文的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现<code>COPY /opt/xxxx /app</code>不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现<code>docker build</code>执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让<code>docker build</code>打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用<code>.gitignore</code>一样的语法写一个<code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为<code>.</code>是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用<code>-f ../Dockerfile.php</code>参数指定某个文件作为 Dockerfile。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
<h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;源路径1&gt;&quot;</span>,... <span class="string">&quot;&lt;目标路径&gt;&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>和<code>RUN</code>指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><code>COPY</code>指令将从构建上下文目录中<code>&lt;源路径&gt;</code>的文件&#x2F;目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure>
<p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的<code>filepath.Match</code>规则，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>
<p><code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用<code>WORKDIR</code>指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用<code>COPY</code>指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上<code>--chown=&lt;user&gt;:&lt;group&gt;</code>选项来改变文件的所属用户及所属组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">COPY --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=bin files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=1 files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=10:11 files* /mydir/</span><br></pre></td></tr></table></figure>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code>指令和<code>COPY</code>的格式和性质基本一致。但是在<code>COPY</code>基础上增加了一些功能。</p>
<p>比如<code>&lt;源路径&gt;</code>可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到<code>&lt;目标路径&gt;</code>去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层<code>RUN</code>进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层<code>RUN</code>指令进行解压缩。所以不如直接使用<code>RUN</code>指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，<code>ADD</code>指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。<br>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用<code>ADD</code>命令了。</p>
<p>在 Docker 官方的 Dockerfile 最佳实践文档中要求，尽可能的使用<code>COPY</code>，因为<code>COPY</code>的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用<code>ADD</code>的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code>指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在<code>COPY</code>和<code>ADD</code>指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用<code>COPY</code>指令，仅在需要自动解压缩的场合使用<code>ADD</code>。<br>在使用该指令的时候还可以加上<code>--chown=&lt;user&gt;:&lt;group&gt;</code>选项来改变文件的所属用户及所属组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span><br><span class="line">ADD --<span class="built_in">chown</span>=bin files* /mydir/</span><br><span class="line">ADD --<span class="built_in">chown</span>=1 files* /mydir/</span><br><span class="line">ADD --<span class="built_in">chown</span>=10:11 files* /mydir/</span><br></pre></td></tr></table></figure>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code>指令的格式和<code>RUN</code>相似，也是两种格式：</p>
<ul>
<li>shell 格式：<code>CMD &lt;命令&gt;</code></li>
<li>exec 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
</ul>
<p>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了<code>ENTRYPOINT</code>指令后，用<code>CMD</code>指定具体的参数。</p>
<p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code>指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是<code>/bin/bash</code>，如果我们直接<code>docker run -it ubuntu</code>的话，会直接进入<code>bash</code>。我们也可以在运行时指定运行别的命令，如<code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 cat &#x2F;etc&#x2F;os-release 命令替换了默认的<code>/bin/bash</code>命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用<code>exec</code>格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。<br>如果使用 shell 格式的话，实际的命令会被包装为<code>sh -c</code>的参数的形式进行执行。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure>
<p>在实际执行中，会将其变更为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。<br>一些初学者将 CMD 写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用<code>systemctl</code>命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用<code>service nginx start</code>命令，则是希望<code>upstart</code>来以后台守护进程形式启动 nginx 服务。而刚才说了<code>CMD service nginx start</code>会被理解为<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 sh。那么当<code>service nginx start</code>命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code>的格式和<code>RUN</code>指令格式一样，分为<code>exec</code>格式和<code>shell</code>格式。</p>
<p><code>ENTRYPOINT</code>的目的和<code>CMD</code>一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code>在运行时也可以替代，不过比<code>CMD</code>要略显繁琐，需要通过<code>docker run</code>的参数<code>--entrypoint</code>来指定。</p>
<p>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>的含义就发生了改变，不再是直接的运行其命令，而是将<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令，换句话说实际执行时，将变为：<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></p>
<p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code>有什么好处么？让我们来看几个场景。</p>
<p>场景一：让镜像变成像命令一样使用<br>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://myip.ipip.net&quot; ]</span><br></pre></td></tr></table></figure>
<p>假如我们使用<code>docker build -t myip .</code>来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的<code>CMD</code>中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上<code>-i</code>参数。那么我们可以直接加<code>-i</code>参数给<code>docker run myip</code>么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;.</span><br></pre></td></tr></table></figure>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s <a target="_blank" rel="noopener" href="http://myip.ipip.net/">http://myip.ipip.net</a> 后面。而 -i 根本不是命令，所以自然找不到。<br>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http://myip.ipip.net -i</span><br></pre></td></tr></table></figure>
<p>这显然不是很好的解决方案，而使用<code>ENTRYPOINT</code>就可以解决这个问题。现在我们重新用<code>ENTRYPOINT</code>来实现这个镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://myip.ipip.net&quot; ]</span><br></pre></td></tr></table></figure>
<p>这次我们再来尝试直接使用 docker run myip -i：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip</span><br></pre></td></tr></table></figure>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure>
<p>可以看到，这次成功了。这是因为当存在<code>ENTRYPOINT</code>后，<code>CMD</code>的内容将会作为参数传给<code>ENTRYPOINT</code>，而这里<code>-i</code>就是新的<code>CMD</code>，因此会作为参数传给 curl，从而达到了我们预期的效果。</p>
<p>场景二：应用运行前的准备工作<br>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。<br>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是<code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;docker-entrypoint.sh&quot;</span>]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD [ <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure>
<p>可以看到其中为了<code>redis</code>服务创建了<code>redis</code>用户，并在最后指定了<code>ENTRYPOINT</code>为<code>docker-entrypoint.sh</code>脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;redis-server&#x27;</span> -a <span class="string">&quot;<span class="subst">$(id -u)</span>&quot;</span> = <span class="string">&#x27;0&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    find . \! -user redis -<span class="built_in">exec</span> <span class="built_in">chown</span> redis <span class="string">&#x27;&#123;&#125;&#x27;</span> +</span><br><span class="line">    <span class="built_in">exec</span> gosu redis <span class="string">&quot;<span class="variable">$0</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>exec “$@”<br>该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis <span class="built_in">id</span></span><br><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br></pre></td></tr></table></figure>

<h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><p>查看正在运行的容器使用命令：<code>docker ps</code>。</p>
<p>查看所有容器使用命令：<code>docker ps -a</code>。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为<code>docker run</code>。</p>
<p>参数说明：</p>
<ul>
<li><code>-i</code>：表示运行容器</li>
<li><code>-t</code>：表示容器启动后会进入其命令行。加入这个参数后，容器创建就能登录进去。即分配一个伪终端。</li>
<li><code>--name</code>:为创建的容器命名。</li>
<li><code>-v</code>：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个<code>－v</code>做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</li>
<li><code>-d</code>：在<code>run</code>后面加上<code>-d</code>参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加<code>-i -t</code>两个参数，创建后就会自动进去容器）。</li>
<li><code>-p</code>：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个<code>-p</code>做多个端口映射</li>
</ul>
<h3 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h3><p>以交互式方式创建并启动容器，启动完成后，直接进入当前容器。使用<code>exit</code>命令退出容器。需要注意的是以此种方式启动容器，如果退出容器，则容器会进入停止状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name=ubuntu ubuntu:18.04 /bin/bash</span><br><span class="line">root@af8bae53bdd3:/#</span><br></pre></td></tr></table></figure>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/# pwd</span><br><span class="line">/</span><br><span class="line">root@af8bae53bdd3:/# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure>
<p>当利用<code>docker run</code>来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个<code>ip</code>地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><p>创建一个守护式容器；如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建并启动守护式容器</span><br><span class="line">$ docker run -di --name=mycentos2 centos:7</span><br><span class="line"># 登录进入容器命令为：docker exec -it container_name (或者 container_id) /bin/bash（exit退出 时，容器不会停止）</span><br><span class="line">$ docker exec -it mycentos2 /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用<code>docker container start 容器名称或者ID</code>或<code>docker start 容器名称或者ID</code>命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用<code>ps</code>或<code>top</code>来查看进程信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:/# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 bash</span><br><span class="line">   11 ?        00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>可见，容器中仅运行了指定的<code>bash</code>应用。这种特点使得 Docker 对资源的利用率极高。</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>可以使用<code>docker container stop 容器名称或者ID</code>或<code>docker stop 容器名称或者ID</code>来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于只启动了一个终端的容器，用户通过<code>exit</code>命令或<code>Ctrl+d</code>来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用<code>docker container ls -a</code>或<code>docker ps -a</code>命令看到。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">&quot;/bin/bash&quot;</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br></pre></td></tr></table></figure>
<p>处于终止状态的容器，可以通过<code>docker container start</code>或<code>docker start</code>命令来重新启动。</p>
<p>此外，<code>docker container restart</code>或<code>docker restart</code>命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用<code>-d</code>参数时，容器启动后会进入后台。某些时候需要进入容器进行操作，使用<code>docker exec</code>命令。</p>
<p><code>docker exec</code>后边可以跟多个参数，这里主要说明<code>-i -t</code>参数。</p>
<ul>
<li>只用<code>-i</code>参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</li>
<li>当<code>-i -t</code>参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -di --name=ubuntu ubuntu:18.04</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       <span class="string">&quot;/bin/bash&quot;</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 /bin/bash</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#登录进入容器命令为：docker exec -it container_name (或者 container_id) /bin/bash（exit退出时，容器不会停止）</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 /bin/bash</span><br><span class="line">root@69d137adef7a:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用<code>docker container rm 容器名称（容器ID）</code>或<code>docker rm 容器名称（容器ID）</code>来删除一个处于终止状态的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>
<p>如果要删除一个运行中的容器，可以添加<code>-f</code>参数。Docker 会发送<code>SIGKILL</code>信号给容器。</p>
<h2 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h2><p>用<code>docker container ls -a</code>命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以删除所有处于终止状态的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br><span class="line">// 或</span><br><span class="line">$ docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure>
<h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（<code>Volumes</code>）</li>
<li>挂载主机目录 (<code>Bind mounts</code>)</li>
</ul>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UnionFS，可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>数据卷默认会一直存在，即使容器被删除</li>
</ul>
<p>注意：数据卷的使用，类似于 Linux 下对目录或文件进行<code>mount</code>，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有的数据卷</span></span><br><span class="line">$ docker volume <span class="built_in">ls</span></span><br><span class="line">​</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure>
<p>在主机里使用以下命令可以查看指定数据卷的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用<code>docker run</code>命令的时候，使用<code>--mount</code>标记来将数据卷挂载到容器里。在一次<code>docker run</code>中可以挂载多个数据卷。</p>
<p>下面创建一个名为<code>web</code>的容器，并加载一个数据卷到容器的<code>/usr/share/nginx/html</code>目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P --name web \</span><br><span class="line">    <span class="comment"># -v my-vol:/usr/share/nginx/html \</span></span><br><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html \</span><br><span class="line">    nginx:alpine</span><br></pre></td></tr></table></figure>
<h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span><br></pre></td></tr></table></figure>
<p>数据卷信息在<code>&quot;Mounts&quot;</code>属性下面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Mounts&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;my-vol&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/usr/share/nginx/html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span><br></pre></td></tr></table></figure>
<p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code>这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>将linux宿主机中的文件拷贝到容器内可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br><span class="line"></span><br><span class="line"># 创建一个文件abc.txt</span><br><span class="line">$ touch abc.txt</span><br><span class="line"># 复制abc.txt到mycentos2的容器的 / 目录下</span><br><span class="line">$ docker cp abc.txt mycentos2:/</span><br><span class="line"># 进入mycentos2容器</span><br><span class="line">$ docker exec -it mycentos2 /bin/bash</span><br><span class="line"># 查看容器 / 目录下文件</span><br><span class="line">$ ll</span><br></pre></td></tr></table></figure>
<p>将文件从容器内拷贝出来到linux宿主机使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br><span class="line">#进入容器后创建文件cba.txt</span><br><span class="line">touch cba.txt</span><br><span class="line"># 退出容器 exit</span><br><span class="line"># 在Linux宿主机器执行复制；将容器mycentos2的/cba.txt文件复制到 宿主机器的/root目录下</span><br><span class="line">docker cp mycentos2:/cba.txt /root</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：容器在停止状态下也可以完成文件的拷贝</p>
</blockquote>
<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><p>可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</p>
<p>创建容器时添加<code>-v</code>参数，后边为宿主机目录:容器目录，例如：<code>docker run -di -v /usr/local/test:/usr/local/test --name=mycentos3 centos:7</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建linux宿主机器要挂载的目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/test</span><br><span class="line"><span class="comment"># 创建并启动容器mycentos3,并挂载linux中的/usr/local/test目录到容器的/usr/local/test；</span></span><br><span class="line"><span class="comment"># 也就是在 linux中的/usr/local/test中操作相当于对容器相应目录操作</span></span><br><span class="line">docker run -di -v /usr/local/test:/usr/local/test --name=mycentos3 centos:7</span><br><span class="line"><span class="comment"># 在linux下创建文件</span></span><br><span class="line"><span class="built_in">touch</span> /usr/local/test/def.txt</span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mycentos3 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器中查看目录中是否有对应文件def.txt</span></span><br><span class="line">ll /usr/local/test</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为 CentOS7 中的安全模块 selinux 把权限禁掉了，需要添加参数<code>--privileged=true</code>来解决挂载的目录没有权限的问题。</p>
</blockquote>
<h1 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>
<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过<code>-P</code>或<code>-p</code>参数来指定端口映射。</p>
<p>当使用<code>-P</code>标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p>
<p>使用<code>docker container ls</code>可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P nginx:alpine</span><br><span class="line"></span><br><span class="line">$ docker container <span class="built_in">ls</span> -l</span><br><span class="line">CONTAINER ID    IMAGE          COMMAND                  CREATED         STATUS       PORTS         NAMES</span><br><span class="line">fae320d08268    nginx:alpine   <span class="string">&quot;/docker-entrypoint.…&quot;</span>   24 seconds ago   </span><br></pre></td></tr></table></figure>
<p><code>-p</code>则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有<code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用<code>hostPort:containerPort</code>格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用<code>ip:hostPort:containerPort</code>格式指定映射使用一个特定地址，比如<code>localhost</code>地址<code>127.0.0.1</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用<code>ip::containerPort</code>绑定<code>localhost</code>的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>还可以使用<code>udp</code>标记来指定<code>udp</code>端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>
<h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用<code>docker port</code>来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port fa 80</span><br><span class="line">0.0.0.0:32768</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>容器有自己的内部网络和 ip 地址（使用 docker inspect 查看，Docker 还可以有一个可变的网络配置。）</li>
<li><code>-p</code>标记可以多次使用来绑定多个端口</li>
</ul>
<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 80:80  -p 443:443 nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/12/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>