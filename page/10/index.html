<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Shell/Bash 模式扩展"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/Shell/Bash%20%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95/" class="article-date">
  <time datetime="2022-10-29T09:05:54.658Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Bash-的模式扩展"><a href="#Bash-的模式扩展" class="headerlink" title="Bash 的模式扩展"></a>Bash 的模式扩展</h1><p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展。其中有些用到通配符，又称为通配符扩展。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code>字符扩展</li>
<li><code>*</code>字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p>模块扩展的英文单词是<code>globbing</code>，这个词来自于早期的 Unix 系统有一个<code>/etc/glob</code>文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<h2 id="波浪线扩展"><a href="#波浪线扩展" class="headerlink" title="波浪线扩展"></a>波浪线扩展</h2><p>波浪线<code>~</code>会自动扩展成当前用户的主目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~</span><br><span class="line">/home/me</span><br></pre></td></tr></table></figure>
<p><code>~/dir</code>表示扩展成主目录的某个子目录，<code>dir</code>是主目录里面的一个子目录名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 /home/me/foo 目录</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/foo</span><br></pre></td></tr></table></figure>
<p><code>~user</code>表示扩展成用户<code>user</code>的主目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~foo</span><br><span class="line">/home/foo</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> ~root</span><br><span class="line">/root</span><br></pre></td></tr></table></figure>
<p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果<code>~user</code>的<code>user</code>是不存在的用户名，则波浪号扩展不起作用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> ~nonExistedUser</span><br><span class="line">~nonExistedUser</span><br></pre></td></tr></table></figure>
<p><code>~+</code>会扩展成当前所在的目录，等同于<code>pwd</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/foo</span><br><span class="line">$ <span class="built_in">echo</span> ~+</span><br><span class="line">/home/me/foo</span><br></pre></td></tr></table></figure>
<h2 id="字符扩展"><a href="#字符扩展" class="headerlink" title="? 字符扩展"></a>? 字符扩展</h2><p><code>?</code>字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code>匹配所有<code>Data</code>后面跟着三个字符的文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> ?.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>?</code>表示单个字符，所以会同时匹配<code>a.txt</code>和<code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个<code>?</code>连用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> ??.txt</span><br><span class="line">ab.txt</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>??</code>匹配了两个字符。</p>
<p><code>?</code>字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录有 a.txt 文件</span></span><br><span class="line">$ <span class="built_in">echo</span> ?.txt</span><br><span class="line">a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录为空目录</span></span><br><span class="line">$ <span class="built_in">echo</span> ?.txt</span><br><span class="line">?.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，如果<code>?.txt</code>可以扩展成文件名，<code>echo</code>命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code>就会原样输出<code>?.txt</code>。</p>
<h2 id="字符扩展-1"><a href="#字符扩展-1" class="headerlink" title="* 字符扩展"></a>* 字符扩展</h2><p><code>*</code>字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> *.txt</span><br><span class="line">a.txt b.txt ab.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>*.txt</code>代表后缀名为<code>.txt</code>的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用<code>*</code>即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls *</span><br></pre></td></tr></table></figure>
<p><code>*</code>可以匹配空字符，下面是一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> a*.txt</span><br><span class="line">a.txt ab.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> *b*</span><br><span class="line">b.txt ab.txt</span><br></pre></td></tr></table></figure>
<p>注意，<code>*</code>不会匹配隐藏文件（以<code>.</code>开头的文件），即<code>ls *</code>不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成<code>.*</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有隐藏文件</span></span><br><span class="line">$ <span class="built_in">echo</span> .*</span><br></pre></td></tr></table></figure>
<p>如果要匹配隐藏文件，同时要排除.和..这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成<code>.[!.]*</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> .[!.]*</span><br></pre></td></tr></table></figure>
<p>注意，<code>*</code>字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录不存在 c 开头的文件</span></span><br><span class="line">$ <span class="built_in">echo</span> c*.txt</span><br><span class="line">c*.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，当前目录里面没有<code>c</code>开头的文件，导致<code>c*.txt</code>会原样输出。</p>
<p><code>*</code>只匹配当前目录，不会匹配子目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子目录有一个 a.txt</span></span><br><span class="line"><span class="comment"># 无效的写法</span></span><br><span class="line">$ <span class="built_in">ls</span> *.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有效的写法</span></span><br><span class="line">$ <span class="built_in">ls</span> */*.txt</span><br></pre></td></tr></table></figure>
<p>上面的例子，文本文件在子目录，<code>*.txt</code>不会产生匹配，必须写成<code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数<code>globstar</code>，当该参数打开时，允许<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>可以匹配顶层的文本文件和任意深度子目录的文本文件。</p>
<h2 id="方括号扩展"><a href="#方括号扩展" class="headerlink" title="方括号扩展"></a>方括号扩展</h2><p>方括号扩展的形式是<code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code>可以匹配五个元音字母中的任意一个。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [ab].txt</span><br><span class="line">a.txt b.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只存在文件 a.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [ab].txt</span><br><span class="line">a.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>[ab]</code>可以匹配<code>a</code>或<code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在文件 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [ab].txt</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;[ab].txt&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code>就原样输出了，导致<code>ls</code>命名报错。</p>
<p>方括号扩展还有两种变体：<code>[^...]</code>和<code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code>或<code>[!abc]</code>表示匹配除了<code>a、b、c</code>以外的字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在 aaa、bbb、aba 三个文件</span></span><br><span class="line">$ <span class="built_in">ls</span> ?[!a]?</span><br><span class="line">aba bbb</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>[!a]</code>表示文件名第二个字符不是<code>a</code>的文件名，所以返回了<code>aba</code>和<code>bbb</code>两个文件。</p>
<p>注意，如果需要匹配<code>[</code>字符，可以放在方括号内，比如<code>[[aeiou]</code>。如果需要匹配连字号<code>-</code>，只能放在方括号内部的开头或结尾，比如<code>[-aeiou]</code>或<code>[aeiou-]</code>。</p>
<h2 id="start-end-扩展"><a href="#start-end-扩展" class="headerlink" title="[start-end] 扩展"></a>[start-end] 扩展</h2><p>方括号扩展有一个简写形式<code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code>等同于<code>[abc]</code>，<code>[0-9]</code>匹配<code>[0123456789]</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 c.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> [a-c].txt</span><br><span class="line">a.txt</span><br><span class="line">b.txt</span><br><span class="line">c.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 存在文件 report1.txt、report2.txt 和 report3.txt</span></span><br><span class="line">$ <span class="built_in">ls</span> report[0-9].txt</span><br><span class="line">report1.txt</span><br><span class="line">report2.txt</span><br><span class="line">report3.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>：所有小写字母。</li>
<li><code>[a-zA-Z]</code>：所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>：所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>：所有以a、b、c字符之一开头的文件名。</li>
<li><code>program.[co]</code>：文件program.c与文件program.o。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>：所有以BACKUP.开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式[!start-end]，表示匹配不属于这个范围的字符。比如，[!a-zA-Z]表示匹配非英文字母的字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo report[!1–3].txt</span><br><span class="line">report4.txt report5.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>[!1-3]</code>表示排除1、2和3。</p>
<h2 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h2><p>大括号扩展<code>&#123;...&#125;</code>表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>&#123;1,2,3&#125;</code>扩展成 1 2 3。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1,2,3&#125;</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> d&#123;a,e,i,u,o&#125;g</span><br><span class="line">dag deg dig dug dog</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> Front-&#123;A,B,C&#125;-Back</span><br><span class="line">Front-A-Back Front-B-Back Front-C-Back</span><br></pre></td></tr></table></figure>
<p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> &#123;a,b,c&#125;.txt</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;a.txt&#x27;</span>: 没有那个文件或目录</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;b.txt&#x27;</span>: 没有那个文件或目录</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;c.txt&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>上面例子中，即使不存在对应的文件，<code>&#123;a,b,c&#125;</code>依然扩展成三个文件名，导致<code>ls</code>命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1 , 2&#125;</span><br><span class="line">&#123;1 , 2&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> a.log&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="comment"># cp a.log a.log.bak</span></span><br></pre></td></tr></table></figure>
<p>大括号可以嵌套。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;j&#123;p,pe&#125;g,png&#125;</span><br><span class="line">jpg jpeg png</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> a&#123;A&#123;1,2&#125;,B&#123;3,4&#125;&#125;b</span><br><span class="line">aA1b aA2b aB3b aB4b</span><br></pre></td></tr></table></figure>
<p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> /bin/&#123;<span class="built_in">cat</span>,b*&#125;</span><br><span class="line">/bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本等同于</span></span><br><span class="line">$ <span class="built_in">echo</span> /bin/cat;<span class="built_in">echo</span> /bin/b*</span><br></pre></td></tr></table></figure>
<p>上面例子中，会先进行大括号扩展，然后进行*扩展，等同于执行两条<code>echo</code>命令。</p>
<p>大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;<span class="built_in">cat</span>,dog&#125;</span><br><span class="line"><span class="built_in">cat</span> dog</span><br></pre></td></tr></table></figure>
<p>由于大括号扩展<code>&#123;...&#125;</code>不是文件名扩展，所以它总是会扩展的。这与方括号扩展[…]完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在 a.txt 和 b.txt</span></span><br><span class="line">$ <span class="built_in">echo</span> [ab].txt</span><br><span class="line">[ab].txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;a,b&#125;.txt</span><br><span class="line">a.txt b.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，如果不存在<code>a.txt</code>和<code>b.txt</code>，那么<code>[ab].txt</code>就会变成一个普通的文件名，而<code>&#123;a,b&#125;.txt</code>可以照样扩展。</p>
<h2 id="start-end-扩展-1"><a href="#start-end-扩展-1" class="headerlink" title="{start..end} 扩展"></a>{start..end} 扩展</h2><p>大括号扩展有一个简写形式<code>&#123;start..end&#125;</code>，表示扩展成一个连续序列。比如，<code>&#123;a..z&#125;</code>可以扩展成 26 个小写英文字母。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a..c&#125;</span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> d&#123;a..d&#125;g</span><br><span class="line">dag dbg dcg ddg</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;1..4&#125;</span><br><span class="line">1 2 3 4</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> Number_&#123;1..5&#125;</span><br><span class="line">Number_1 Number_2 Number_3 Number_4 Number_5</span><br></pre></td></tr></table></figure>
<p>这种简写形式支持逆序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;c..a&#125;</span><br><span class="line">c b a</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;5..1&#125;</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>
<p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a1..3c&#125;</span><br><span class="line">&#123;a1..3c&#125;</span><br></pre></td></tr></table></figure>
<p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> .&#123;mp&#123;3..4&#125;,m4&#123;a,b,p,v&#125;&#125;</span><br><span class="line">.mp3 .mp4 .m4a .m4b .m4p .m4v</span><br></pre></td></tr></table></figure>
<p>大括号扩展的常见用途为新建一系列目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> &#123;2007..2009&#125;-&#123;01..12&#125;</span><br></pre></td></tr></table></figure>
<p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于<code>for</code>循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..4&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>上面例子会循环 4 次。</p>
<p>如果整数前面有前导 0，扩展输出的每一项都有前导0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;01..5&#125;</span><br><span class="line">01 02 03 04 05</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> &#123;001..5&#125;</span><br><span class="line">001 002 003 004 005</span><br></pre></td></tr></table></figure>
<p>这种简写形式还可以使用第二个双点号（<code>start..end..step</code>），用来指定扩展的步长。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;0..8..2&#125;</span><br><span class="line">0 2 4 6 8</span><br></pre></td></tr></table></figure>
<p>上面代码将 0 扩展到 8，每次递增的长度为 2，所以一共输出 5 个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;a..c&#125;&#123;1..3&#125;</span><br><span class="line">a1 a2 a3 b1 b2 b3 c1 c2 c3</span><br></pre></td></tr></table></figure>
<h2 id="变量扩展"><a href="#变量扩展" class="headerlink" title="变量扩展"></a>变量扩展</h2><p>Bash 将美元符号<code>$</code>开头的词元视为变量，将其扩展成变量值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>变量名除了放在美元符号后面，也可以放在<code>$&#123;&#125;</code>里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;SHELL&#125;</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p><code>$&#123;!string*&#125;</code>或<code>$&#123;!string@&#125;</code>返回所有匹配给定字符串<code>string</code>的变量名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!S*&#125;</span></span><br><span class="line"></span><br><span class="line">SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>$&#123;!S*&#125;</code>扩展成所有以<code>S</code>开头的变量名。</p>
<h2 id="子命令扩展"><a href="#子命令扩展" class="headerlink" title="子命令扩展"></a>子命令扩展</h2><p><code>$(...)</code>可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $(<span class="built_in">date</span>)</span><br><span class="line">Tue Jan 28 00:01:13 CST 2020</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>$(date)</code>返回<code>date</code>命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> `<span class="built_in">date</span>`</span><br><span class="line">Tue Jan 28 00:01:13 CST 2020</span><br></pre></td></tr></table></figure>
<p><code>$(...)</code>可以嵌套，比如<code>$(ls $(pwd))</code>。</p>
<h2 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h2><p><code>$((...))</code>可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $((<span class="number">2</span> + <span class="number">2</span>))</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p><code>[[:class:]]</code>表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>：匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>：匹配任意英文字母</li>
<li><code>[[:blank:]]</code>：空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>：ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>：匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>：A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>：匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>：ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。</li>
<li><code>[[:space:]]</code>：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。</li>
<li><code>[[:upper:]]</code>：匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>：16进制字符（A-F、a-f、0-9）。</li>
</ul>
<p>请看下面的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> [[:upper:]]*</span><br></pre></td></tr></table></figure>
<p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号<code>!</code>，表示否定。比如，<code>[![:digit:]]</code>匹配所有非数字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> [![:digit:]]*</span><br></pre></td></tr></table></figure>
<p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在以大写字母开头的文件</span></span><br><span class="line">$ <span class="built_in">echo</span> [[:upper:]]*</span><br><span class="line">[[:upper:]]*</span><br></pre></td></tr></table></figure>
<p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><p>通配符有一些使用注意点，不可不知。</p>
<h3 id="1-通配符是先解释，再执行。"><a href="#1-通配符是先解释，再执行。" class="headerlink" title="1.通配符是先解释，再执行。"></a>1.通配符是先解释，再执行。</h3><p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> a*.txt</span><br><span class="line">ab.txt</span><br></pre></td></tr></table></figure>
<p>上面命令的执行过程是，Bash 先将<code>a*.txt</code>扩展成<code>ab.txt</code>，然后再执行<code>ls ab.txt</code>。</p>
<h3 id="2-文件名扩展在不匹配时，会原样输出。"><a href="#2-文件名扩展在不匹配时，会原样输出。" class="headerlink" title="2.文件名扩展在不匹配时，会原样输出。"></a>2.文件名扩展在不匹配时，会原样输出。</h3><p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不存在 r 开头的文件名</span></span><br><span class="line">$ <span class="built_in">echo</span> r*</span><br><span class="line">r*</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于不存在<code>r</code>开头的文件名，<code>r*</code>会原样输出。</p>
<p>下面是另一个例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> *.csv</span><br><span class="line"><span class="built_in">ls</span>: *.csv: No such file or directory</span><br></pre></td></tr></table></figure>
<p>另外，前面已经说过，大括号扩展<code>&#123;...&#125;</code>不是文件名扩展。</p>
<h3 id="3-只适用于单层路径。"><a href="#3-只适用于单层路径。" class="headerlink" title="3.只适用于单层路径。"></a>3.只适用于单层路径。</h3><p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（&#x2F;）。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> */*.txt</span><br></pre></td></tr></table></figure>
<p>Bash 4.0 新增了一个<code>globstar</code>参数，允许<code>**</code>匹配零个或多个子目录。</p>
<h3 id="3-文件名可以使用通配符。"><a href="#3-文件名可以使用通配符。" class="headerlink" title="3. 文件名可以使用通配符。"></a>3. 文件名可以使用通配符。</h3><p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号或双引号里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> <span class="string">&#x27;fo*&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">fo*</span><br></pre></td></tr></table></figure>
<p>上面代码创建了一个<code>fo*</code>文件，这时<code>*</code>就是文件名的一部分。</p>
<h2 id="量词语法"><a href="#量词语法" class="headerlink" title="量词语法"></a>量词语法</h2><p>量词语法用来控制模式匹配的次数。它只有在 Bash 的<code>extglob</code>参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> extglob</span><br><span class="line">extglob        	on</span><br></pre></td></tr></table></figure>
<p>如果extglob参数是关闭的，可以用下面的命令打开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s extglob</span><br></pre></td></tr></table></figure>
<p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>：模式匹配零次或一次。</li>
<li><code>*(pattern-list)</code>：模式匹配零次或多次。</li>
<li><code>+(pattern-list)</code>：模式匹配一次或多次。</li>
<li><code>@(pattern-list)</code>：只匹配一次模式。</li>
<li><code>!(pattern-list)</code>：匹配给定模式以外的任何内容。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc?(.)txt</span><br><span class="line">abctxt abc.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>?(.)</code>匹配零个或一个点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc?(def)</span><br><span class="line">abc abcdef</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>?(def)</code>匹配零个或一个<code>def</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc@(.txt|.php)</span><br><span class="line">abc.php abc.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>@(.txt|.php)</code>匹配文件有且只有一个<code>.txt</code>或<code>.php</code>后缀名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> abc+(.txt)</span><br><span class="line">abc.txt abc.txt.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>+(.txt)</code>匹配文件有一个或多个<code>.txt</code>后缀名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> a!(b).txt</span><br><span class="line">a.txt abb.txt ac.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>!(b)</code>表示匹配单个字母b以外的任意内容，所以除了<code>ab.txt</code>以外，其他文件名都能匹配。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有 abc 开头的文件名</span></span><br><span class="line">$ <span class="built_in">ls</span> abc?(def)</span><br><span class="line"><span class="built_in">ls</span>: 无法访问<span class="string">&#x27;abc?(def)&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code>就原样输出，导致<code>ls</code>命令报错。</p>
<h2 id="shopt-命令"><a href="#shopt-命令" class="headerlink" title="shopt 命令"></a>shopt 命令</h2><p><code>shopt</code>命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p>shopt命令的使用方法如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -s [optionname]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭某个参数</span></span><br><span class="line">$ <span class="built_in">shopt</span> -u [optionname]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询某个参数关闭还是打开</span></span><br><span class="line">$ <span class="built_in">shopt</span> [optionname]</span><br></pre></td></tr></table></figure>
<h3 id="dotglob-参数"><a href="#dotglob-参数" class="headerlink" title="dotglob 参数"></a>dotglob 参数</h3><p><code>dotglob</code>参数可以让扩展结果包括隐藏文件（即点开头的文件）。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> *</span><br><span class="line">abc.txt</span><br></pre></td></tr></table></figure>
<p>打开<code>dotglob</code>，就会包括隐藏文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s dotglob</span><br><span class="line">$ <span class="built_in">ls</span> *</span><br><span class="line">abc.txt .config</span><br></pre></td></tr></table></figure>
<h3 id="nullglob-参数"><a href="#nullglob-参数" class="headerlink" title="nullglob 参数"></a>nullglob 参数</h3><p><code>nullglob</code>参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> b*</span><br><span class="line"><span class="built_in">rm</span>: 无法删除<span class="string">&#x27;b*&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure>
<p>上面例子中，由于当前目录不包括<code>b</code>开头的文件名，导致<code>b*</code>不会发生文件名扩展，保持原样不变，所以<code>rm</code>命令报错没有<code>b*</code>这个文件。</p>
<p>打开<code>nullglob</code>参数，就可以让不匹配的通配符返回空字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s nullglob</span><br><span class="line">$ <span class="built_in">rm</span> b*</span><br><span class="line"><span class="built_in">rm</span>: 缺少操作数</span><br></pre></td></tr></table></figure>
<p>上面例子中，由于没有<code>b*</code>匹配的文件名，所以<code>rm b*</code>扩展成了<code>rm</code>，导致报错变成了”缺少操作数“。</p>
<h3 id="failglob-参数"><a href="#failglob-参数" class="headerlink" title="failglob 参数"></a>failglob 参数</h3><p><code>failglob</code>参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s failglob</span><br><span class="line">$ <span class="built_in">rm</span> b*</span><br><span class="line">bash: 无匹配: b*</span><br></pre></td></tr></table></figure>
<p>上面例子中，打开<code>failglob</code>以后，由于b*不匹配任何文件名，Bash 直接报错了，不再让<code>rm</code>命令去处理。</p>
<h3 id="extglob-参数"><a href="#extglob-参数" class="headerlink" title="extglob 参数"></a>extglob 参数</h3><p><code>extglob</code>参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> extglob</span><br><span class="line">extglob        	on</span><br></pre></td></tr></table></figure>
<p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -u extglob</span><br></pre></td></tr></table></figure>
<h3 id="nocaseglob-参数"><a href="#nocaseglob-参数" class="headerlink" title="nocaseglob 参数"></a>nocaseglob 参数</h3><p><code>nocaseglob</code>参数可以让通配符扩展不区分大小写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s nocaseglob</span><br><span class="line">$ <span class="built_in">ls</span> /windows/program*</span><br><span class="line">/windows/ProgramData</span><br><span class="line">/windows/Program Files</span><br><span class="line">/windows/Program Files (x86)</span><br></pre></td></tr></table></figure>
<p>上面例子中，打开<code>nocaseglob</code>以后，<code>program*</code>就不区分大小写了，可以匹配<code>ProgramData</code>等。</p>
<h3 id="globstar-参数"><a href="#globstar-参数" class="headerlink" title="globstar 参数"></a>globstar 参数</h3><p><code>globstar</code>参数可以使得<code>**</code>匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.txt</span><br><span class="line">sub1/b.txt</span><br><span class="line">sub1/sub2/c.txt</span><br></pre></td></tr></table></figure>
<p>上面的文件结构中，顶层目录、第一级子目录<code>sub1</code>、第二级子目录<code>sub1\sub2</code>里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？</p>
<p>默认情况下，只能写成下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> *.txt */*.txt */*/*.txt</span><br><span class="line">a.txt  sub1/b.txt  sub1/sub2/c.txt</span><br></pre></td></tr></table></figure>
<p>这是因为<code>*</code>只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开<code>globstar</code>参数以后，<code>**</code>匹配零个或多个子目录。因此，<code>**/*.txt</code>就可以得到想要的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">shopt</span> -s globstar</span><br><span class="line">$ <span class="built_in">ls</span> **/*.txt</span><br><span class="line">a.txt  sub1/b.txt  sub1/sub2/c.txt</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Shell/Shell编程入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/Shell/Shell%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-10-29T09:05:54.658Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h1><p>在 Bash shell 中，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</p>
<p>这意味着，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串。</p>
<h2 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">url=<span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">website1=<span class="string">&#x27;百度：$&#123;url&#125;&#x27;</span></span><br><span class="line">website2=<span class="string">&quot;百度：<span class="variable">$&#123;url&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$website1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$website2</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">百度：$&#123;url&#125;</span><br><span class="line">百度：:http://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>以单引号<code>&#39; &#39;</code>包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
<p>以双引号<code>&quot; &quot;</code>包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p>
<p>如果变量的内容是数字，那么可以不加引号；如果真的需要原样输出就加单引号；其他没有特别要求的字符串等最好都加上双引号，定义变量时加双引号是最常见的使用场景。</p>
<h2 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h2><p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`<span class="built_in">command</span>`</span><br><span class="line">variable=$(<span class="built_in">command</span>)</span><br></pre></td></tr></table></figure>
<p>第一种方式把命令用反引号` `（位于 Esc 键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</p>
<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用<code>readonly</code>命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myUrl=<span class="string">&quot;http://abc.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">myUrl=<span class="string">&quot;http://abc.com/shell/&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行脚本，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash: myUrl: This variable is read only.</span><br></pre></td></tr></table></figure>
<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用<code>unset</code>命令可以删除变量。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure>
<p>变量被删除后不能再次使用；<code>unset</code>命令不能删除只读变量。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">myUrl=<span class="string">&quot;http://c.biancheng.net/shell/&quot;</span></span><br><span class="line"><span class="built_in">unset</span> myUrl</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$myUrl</span></span><br></pre></td></tr></table></figure>
<p>上面的脚本没有任何输出。</p>
<h1 id="Shell位置参数（命令行参数）"><a href="#Shell位置参数（命令行参数）" class="headerlink" title="Shell位置参数（命令行参数）"></a>Shell位置参数（命令行参数）</h1><p>运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用$n的形式来接收，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，依次类推。</p>
<p>同样，在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用$n的形式接收，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，依次类推。</p>
<p>这种通过<code>$n</code>的形式来接收的参数，在 Shell 中称为位置参数。</p>
<p>变量的名字必须以字母或者下划线开头，不能以数字开头；但是位置参数却偏偏是数字，这和变量的命名规则是相悖的，所以我们将它们视为“特殊变量”。</p>
<h2 id="1-给脚本文件传递位置参数"><a href="#1-给脚本文件传递位置参数" class="headerlink" title="1) 给脚本文件传递位置参数"></a>1) 给脚本文件传递位置参数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Language: <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行<code>test.sh</code>，并附带参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ ./test.sh Shell http://abc.com/</span><br><span class="line">Language: Shell</span><br><span class="line">URL: http://abc.com/</span><br></pre></td></tr></table></figure>
<p>其中<code>Shell</code>是第一个位置参数，<code>http://abc.com/</code>是第二个位置参数，两者之间以空格分隔。</p>
<h2 id="2-给函数传递位置参数"><a href="#2-给函数传递位置参数" class="headerlink" title="2) 给函数传递位置参数"></a>2) 给函数传递位置参数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Language: <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func C++ http://c.biancheng.net/cplus/</span><br></pre></td></tr></table></figure>
<p>运行<code>test.sh</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ ./test.sh</span><br><span class="line">Language: C++</span><br><span class="line">URL: http://c.biancheng.net/cplus/</span><br></pre></td></tr></table></figure>
<p>如果参数个数太多，达到或者超过了 10 个，那么就得用<code>$&#123;n&#125;</code>的形式来接收了，例如<code>$&#123;10&#125;、$&#123;23&#125;</code>。<code>&#123; &#125;</code>的作用是为了帮助解释器识别参数的边界，这跟使用变量时加<code>&#123; &#125;</code>是一样的效果。</p>
<h1 id="Shell特殊变量"><a href="#Shell特殊变量" class="headerlink" title="Shell特殊变量"></a>Shell特殊变量</h1><table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$0</code></td>
<td align="center">当前脚本的文件名。</td>
</tr>
<tr>
<td align="center"><code>$n（n≥1）</code></td>
<td align="center">传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。</td>
</tr>
<tr>
<td align="center"><code>$#</code></td>
<td align="center">传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td align="center"><code>$*</code></td>
<td align="center">传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td align="center"><code>$@</code></td>
<td align="center">传递给脚本或函数的所有参数。当被双引号” “包含时，$@ 与 $* 稍有不同。</td>
</tr>
<tr>
<td align="center"><code>$?</code></td>
<td align="center">上个命令的退出状态，或函数的返回值</td>
</tr>
<tr>
<td align="center"><code>$$</code></td>
<td align="center">当前 Shell 进程 ID。</td>
</tr>
</tbody></table>
<h2 id="1-给脚本文件传递参数"><a href="#1-给脚本文件传递参数" class="headerlink" title="1) 给脚本文件传递参数"></a>1) 给脚本文件传递参数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Process ID: $$&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;File Name: <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;First Parameter : <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Second Parameter : <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 1: <span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;All parameters 2: $*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Total: <span class="variable">$#</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行<code>test.sh</code>，并附带参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ ./test.sh Shell Linux</span><br><span class="line">Process ID: 5943</span><br><span class="line">File Name: bash</span><br><span class="line">First Parameter : Shell</span><br><span class="line">Second Parameter : Linux</span><br><span class="line">All parameters 1: Shell Linux</span><br><span class="line">All parameters 2: Shell Linux</span><br><span class="line">Total: 2</span><br></pre></td></tr></table></figure>
<h2 id="2-给函数传递参数"><a href="#2-给函数传递参数" class="headerlink" title="2) 给函数传递参数"></a>2) 给函数传递参数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Language: <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;First Parameter : <span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Second Parameter : <span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;All parameters 1: <span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;All parameters 2: $*&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Total: <span class="variable">$#</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">func Java abc</span><br></pre></td></tr></table></figure>
<h1 id="：获取函数返回值或者上一个命令的退出状态"><a href="#：获取函数返回值或者上一个命令的退出状态" class="headerlink" title="$?：获取函数返回值或者上一个命令的退出状态"></a>$?：获取函数返回值或者上一个命令的退出状态</h1><p><code>$?</code>是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。</p>
<p>所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p>
<p>不过，也有一些命令返回其他值，表示不同类型的错误。</p>
<h2 id="1-获取上一个命令的退出状态"><a href="#1-获取上一个命令的退出状态" class="headerlink" title="1) $? 获取上一个命令的退出状态"></a>1) $? 获取上一个命令的退出状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == 100 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exit</span> 0  <span class="comment">#参数正确，退出状态为0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exit</span> 1  <span class="comment">#参数错误，退出状态1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><code>exit</code>表示退出当前 Shell 进程，我们必须在新进程中运行<code>test.sh</code>，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法取得它的退出状态了。</p>
<p>运行<code>test.sh</code>时传递参数 100：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 100  #作为一个新进程运行</span><br><span class="line">[mozhiyan@localhost demo]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>运行<code>test.sh</code>时传递参数 89：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost demo]$ bash ./test.sh 89  #作为一个新进程运行</span><br><span class="line">[mozhiyan@localhost demo]$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="2-获取函数的返回值"><a href="#2-获取函数的返回值" class="headerlink" title="2) $? 获取函数的返回值"></a>2) $? 获取函数的返回值</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#得到两个数相加的和</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> `<span class="built_in">expr</span> <span class="variable">$1</span> + <span class="variable">$2</span>`</span><br><span class="line">&#125;</span><br><span class="line">add 23 50  <span class="comment">#调用函数</span></span><br><span class="line"><span class="built_in">echo</span> $?  <span class="comment">#获取函数返回值</span></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># 73</span></span><br></pre></td></tr></table></figure>


<h1 id="echo命令：输出字符串"><a href="#echo命令：输出字符串" class="headerlink" title="echo命令：输出字符串"></a>echo命令：输出字符串</h1><p><code>echo</code>是一个 Shell 内建命令，用来在终端输出字符串，并在最后默认加上换行符。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&quot;Shell教程&quot;</span></span><br><span class="line">url=<span class="string">&quot;http://abc.com/shell/&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你好！&quot;</span>  <span class="comment">#直接输出字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$url</span>  <span class="comment">#输出变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;name&#125;</span>的网址是：<span class="variable">$&#123;url&#125;</span>&quot;</span>  <span class="comment">#双引号包围的字符串中可以解析变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$&#123;name&#125;的网址是：$&#123;url&#125;&#x27;</span>  <span class="comment">#单引号包围的字符串中不能解析变量</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你好！</span><br><span class="line">http://abc.com/shell/</span><br><span class="line">Shell教程的网址是：http://abc.com/shell/</span><br><span class="line">$&#123;name&#125;的网址是：$&#123;url&#125;</span><br></pre></td></tr></table></figure>
<h2 id="不换行"><a href="#不换行" class="headerlink" title="不换行"></a>不换行</h2><p><code>echo</code>命令输出结束后默认会换行，如果不希望换行，可以加上<code>-n</code>参数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&quot;Tom&quot;</span></span><br><span class="line">age=20</span><br><span class="line">height=175</span><br><span class="line">weight=62</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$&#123;name&#125;</span> is <span class="variable">$&#123;age&#125;</span> years old, &quot;</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$&#123;height&#125;</span>cm in height &quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;and <span class="variable">$&#123;weight&#125;</span>kg in weight.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Thank you!&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tom is 20 years old, 175cm in height and 62kg in weight.</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>
<h2 id="输出转义字符"><a href="#输出转义字符" class="headerlink" title="输出转义字符"></a>输出转义字符</h2><p>默认情况下，<code>echo</code>不会解析以反斜杠<code>\</code>开头的转义字符。比如，<code>\n</code>表示换行，<code>echo</code> 默认会将它作为普通字符对待。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;hello \nworld&quot;</span><br><span class="line">hello \nworld</span><br></pre></td></tr></table></figure>
<p>我们可以添加<code>-e</code>参数来让<code>echo</code>命令解析转义字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo -e &quot;hello \nworld&quot;</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<h2 id="c-转义字符"><a href="#c-转义字符" class="headerlink" title="\c 转义字符"></a>\c 转义字符</h2><p>有了<code>-e</code>参数，我们也可以使用转义字符<code>\c</code>来强制<code>echo</code>命令不换行了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&quot;Tom&quot;</span></span><br><span class="line">age=20</span><br><span class="line">height=175</span><br><span class="line">weight=62</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;name&#125;</span> is <span class="variable">$&#123;age&#125;</span> years old, \c&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;height&#125;</span>cm in height \c&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;and <span class="variable">$&#123;weight&#125;</span>kg in weight.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Thank you!&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tom is 20 years old, 175cm in height and 62kg in weight.</span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>
<h1 id="exit命令：退出当前进程"><a href="#exit命令：退出当前进程" class="headerlink" title="exit命令：退出当前进程"></a>exit命令：退出当前进程</h1><p><code>exit</code>是一个 Shell 内置命令，用来退出当前 Shell 进程，并返回一个退出状态；使用<code>$?</code>可以接收这个退出状态。</p>
<p><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。</p>
<p>一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。</p>
<p><code>exit</code>退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。</p>
<p>Shell 进程执行出错时，可以根据退出状态来判断具体出现了什么错误，比如打开一个文件时，我们可以指定 1 表示文件不存在，2 表示文件没有读取权限，3 表示文件类型不对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;befor exit&quot;</span><br><span class="line">exit 8</span><br><span class="line">echo &quot;after exit&quot;</span><br></pre></td></tr></table></figure>
<p>运行该脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ bash ./test.sh</span><br><span class="line">befor exit</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>&quot;after exit&quot;</code>并没有输出，这说明遇到<code>exit</code>命令后，<code>test.sh</code>执行就结束了。</p>
<p>注意，<code>exit</code>表示退出当前 Shell 进程，我们必须在新进程中运行<code>test.sh</code>，否则当前 Shell 会话（终端窗口）会被关闭，我们就无法看到输出结果了。</p>
<p>我们可以紧接着使用<code>$?</code>来获取<code>test.sh</code>的退出状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mozhiyan@localhost ~]$ echo $?</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h1 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h1><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p><code>condition</code>是判断条件，如果<code>condition</code>成立（返回“真”），那么<code>then</code>后边的语句将会被执行；如果<code>condition</code>不成立（返回“假”），那么不会执行任何语句。</p>
<p>从本质上讲，<code>if</code>检测的是命令的退出状态。</p>
<p>注意，最后必须以<code>fi</code>来闭合，<code>fi</code>就是<code>if</code>倒过来拼写。也正是有了<code>fi</code>来结尾，所以即使有多条语句也不需要用<code>&#123; &#125;</code>包围起来。</p>
<p>也可以将<code>then</code>和<code>if</code>写在一行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition;  <span class="keyword">then</span></span><br><span class="line">  statement(s)</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>请注意<code>condition</code>后边的分号<code>;</code>，当<code>if</code>和<code>then</code>位于同一行的时候，这个分号是必须的，否则会有语法错误。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="built_in">read</span> b</span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> == <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;a和b相等&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">84↙</span><br><span class="line">84↙</span><br><span class="line">a和b相等</span><br></pre></td></tr></table></figure>
<p><code>(())</code>是一种数学计算命令，它除了可以进行最基本的加减乘除运算，还可以进行大于、小于、等于等关系运算，以及与、或、非逻辑运算。当<code>a</code>和<code>b</code>相等时，<code>(( $a == $b ))</code>判断条件成立，进入<code>if</code>，执行<code>then</code>后边的<code>echo</code>语句。</p>
<h2 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  statement2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>如果<code>condition</code>成立，那么<code>then</code>后边的<code>statement1</code>语句将会被执行；否则，执行<code>else</code>后边的<code>statement2</code>语句。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="built_in">read</span> b</span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$a</span> == <span class="variable">$b</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;a和b相等&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;a和b不相等，输入错误&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10↙</span><br><span class="line">20↙</span><br><span class="line">a 和 b 不相等，输入错误</span><br></pre></td></tr></table></figure>
<h2 id="if-elif-else-语句"><a href="#if-elif-else-语句" class="headerlink" title="if elif else 语句"></a>if elif else 语句</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  condition1</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  statement1</span><br><span class="line"><span class="keyword">elif</span> condition2</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  statement2</span><br><span class="line"><span class="keyword">elif</span> condition3</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  statement3</span><br><span class="line">……</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  statementn</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>if</code>和<code>elif</code>后边都得跟着<code>then</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> age</span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$age</span> &lt;= <span class="number">2</span> )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;婴儿&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$age</span> &gt;= <span class="number">3</span> &amp;&amp; <span class="variable">$age</span> &lt;= <span class="number">8</span> )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;幼儿&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$age</span> &gt;= <span class="number">9</span> &amp;&amp; <span class="variable">$age</span> &lt;= <span class="number">17</span> )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;少年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$age</span> &gt;= <span class="number">18</span> &amp;&amp; <span class="variable">$age</span> &lt;=<span class="number">25</span> )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;成年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$age</span> &gt;= <span class="number">26</span> &amp;&amp; <span class="variable">$age</span> &lt;= <span class="number">40</span> )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;青年&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$age</span> &gt;= <span class="number">41</span> &amp;&amp; <span class="variable">$age</span> &lt;= <span class="number">60</span> )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;中年&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;老年&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h1 id="Shell退出状态"><a href="#Shell退出状态" class="headerlink" title="Shell退出状态"></a>Shell退出状态</h1><p>每一条 Shell 命令，不管是 Bash 内置命令（例如<code>cd、echo</code>），还是外部的 Linux 命令（例如<code>ls、awk</code>），还是自定义的 Shell 函数，当它退出（运行结束）时，都会返回一个比较小的整数值给调用（使用）它的程序，这就是命令的退出状态。</p>
<p>很多 Linux 命令其实就是一个C语言程序，熟悉C语言的读者都知道，<code>main()</code>函数的最后都有一个<code>return 0</code>，如果程序想在中间退出，还可以使用<code>exit 0</code>，这其实就是C语言程序的退出状态。当有其它程序调用这个程序时，就可以捕获这个退出状态。</p>
<p><code>if</code>语句的判断条件，从本质上讲，判断的就是命令的退出状态。</p>
<p>按照惯例来说，退出状态为 0 表示“成功”；也就是说，程序执行完成并且没有遇到任何问题。除 0 以外的其它任何退出状态都为“失败”。</p>
<p>之所以说这是“惯例”而非“规定”，是因为也会有例外，比如<code>diff</code>命令用来比较两个文件的不同，对于“没有差别”的文件返回 0，对于“找到差别”的文件返回 1，对无效文件名返回 2。</p>
<p>在 Shell 中，有多种方式取得命令的退出状态，其中<code>$?</code>是最常见的一种。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="built_in">read</span> b</span><br><span class="line">(( <span class="variable">$a</span> == <span class="variable">$b</span> ));</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;退出状态：&quot;</span>$?</span><br></pre></td></tr></table></figure>
<p>运行结果1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">26</span><br><span class="line">退出状态：0</span><br></pre></td></tr></table></figure>
<p>运行结果2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">39</span><br><span class="line">退出状态：1</span><br></pre></td></tr></table></figure>
<h2 id="退出状态和逻辑运算符的组合"><a href="#退出状态和逻辑运算符的组合" class="headerlink" title="退出状态和逻辑运算符的组合"></a>退出状态和逻辑运算符的组合</h2><p>Shell <code>if</code>语句的一个神奇之处是允许我们使用逻辑运算符将多个退出状态组合起来，这样就可以一次判断多个条件了。</p>
<p>运算符	使用格式	说明<br>| &amp;&amp; | expression1 &amp;&amp; expression2 | 逻辑与运算符，当 expression1 和 expression2 同时成立时，整个表达式才成立。<br>如果检测到 expression1 的退出状态为 0，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是不成立的，检测了也是多此一举。 |<br>| <code>||</code> | expression1 || expression2 | 逻辑或运算符，expression1 和 expression2 两个表达式中只要有一个成立，整个表达式就成立。<br>如果检测到 expression1 的退出状态为 1，就不会再检测 expression2 了，因为不管 expression2 的退出状态是什么，整个表达式必然都是成立的，检测了也是多此一举。 |<br>| ! | !expression | 逻辑非运算符，相当于“取反”的效果。如果 expression 成立，那么整个表达式就不成立；如果 expression 不成立，那么整个表达式就成立。 |</p>
<p>将用户输入的 URL 写入到文件中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> filename</span><br><span class="line"><span class="built_in">read</span> url</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -w <span class="variable">$filename</span> &amp;&amp; <span class="built_in">test</span> -n <span class="variable">$url</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$url</span> &gt; <span class="variable">$filename</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;写入成功&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;写入失败&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>在 Shell 脚本文件所在的目录新建一个文本文件并命名为<code>urls.txt</code>，然后运行 Shell 脚本，运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urls.txt↙</span><br><span class="line">http://c.biancheng.net/shell/↙</span><br><span class="line">写入成功</span><br></pre></td></tr></table></figure>
<p><code>test</code>是 Shell 内置命令，可以对文件或者字符串进行检测，其中，<code>-w</code>选项用来检测文件是否存在并且可写，<code>-n</code>选项用来检测字符串是否非空。</p>
<p><code>&gt;</code>表示重定向，默认情况下，echo 向控制台输出，这里我们将输出结果重定向到文件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/常见错误"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/MySQL/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" class="article-date">
  <time datetime="2022-10-29T09:05:54.594Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Navicat-运行-SQL-文件报-Unknown-error-1067。"><a href="#Navicat-运行-SQL-文件报-Unknown-error-1067。" class="headerlink" title="Navicat 运行 SQL 文件报 Unknown error 1067。"></a>Navicat 运行 SQL 文件报 Unknown error 1067。</h2><p>解决办法：</p>
<ol>
<li>编辑my.cnf<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql_mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">explicit_defaults_for_timestamp=1</span><br></pre></td></tr></table></figure></li>
<li>重启mysql</li>
</ol>
<p>在MySQL 5.7版本之前，且在MySQL 5.6.6版本之后（explicit_defaults_for_timestamp参数在MySQL 5.6.6开始加入）的版本中，如果没有设置explicit_defaults_for_timestamp&#x3D;1的情况下：</p>
<p>1）在默认情况下，如果TIMESTAMP列没有显示的指明null属性，那么该列会被自动加上not null属性（而其他类型的列如果没有被显示的指定not null，那么是允许null值的），如果往这个列中插入null值，会自动的设置该列的值为current timestamp值。</p>
<p>2）表中的第一个TIMESTAMP列，如果没有指定null属性或者没有指定默认值，也没有指定ON UPDATE语句。那么该列会自动被加上DEFAULT CURRENT_TIMESTAMP和ON UPDATE CURRENT_TIMESTAMP属性。</p>
<p>3）第一个TIMESTAMP列之后的其他的TIMESTAMP类型的列，如果没有指定null属性，也没有指定默认值，那么该列会被自动加上DEFAULT ‘0000-00-00 00:00:00’属性。如果insert语句中没有为该列指定值，那么该列中插入’0000-00-00 00:00:00’，并且没有warning。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-MySQL/MySQL面试题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/MySQL/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2022-10-29T09:05:54.593Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="如果要存ip地址，用什么数据类型比较好"><a href="#如果要存ip地址，用什么数据类型比较好" class="headerlink" title="如果要存ip地址，用什么数据类型比较好"></a>如果要存ip地址，用什么数据类型比较好</h2><p>当存储 IPv4 地址时，应该使用32位的无符号整数（<code>UNSIGNED INT</code>）来存储 IP 地址，而不是使用字符串。</p>
<p>相对字符串存储，使用无符号整数来存储有如下的好处：</p>
<ul>
<li>节省空间，不管是数据存储空间，还是索引存储空间</li>
<li>便于使用范围查询（<code>BETWEEN...AND</code>），且效率更高</li>
<li>通常，在保存 IPv4 地址时，一个 IPv4 最小需要 7 个字符，最大需要15个字符，所以，使用<code>VARCHAR(15)</code>即可。MySQL 在保存变长的字符串时，还需要额外的一个字节来保存此字符串的长度。而如果使用无符号整数来存储，只需要4个字节即可。</li>
<li>另外还可以使用 4 个字段分别存储 IPv4 中的各部分，但是通常这不管是存储空间和查询效率应该都不是很高（可能有的场景适合使用这种方式存储）。</li>
</ul>
<p>使用无符号整数来存储也有缺点：不便于阅读、需要手动转换。</p>
<p>对于转换来说，MySQL 提供了相应的函数来把字符串格式的 IP 转换成整数<code>INET_ATON</code>，以及把整数格式的IP转换成字符串的<code>INET_NTOA</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select inet_aton(&#x27;192.168.0.1&#x27;);</span><br><span class="line">+--------------------------+</span><br><span class="line">| inet_aton(&#x27;192.168.0.1&#x27;) |</span><br><span class="line">+--------------------------+</span><br><span class="line">|               3232235521 |</span><br><span class="line">+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select inet_ntoa(3232235521);</span><br><span class="line">+-----------------------+</span><br><span class="line">| inet_ntoa(3232235521) |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 192.168.0.1           |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>对于 IPv6 来说，使用<code>VARBINARY</code>同样可获得相同的好处，同时 MySQL 也提供了相应的转换函数，即<code>INET6_ATON</code>和<code>INET6_NTOA</code>。<br>对于转换字符串 IPv4 和数值类型，可以放在应用层，下面是使用java代码来对二者转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mikan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mikan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IpLongUtils</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 把字符串IP转换成long</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ipStr 字符串IP</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> IP对应的long值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ip2Long</span><span class="params">(String ipStr)</span> &#123;</span><br><span class="line">    String[] ip = ipStr.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (Long.valueOf(ip[<span class="number">0</span>]) &lt;&lt; <span class="number">24</span>) + (Long.valueOf(ip[<span class="number">1</span>]) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            + (Long.valueOf(ip[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + Long.valueOf(ip[<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 把IP的long值转换成字符串</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ipLong IP的long值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> long值对应的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">long2Ip</span><span class="params">(<span class="type">long</span> ipLong)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">ip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    ip.append(ipLong &gt;&gt;&gt; <span class="number">24</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    ip.append((ipLong &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    ip.append((ipLong &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    ip.append(ipLong &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="keyword">return</span> ip.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(ip2Long(<span class="string">&quot;192.168.0.1&quot;</span>));</span><br><span class="line">    System.out.println(long2Ip(<span class="number">3232235521L</span>));</span><br><span class="line">    System.out.println(ip2Long(<span class="string">&quot;10.0.0.1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3232235521</span><br><span class="line">192.168.0.1</span><br><span class="line">167772161</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux/Linux进程管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/Linux/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-10-29T09:05:54.554Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="进程启动的方式"><a href="#进程启动的方式" class="headerlink" title="进程启动的方式"></a>进程启动的方式</h1><p>在 Linux 系统中，每个进程都有一个唯一的进程号（PID），方便系统识别和调度进程。通过简单地输出运行程序的程序名，就可以运行该程序，其实也就是启动了一个进程。</p>
<p>总体来说，启动一个进程主要有 2 种途径，分别是通过手工启动和通过调度启动（事先进行设置，根据用户要求，进程可以自行启动），接下来就一一介绍这 2 中方式。</p>
<h2 id="Linux手工启动进程"><a href="#Linux手工启动进程" class="headerlink" title="Linux手工启动进程"></a>Linux手工启动进程</h2><p>手工启动进程指的是由用户输入命令直接启动一个进程，根据所启动的进程类型和性质的不同，其又可以细分为前台启动和后台启动 2 种方式。</p>
<h3 id="前台启动进程"><a href="#前台启动进程" class="headerlink" title="前台启动进程"></a>前台启动进程</h3><p>这是手工启动进程最常用的方式，因为当用户输入一个命令并运行，就已经启动了一个进程，而且是一个前台的进程，此时系统其实已经处于一个多进程的状态（一个是 Shell 进程，另一个是新启动的进程）。</p>
<p>假如启动一个比较耗时的进程，然后再把该进程挂起，并使用 ps 命令查看，就会看到该进程在 ps 显示列表中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -name demo.jpg &lt;--在根目录下查找 demo.jpg 文件，比较耗时</span><br><span class="line">#此处省略了该命令的部分输出信息</span><br><span class="line">#按“CTRL+Z”组合键，即可将该进程挂起</span><br><span class="line">[root@localhost ~]# ps &lt;--查看正在运行的进程</span><br><span class="line">PID  TTY      TIME   CMD</span><br><span class="line">2573 pts/0  00:00:00 bash</span><br><span class="line">2587 pts/0  00:00:01 find</span><br><span class="line">2588 pts/0  00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>将进程挂起，指的是将前台运行的进程放到后台，并且暂停其运行。</p>
<p>通过运行<code>ps</code>命令查看进程信息，可以看到，刚刚执行的<code>find</code>命令的进程号为 2587，同时<code>ps</code>进程的进程号为 2588。</p>
<h3 id="后台启动进程"><a href="#后台启动进程" class="headerlink" title="后台启动进程"></a>后台启动进程</h3><p>进程直接从后台运行，用的相对较少，除非该进程非常耗时，且用户也不急着需要其运行结果的时候，例如，用户需要启动一个需要长时间运行的格式化文本文件的进程，为了不使整个 Shell 在格式化过程中都处于“被占用”状态，从后台启动这个进程是比较明智的选择。</p>
<p>从后台启动进程，其实就是在命令结尾处添加一个 “ &amp;” 符号（注意，&amp; 前面有空格）。输入命令并运行之后，Shell 会提供给我们一个数字，此数字就是该进程的进程号。然后直接就会出现提示符，用户就可以继续完成其他工作，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -name install.log &amp;</span><br><span class="line">[1] 1920</span><br><span class="line">#[1]是工作号，1920是进程号</span><br></pre></td></tr></table></figure>
<p>以上介绍了手工启动的 2 种方式，实际上它们有个共同的特点，就是新进程都是由当前 Shell 这个进程产生的，换句话说，是 Shell 创建了新进程，于是称这种关系为进程间的父子关系，其中 Shell 是父进程，新进程是子进程。</p>
<p>值得一提的是，一个父进程可以有多个子进程，通常子进程结束后才能继续父进程；当然，如果是从后台启动，父进程就不用等待子进程了。</p>
<h2 id="Linux调度启动进程"><a href="#Linux调度启动进程" class="headerlink" title="Linux调度启动进程"></a>Linux调度启动进程</h2><p>在 Linux 系统中，任务可以被配置在指定的时间、日期或者系统平均负载量低于指定值时自动启动。</p>
<p>例如，Linux 预配置了重要系统任务的运行，以便可以使系统能够实时被更新，系统管理员也可以使用自动化的任务来定期对重要数据进行备份。</p>
<p>实现调度启动进程的方法有很多，例如通过 crontab、at 等命令。</p>
<h1 id="ps命令：查看正在运行的进程"><a href="#ps命令：查看正在运行的进程" class="headerlink" title="ps命令：查看正在运行的进程"></a>ps命令：查看正在运行的进程</h1><p>ps 命令是最常用的监控进程的命令，通过此命令可以查看系统中所有运行进程的详细信息。</p>
<p>ps 命令有多种不同的使用方法，这常常给初学者带来困惑。在各种 Linux 论坛上，询问 ps 命令语法的帖子屡见不鲜，而出现这样的情况，还要归咎于 UNIX 悠久的历史和庞大的派系。在不同的 Linux 发行版上，ps 命令的语法各不相同，为此，Linux 采取了一个折中的方法，即融合各种不同的风格，兼顾那些已经习惯了其它系统上使用 ps  命令的用户。</p>
<p>ps 命令的基本格式如下：<br>[root@localhost ~]# ps aux<br>#查看系统中所有的进程，使用 BS 操作系统格式<br>[root@localhost ~]# ps -le<br>#查看系统中所有的进程，使用 Linux 标准命令格式</p>
<p>选项：<br>a：显示一个终端的所有进程，除会话引线外；<br>u：显示进程的归属用户及内存的使用情况；<br>x：显示没有控制终端的进程；<br>-l：长格式显示更加详细的信息；<br>-e：显示所有进程；<br>可以看到，ps 命令有些与众不同，它的部分选项不能加入”-“，比如命令”ps aux”，其中”aux”是选项，但是前面不能带“-”。</p>
<p>大家如果执行 “man ps” 命令，则会发现 ps 命令的帮助为了适应不同的类 UNIX 系统，可用格式非常多，不方便记忆。所以，我建议大家记忆几个固定选项即可。比如：<br>“ps aux” 可以查看系统中所有的进程；<br>“ps -le” 可以查看系统中所有的进程，而且还能看到进程的父进程的 PID 和进程优先级；<br>“ps -l” 只能看到当前 Shell 产生的进程；</p>
<p>有这三个命令就足够了，下面分别来查看。</p>
<p>【例 1】<br>[root@localhost ~]# ps aux<br>#查看系统中所有的进程<br>USER PID %CPU %MEM  VSZ  RSS   TTY STAT START TIME COMMAND<br>root   1  0.0  0.2 2872 1416   ?   Ss   Jun04 0:02 &#x2F;sbin&#x2F;init<br>root   2  0.0  0.0    0    0   ?    S   Jun04 0:00 [kthreadd]<br>root   3  0.0  0.0    0    0   ?    S   Jun04 0:00 [migration&#x2F;0]<br>root   4  0.0  0.0    0    0   ?    S   Jun04 0:00 [ksoftirqd&#x2F;0]<br>…省略部分输出…<br>表 1 中罗列出了以上输出信息中各列的具体含义。</p>
<p>表 1 ps命令输出信息含义<br>表头	含义<br>USER	该进程是由哪个用户产生的。<br>PID	进程的 ID。<br>%CPU	该进程占用 CPU 资源的百分比，占用的百分比越高，进程越耗费资源。<br>%MEM	该进程占用物理内存的百分比，占用的百分比越高，进程越耗费资源。<br>VSZ	该进程占用虚拟内存的大小，单位为 KB。<br>RSS	该进程占用实际物理内存的大小，单位为 KB。<br>TTY	该进程是在哪个终端运行的。其中，tty1 ~ tty7 代表本地控制台终端（可以通过 Alt+F1 ~ F7 快捷键切换不同的终端），tty1~tty6 是本地的字符界面终端，tty7 是图形终端。pts&#x2F;0 ~ 255 代表虚拟终端，一般是远程连接的终端，第一个远程连接占用 pts&#x2F;0，第二个远程连接占用 pts&#x2F;1，依次増长。<br>STAT	进程状态。常见的状态有以下几种：<br>-D：不可被唤醒的睡眠状态，通常用于 I&#x2F;O 情况。<br>-R：该进程正在运行。<br>-S：该进程处于睡眠状态，可被唤醒。<br>-T：停止状态，可能是在后台暂停或进程处于除错状态。<br>-W：内存交互状态（从 2.6 内核开始无效）。<br>-X：死掉的进程（应该不会出现）。<br>-Z：僵尸进程。进程已经中止，但是部分程序还在内存当中。<br>-&lt;：高优先级（以下状态在 BSD 格式中出现）。<br>-N：低优先级。<br>-L：被锁入内存。<br>-s：包含子进程。<br>-l：多线程（小写 L）。<br>-+：位于后台。<br>START	该进程的启动时间。<br>TIME	该进程占用 CPU 的运算时间，注意不是系统时间。<br>COMMAND	产生此进程的命令名。<br>【例 2】”ps aux”命令可以看到系统中所有的进程，”ps -le”命令也能看到系统中所有的进程。由于 “-l” 选项的作用，所以 “ps -le” 命令能够看到更加详细的信息，比如父进程的 PID、优先级等。但是这两个命令的基本作用是一致的，掌握其中一个就足够了。<br>[root@localhost ~]# ps -le<br>F S UID PID PPID C  PRI Nl ADDR  SZ WCHAN TTY      TIME  CMD<br>4 S   0   1    0 0  80   0 -    718 -     ?    00:00:02  init<br>1 S   0   2    0 0  80   0 -      0 -     ?    00:00:00  kthreadd<br>1 S   0   3    2 0 -40   - -      0 -     ?    00:00:00  migration&#x2F;0<br>1 S   0   4    2 0  80   0 -      0 -     ?    00:00:00  ksoflirqd&#x2F;0<br>1 S   0   5    2 0 -40   - -      0 -     ?    00:00:00  migration&#x2F;0<br>…省略部分输出…<br>表 2 罗列出以上输出信息中各列的含义。</p>
<p>表 2 ps -le 命令输出信息<br>表头	含义<br>F	进程标志，说明进程的权限，常见的标志有两个:<br>1：进程可以被复制，但是不能被执行；<br>4：进程使用超级用户权限；<br>S	进程状态。具体的状态和”psaux”命令中的 STAT 状态一致；<br>UID	运行此进程的用户的 ID；<br>PID	进程的 ID；<br>PPID	父进程的 ID；<br>C	该进程的 CPU 使用率，单位是百分比；<br>PRI	进程的优先级，数值越小，该进程的优先级越高，越早被 CPU 执行；<br>NI	进程的优先级，数值越小，该进程越早被执行；<br>ADDR	该进程在内存的哪个位置；<br>SZ	该进程占用多大内存；<br>WCHAN	该进程是否运行。”-“代表正在运行；<br>TTY	该进程由哪个终端产生；<br>TIME	该进程占用 CPU 的运算时间，注意不是系统时间；<br>CMD	产生此进程的命令名；<br>【例 3】如果不想看到所有的进程，只想查看一下当前登录产生了哪些进程，那只需使用 “ps -l” 命令就足够了：<br>[root@localhost ~]# ps -l<br>#查看当前登录产生的进程<br>F S UID   PID  PPID C PRI NI ADDR SZ WCHAN TTY       TIME CMD<br>4 S 0   18618 18614 0  80  0 - 1681  -     pts&#x2F;1 00:00:00 bash<br>4 R 0   18683 18618 4  80  0 - 1619  -     pts&#x2F;1 00:00:00 ps<br>可以看到，这次从 pts&#x2F;1 虚拟终端登录，只产生了两个进程：一个是登录之后生成的 Shell，也就是 bash；另一个是正在执行的 ps 命令。</p>
<p>我们再来说说僵尸进程。僵尸进程的产生一般是由于进程非正常停止或程序编写错误，导致子进程先于父进程结束，而父进程又没有正确地回收子进程，从而造成子进程一直存在于内存当中，这就是僵尸进程。</p>
<p>僵尸进程会对主机的稳定性产生影响，所以，在产生僵尸进程后，一定要对产生僵尸进程的软件进行优化，避免一直产生僵尸进程；对于已经产生的僵尸进程，可以在查找出来之后强制中止。</p>
<h1 id="top命令：持续监听进程运行状态"><a href="#top命令：持续监听进程运行状态" class="headerlink" title="top命令：持续监听进程运行状态"></a>top命令：持续监听进程运行状态</h1><h1 id="pstree命令：查看进程树"><a href="#pstree命令：查看进程树" class="headerlink" title="pstree命令：查看进程树"></a>pstree命令：查看进程树</h1><h1 id="lsof命令：列出进程调用或打开的文件信息"><a href="#lsof命令：列出进程调用或打开的文件信息" class="headerlink" title="lsof命令：列出进程调用或打开的文件信息"></a>lsof命令：列出进程调用或打开的文件信息</h1><h1 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h1><h1 id="nice和renice命令：改变进程优先级"><a href="#nice和renice命令：改变进程优先级" class="headerlink" title="nice和renice命令：改变进程优先级"></a>nice和renice命令：改变进程优先级</h1><h1 id="常用信号（进程间通信）"><a href="#常用信号（进程间通信）" class="headerlink" title="常用信号（进程间通信）"></a>常用信号（进程间通信）</h1><p>进程的管理主要是指进程的关闭与重启。我们一般关闭或重启软件，都是关闭或重启它的程序，而不是直接操作进程的。比如，要重启 apache 服务，一般使用命令”service httpd restart”重启 apache的程序。</p>
<p>那么，可以通过直接管理进程来关闭或重启 apache 吗？答案是肯定的，这时就要依赖进程的信号（Signal）了。我们需要给予该进程号，告诉进程我们想要让它做什么。</p>
<p>系统中可以识别的信号较多，我们可以使用命令”kill -l”或”man 7 signal”来查询。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#kill -l</span><br><span class="line">1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line">6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1</span><br><span class="line">11)SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15)SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG</span><br><span class="line">24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN +4 39) SIGRTMIN +5 40) SIGRTMIN+6 41)SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN +9 44) SIGRTMIN +10 45) SIGRTMIN+11 46) SIGRTMIN+1247) SIGRTMIN+13 48) SIGRTMIN +14 49) SIGRTMIN +15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX</span><br></pre></td></tr></table></figure>
<p>常见的进程信号：</p>
<p>| 信号代号 |  信号名称 | 说 明 |</p>
<p>| 1	       | SIGHUP    | 该信号让进程立即关闭.然后重新读取配置文件之后重启 |<br>| 2        | SIGINT    | 程序中止信号，用于中止前台进程。相当于输出 Ctrl+C 快捷键 |<br>| 8        | SIGFPE    | 在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其他所有的算术运算错误 |<br>| 9        | SIGKILL   | 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。般用于强制中止进程 |<br>| 14       | SIGALRM   | 时钟定时信号，计算的是实际的时间或时钟时间。alarm 函数使用该信号 |<br>| 15       | SIGTERM   | 正常结束进程的信号，kill 命令的默认信号。如果进程已经发生了问题，那么这 个信号是无法正常中止进程的，这时我们才会尝试 SIGKILL 信号，也就是信号 9 |<br>| 18       | SIGCONT   | 该信号可以让暂停的进程恢复执行。本信号不能被阻断 |<br>| 19       | SIGSTOP   | 该信号可以暂停前台进程，相当于输入 Ctrl+Z 快捷键。本信号不能被阻断 |</p>
<p>其中最重要的就是 “1”、”9”、”15”这三个信号，我们只需要记住这三个信号即可。</p>
<h1 id="kill命令：终止进程"><a href="#kill命令：终止进程" class="headerlink" title="kill命令：终止进程"></a>kill命令：终止进程</h1><p><code>kill</code>命令只是用来向进程发送一个信号，至于这个信号是什么，是用户指定的。</p>
<p>也就是说，<code>kill</code>命令的执行原理是这样的，<code>kill</code>命令会向操作系统内核发送一个信号（多是终止信号）和目标进程的<code>PID</code>，然后系统内核根据收到的信号类型，对指定进程进行相应的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill [信号] PID</span><br></pre></td></tr></table></figure>
<p><code>kill</code>命令是按照<code>PID</code>来确定进程的，所以<code>kill</code>命令只能识别<code>PID</code>，而不能识别进程名。Linux 定义了几十种不同类型的信号，可以使用<code>kill -l</code>命令查看所有信号及其编号。</p>
<p><code>kill</code>命令常用信号及其含义：</p>
<table>
<thead>
<tr>
<th align="center">信号编号</th>
<th align="center">信号名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">EXIT</td>
<td align="center">程序退出时收到该信息。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">HUP</td>
<td align="center">挂掉电话线或终端连接的挂起信号，这个信号也会造成某些进程在没有终止的情况下重新初始化。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">INT</td>
<td align="center">表示结束进程，但并不是强制性的，常用的 “Ctrl+C” 组合键发出就是一个 kill -2 的信号。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">QUIT</td>
<td align="center">退出。</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">KILL</td>
<td align="center">杀死进程，即强制结束进程。</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">SEGV</td>
<td align="center">段错误。</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">TERM</td>
<td align="center">正常结束进程，是 kill 命令的默认信号。</td>
</tr>
</tbody></table>
<p>需要注意的是，表中省略了各个信号名称的前缀<code>SIG</code>，也就是说，<code>SIGTERM</code>和<code>TERM</code>这两种写法都对，<code>kill</code>命令都可以理解。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h4 id="标准-kill-命令"><a href="#标准-kill-命令" class="headerlink" title="标准 kill 命令"></a>标准 kill 命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~】# service httpd start</span><br><span class="line">#启动RPM包默认安装的apache服务</span><br><span class="line">[root@localhost ~]# pstree -p 丨 grep httpd | grep -v &quot;grep&quot;</span><br><span class="line">#查看 httpd 的进程树及 PID。grep 命令査看 httpd 也会生成包含&quot;httpd&quot;关键字的进程，所以使用“-v”反向选择包含“grep”关键字的进程，这里使用 pstree 命令来查询进程，当然也可以使用 ps 和 top 命令</span><br><span class="line">|-httpd(2246)-+-httpd(2247)</span><br><span class="line">|    |-httpd(2248)</span><br><span class="line">|    |-httpd(2249)</span><br><span class="line">|    |-httpd(2250)</span><br><span class="line">|    |-httpd(2251)</span><br><span class="line">[root@localhost ~]# kill 2248</span><br><span class="line">#杀死PID是2248的httpd进程，默认信号是15，正常停止</span><br><span class="line">#如果默认信号15不能杀死进程，则可以尝试-9信号，强制杀死进程</span><br><span class="line">[root@localhost ~]# pstree -p | grep httpd | grep -v &quot;grep&quot;</span><br><span class="line">|-httpd(2246&gt;-+-httpd(2247)</span><br><span class="line">|    |-httpd(2249)</span><br><span class="line">|    |-httpd(2250)</span><br><span class="line">|    |-httpd(2251)</span><br><span class="line">#PID是2248的httpd进程消失了</span><br></pre></td></tr></table></figure>
<h4 id="使用“-1”信号，让进程重启。"><a href="#使用“-1”信号，让进程重启。" class="headerlink" title="使用“-1”信号，让进程重启。"></a>使用“-1”信号，让进程重启。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -1 2246</span><br><span class="line">使用“-1 (数字1)”信号，让httpd的主进程重新启动</span><br><span class="line">[root@localhost ~]# pstree -p | grep httpd | grep -v &quot;grep&quot;</span><br><span class="line">|-httpd(2246)-+-httpd(2270)</span><br><span class="line">|    |-httpd(2271)</span><br><span class="line">|    |-httpd(2272)</span><br><span class="line">|    |-httpd(2273)</span><br><span class="line">|    |-httpd(2274)</span><br><span class="line">#子httpd进程的PID都更换了，说明httpd进程已经重启了一次</span><br></pre></td></tr></table></figure>
<h4 id="使用“-19”信号，让进程暂停。"><a href="#使用“-19”信号，让进程暂停。" class="headerlink" title="使用“-19”信号，让进程暂停。"></a>使用“-19”信号，让进程暂停。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi test.sh #使用vi命令编辑一个文件，不要退出</span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vi&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root 2313 0.0 0.2 7116 1544 pts/1 S+ 19:2.0 0:00 vi test.sh</span><br><span class="line">#换一个不同的终端，查看一下这个进程的状态。进程状态是S（休眠）和+（位于后台），因为是在另一个终端运行的命令</span><br><span class="line">[root@localhost ~]# kill -19 2313</span><br><span class="line">#使用-19信号，让PID为2313的进程暂停。相当于在vi界面按 Ctrl+Z 快捷键</span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vi&quot; | grep -v &quot;grep&quot;</span><br><span class="line">root 2313 0.0 0.2 7116 1580 pts/1 T 19:20 0:00 vi test.sh</span><br><span class="line">#注意2313进程的状态，变成了 T（暂停）状态。这时切换回vi的终端,发现vi命令已经暂停，又回到了命令提示符，不过2313进程就会卡在后台。如果想要恢复，可以使用&quot;kill -9 2313”命令强制中止进程，</span><br></pre></td></tr></table></figure>
<p>使用<code>kill</code>命令一定可以终止一个进程吗？</p>
<p>答案是否定的。<code>kill</code>命令只是“发送”一个信号，因此，只有当信号被程序成功“捕获”，系统才会执行<code>kill</code>命令指定的操作；反之，如果信号被“封锁”或者“忽略”，则<code>kill</code>命令将会失效。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Docker/Docker Compose"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/Docker/Docker%20Compose/" class="article-date">
  <time datetime="2022-10-29T09:05:54.541Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 国内用户可以使用以下方式加快下载</span><br><span class="line">$ sudo curl -L https://download.fastgit.org/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h2 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://raw.githubusercontent.com/docker/compose/1.27.4/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>如果是二进制包方式安装的，删除二进制文件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li>
</ul>
<p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code>面向项目进行管理。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。<br>下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。<br>web 应用<br>新建文件夹，在该目录中编写 app.py 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=&#x27;redis&#x27;, port=6379)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    count = redis.incr(&#x27;hits&#x27;)</span><br><span class="line">    return &#x27;Hello World! 该页面已被访问 &#123;&#125; 次。\n&#x27;.format(count)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, debug=True)</span><br></pre></td></tr></table></figure>
<p>Dockerfile</p>
<p>编写 Dockerfile 文件，内容为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br><span class="line">docker-compose.yml</span><br><span class="line">编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。</span><br><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;5000:5000&quot;</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br></pre></td></tr></table></figure>
<p>运行 compose 项目</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up</span><br></pre></td></tr></table></figure>
<p>此时访问本地 5000 端口，每次刷新页面，计数就会加 1。</p>
<h1 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a>Compose 模板文件</h1><p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。这里面大部分指令跟<code>docker run</code>相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为<code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">​</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    image: examples/web</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/data&quot;</span><br></pre></td></tr></table></figure>
<p>注意每个服务都必须通过<code>image</code>指令指定镜像或<code>build</code>指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用<code>build</code>指令，在 Dockerfile 中设置的选项(例如：<code>CMD, EXPOSE, VOLUME, ENV</code>等) 将会自动被获取，无需在<code>docker-compose.yml</code>中重复设置。</p>
<h2 id="varsion"><a href="#varsion" class="headerlink" title="varsion"></a>varsion</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br></pre></td></tr></table></figure>
<p>表示使用第三代语法来构建<code>docker-compose.yaml</code>文件。</p>
<h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">​</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>
<p>你也可以使用<code>context</code>指令指定 Dockerfile 所在文件夹的路径。</p>
<p>使用<code>dockerfile</code>指令指定 Dockerfile 文件名。</p>
<p>使用<code>arg</code>指令指定构建镜像时的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">​</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure>
<p>使用<code>cache_from</code>指定构建镜像的缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  cache_from:</span><br><span class="line">    - alpine:latest</span><br><span class="line">    - corp/web_app:3.14</span><br></pre></td></tr></table></figure>
<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>覆盖容器启动后默认执行的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<h2 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h2><p>指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: docker-web-container</span><br></pre></td></tr></table></figure>
<p>注意: 指定容器名称后，该服务将无法进行扩展，因为 Docker 不允许多个容器具有相同的名称。</p>
<h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h2><p>解决容器的依赖、启动先后的问题。以下例子中会先启动<code>redis db</code>再启动<code>web</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">​</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">​</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">​</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>
<p>注意：web 服务不会等待<code>redis db</code>「完全启动」之后才启动。</p>
<h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><p>挂载一个<code>tmpfs</code>文件系统到容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line">tmpfs:</span><br><span class="line">  - /run</span><br><span class="line">  - /tmp</span><br></pre></td></tr></table></figure>
<h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h2><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过<code>docker-compose -f FILE</code>方式来指定<code>Compose</code>模板文件，则<code>env_file</code>中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与<code>environment</code>指令冲突，则按照惯例，以后者为准。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line">​</span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<p>环境变量文件中每一行必须符合格式，支持<code>#</code>开头的注释行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># common.env: Set development environment</span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line">​</span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure>
<p>如果变量名称或者值中用到<code>true|false，yes|no</code>等表达  含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>
<h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>
<h2 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h2><p>通过命令检查容器是否健康运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code>将会尝试拉取这个镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure>
<h2 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h2><p>为容器添加 Docker 元数据信息。例如可以为容器添加辅助说明信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.startupteam.description: &quot;webapp for a startup team&quot;</span><br><span class="line">  com.startupteam.department: &quot;devops department&quot;</span><br><span class="line">  com.startupteam.release: &quot;rc3 for v1.0&quot;</span><br></pre></td></tr></table></figure>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>配置日志选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
<p>目前支持三种日志驱动类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>
<p><code>options</code>配置日志驱动的相关参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure>
<h2 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h2><p>设置网络模式。使用和<code>docker run</code>的<code>--network</code>参数一样的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure>
<h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h2><p>配置容器连接的网络。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">​</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line">​</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure>
<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: &quot;host&quot;</span><br></pre></td></tr></table></figure>
<h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h2><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 (<code>HOST:CONTAINER</code>) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure>
<p>注意：当使用<code>HOST:CONTAINER</code>格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果。</p>
<h2 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h2><p>存储敏感数据，例如 mysql 服务密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line">​</span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</span><br><span class="line">  secrets:</span><br><span class="line">    - db_root_password</span><br><span class="line">    - my_other_secret</span><br><span class="line">​</span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">  my_other_secret:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>
<h2 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h2><p>指定容器的<code>ulimits</code>限制值。<br>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>
<h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h2><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。<br>该指令中路径支持相对路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">​</span><br><span class="line">services:</span><br><span class="line">  my_src:</span><br><span class="line">    image: mysql:8.0</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql_data:/var/lib/mysql</span><br><span class="line">​</span><br><span class="line">volumes:</span><br><span class="line">  mysql_data:</span><br></pre></td></tr></table></figure>
<h2 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h2><p>此外，还有包括<code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code>等指令，基本跟<code>docker run</code>中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>
<p>指定容器中运行应用的用户名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></table></figure>
<p>指定容器中工作目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">working_dir: /code</span><br></pre></td></tr></table></figure>
<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">domainname: your_website.com</span><br><span class="line">hostname: test</span><br><span class="line">mac_address: 08-00-27-00-0C-0A</span><br></pre></td></tr></table></figure>
<p>允许容器中运行一些特权命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privileged: true</span><br></pre></td></tr></table></figure>
<p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为<code>always</code>或者<code>unless-stopped</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure>
<p>以只读模式挂载容器的<code>root</code>文件系统，意味着不能对容器内容进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_only: true</span><br></pre></td></tr></table></figure>
<p>打开标准输入，可以接受外部输入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdin_open: true</span><br></pre></td></tr></table></figure>
<p>模拟一个伪终端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty: true</span><br></pre></td></tr></table></figure>
<h2 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h2><p><code>Compose</code>模板文件支持动态读取主机的系统环境变量和当前目录下的<code>.env</code>文件中的变量。<br>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">​</span><br><span class="line">db:</span><br><span class="line">  image: &quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>如果执行<code>MONGO_VERSION=3.2 docker-compose up</code>则会启动一个 mongo:3.2 镜像的容器；如果执行<code>MONGO_VERSION=2.8 docker-compose up</code>则会启动一个<code>mongo:2.8</code>镜像的容器。<br>若当前目录存在<code>.env</code>文件，执行 docker-compose 命令时将从该文件中读取变量。<br>在当前目录新建<code>.env</code>文件并写入以下内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure>
<p>执行<code>docker-compose up</code>则会启动一个<code>mongo:3.6</code>镜像的容器。</p>
<p>自定义配置文件redis.conf<br>下载redis获取对应版本的redis.conf，地址<a target="_blank" rel="noopener" href="https://redis.io/download%EF%BC%88%E6%B3%A8%E6%84%8F%EF%BC%9A%E8%BF%99%E9%87%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8E%E5%90%8E%E7%BB%ADdocker-compose.yml%E4%B8%AD%E7%89%88%E6%9C%AC%E9%9C%80%E4%B8%80%E8%87%B4%EF%BC%89">https://redis.io/download（注意：这里下载的版本与后续docker-compose.yml中版本需一致）</a><br>必须修改redis.conf的配置：<br>bind 127.0.0.1   改为：#bind 127.0.0.1 </p>
<p>protected-mode yes 改为：protected-mode no</p>
<p>#requirepass password 改为：requirepass 自定义密码</p>
<p> hostname: redis</p>
<h1 id="关于网络-如果用到mysql或者redis，并且希望在同一个网络，那么就可以直接使用同一个网络名"><a href="#关于网络-如果用到mysql或者redis，并且希望在同一个网络，那么就可以直接使用同一个网络名" class="headerlink" title="关于网络,如果用到mysql或者redis，并且希望在同一个网络，那么就可以直接使用同一个网络名"></a>关于网络,如果用到mysql或者redis，并且希望在同一个网络，那么就可以直接使用同一个网络名</h1><h1 id="docker-network-create-project-demo-bridge"><a href="#docker-network-create-project-demo-bridge" class="headerlink" title="docker network create project-demo_bridge"></a>docker network create project-demo_bridge</h1><p>networks:<br>  project-demo_bridge:<br>    driver: bridge</p>
<p>services:<br>   project-demo:<br>     container_name: project-demo<br>     image: project-demo:1.0<br>     restart: always<br>     volumes:<br>       # 同步时间<br>       - &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime:ro<br>       # 如果项目有些日志或者写文件，需要同步到宿主机器，也需要定义相应的卷<br>       - .&#x2F;data:&#x2F;etc&#x2F;project-demo&#x2F;data<br>       - .&#x2F;log:&#x2F;etc&#x2F;project-demo&#x2F;log<br>     ports:<br>       - 8080:8080<br>     networks:<br>       - project-demo_bridge</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/css/CSS伪类和伪元素"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/21/%E5%89%8D%E7%AB%AF/css/CSS%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"
    >CSS伪类和伪元素</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/21/%E5%89%8D%E7%AB%AF/css/CSS%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/" class="article-date">
  <time datetime="2022-09-21T02:12:04.000Z" itemprop="datePublished">2022-09-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/CSS/">CSS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="和"><a href="#和" class="headerlink" title=": 和 ::"></a>: 和 ::</h1><ul>
<li><code>:</code>指的是伪类，例如<code>:visited</code>或<code>:hover</code></li>
<li><code>::</code>用于伪元素，例如<code>::first-of-type</code>或<code>::after</code></li>
</ul>
<p>伪类和伪元素不手动写入 HTML，也不会出现在 DOM（或文档树）中，而由 CSS 创建。</p>
<h1 id="什么是伪类"><a href="#什么是伪类" class="headerlink" title="什么是伪类"></a>什么是伪类</h1><p>伪类允许你根据页面上编写的 HTML 之外的信息（例如用户交互或存储在浏览器中的信息）选择 CSS 中的元素。伪类通过单个冒号(<code>:</code>)后跟伪类名称实现访问。</p>
<p>你可以使用伪类根据元素的状态设置元素的样式。我们经常会看到页面上访问过的链接显示为不同的颜色，实现方式是通过在 CSS 中定位锚标记(<code>&lt;a&gt;</code>元素)的<code>:visited</code>伪类来设置其样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c58af9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="什么是伪元素？"><a href="#什么是伪元素？" class="headerlink" title="什么是伪元素？"></a>什么是伪元素？</h1><p>伪元素选择器允许你使用 CSS 来设置 DOM 元素特定部分的样式。伪元素通过双冒号(<code>::</code>)后跟伪元素选择器来实现访问。与伪类不同，伪元素不能根据元素的状态来设置元素的样式。</p>
<p>通常，文章内容类的网站会使用“首字下沉”，表现为会有一个非常大的单个字母来标记一段文本的开头。你可以通过定位 CSS 中的<code>::first-letter</code>伪元素来实现这一点。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">300%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用<code>::first-line</code>选择器选择定位元素的第一行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">300%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CSS文件中其他常见的伪元素选择器包括：</p>
<ul>
<li><code>::before</code></li>
<li><code>::after</code></li>
<li><code>::first-of-type</code></li>
<li><code>::last-of-type</code></li>
<li><code>::placeholder</code></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-utils/vsCode插件"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/"
    >vscode插件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2022-09-06T03:36:04.000Z" itemprop="datePublished">2022-09-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="Bracket-Pair-Colorizer-2"><a href="#Bracket-Pair-Colorizer-2" class="headerlink" title="Bracket Pair Colorizer 2"></a>Bracket Pair Colorizer 2</h3><ul>
<li>插件名: Bracket Pair Colorizer 2</li>
<li>功能：给匹配的括号() 或者 对象{}.. 添加对应的颜色用于区分</li>
</ul>
<img src="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/bracket.png" class="">

<h3 id="Auto-Rename-Tag"><a href="#Auto-Rename-Tag" class="headerlink" title="Auto Rename Tag"></a>Auto Rename Tag</h3><ul>
<li>插件名: Auto Rename Tag</li>
<li>功能：自动重命名标签</li>
</ul>
<img src="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/rename.gif" class="">

<h3 id="Code-Runner"><a href="#Code-Runner" class="headerlink" title="Code Runner"></a>Code Runner</h3><ul>
<li>插件名：Code Runner</li>
<li>功能：一键执行各种语言代码（常用于测试）</li>
</ul>
<img src="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/coderunner.gif" class="">

<h3 id="Debugger-for-Chrome"><a href="#Debugger-for-Chrome" class="headerlink" title="Debugger for Chrome"></a>Debugger for Chrome</h3><ul>
<li>插件名：Debugger for Chrome</li>
<li>功能：在VSCode端，调试代码</li>
</ul>
<img src="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/debugger.png" class="">

<h3 id="Svg-Preview"><a href="#Svg-Preview" class="headerlink" title="Svg Preview"></a>Svg Preview</h3><ul>
<li>插件名：Svg Preview</li>
<li>功能：可以显示你的SVG图片，还可以编辑</li>
</ul>
<img src="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/svgpreview.gif" class="">

<h3 id="Template-String-Converter"><a href="#Template-String-Converter" class="headerlink" title="Template String Converter"></a>Template String Converter</h3><ul>
<li>插件名：Template String Converter</li>
<li>功能：在字符串中输入$触发，将字符串转换为模板字符串</li>
</ul>
<img src="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/converter.gif" class="">

<h3 id="Project-Manager"><a href="#Project-Manager" class="headerlink" title="Project Manager"></a>Project Manager</h3><ul>
<li>插件名：Project Manager</li>
<li>功能：项目管理插件，当开发多个项目时，可以快速跳转</li>
</ul>
<h3 id="Vue-3-Snippets"><a href="#Vue-3-Snippets" class="headerlink" title="Vue 3 Snippets"></a>Vue 3 Snippets</h3><p>插件名：Vue 3 Snippets<br>功能：很多Vue的代码段，很方便开发</p>
<h3 id="Dracula-Official"><a href="#Dracula-Official" class="headerlink" title="Dracula Official"></a>Dracula Official</h3><p>插件名：vscode-styled-components<br>功能：主题</p>
<h3 id="vscode-icons"><a href="#vscode-icons" class="headerlink" title="vscode-icons"></a>vscode-icons</h3><p>插件名：vscode-icons<br>VSCode文件夹&amp;文件图标</p>
<h3 id="画板作图"><a href="#画板作图" class="headerlink" title="画板作图"></a>画板作图</h3><p>插件名：Draw.io Integration<br>功能：在VSCode中画图，支持多人协作编辑图表</p>
<img src="/2022/09/06/utils/vsCode%E6%8F%92%E4%BB%B6/draw.gif" class="">

<h3 id="Echarts-智能提示插件"><a href="#Echarts-智能提示插件" class="headerlink" title="Echarts 智能提示插件"></a>Echarts 智能提示插件</h3><p>插件名：echarts-vscode-extension<br>使用：安装插件后，ctrl+shift+p输入active Echars即可开启智能提示<br>功能：提示各种Echart中Option 的属性</p>
<h3 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h3><p>在工作环境中的任何 HTML 文件或项目上运行服务器。</p>
<h3 id="Turbo-Console-Log"><a href="#Turbo-Console-Log" class="headerlink" title="Turbo Console Log"></a>Turbo Console Log</h3><p>无需手动添加日志语句即可调试您的代码。Turbo Console Log 扩展让您只需单击一下即可将控制台日志语句添加到您的代码中。</p>
<h3 id="CSS-Peek"><a href="#CSS-Peek" class="headerlink" title="CSS Peek"></a>CSS Peek</h3><p>使用 CSS Peek VS Code 扩展，您只需将鼠标悬停在 HTML 元素上即可显示一个显示应用于该元素的 CSS 样式的查看窗口。然后，您可以通过单击查看窗口跳转到 CSS 代码，从而轻松编辑样式。此功能使您免于每次都手动搜索 CSS 代码的麻烦。</p>
<h3 id="Tabnine-AI"><a href="#Tabnine-AI" class="headerlink" title="Tabnine AI"></a>Tabnine AI</h3><p>Tabnine VS Code 扩展是关于生产力的。它是一个人工智能代码助手，可以加速您的开发过程，实时自动完成您的代码。它支持所有流行的编码语言和 IDE。</p>
<p>Tabnine 具有类似于 IntelliSense 的 AI 辅助代码完成功能。此扩展可以根据上下文和语法预测和建议您的下一行代码，从而帮助您更快地编写代码。</p>
<h3 id="Color-Highlight"><a href="#Color-Highlight" class="headerlink" title="Color Highlight"></a>Color Highlight</h3><p>简单而强大的扩展，可以实时为所有文件以实际颜色边框或背景突出显示颜色。</p>
<h3 id="CodeSnap"><a href="#CodeSnap" class="headerlink" title="CodeSnap"></a>CodeSnap</h3><p>按下Ctrl + Shift + P，搜索CodeSnap，选择您想要捕捉的代码，然后您的快照就可以分享了！</p>
<h3 id="SVG-Preview"><a href="#SVG-Preview" class="headerlink" title="SVG Preview"></a>SVG Preview</h3><p>此扩展为VS Code添加了对SVG的实时预览和实时编辑的支持。</p>
<h3 id="TypeScript-Error-Translator"><a href="#TypeScript-Error-Translator" class="headerlink" title="TypeScript Error Translator"></a>TypeScript Error Translator</h3><p>TypeScript的错误有时可能会令人困惑和沮丧，但是这个扩展将错误转化为可直接从IDE阅读的人类可读形式。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-vue/v3组合式API基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/23/vue/v3%E7%BB%84%E5%90%88%E5%BC%8FAPI%E5%9F%BA%E7%A1%80/"
    >v3组合式API基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/23/vue/v3%E7%BB%84%E5%90%88%E5%BC%8FAPI%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-07-23T09:52:35.000Z" itemprop="datePublished">2022-07-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="创建一个-Vue-应用"><a href="#创建一个-Vue-应用" class="headerlink" title="创建一个 Vue 应用"></a>创建一个 Vue 应用</h1><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>每个 Vue 应用都是通过<code>createApp</code>函数创建的一个新的应用实例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="comment">/* 根组件选项 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h2><p>我们传入<code>createApp</code>的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p>
<p>如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 从一个单文件组件中导入根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br></pre></td></tr></table></figure>
<h2 id="挂载应用"><a href="#挂载应用" class="headerlink" title="挂载应用"></a>挂载应用</h2><p>应用实例必须在调用了<code>.mount()</code>方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。</p>
<p><code>.mount()</code>方法应该始终在整个应用配置和资源注册完成后被调用。同时应注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</p>
<h2 id="多个应用实例"><a href="#多个应用实例" class="headerlink" title="多个应用实例"></a>多个应用实例</h2><p>你不必再受限于一个页面只能拥有一个应用实例。<code>createApp</code> API 允许多个 Vue 应用共存于同一个页面上，而且每个应用都拥有自己的用于配置和全局资源的作用域。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app1 = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line">app1.<span class="title function_">mount</span>(<span class="string">&#x27;#container-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app2 = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br><span class="line">app2.<span class="title function_">mount</span>(<span class="string">&#x27;#container-2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h1><h2 id="声明响应式状态"><a href="#声明响应式状态" class="headerlink" title="声明响应式状态"></a>声明响应式状态</h2><p>我们可以使用<code>reactive()</code>函数创建一个响应式对象或数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;</span><br><span class="line">    &#123; &#123; state.count &#125; &#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  state.count++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>响应式对象其实是 JavaScript <code>Proxy</code>，其行为表现与一般对象相似。不同之处在于 Vue 能够跟踪对响应式对象<code>property</code>的访问与更改操作。</p>
<h4 id="DOM-更新时机"><a href="#DOM-更新时机" class="headerlink" title="DOM 更新时机"></a>DOM 更新时机</h4><p>当你更改响应式状态后，DOM 也会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次声明更改，每个组件都只需要更新一次。</p>
<p>若要等待一个状态改变后的 DOM 更新完成，可以使用<code>nextTick()</code>这个全局 API：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  state.<span class="property">count</span>++</span><br><span class="line">  <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 访问更新后的 DOM</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深层响应性"><a href="#深层响应性" class="headerlink" title="深层响应性"></a>深层响应性</h4><p>在 Vue 中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，你的改动也能被检测到。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">nested</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mutateDeeply</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 以下都会按照期望工作</span></span><br><span class="line">  obj.<span class="property">nested</span>.<span class="property">count</span>++</span><br><span class="line">  obj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="响应式代理-vs-原始对象"><a href="#响应式代理-vs-原始对象" class="headerlink" title="响应式代理 vs 原始对象"></a>响应式代理 vs 原始对象</h4><p><code>reactive()</code>返回的是一个原始对象的<code>Proxy</code>，它和原始对象是不相等的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(raw)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理和原始对象不是全等的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy === raw) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>只有代理是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是 仅使用你声明对象的代理版本。</p>
<p>为保证访问代理的一致性，对同一个对象调用<code>reactive()</code>会总是返回同样的代理，而对一个已存在代理调用<code>reactive()</code>也是返回同样的代理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在同一个对象上调用 reactive() 会返回相同的代理</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(raw) === proxy) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个代理上调用 reactive() 会返回它自己</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(proxy) === proxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个规则对嵌套对象也适用。依靠深层响应性，响应式对象内的嵌套对象依然是代理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line">proxy.<span class="property">nested</span> = raw</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">nested</span> === raw) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="reactive-的局限性"><a href="#reactive-的局限性" class="headerlink" title="reactive() 的局限性"></a>reactive() 的局限性</h4><p><code>reactive()</code> API 有两条限制：</p>
<ul>
<li>仅对对象类型有效（对象、数组和<code>Map、Set</code>这样的集合类型），而对<code>string、number</code>和<code>boolean</code>这样的原始类型无效。</li>
<li>因为 Vue 的响应式系统是通过<code>property</code>访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的引用 (&#123; count: 0 &#125;) 将不再被追踪（响应性连接已丢失！）</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>同时这也意味着当我们将响应式对象的 property 赋值或解构至本地变量时，或是将该 property 传入一个函数时，我们会失去响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// n 是一个局部变量，同 state.count</span></span><br><span class="line"><span class="comment">// 失去响应性连接</span></span><br><span class="line"><span class="keyword">let</span> n = state.<span class="property">count</span></span><br><span class="line"><span class="comment">// 不影响原始的 state</span></span><br><span class="line">n++</span><br><span class="line"></span><br><span class="line"><span class="comment">// count 也和 state.count 失去了响应性连接</span></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = state</span><br><span class="line"><span class="comment">// 不会影响原始的 state</span></span><br><span class="line">count++</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数接收一个普通数字，并且</span></span><br><span class="line"><span class="comment">// 将无法跟踪 state.count 的变化</span></span><br><span class="line"><span class="title function_">callSomeFunction</span>(state.<span class="property">count</span>)</span><br></pre></td></tr></table></figure>
<h2 id="ref-定义响应式变量"><a href="#ref-定义响应式变量" class="headerlink" title="ref() 定义响应式变量"></a>ref() 定义响应式变量</h2><p>为了解决<code>reactive()</code>带来的限制，Vue 也提供了一个<code>ref()</code>方法来允许我们创建可以使用任何值类型的响应式<code>ref</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>ref()</code>从参数中获取到值，将其包装为一个带<code>.value property</code>的<code>ref</code>对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>和响应式对象的<code>property</code>类似，<code>ref</code>的<code>.value property</code>也是响应式的。同时，当值为对象类型时，会用<code>reactive()</code>自动转换它的<code>.value</code>。</p>
<p>一个包含对象类型值的<code>ref</code>可以响应式地替换整个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectRef = <span class="title function_">ref</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是响应式的替换</span></span><br><span class="line">objectRef.<span class="property">value</span> = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>ref</code>被传递给函数或是从一般对象上被解构时，不会丢失响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="title function_">ref</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="attr">bar</span>: <span class="title function_">ref</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数接收一个 ref</span></span><br><span class="line"><span class="comment">// 需要通过 .value 取值</span></span><br><span class="line"><span class="comment">// 但它会保持响应性</span></span><br><span class="line"><span class="title function_">callSomeFunction</span>(obj.<span class="property">foo</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍然是响应式的</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo, bar &#125; = obj</span><br></pre></td></tr></table></figure>
<h4 id="ref-在模板中的解包"><a href="#ref-在模板中的解包" class="headerlink" title="ref 在模板中的解包"></a>ref 在模板中的解包</h4><p>当<code>ref</code>在模板中作为顶层<code>property</code>被访问时，它们会被自动“解包”，所以不需要使用<code>.value</code>。下面是之前的计数器例子，用<code>ref()</code>代替：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  count.<span class="property">value</span>++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123; &#123; count &#125; &#125; <span class="comment">&lt;!-- 无需 .value --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>请注意，仅当<code>ref</code>是模板渲染上下文的顶层<code>property</code>时才适用自动“解包”。 例如，<code>foo</code>是顶层<code>property</code>，但<code>object.foo</code>不是。</p>
<p>所以我们给出以下<code>object</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const object = &#123; foo: ref(1) &#125;</span><br></pre></td></tr></table></figure>
<p>下面的表达式将不会像预期的那样工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; object.<span class="property">foo</span> + <span class="number">1</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>渲染的结果会是一个<code>[object Object]</code>，因为<code>object.foo</code>是一个<code>ref</code>对象。我们可以通过让<code>foo</code>成为顶级<code>property</code>来解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; foo &#125; = object</span><br><span class="line">&#123; &#123; foo + <span class="number">1</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>现在渲染结果将是 2。</p>
<p>需要注意的是，如果一个<code>ref</code>是文本插值（即一个<code>&#123; &#123; &#125; &#125;</code>符号）计算的最终值，它也将被解包。因此下面的渲染结果将为 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; object.foo &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>这只是文本插值的一个方便功能，相当于<code>&#123; &#123; object.foo.value &#125; &#125;</code>。</p>
<h4 id="ref-在响应式对象中的解包"><a href="#ref-在响应式对象中的解包" class="headerlink" title="ref 在响应式对象中的解包"></a>ref 在响应式对象中的解包</h4><p>当一个<code>ref</code>作为一个响应式对象的<code>property</code>被访问或更改时，它会自动解包，因此会表现得和一般的<code>property</code>一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  count</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>如果将一个新的<code>ref</code>赋值给一个关联了已有<code>ref</code>的<code>property</code>，那么它会替换掉旧的<code>ref</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const otherCount = ref(2)</span><br><span class="line"></span><br><span class="line">state.count = otherCount</span><br><span class="line">console.log(state.count) // 2</span><br><span class="line">// 原始 ref 现在已经和 state.count 失去联系</span><br><span class="line">console.log(count.value) // 1</span><br></pre></td></tr></table></figure>
<h4 id="数组和集合类型的-ref-解包"><a href="#数组和集合类型的-ref-解包" class="headerlink" title="数组和集合类型的 ref 解包"></a>数组和集合类型的 ref 解包</h4><p>不像响应式对象，当<code>ref</code>作为响应式数组或像<code>Map</code>这种原生集合类型的元素被访问时，不会进行解包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const books = reactive([ref(&#x27;Vue 3 Guide&#x27;)])</span><br><span class="line">// 这里需要 .value</span><br><span class="line">console.log(books[0].value)</span><br><span class="line"></span><br><span class="line">const map = reactive(new Map([[&#x27;count&#x27;, ref(0)]]))</span><br><span class="line">// 这里需要 .value</span><br><span class="line">console.log(map.get(&#x27;count&#x27;).value)</span><br></pre></td></tr></table></figure>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const author = reactive(&#123;</span><br><span class="line">  name: &#x27;John Doe&#x27;,</span><br><span class="line">  books: [</span><br><span class="line">    &#x27;Vue 2 - Advanced Guide&#x27;,</span><br><span class="line">    &#x27;Vue 3 - Basic Guide&#x27;,</span><br><span class="line">    &#x27;Vue 4 - The Mystery&#x27;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们想根据<code>author</code>是否已有一些书籍来展示不同的信息：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Has published books:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123; &#123;author.books.length&gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;&#125; &#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于<code>author.books</code>。更重要的是，如果在模板中需要不止一次这样的计算，我们可能不想写重复的代码。</p>
<p>推荐使用计算属性来描述依赖响应式状态的复杂逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const author = reactive(&#123;</span><br><span class="line">  name: &#x27;John Doe&#x27;,</span><br><span class="line">  books: [</span><br><span class="line">    &#x27;Vue 2 - Advanced Guide&#x27;,</span><br><span class="line">    &#x27;Vue 3 - Basic Guide&#x27;,</span><br><span class="line">    &#x27;Vue 4 - The Mystery&#x27;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 一个计算属性 ref</span><br><span class="line">const publishedBooksMessage = computed(() =&gt; &#123;</span><br><span class="line">  return author.books.length &gt; 0 ? &#x27;Yes&#x27; : &#x27;No&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;Has published books:&lt;/p&gt;</span><br><span class="line">  &lt;span&gt;&#123; &#123; publishedBooksMessage &#125; &#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>我们在这里定义了一个计算属性<code>publishedBooksMessage</code>。<code>computed()</code>方法期望接收一个<code>getter</code>函数，返回值为一个计算属性<code>ref</code>。和其他一般的<code>ref</code>类似，可以通过<code>publishedBooksMessage.value</code>访问计算结果。计算属性<code>ref</code>也会在模板中自动解包，因此在模板表达式中引用时无需添加<code>.value</code>。</p>
<p>Vue 的计算属性会自动追踪响应式依赖。它会检测到<code>publishedBooksMessage</code>依赖于<code>author.books</code>，所以当<code>author.books</code>改变时，任何依赖于<code>publishedBooksMessage</code>的绑定都会同时更新。</p>
<h1 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h1><h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>计算属性允许我们声明性地计算推导值。然而，在有些情况下，为了应对一些状态的变化，我们需要运行些“副作用”：例如更改 DOM，或者根据异步操作的结果，去修改另一处的状态。</p>
<p>在组合式 API 中，我们可以使用<code>watch</code>函数在每次响应式状态发生变化时触发回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const question = ref(&#x27;&#x27;)</span><br><span class="line">const answer = ref(&#x27;Questions usually contain a question mark. ;-)&#x27;)</span><br><span class="line"></span><br><span class="line">// 可以直接侦听一个 ref</span><br><span class="line">watch(question, async (newQuestion, oldQuestion) =&gt; &#123;</span><br><span class="line">  if (newQuestion.indexOf(&#x27;?&#x27;) &gt; -1) &#123;</span><br><span class="line">    answer.value = &#x27;Thinking...&#x27;</span><br><span class="line">    try &#123;</span><br><span class="line">      const res = await fetch(&#x27;https://yesno.wtf/api&#x27;)</span><br><span class="line">      answer.value = (await res.json()).answer</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      answer.value = &#x27;Error! Could not reach the API. &#x27; + error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=&quot;question&quot; /&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123; &#123; answer &#125; &#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h2 id="侦听来源类型"><a href="#侦听来源类型" class="headerlink" title="侦听来源类型"></a>侦听来源类型</h2><p><code>watch</code>的第一个参数可以是不同形式的“来源”：它可以是一个<code>ref</code>(包括计算属性)、一个响应式对象、一个<code>getter</code>函数、或多个来源组成的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const x = ref(0)</span><br><span class="line">const y = ref(0)</span><br><span class="line"></span><br><span class="line">// 单个 ref</span><br><span class="line">watch(x, (newX) =&gt; &#123;</span><br><span class="line">  console.log(`x is $&#123;newX&#125;`)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// getter 函数</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; x.value + y.value,</span><br><span class="line">  (sum) =&gt; &#123;</span><br><span class="line">    console.log(`sum of x + y is: $&#123;sum&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 多个来源组成的数组</span><br><span class="line">watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;</span><br><span class="line">  console.log(`x is $&#123;newX&#125; and y is $&#123;newY&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意，你不能侦听响应式对象的<code>property</code>，例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const obj = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">// 这不起作用，因为你向 watch() 传入了一个 number</span><br><span class="line">watch(obj.count, (count) =&gt; &#123;</span><br><span class="line">  console.log(`count is: $&#123;count&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而是用<code>getter</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 提供一个 getter 函数</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; obj.count,</span><br><span class="line">  (count) =&gt; &#123;</span><br><span class="line">    console.log(`count is: $&#123;count&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h2><p>直接给<code>watch()</code>传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">watch(obj, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">  // 在嵌套的 property 变更时触发</span><br><span class="line">  // 注意：`newValue` 此处和 `oldValue` 是相等的</span><br><span class="line">  // 因为它们是同一个对象！</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.count++</span><br></pre></td></tr></table></figure>
<p>这不同于返回响应式对象的<code>getter</code>函数：只有在<code>getter</code>函数返回不同的对象时，才会触发回调：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; state.someObject,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    // 仅当 state.someObject 被替换时触发</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然而，在上面的例子里，你可以显式地加上<code>deep</code>选项，强制转成深层侦听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; state.someObject,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    // 注意：`newValue` 此处和 `oldValue` 是相等的</span><br><span class="line">    // *除非* state.someObject 被整个替换了</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; deep: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a>watchEffect()</h2><p><code>watch()</code>是懒执行的：仅在侦听源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举个例子，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const url = ref(&#x27;https://...&#x27;)</span><br><span class="line">const data = ref(null)</span><br><span class="line"></span><br><span class="line">async function fetchData() &#123;</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 立即获取</span><br><span class="line">fetchData()</span><br><span class="line">// ...再侦听 url 变化</span><br><span class="line">watch(url, fetchData)</span><br></pre></td></tr></table></figure>
<p>这段代码还可以用<code>watchEffect</code>函数来简化。<code>watchEffect()</code>会立即执行一遍回调函数，如果这时函数产生了副作用，Vue 会自动追踪副作用的依赖关系，自动分析出响应源。上面的例子可以重写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(async () =&gt; &#123;</span><br><span class="line">  const response = await fetch(url.value)</span><br><span class="line">  data.value = await response.json()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个例子中，回调会立即执行。在执行期间，它会自动追踪<code>url.value</code>作为依赖（近似于计算属性）。每当<code>url.value</code>变化时，回调会再次执行。</p>
<h2 id="watch-vs-watchEffect"><a href="#watch-vs-watchEffect" class="headerlink" title="watch vs watchEffect"></a>watch vs watchEffect</h2><p><code>watch</code>和<code>watchEffect</code>都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p>
<ul>
<li><code>watch</code>只追踪明确侦听的源。它不会追踪任何在回调中访问到的东西。另外，仅在响应源确实改变时才会触发回调。<code>watch</code>会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li>
<li><code>watchEffect</code>，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式<code>property</code>。这更方便，而且代码往往更简洁，但其响应性依赖关系不那么明确。</li>
</ul>
<h2 id="回调的刷新时机"><a href="#回调的刷新时机" class="headerlink" title="回调的刷新时机"></a>回调的刷新时机</h2><p>当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。</p>
<p>默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。</p>
<p>如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明<code>flush: &#39;post&#39;</code>选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, &#123;</span><br><span class="line">  flush: &#x27;post&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchEffect(callback, &#123;</span><br><span class="line">  flush: &#x27;post&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>后置刷新的<code>watchEffect()</code>有个更方便的别名<code>watchPostEffect()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; watchPostEffect &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">watchPostEffect(() =&gt; &#123;</span><br><span class="line">  /* 在 Vue 更新后执行 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="停止侦听器"><a href="#停止侦听器" class="headerlink" title="停止侦听器"></a>停止侦听器</h2><p>在<code>&lt;script setup&gt;</code>中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。</p>
<p>一个关键点是，侦听器必须用同步语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; watchEffect &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 它会自动停止</span><br><span class="line">watchEffect(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// ...这个则不会！</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  watchEffect(() =&gt; &#123;&#125;)</span><br><span class="line">&#125;, 100)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>要手动停止一个侦听器，请调用<code>watch</code>或<code>watchEffect</code>返回的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const unwatch = watchEffect(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// ...当该侦听器不再需要时</span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure>
<p>注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 需要异步请求得到的数据</span><br><span class="line">const data = ref(null)</span><br><span class="line"></span><br><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">  if (data.value) &#123;</span><br><span class="line">    // 数据加载后执行某些操作...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="模板-ref"><a href="#模板-ref" class="headerlink" title="模板 ref"></a>模板 ref</h1><p>虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的<code>ref attribute</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&quot;input&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><code>ref</code>是一个特殊的<code>attribute</code>，和<code>v-for</code>中的<code>key</code>类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时编程式地聚焦到一个<code>input</code>元素上，或在一个元素上初始化一个第三方库。</p>
<h2 id="访问模板-ref"><a href="#访问模板-ref" class="headerlink" title="访问模板 ref"></a>访问模板 ref</h2><p>为了通过组合式 API 获得该模板<code>ref</code>，我们需要声明一个同名的<code>ref</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 声明一个 ref 来存放该元素的引用</span><br><span class="line">// 必须和模板 ref 同名</span><br><span class="line">const input = ref(null)</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  input.value.focus()</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input ref=&quot;input&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>如果你正试图观察一个模板<code>ref</code>的变化，确保考虑到<code>ref</code>的值为<code>null</code>的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">  if (input.value) &#123;</span><br><span class="line">    input.value.focus()</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="v-for-中的-ref"><a href="#v-for-中的-ref" class="headerlink" title="v-for 中的 ref"></a>v-for 中的 ref</h2><p>当<code>ref</code>在<code>v-for</code>中使用时，相应的<code>ref</code>中包含的值是一个数组，它将在元素被挂载后填充：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const list = ref([</span><br><span class="line">  /* ... */</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">const itemRefs = ref([])</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; console.log(itemRefs.value))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt;</span><br><span class="line">      &#123; &#123; item &#125; &#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>应该注意的是，<code>ref</code>数组不能保证与源数组相同的顺序。</p>
<h2 id="函数型-ref"><a href="#函数型-ref" class="headerlink" title="函数型 ref"></a>函数型 ref</h2><p>除了使用字符串值作名字，<code>ref attribute</code>还可以绑定为一个函数，会在每次组件更新时都被调用。函数接受该元素引用作为第一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :ref=&quot;(el) =&gt; &#123; /* 将 el 分配给 property 或 ref */ &#125;&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>如果你正在使用一个动态的<code>:ref</code>绑定，我们也可以传一个函数。当元素卸载时，这个<code>el</code>参数会是<code>null</code>。你当然也可以使用一个方法而不是内联函数。</p>
<h2 id="组件上的-ref"><a href="#组件上的-ref" class="headerlink" title="组件上的 ref"></a>组件上的 ref</h2><p><code>ref</code>也可以被用在一个子组件上。此时<code>ref</code>中引用的是组件实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line"></span><br><span class="line">const child = ref(null)</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  // child.value 是 &lt;Child /&gt; 组件的实例</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child ref=&quot;child&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>如果一个子组件使用的是选项式 API 或没有使用<code>&lt;script setup&gt;</code>，被引用的组件实例和该子组件的<code>this</code>完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的<code>props</code>和<code>emit</code>接口来实现父子组件交互。</p>
<p>有一个例外的情况，使用了<code>&lt;script setup&gt;</code>的组件是默认私有的：一个父组件无法访问到一个使用了<code>&lt;script setup&gt;</code>的子组件中的任何东西，除非子组件在其中通过<code>defineExpose</code>宏显式暴露：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const a = 1</span><br><span class="line">const b = ref(2)</span><br><span class="line"></span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当父组件通过模板<code>ref</code>获取到了该组件的实例时，得到的实例类型为<code>&#123; a: number, b: number &#125;</code> (<code>ref</code>都会自动解包，和一般的实例一样)。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-vue/v3新语法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/20/vue/v3%E6%96%B0%E8%AF%AD%E6%B3%95/"
    >vue3新语法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/20/vue/v3%E6%96%B0%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2022-07-20T08:12:35.000Z" itemprop="datePublished">2022-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h1><p>在<code>script</code>标签中添加<code>setup</code>，组件只需引入不用注册，属性和方法也不用返回，也不用写<code>setup</code>函数，也不用写<code>export default</code>，甚至是自定义指令也可以在我们的<code>template</code>中自动获得。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    显示的值&#123;&#123;flag &#125;&#125;</span><br><span class="line">    &lt;button @click=&quot;changeHander&quot;&gt;改变值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;!-- 只需要在script上添加setup --&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">    &lt;!-- flag变量不需要在 return出去了 --&gt;</span><br><span class="line">    let flag=ref(&quot;开端-第一次循环&quot;)</span><br><span class="line"></span><br><span class="line">    &lt;!-- 函数也可以直接引用,不用在return中返回 --&gt;</span><br><span class="line">    let changeHander=():void=&gt;&#123;</span><br><span class="line">        flag.value=&#x27;开端-第二次循环&#x27;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="组件不需要在注册"><a href="#组件不需要在注册" class="headerlink" title="组件不需要在注册"></a>组件不需要在注册</h1><p>在<code>script setup</code>中，引入的组件可以直接使用无需再通过<code>components</code>进行注册，并且无法指定当前组件的名字，它会自动以文件名为主，也就是不用再写<code>name</code>属性了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这个是组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt; 你好-我是肖鹤云&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用的页面</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;test-com&gt;&lt;/test-com&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">// 组件命名采用的是大驼峰，引入后不需要在注册，是不是爽歪歪呀!</span><br><span class="line">//在使用的使用直接是小写和横杠的方式连接 test-com</span><br><span class="line">import TestCom from &quot;../components/TestCom.vue&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="defineProps"><a href="#defineProps" class="headerlink" title="defineProps"></a>defineProps</h1><p>子组件接受父组件传递过来的值，代替<code>props</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父组件传递参数</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;test-com :info=&quot;msg&quot; time=&quot;42分钟&quot;&gt;&lt;/test-com&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">// 组件命名采用的是大驼峰，引入后不需要在注册，是不是爽歪歪呀!</span><br><span class="line">import TestCom from &quot;../components/TestCom.vue&quot;</span><br><span class="line">let msg=&#x27;公交车-第一次循环&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">子组件接受参数</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt; 你好-我是肖鹤云&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;信息:&#123;&#123; info&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; time &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123;defineProps&#125; from &#x27;vue&#x27;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">    info:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#x27;----&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    time:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#x27;0分钟&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="defineEmits"><a href="#defineEmits" class="headerlink" title="defineEmits"></a>defineEmits</h1><p>子组件向父组件抛出事件，代替<code>$emit</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt; 你好-我是肖鹤云&lt;/h2&gt;</span><br><span class="line">        &lt;button @click=&quot;hander1Click&quot;&gt;新增&lt;/button&gt;</span><br><span class="line">        &lt;button @click=&quot;hander2Click&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line"> import &#123;defineEmits&#125; from &#x27;vue&#x27;</span><br><span class="line">//  使用defineEmits创建名称，接受一个数组</span><br><span class="line">let $myemit=defineEmits([&#x27;myAdd&#x27;,&#x27;myDel&#x27;])</span><br><span class="line">let hander1Click=():void=&gt;&#123;</span><br><span class="line">    $myemit(&#x27;myAdd&#x27;,&#x27;新增的数据&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let hander2Click=():void=&gt;&#123;</span><br><span class="line">    $myemit(&#x27;myDel&#x27;,&#x27;删除的数据&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;test-com @myAdd=&quot;myAddHander&quot; @myDel=&#x27;myDelHander&#x27;&gt;&lt;/test-com&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">// 组件命名采用的是大驼峰，引入后不需要在注册，是不是爽歪歪呀!</span><br><span class="line">//在使用的使用直接是小写和横杠的方式连接 test-com</span><br><span class="line">import TestCom from &quot;../components/TestCom.vue&quot;</span><br><span class="line">let myAddHander=(mess):void=&gt;&#123;</span><br><span class="line">  console.log(&#x27;新增==&gt;&#x27;,mess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myDelHander=(mess):void=&gt;&#123;</span><br><span class="line">  console.log(&#x27;删除==&gt;&#x27;, mess);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="获取子组件中的属性值"><a href="#获取子组件中的属性值" class="headerlink" title="获取子组件中的属性值"></a>获取子组件中的属性值</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h2&gt; 你好-我是肖鹤云&lt;/h2&gt;</span><br><span class="line">        &lt;p&gt;性别:&#123;&#123; sex&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;其他信息:&#123;&#123; info&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; reactive, ref,defineExpose &#125; from &quot;vue&quot;;</span><br><span class="line">let sex=ref(&#x27;男&#x27;)</span><br><span class="line">let info=reactive(&#123;</span><br><span class="line">    like:&#x27;喜欢李诗晴&#x27;,</span><br><span class="line">    age:27</span><br><span class="line">&#125;)</span><br><span class="line">// 将组件中的属性暴露出去，这样父组件可以获取</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">    sex,</span><br><span class="line">    info</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;test-com @myAdd=&quot;myAddHander&quot; @myDel=&#x27;myDelHander&#x27; ref=&quot;testcomRef&quot;&gt;&lt;/test-com&gt;</span><br><span class="line">    &lt;button @click=&quot;getSonHander&quot;&gt;获取子组件中的数据&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import TestCom from &quot;../components/TestCom.vue&quot;</span><br><span class="line">import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">const testcomRef = ref()</span><br><span class="line">const getSonHander=()=&gt;&#123;</span><br><span class="line">  console.log(&#x27;获取子组件中的性别&#x27;, testcomRef.value.sex );</span><br><span class="line">  console.log(&#x27;获取子组件中的其他信息&#x27;, testcomRef.value.info );</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="style-v-bind"><a href="#style-v-bind" class="headerlink" title="style v-bind"></a>style v-bind</h1><p>我们可以在<code>style</code>中去使用变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt; 有开始循环了-开端 &lt;/span&gt;  </span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line">  const state = reactive(&#123;</span><br><span class="line">    color: &#x27;red&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  span &#123;</span><br><span class="line">    /* 使用v-bind绑定state中的变量 */</span><br><span class="line">    color: v-bind(&#x27;state.color&#x27;);</span><br><span class="line">  &#125;  </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h1 id="生命周期的变化"><a href="#生命周期的变化" class="headerlink" title="生命周期的变化"></a>生命周期的变化</h1><p>整体来看，变化不大，只是名字大部分需要<code>+on</code>，功能上类似。使用上 Vue3 组合式 API 需要先引入；Vue2 选项 API 则可直接调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// vue3</span><br><span class="line">&lt;script setup&gt;     </span><br><span class="line">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line">// 可将不同的逻辑拆开成多个onMounted，依然按顺序执行，不被覆盖</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// vue2</span><br><span class="line">&lt;script&gt;     </span><br><span class="line">   export default &#123;         </span><br><span class="line">      mounted() &#123;             </span><br><span class="line">        ...         </span><br><span class="line">      &#125;,           </span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">Vue2.x</th>
<th align="center">Vue3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">Not needed*</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">Not needed*</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">onBeforeMount</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">onMounted</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="center">onBeforeUpdate</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">onUpdated</td>
</tr>
<tr>
<td align="center">beforeDestroy</td>
<td align="center">onBeforeUnmount</td>
</tr>
<tr>
<td align="center">destroyed</td>
<td align="center">onUnmounted</td>
</tr>
</tbody></table>
<p><code>setup</code>是围绕<code>beforeCreate</code>和<code>created</code>生命周期钩子运行的，所以不需要显式地去定义。</p>
<h1 id="多根节点"><a href="#多根节点" class="headerlink" title="多根节点"></a>多根节点</h1><p>Vue3 支持了多根节点组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">  &lt;main&gt;...&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h1 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h1><p>Vue3 提供<code>Suspense</code>组件，允许程序在等待异步组件时渲染兜底的内容，如<code>loading</code>，使用户体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：<code>default</code>和fallback。Suspense确保加载完异步内容时显示默认插槽，并将<code>fallback</code>插槽用作加载状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tempalte&gt;</span><br><span class="line">   &lt;suspense&gt;</span><br><span class="line">     &lt;template #default&gt;</span><br><span class="line">       &lt;todo-list /&gt;</span><br><span class="line">     &lt;/template&gt;</span><br><span class="line">     &lt;template #fallback&gt;</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">         Loading...</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">     &lt;/template&gt;</span><br><span class="line">   &lt;/suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h1><p>Vue3 提供<code>Teleport</code>组件可将部分 DOM 移动到 Vue <code>app</code>之外的位置。比如项目中常见的<code>Dialog</code>组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;dialogVisible = true&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;teleport to=&quot;body&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;dialog&quot; v-if=&quot;dialogVisible&quot;&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>
<h1 id="组合式API"><a href="#组合式API" class="headerlink" title="组合式API"></a>组合式API</h1><p>Vue2 是选项式<code>API（Option API）</code>，一个逻辑会散乱在文件不同位置（<code>data、props、computed、watch</code>、生命周期函数等），导致代码的可读性变差，需要上下来回跳转文件位置。</p>
<p>Vue3 组合式API（<code>Composition API</code>）则很好地解决了这个问题，可将同一逻辑的内容写到一起。</p>
<p>除了增强了代码的可读性、内聚性，组合式API 还提供了较为完美的逻辑复用性方案，举个🌰，如下所示公用鼠标坐标案例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// main.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt;mouse position &#123;&#123;x&#125;&#125; &#123;&#123;y&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">import useMousePosition from &#x27;./useMousePosition&#x27;</span><br><span class="line"></span><br><span class="line">const &#123;x, y&#125; = useMousePosition()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// useMousePosition.js</span><br><span class="line">import &#123; ref, onMounted, onUnmounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">function useMousePosition() &#123;</span><br><span class="line">  let x = ref(0)</span><br><span class="line">  let y = ref(0)</span><br><span class="line">  </span><br><span class="line">  function update(e) &#123;</span><br><span class="line">    x.value = e.pageX</span><br><span class="line">    y.value = e.pageY</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  onMounted(() =&gt; &#123;</span><br><span class="line">    window.addEventListener(&#x27;mousemove&#x27;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  onUnmounted(() =&gt; &#123;</span><br><span class="line">    window.removeEventListener(&#x27;mousemove&#x27;, update)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  return &#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>解决了 Vue2 <code>Mixin</code>的存在的命名冲突隐患，依赖关系不明确，不同组件间配置化使用不够灵活。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/11/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>