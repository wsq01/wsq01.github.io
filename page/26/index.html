<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/axios/axios基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/16/%E5%89%8D%E7%AB%AF/axios/axios%E5%9F%BA%E7%A1%80/"
    >axios基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/16/%E5%89%8D%E7%AB%AF/axios/axios%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2020-03-16T02:25:55.000Z" itemprop="datePublished">2020-03-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/axios/">axios</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是-axios"><a href="#什么是-axios" class="headerlink" title="什么是 axios"></a>什么是 axios</h1><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>从浏览器中创建 XMLHttpRequests<br>从 node.js 创建 http 请求<br>支持 Promise API<br>拦截请求和响应<br>转换请求数据和响应数据<br>取消请求<br>自动转换 JSON 数据<br>客户端支持防御 XSRF</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>可以通过向 axios 传递相关配置来创建请求</p>
<h2 id="axios-config"><a href="#axios-config" class="headerlink" title="axios(config)"></a>axios(config)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取远端图片</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">  <span class="attr">responseType</span>:<span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  response.<span class="property">data</span>.<span class="title function_">pipe</span>(fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[, config])"></a>axios(url[, config])</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 GET 请求（默认的方法）</span></span><br><span class="line"><span class="title function_">axios</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h2><p>为方便起见，为所有支持的请求方法提供了别名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">request</span>(config)</span><br><span class="line">axios.<span class="title function_">get</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">delete</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">head</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">options</span>(url[, config])</span><br><span class="line">axios.<span class="title function_">post</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">put</span>(url[, data[, config]])</span><br><span class="line">axios.<span class="title function_">patch</span>(url[, data[, config]])</span><br></pre></td></tr></table></figure>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>处理并发请求的助手函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">all</span>(iterable)</span><br><span class="line">axios.<span class="title function_">spread</span>(callback)</span><br></pre></td></tr></table></figure>
<h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>可以使用自定义配置新建一个 axios 实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">create</span>([config])</span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>以下是可用的实例方法。指定的配置将与实例的配置合并。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios#<span class="title function_">request</span>(config)</span><br><span class="line">axios#<span class="title function_">get</span>(url[, config])</span><br><span class="line">axios#<span class="title function_">delete</span>(url[, config])</span><br><span class="line">axios#<span class="title function_">head</span>(url[, config])</span><br><span class="line">axios#<span class="title function_">options</span>(url[, config])</span><br><span class="line">axios#<span class="title function_">post</span>(url[, data[, config]])</span><br><span class="line">axios#<span class="title function_">put</span>(url[, data[, config]])</span><br><span class="line">axios#<span class="title function_">patch</span>(url[, data[, config]])</span><br></pre></td></tr></table></figure>
<h2 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h2><p>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">  <span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  <span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params` 是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  <span class="attr">paramsSerializer</span>: <span class="keyword">function</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Qs</span>.<span class="title function_">stringify</span>(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属：FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属： Stream</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span></span><br><span class="line">  <span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span></span><br><span class="line">  <span class="attr">auth</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;janedoe&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;s00pers3cret&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` indicates encoding to use for decoding responses</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  <span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  <span class="attr">xsrfCookieName</span>: <span class="string">&#x27;XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span></span><br><span class="line">  <span class="attr">xsrfHeaderName</span>: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  <span class="attr">onUploadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// Do whatever you want with the native progress event</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  <span class="attr">onDownloadProgress</span>: <span class="keyword">function</span> (<span class="params">progressEvent</span>) &#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  <span class="attr">maxContentLength</span>: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// default</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span></span><br><span class="line">  <span class="comment">// 如果设置为0，将不会 follow 任何重定向</span></span><br><span class="line">  <span class="attr">maxRedirects</span>: <span class="number">5</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; to send requests to the docker daemon.</span></span><br><span class="line">  <span class="comment">// Only either `socketPath` or `proxy` can be specified.</span></span><br><span class="line">  <span class="comment">// If both are specified, `socketPath` is used.</span></span><br><span class="line">  <span class="attr">socketPath</span>: <span class="literal">null</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  <span class="attr">httpAgent</span>: <span class="keyword">new</span> http.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  <span class="attr">httpsAgent</span>: <span class="keyword">new</span> https.<span class="title class_">Agent</span>(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#x27;proxy&#x27; 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  <span class="attr">proxy</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">    <span class="attr">auth</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&#x27;mikeymike&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;rapunz3l&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  <span class="comment">// （查看后面的 Cancellation 这节了解更多）</span></span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">cancel</span>) &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p>某个请求的响应包含以下信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"> <span class="comment">// &#x27;request&#x27;</span></span><br><span class="line">  <span class="comment">// `request` is the request that generated this response</span></span><br><span class="line">  <span class="comment">// It is the last ClientRequest instance in node.js (in redirects)</span></span><br><span class="line">  <span class="comment">// and an XMLHttpRequest instance the browser</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 then 时，你将接收下面这样的响应 :</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">config</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。</p>
<h2 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h2><p>你可以指定将被用在各个请求的配置默认值</p>
<p>全局的 axios 默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;https://api.example.com&#x27;</span>;</span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span>;</span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">post</span>[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>;</span><br><span class="line">自定义实例默认值</span><br><span class="line"><span class="comment">// Set config defaults when creating the instance</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alter defaults after instance has been created</span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">headers</span>.<span class="property">common</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="variable constant_">AUTH_TOKEN</span>;</span><br></pre></td></tr></table></figure>
<h2 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h2><p>配置会以一个优先顺序进行合并。这个顺序是：在 lib&#x2F;defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用由库提供的配置的默认值来创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 `0`</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写库的超时默认值</span></span><br><span class="line"><span class="comment">// 现在，在超时前，所有请求都会等待 2.5 秒</span></span><br><span class="line">instance.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为已知需要花费很长时间的请求覆写超时设置</span></span><br><span class="line">instance.<span class="title function_">get</span>(<span class="string">&#x27;/longRequest&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><p>在请求或响应被 then 或 catch 处理前拦截它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>如果你想在稍后移除拦截器，可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor);</span><br></pre></td></tr></table></figure>
<p>可以为自定义 axios 实例添加拦截器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>();</span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">response</span>) &#123;</span><br><span class="line">      <span class="comment">// The request was made and the server responded with a status code</span></span><br><span class="line">      <span class="comment">// that falls out of the range of 2xx</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">response</span>.<span class="property">data</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">response</span>.<span class="property">status</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">response</span>.<span class="property">headers</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.<span class="property">request</span>) &#123;</span><br><span class="line">      <span class="comment">// The request was made but no response was received</span></span><br><span class="line">      <span class="comment">// `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span></span><br><span class="line">      <span class="comment">// http.ClientRequest in node.js</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">request</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Something happened in setting up the request that triggered an Error</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">config</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>Y可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="keyword">function</span> (<span class="params">status</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">// Reject only if the status code is greater than or equal to 500</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h1><p>使用 cancel token 取消请求</p>
<p>Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。</p>
<p>可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">thrown</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(thrown)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request canceled&#x27;</span>, thrown.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;new name&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求（message 参数是可选的）</span></span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;Operation canceled by the user.&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> <span class="title function_">executor</span>(<span class="params">c</span>) &#123;</span><br><span class="line">    <span class="comment">// executor 函数接收一个 cancel 函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel the request</span></span><br><span class="line"><span class="title function_">cancel</span>();</span><br></pre></td></tr></table></figure>
<p>注意: 可以使用同一个 cancel token 取消多个请求</p>
<p>使用 application&#x2F;x-www-form-urlencoded format<br>默认情况下，axios将JavaScript对象序列化为JSON。 要以application &#x2F; x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。</p>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>在浏览器中，您可以使用URLSearchParams API，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>();</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;param1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;param2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/foo&#x27;</span>, params);</span><br></pre></td></tr></table></figure>
<p>请注意，所有浏览器都不支持URLSearchParams（请参阅caniuse.com），但可以使用polyfill（确保填充全局环境）。</p>
<p>或者，您可以使用qs库编码数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>);</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/foo&#x27;</span>, qs.<span class="title function_">stringify</span>(&#123; <span class="string">&#x27;bar&#x27;</span>: <span class="number">123</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>或者以另一种方式（ES6），</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">&#x27;bar&#x27;</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">data</span>: qs.<span class="title function_">stringify</span>(data),</span><br><span class="line">  url,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">axios</span>(options);</span><br></pre></td></tr></table></figure>
<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>在node.js中，您可以使用querystring模块，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;http://something.com/&#x27;</span>, querystring.<span class="title function_">stringify</span>(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>您也可以使用qs库。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/axios/" rel="tag">axios</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/call apply bind"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/12/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/call%20apply%20bind/"
    >call apply bind</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/12/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/call%20apply%20bind/" class="article-date">
  <time datetime="2020-03-12T02:25:14.000Z" itemprop="datePublished">2020-03-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>call，apply，bind</code>这三个函数是<code>Function</code>原型上的方法<code>Function.prototype.call()</code>，<code>Function.prototype.apply</code>，<code>Function.prototype.bind()</code>，所有的函数都是<code>Funciton</code>的实例，因此所有的函数可以调用<code>call，apply，bind</code>这三个方法。</p>
<h1 id="call，apply，bind-在用法上的异同"><a href="#call，apply，bind-在用法上的异同" class="headerlink" title="call，apply，bind 在用法上的异同"></a>call，apply，bind 在用法上的异同</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ul>
<li>三者都可以改变函数的<code>this</code>对象指向。</li>
<li>三者第一个参数都是<code>this</code>要指向的对象，如果如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code>。</li>
</ul>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul>
<li>函数调用<code>call</code>，<code>apply</code>方法时，返回的是调用函数的返回值。而<code>bind</code>是返回一个新的函数，你需要再加一个小括号来调用。</li>
<li>三者都可以传参，<code>call</code>接受的是一系列参数，<code>apply</code>接受的是一个数组，<code>bind</code>可以分为多次传入。</li>
</ul>
<h1 id="Function-prototype-call-thisArg-arg1-arg2-…"><a href="#Function-prototype-call-thisArg-arg1-arg2-…" class="headerlink" title="Function.prototype.call(thisArg [, arg1, arg2, …])"></a>Function.prototype.call(thisArg [, arg1, arg2, …])</h1><p><code>call()</code>方法调用一个函数，第一个参数是<code>this</code>的指向，后面传入的是一个参数列表（注意和<code>apply</code>传参的区别）。当第一个参数为<code>null</code>或<code>undefined</code>的时候，表示指向<code>window</code>（在浏览器中），使用<code>call</code>方法改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lisi&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, ...args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);               <span class="comment">// zhangsan 1 2 3</span></span><br><span class="line">log.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// zhangsan 1 2 3</span></span><br><span class="line">log.<span class="title function_">call</span>(product, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// lisi 1 2 3</span></span><br></pre></td></tr></table></figure>
<h1 id="Function-prototype-apply-thisArg-Array"><a href="#Function-prototype-apply-thisArg-Array" class="headerlink" title="Function.prototype.apply(thisArg [, Array])"></a>Function.prototype.apply(thisArg [, Array])</h1><p><code>apply()</code>方法调用一个函数，第一个参数是<code>this</code>的指向，后面传入的是一个数组（或类数组对象）形式的参数列表（注意和<code>call</code>传参的区别）。当第一个参数为<code>null</code>或<code>undefined</code>的时候，表示指向<code>window</code>（在浏览器中），使用<code>apply</code>方法改变<code>this</code>指向后原函数会立即执行，且此方法只是临时改变<code>this</code>指向一次。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> product = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lisi&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, ...args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);                 <span class="comment">// zhangsan [1 2 3]</span></span><br><span class="line">log.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);     <span class="comment">// zhangsan 1 2 3</span></span><br><span class="line">log.<span class="title function_">apply</span>(product, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// lisi 1 2 3</span></span><br></pre></td></tr></table></figure>
<h1 id="Function-prototype-bind-thisArg-arg1-arg2-…"><a href="#Function-prototype-bind-thisArg-arg1-arg2-…" class="headerlink" title="Function.prototype.bind(thisArg [, arg1, arg2, …])"></a>Function.prototype.bind(thisArg [, arg1, arg2, …])</h1><p><code>bind</code>方法的第一参数是<code>this</code>的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入，<code>call</code>则必须一次性传入所有参数)，但是它改变<code>this</code>指向后不会立即执行，而是返回一个永久改变<code>this</code>指向的函数。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">81</span>,</span><br><span class="line">  <span class="attr">getX</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">getX</span>();  <span class="comment">// 返回 81 （通过对象调用函数， 上下文为该对象）</span></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="variable language_">module</span>.<span class="property">getX</span>;  <span class="comment">// 获取对象中函数的引用地址</span></span><br><span class="line"><span class="title function_">retrieveX</span>();    <span class="comment">// 返回 9, 在这种情况下， &quot;this&quot; 指向全局作用域（在全局对象下调用函数）</span></span><br><span class="line"><span class="comment">// 永久为函数 boundGetX 绑定 this 上下文</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.<span class="title function_">bind</span>(<span class="variable language_">module</span>);</span><br><span class="line"><span class="title function_">boundGetX</span>();   <span class="comment">// 返回 81 （函数 this 上下文永久绑定为 module）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例二为回调函数绑定 this 上下文</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="title function_">ffunction</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将对象中方法取出（函数的引用地址），作为回调函数， 又因为 setTimeout 回调函数执行的上下文是 window</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">get</span>, <span class="number">1000</span>);            <span class="comment">// 打印 10</span></span><br><span class="line"><span class="comment">// 将对象中方法取出（函数的引用地址），作为回调函数并绑定 this 上下文</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.<span class="property">get</span>.<span class="title function_">bind</span>(obj), <span class="number">1000</span>);  <span class="comment">// 打印 20</span></span><br></pre></td></tr></table></figure>
<h1 id="手写-call，apply，bind"><a href="#手写-call，apply，bind" class="headerlink" title="手写 call，apply，bind"></a>手写 call，apply，bind</h1><h2 id="实现一个call"><a href="#实现一个call" class="headerlink" title="实现一个call"></a>实现一个call</h2><p>通过在<code>thisArg</code>上临时添加<code>func</code>，然后直接调用<code>thisArg.func()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">func</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="title class_">Symbol</span>(<span class="string">&#x27;Temp property&#x27;</span>);</span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg[tempFunc] = func;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[tempFunc](...args);</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(thisArg, tempFunc);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(printName.<span class="title function_">myCall</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;ly&#x27;</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure>
<h2 id="实现一个apply"><a href="#实现一个apply" class="headerlink" title="实现一个apply"></a>实现一个apply</h2><p>过程和<code>call</code>类似，只是参数不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (thisArg === <span class="literal">undefined</span> || thisArg === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 thisArg 是 undefined 或则 null，this 指向全局对象，直接调用就可以达到指向全局对象的目的了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">tempFunc</span>(args);</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 这里的 this 其实就是 func.myCall(thisArg, ...args) 中的 func，因为 myCall 是通过 func 调用的嘛</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="variable language_">this</span>;</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> tempFunc = <span class="title class_">Symbol</span>(<span class="string">&#x27;Temp property&#x27;</span>);</span><br><span class="line">  <span class="comment">// 在 thisArg 上临时绑定 func</span></span><br><span class="line">  thisArg[tempFunc] = func;</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 通过 thisArg 调用 func 来达到改变 this 指向的作用</span></span><br><span class="line">  <span class="keyword">const</span> result = thisArg[tempFunc](args);</span><br><span class="line">​</span><br><span class="line">  <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[tempFunc];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(printName.<span class="title function_">myCall</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;ly&#x27;</span> &#125;)); <span class="comment">// =&gt; ly</span></span><br></pre></td></tr></table></figure>
<h2 id="实现一个bind"><a href="#实现一个bind" class="headerlink" title="实现一个bind"></a>实现一个bind</h2><p><code>bind()</code>方法创建一个新的函数，在<code>bind()</code>被调用时，这个新函数的<code>this</code>被指定为<code>bind()</code>的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">thisArg <span class="comment">/* , args */</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 将this和arguments的值保存至变量中以便在后面嵌套的函数中可以使用它们</span></span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span>, boundArgs = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind()方法的返回值是一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 创建一个实参列表，将传入bind()的第二个及后续的实参都传入这个函数</span></span><br><span class="line">    <span class="keyword">var</span> i, args = [];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; boundArgs.<span class="property">length</span>; i++)&#123; args.<span class="title function_">push</span>(boundArgs[i]) &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++)&#123; args.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]) &#125;</span><br><span class="line">    <span class="comment">// 现在将self作为o的方法来调用，传入这些实参</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(thisArg, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="keyword">function</span>(<span class="params">b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn1 = fn.<span class="title function_">bind</span>(obj, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h1 id="apply-call-bind-的一些运用"><a href="#apply-call-bind-的一些运用" class="headerlink" title="apply call bind 的一些运用"></a>apply call bind 的一些运用</h1><h2 id="类数组转为数组"><a href="#类数组转为数组" class="headerlink" title="类数组转为数组"></a>类数组转为数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="number">0</span>: <span class="string">&#x27;q&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;i&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;q&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;a&#x27;</span>,  <span class="number">4</span>:<span class="string">&#x27;n&#x27;</span>, <span class="number">5</span>: <span class="string">&#x27;y&#x27;</span>, <span class="number">6</span>:<span class="string">&#x27;i&#x27;</span>, <span class="number">7</span>:<span class="string">&#x27;n&#x27;</span>, <span class="attr">length</span>: <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">apply</span>(arr, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [&quot;q&quot;, &quot;i&quot;, &quot;q&quot;, &quot;a&quot;, &quot;n&quot;, &quot;y&quot;, &quot;i&quot;, &quot;n&quot;]</span></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="number">0</span>: <span class="string">&#x27;q&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;i&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(obj);  <span class="comment">// [q, i]</span></span><br></pre></td></tr></table></figure>
<h2 id="为伪数组添加新的元素"><a href="#为伪数组添加新的元素" class="headerlink" title="为伪数组添加新的元素"></a>为伪数组添加新的元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一: 当然你也可以使用 apply</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="number">0</span>: <span class="string">&#x27;q&#x27;</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">call</span>(obj, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);   <span class="comment">// &#123;0: &#x27;q&#x27;, 1: &#x27;i&#x27;, 2: &#x27;a&#x27;, 3: &#x27;n&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="number">0</span>: <span class="string">&#x27;q&#x27;</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> push = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">push</span>(<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;n&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);   <span class="comment">// &#123;0: &#x27;q&#x27;, 1: &#x27;i&#x27;, 2: &#x27;a&#x27;, 3: &#x27;n&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="求数组中最大值-最小值一样做法"><a href="#求数组中最大值-最小值一样做法" class="headerlink" title="求数组中最大值(最小值一样做法)"></a>求数组中最大值(最小值一样做法)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr);</span><br><span class="line"><span class="comment">// 或 const max = Math.max.call(null, ...arr)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h2 id="数组合并追加"><a href="#数组合并追加" class="headerlink" title="数组合并追加"></a>数组合并追加</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> brr = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">apply</span>(arr, brr);</span><br><span class="line"><span class="comment">// 或者 Array.prototype.push.call(arr, ...brr);</span></span><br><span class="line"><span class="comment">// 当然还可以这样 arr.push(...brr);</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 索引"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/07/SQL/SQL%20%E7%B4%A2%E5%BC%95/"
    >SQL 索引</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/07/SQL/SQL%20%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2020-03-07T08:15:08.000Z" itemprop="datePublished">2020-03-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="索引是万能的吗？"><a href="#索引是万能的吗？" class="headerlink" title="索引是万能的吗？"></a>索引是万能的吗？</h1><p>数据库中的索引，就好比一本书的目录，它可以帮我们快速进行特定值的定位与查找，从而加快数据查询的效率。</p>
<p>索引就是帮助数据库管理系统高效获取数据的数据结构。</p>
<p>如果我们不使用索引，就必须从第 1 条记录开始扫描，直到把所有的数据表都扫描完，才能找到想要的数据。既然如此，如果我们想要快速查找数据，就只需要创建更多的索引就好了呢？</p>
<p>其实索引不是万能的，在有些情况下使用索引反而会让效率变低。</p>
<p>索引的价值是帮我们从海量数据中找到想要的数据，如果数据量少，那么是否使用索引对结果的影响并不大。</p>
<p>在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。另外，当数据重复度大，比如高于 10% 的时候，也不需要对这个字段使用索引。比如性别这个字段，就不需要对它创建索引。这是为什么呢？如果你想要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p>
<h2 id="实验-1：数据行数少的情况下，索引效率如何"><a href="#实验-1：数据行数少的情况下，索引效率如何" class="headerlink" title="实验 1：数据行数少的情况下，索引效率如何"></a>实验 1：数据行数少的情况下，索引效率如何</h2><p>比如<a target="_blank" rel="noopener" href="https://github.com/wsq01/SQL-repo/blob/master/heros_without_index.sql">heros_without_index.sql</a>和<a target="_blank" rel="noopener" href="https://github.com/wsq01/SQL-repo/blob/master/heros_with_index.sql">heros_with_index.sql</a>这两个数据表。</p>
<p>在第一个数据表中，除了自增的<code>id</code>以外没有建立额外的索引。第二张数据表中，对<code>name</code>字段建立了唯一索引。</p>
<p><code>heros</code>数据表一共有 69 个英雄，数据量很少。当我们对<code>name</code>进行条件查询的时候，我们观察一下创建索引前后的效率。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, hp_max, mp_max <span class="keyword">FROM</span> heros_without_index <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;刘禅&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果（1 条数据，运行时间 0.072s）：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
<th align="center">hp_max</th>
<th align="center">mp_max</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10015</td>
<td align="center">刘禅</td>
<td align="center">8581</td>
<td align="center">1694</td>
</tr>
</tbody></table>
<p>我对<code>name</code>字段建立索引后，再进行查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, hp_max, mp_max <span class="keyword">FROM</span> heros_with_index <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;刘禅&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果（1 条数据，运行时间 0.080s）：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
<th align="center">hp_max</th>
<th align="center">mp_max</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10015</td>
<td align="center">刘禅</td>
<td align="center">8581</td>
<td align="center">1694</td>
</tr>
</tbody></table>
<p>你能看到运行结果相同，但是创建了<code>name</code>字段索引的效率比没有创建索引时效率更低。在数据量不大的情况下，索引就发挥不出作用了。</p>
<h2 id="实验-2：性别（男或女）字段真的不应该创建索引吗？"><a href="#实验-2：性别（男或女）字段真的不应该创建索引吗？" class="headerlink" title="实验 2：性别（男或女）字段真的不应该创建索引吗？"></a>实验 2：性别（男或女）字段真的不应该创建索引吗？</h2><p>如果一个字段的取值少，比如性别这个字段，通常是不需要创建索引的。那么有没有特殊的情况呢？</p>
<p>下面我们来看一个例子，假设有一个女儿国，人口总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p>
<p>女儿国的人口数据表<a target="_blank" rel="noopener" href="https://github.com/wsq01/SQL-repo/blob/master/user_gender.sql">user_gender.sql</a>。其中数据表中的<code>user_gender</code>字段取值为 0 或 1，0 代表女性，1 代表男性。</p>
<p>如果我们要筛选出这个国家中的男性，可以使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_gender <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>运行结果（10 条数据，运行时间 0.696s）：</p>
<table>
<thead>
<tr>
<th align="center">user_id</th>
<th align="center">user_name</th>
<th align="center">user_gender</th>
</tr>
</thead>
<tbody><tr>
<td align="center">110000</td>
<td align="center">student_100000</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">210000</td>
<td align="center">student_200000</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">101000</td>
<td align="center">Student_100000</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>你能看到在未创建索引的情况下，运行的效率并不高。如果我们针对<code>user_gender</code>字段创建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_gender <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>同样是 10 条数据，运行结果相同，时间却缩短到了 0.052s，大幅提升了查询的效率。</p>
<p>其实通过这两个实验你也能看出来，索引的价值是帮你快速定位。如果想要定位的数据有很多，那么索引就失去了它的使用价值，比如通常情况下的性别字段。不过有时候，我们还要考虑这个字段中的数值分布的情况，在实验 2 中，性别字段的数值分布非常特殊，男性的比例非常少。</p>
<p>我们不仅要看字段中的数值个数，还要根据数值的分布情况来考虑是否需要创建索引。</p>
<h1 id="索引的种类有哪些？"><a href="#索引的种类有哪些？" class="headerlink" title="索引的种类有哪些？"></a>索引的种类有哪些？</h1><p>虽然使用索引的本质目的是帮我们快速定位想要查找的数据，但实际上，索引有很多种类。</p>
<p>从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引和全文索引。</p>
<p>普通索引是基础的索引，没有任何约束，主要用于提高查询效率。唯一索引就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。主键索引在唯一索引的基础上增加了不为空的约束，也就是<code>NOT NULL+UNIQUE</code>，一张表里最多只有一个主键索引。全文索引用的不多，MySQL 自带的全文索引只支持英文。我们通常可以采用专门的全文搜索引擎，比如ES(ElasticSearch) 和 Solr。</p>
<p>其实前三种索引（普通索引、唯一索引和主键索引）都是一类索引，只不过对数据的约束性逐渐提升。在一张数据表中只能有一个主键索引，这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。但可以有多个普通索引或者多个唯一索引。</p>
<p>按照物理实现方式，索引可以分为 2 种：聚集索引和非聚集索引。我们也把非聚集索引称为二级索引或者辅助索引。</p>
<p>聚集索引可以按照主键来排序存储数据，这样在查找行的时候非常有效。举个例子，如果是一本汉语字典，我们想要查找“数”这个字，直接在书中找汉语拼音的位置即可，也就是拼音“shu”。这样找到了索引的位置，在它后面就是我们想要找的数据行。</p>
<p>非聚集索引又是什么呢？</p>
<p>在数据库系统会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的。也就是说系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行。非聚集索引不会把索引指向的内容像聚集索引一样直接放到索引的后面，而是维护单独的索引表（只维护索引，不维护索引指向的数据），为数据检索提供方便。我们还以汉语字典为例，如果想要查找“数”字，那么按照部首查找的方式，先找到“数”字的偏旁部首，然后这个目录会告诉我们“数”字存放到第多少页，我们再去指定的页码找这个字。</p>
<p>聚集索引指表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每一个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。</p>
<p>聚集索引与非聚集索引的原理不同，在使用上也有一些区别：</p>
<p>聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。<br>一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。<br>使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。</p>
<h2 id="实验-3：使用聚集索引和非聚集索引的查询效率"><a href="#实验-3：使用聚集索引和非聚集索引的查询效率" class="headerlink" title="实验 3：使用聚集索引和非聚集索引的查询效率"></a>实验 3：使用聚集索引和非聚集索引的查询效率</h2><p>还是针对刚才的<code>user_gender</code>数据表，我们来看下使用聚集索引和非聚集索引的查询效率有什么区别。在<code>user_gender</code>表中，我设置了<code>user_id</code>为主键，也就是聚集索引的字段是<code>user_id</code>。这里我们查询下<code>user_id=90001</code>的用户信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, user_name, user_gender <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">900001</span></span><br></pre></td></tr></table></figure>
<p>运行结果（1 条数据，运行时间 0.043s）：</p>
<table>
<thead>
<tr>
<th align="center">user_id</th>
<th align="center">user_name</th>
<th align="center">user_gender</th>
</tr>
</thead>
<tbody><tr>
<td align="center">900001</td>
<td align="center">student_890001</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>我们再直接对<code>user_name</code>字段进行条件查询，此时<code>user_name</code>字段没有创建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, user_name, user_gender <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_name <span class="operator">=</span> <span class="string">&#x27;student_890001&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：1 条数据，运行时间 0.961s。</p>
<p>对没有建立索引的字段进行条件查询，查询效率明显降低了。</p>
<p>然后我们对<code>user_name</code>字段创建普通索引，进行 SQL 查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, user_name, user_gender <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_name <span class="operator">=</span> <span class="string">&#x27;student_890001&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：1 条数据，运行时间 0.050s。</p>
<p>通过对这 3 次 SQL 查询结果的对比，我们可以总结出以下两点内容：</p>
<p>对<code>WHERE</code>子句的字段建立索引，可以大幅提升查询效率。<br>采用聚集索引进行数据查询，比使用非聚集索引的查询效率略高。如果查询次数比较多，还是尽量使用主键索引进行数据查询。<br>除了业务逻辑和物理实现方式，索引还可以按照字段个数进行划分，分成单一索引和联合索引。</p>
<p>索引列为一列时为单一索引；多个列组合在一起创建的索引叫做联合索引。</p>
<p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (<code>x, y, z</code>) 和 (<code>z, y, x</code>) 在使用的时候效率可能会存在差别。</p>
<p>这里需要说明的是联合索引存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。比如刚才举例的 (<code>x, y, z</code>)，如果查询条件是<code>WHERE x=1 AND y=2 AND z=3</code>，就可以匹配上联合索引；如果查询条件是<code>WHERE y=2</code>，就无法匹配上联合索引。</p>
<h2 id="实验-4：联合索引的最左原则"><a href="#实验-4：联合索引的最左原则" class="headerlink" title="实验 4：联合索引的最左原则"></a>实验 4：联合索引的最左原则</h2><p>还是针对<code>user_gender</code>数据表，我们把<code>user_id</code>和<code>user_name</code>字段设置为联合主键，然后看下 SQL 查询效率有什么区别。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, user_name, user_gender <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">900001</span> <span class="keyword">AND</span> user_name <span class="operator">=</span> <span class="string">&#x27;student_890001&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果（1 条数据，运行时间 0.046s）：</p>
<table>
<thead>
<tr>
<th align="center">user_id</th>
<th align="center">user_name</th>
<th align="center">user_gender</th>
</tr>
</thead>
<tbody><tr>
<td align="center">900001</td>
<td align="center">student_890001</td>
<td align="center">0</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, user_name, user_gender <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">900001</span></span><br></pre></td></tr></table></figure>
<p>运行结果：1 条数据，运行时间 0.046s。</p>
<p>我们再来看下普通的条件查询是什么样子的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_id, user_name, user_gender <span class="keyword">FROM</span> user_gender <span class="keyword">WHERE</span> user_name <span class="operator">=</span> <span class="string">&#x27;student_890001&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：1 条数据，运行时间 0.943s。</p>
<p>当我们使用了联合索引 (<code>user_id, user_name</code>) 的时候，在<code>WHERE</code>子句中对联合索引中的字段<code>user_id</code>和<code>user_name</code>进行条件查询，或者只对<code>user_id</code>进行查询，效率基本上是一样的。当我们对<code>user_name</code>进行条件查询时，效率就会降低很多，这是因为根据联合索引的最左原则，<code>user_id</code>在<code>user_name</code>的左侧，如果没有使用<code>user_id</code>，而是直接使用<code>user_name</code>进行条件查询，联合索引就会失效。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/06/SQL/SQL%20%E9%94%81/"
    >SQL 查询优化器工作原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/06/SQL/SQL%20%E9%94%81/" class="article-date">
  <time datetime="2020-03-06T08:15:08.000Z" itemprop="datePublished">2020-03-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>实际上加锁是为了保证数据的一致性，这个思想在程序开发领域中同样很重要。在程序开发中也会存在多线程同步的问题。当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻最多只有一个线程在进行访问，保证数据的完整性和一致性。</p>
<h1 id="按照锁粒度进行划分"><a href="#按照锁粒度进行划分" class="headerlink" title="按照锁粒度进行划分"></a>按照锁粒度进行划分</h1><p>锁用来对数据进行锁定，我们可以从锁定对象的粒度大小来对锁进行划分，分别为行锁、页锁和表锁。</p>
<p>顾名思义，行锁就是按照行的粒度对数据进行锁定。锁定力度小，发生锁冲突概率低，可以实现的并发度高，但是对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。</p>
<p>页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</p>
<p>表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。不过好处在于对锁的使用开销小，加锁会很快。</p>
<p>行锁、页锁和表锁是相对常见的三种锁，除此以外我们还可以在区和数据库的粒度上锁定数据，对应区锁和数据库锁。不同的数据库和存储引擎支持的锁粒度不同，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">行锁</th>
<th align="center">页锁</th>
<th align="center">表锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InnoDB</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">MyISAM</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">BDB</td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">Oracle</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">SQL Server</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>这里需要说明下，每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<p>从数据库管理的角度对锁进行划分<br>除了按照锁粒度大小对锁进行划分外，我们还可以从数据库管理的角度对锁进行划分。共享锁和排它锁，是我们经常会接触到的两把锁。</p>
<p>共享锁也叫读锁或 S 锁，共享锁锁定的资源可以被其他用户读取，但不能修改。在进行<code>SELECT</code>的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。</p>
<p>比如我们想给<code>product_comment</code>在表上加共享锁，可以使用下面这行命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK <span class="keyword">TABLE</span> product_comment READ;</span><br></pre></td></tr></table></figure>
<p>当对数据表加上共享锁的时候，该数据表就变成了只读模式，此时我们想要更新<code>product_comment</code>表中的数据，比如下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> product_comment <span class="keyword">SET</span> product_id <span class="operator">=</span> <span class="number">10002</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">912178</span>;</span><br></pre></td></tr></table></figure>
<p>系统会做出如下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1099 (HY000): Table &#x27;product_comment&#x27; was locked with a READ lock and can&#x27;t be updated</span><br></pre></td></tr></table></figure>
<p>也就是当共享锁没有释放时，不能对锁住的数据进行修改。</p>
<p>如果我们想要对表上的共享锁进行解锁，可以使用下面这行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLE;</span><br></pre></td></tr></table></figure>
<p>如果我们想要给某一行加上共享锁呢，比如想对<code>user_id=912178</code>的数据行加上共享锁，可以像下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, product_id, comment_text, user_id <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">912178</span> LOCK <span class="keyword">IN</span> SHARE MODE</span><br></pre></td></tr></table></figure>
<p>排它锁也叫独占锁、写锁或 X 锁。排它锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。</p>
<p>如果我们想给 product_comment 数据表添加排它锁，可以使用下面这行命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK <span class="keyword">TABLE</span> product_comment WRITE;</span><br></pre></td></tr></table></figure>
<p>这时只有获得排它锁的事务可以对<code>product_comment</code>进行查询或修改，其他事务如果想要在<code>product_comment</code>表上查询数据，则需要等待。你可以自己开两个 MySQL 客户端来模拟下。</p>
<p>这时我们释放掉排它锁，使用这行命令即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK <span class="keyword">TABLE</span>;</span><br></pre></td></tr></table></figure>
<p>同样的，如果我们想要在某个数据行上添加排它锁，比如针对<code>user_id=912178</code>的数据行，则写成如下这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_id, product_id, comment_text, user_id <span class="keyword">FROM</span> product_comment <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">912178</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>另外当我们对数据进行更新的时候，也就是<code>INSERT、DELETE</code>或者<code>UPDATE</code>的时候，数据库也会自动使用排它锁，防止其他事务对该数据行进行操作。</p>
<p>当我们想要获取某个数据表的排它锁的时候，需要先看下这张数据表有没有上了排它锁。如果这个数据表中的某个数据行被上了行锁，我们就无法获取排它锁。这时需要对数据表中的行逐一排查，检查是否有行锁，如果没有，才可以获取这张数据表的排它锁。这个过程是不是有些麻烦？这里就需要用到意向锁。</p>
<p>意向锁（<code>Intent Lock</code>），简单来说就是给更大一级别的空间示意里面是否已经上过锁。举个例子，你可以给整个房子设置一个标识，告诉它里面有人，即使你只是获取了房子中某一个房间的锁。这样其他人如果想要获取整个房子的控制权，只需要看这个房子的标识即可，不需要再对房子中的每个房间进行查找。这样是不是很方便？</p>
<p>返回数据表的场景，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p>
<p>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录，不能对整个表进行全表扫描。</p>
<h1 id="为什么共享锁会发生死锁的情况？"><a href="#为什么共享锁会发生死锁的情况？" class="headerlink" title="为什么共享锁会发生死锁的情况？"></a>为什么共享锁会发生死锁的情况？</h1><p>当我们使用共享锁的时候会出现死锁的风险，下面我们用两个 MySQL 客户端来模拟一下事务查询。</p>
<p>首先客户端 1 开启事务，然后采用读锁的方式对<code>user_id=912178</code>的数据行进行查询，这时事务没有提交的时候，这两行数据行上了读锁。</p>
<img src="/2020/03/06/SQL/SQL%20%E9%94%81/img1.png" class="">

<p>然后我们用客户端 2 开启事务，同样对<code>user_id=912178</code>获取读锁，理论上获取读锁后还可以对数据进行修改，比如执行下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> product_comment <span class="keyword">SET</span> product_i <span class="operator">=</span> <span class="number">10002</span> <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">912178</span>;</span><br></pre></td></tr></table></figure>
<p>当我们执行的时候客户端 2 会一直等待，因为客户端 1 也获取了该数据的读锁，不需要客户端 2 对该数据进行修改。这时客户端 2 会提示等待超时，重新执行事务。</p>
<img src="/2020/03/06/SQL/SQL%20%E9%94%81/img2.png" class="">

<p>你能看到当有多个事务对同一数据获得读锁的时候，可能会出现死锁的情况。</p>
<h2 id="从程序员的角度对进行划分"><a href="#从程序员的角度对进行划分" class="headerlink" title="从程序员的角度对进行划分"></a>从程序员的角度对进行划分</h2><p>如果从程序员的视角来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待数据并发的思维方式。</p>
<p>乐观锁（<code>Optimistic Locking</code>）认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。</p>
<h3 id="乐观锁的版本号机制"><a href="#乐观锁的版本号机制" class="headerlink" title="乐观锁的版本号机制"></a>乐观锁的版本号机制</h3><p>在表中设计一个版本字段<code>version</code>，第一次读的时候，会获取<code>version</code>字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<p>这种方式类似我们熟悉的 SVN、CVS 版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p>
<h3 id="乐观锁的时间戳机制"><a href="#乐观锁的时间戳机制" class="headerlink" title="乐观锁的时间戳机制"></a>乐观锁的时间戳机制</h3><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p>
<p>悲观锁（<code>Pessimistic Locking</code>）也是一种思想，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p>
<img src="/2020/03/06/SQL/SQL%20%E9%94%81/img3.png" class="">

<p>从这两种锁的设计思想中，你能看出乐观锁和悲观锁的适用场景：</p>
<p>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p>
<p>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 事务处理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/06/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"
    >SQL 事务处理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/06/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2020-03-06T06:12:04.000Z" itemprop="datePublished">2020-03-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在 MySQL 5.5 版本之前，默认的存储引擎是 MyISAM，在 5.5 版本之后默认存储引擎是 InnoDB。InnoDB 和 MyISAM 区别之一就是 InnoDB 支持事务，也可以说这是 InnoDB 取代 MyISAM 的重要原因。那么什么是事务呢？事务是进行一次处理的基本单元，要么完全执行，要么都不执行。</p>
<p>不知道你是否遇到过这样的情况，你去家门口的小卖铺买东西，已经交了钱，但是老板比较忙接了个电话，忘记你是否交过钱，然后让你重新付款，这时你还要找之前的付款记录证明你已经完成了付款。</p>
<p>实际上如果我们线下的交易也能支持事务（满足事务的特性），就不会出现交了钱却拿不到商品的烦恼了，同样，对于小卖铺的老板来说，也不存在给出了商品但没有收到款的风险。总之，事务保证了一次处理的完整性，也保证了数据库中的数据一致性。它是一种高级的数据处理方式，如果我们在增加、删除、修改的时候某一个环节出了错，它允许我们回滚还原。正是因为这个特点，事务非常适合应用在安全性高的场景里，比如金融行业等。</p>
<h1 id="事务的特性：ACID"><a href="#事务的特性：ACID" class="headerlink" title="事务的特性：ACID"></a>事务的特性：ACID</h1><p>事务的特性：要么完全执行，要么都不执行。不过要对事务进行更深一步的理解，还要从事务的 4 个特性说起，这 4 个特性用英文字母来表达就是 ACID。</p>
<ul>
<li>A，也就是原子性（<code>Atomicity</code>）。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。</li>
<li>C，就是一致性（<code>Consistency</code>）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。</li>
<li>I，就是隔离性（<code>Isolation</code>）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。</li>
<li>最后一个 D，指的是持久性（<code>Durability</code>）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。</li>
</ul>
<p>ACID 可以说是事务的四大特性，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的。</p>
<p>这里指的一致性本身是由具体的业务定义的，也就是说，任何写入数据库中的数据都需要满足我们事先定义的约束规则。</p>
<p>比如说，在数据表中我们将姓名字段设置为唯一性约束，这时当事务进行提交或者事务发生回滚的时候，如果数据表中的姓名非唯一，就破坏了事务的一致性要求。所以说，事务操作会让数据表的状态变成另一种一致的状态，如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p>
<p>事务的另一个特点就是持久性，持久性是通过事务日志来保证的。日志包括了回滚日志和重做日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p>
<h1 id="事务的控制"><a href="#事务的控制" class="headerlink" title="事务的控制"></a>事务的控制</h1><p>当我们了解了事务的特性后，再来看下如何使用事务。我们知道 Oracle 是支持事务的，而在 MySQL 中，则需要选择适合的存储引擎才可以支持事务。如果你使用的是 MySQL，可以通过<code>SHOW ENGINES</code>命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p>
<p>看到这里，我们已经对事务有了一定的了解，现在我们再来看下事务的常用控制语句都有哪些。</p>
<ul>
<li><code>START TRANSACTION</code>或者<code>BEGIN</code>，作用是显式开启一个事务。</li>
<li><code>COMMIT</code>：提交事务。当提交事务后，对数据库的修改是永久性的。</li>
<li><code>ROLLBACK</code>或者<code>ROLLBACK TO [SAVEPOINT]</code>，意为回滚事务。意思是撤销正在进行的所有没有提交的修改，或者将事务回滚到某个保存点。</li>
<li><code>SAVEPOINT</code>：在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</li>
<li><code>RELEASE SAVEPOINT</code>：删除某个保存点。</li>
<li><code>SET TRANSACTION</code>，设置事务的隔离级别。</li>
</ul>
<p>需要说明的是，使用事务有两种方式，分别为隐式事务和显式事务。隐式事务实际上就是自动提交，Oracle 默认不自动提交，需要手写<code>COMMIT</code>命令，而 MySQL 默认自动提交，当然我们可以配置 MySQL 的参数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> autocommit <span class="operator">=</span><span class="number">0</span>;  <span class="operator">/</span><span class="operator">/</span> 关闭自动提交</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> autocommit <span class="operator">=</span><span class="number">1</span>;  <span class="operator">/</span><span class="operator">/</span> 开启自动提交</span><br></pre></td></tr></table></figure>
<p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;关羽&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>
<p>运行结果（1 行数据）：</p>
<table>
<thead>
<tr>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关羽</td>
</tr>
</tbody></table>
<p>在这个事务中，整个 SQL 一共执行了 2 个事务，第一个是插入“关羽”，提交后执行成功，第二个是插入两次“张飞”，这里需要注意的是，我们将<code>name</code>设置为了主键，也就是说主键的值是唯一的，那么第二次插入“张飞”时就会产生错误，然后执行<code>ROLLBACK</code>相当于对事务进行了回滚，所以我们看到最终结果只有一行数据，也就是第一个事务执行之后的结果，即“关羽”。</p>
<p>那么如果我们进行下面的操作又会怎样呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;关羽&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>
<p>运行结果（2 行数据）：</p>
<table>
<thead>
<tr>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关羽</td>
</tr>
<tr>
<td align="center">张飞</td>
</tr>
</tbody></table>
<p>你能看到这次数据是 2 行，上一次操作我把两次插入“张飞”放到一个事务里，而这次操作它们不在同一个事务里，那么对于 MySQL 来说，默认情况下这实际上就是两个事务，因为在<code>autocommit=1</code>的情况下，MySQL 会进行隐式事务，也就是自动提交，因此在进行第一次插入“张飞”后，数据表里就存在了两行数据，而第二次插入“张飞”就会报错：<code>1062 - Duplicate entry &#39;张飞&#39; for key &#39;PRIMARY&#39;</code>。</p>
<p>最后我们在执行<code>ROLLBACK</code>的时候，实际上事务已经自动提交了，就没法进行回滚了。</p>
<p>同样的我们再来看下这段代码，你又能发现什么不同呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@completion</span>_type <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;关羽&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">SELECT</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure>
<p>运行结果（1 行数据）：</p>
<table>
<thead>
<tr>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关羽</td>
</tr>
</tbody></table>
<p>你能看到还是相同的 SQL 代码，只是我在事务开始之前设置了<code>SET @@completion_type = 1;</code>，结果就和我们第一次处理的一样，只有一个“关羽”。这是为什么呢？</p>
<p>MySQL 中<code>completion_type</code>参数的作用，实际上这个参数有 3 种可能：</p>
<ul>
<li><code>completion=0</code>，这是默认情况。也就是说当我们执行<code>COMMIT</code>的时候会提交事务，在执行下一个事务时，还需要我们使用<code>START TRANSACTION</code>或者<code>BEGIN</code>来开启。</li>
<li><code>completion=1</code>，这种情况下，当我们提交事务后，相当于执行了<code>COMMIT AND CHAIN</code>，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务（隔离级别会在下一节中进行介绍）。</li>
<li><code>completion=2</code>，这种情况下<code>COMMIT=COMMIT AND RELEASE</code>，也就是当我们提交后，会自动与服务器断开连接。</li>
</ul>
<p>在上面这段代码里使用了<code>completion=1</code>，也就是说当我提交之后，相当于在下一行写了一个<code>START TRANSACTION</code>或<code>BEGIN</code>。这时两次插入“张飞”会被认为是在同一个事务之内的操作，那么第二次插入“张飞”就会导致事务失败，而回滚也将这次事务进行了撤销，所以你能看到的结果就只有一个“关羽”。</p>
<p>通过这样简单的练习，你应该能体会到事务提交和回滚的操作。</p>
<p>当我们设置<code>autocommit=0</code>时，不论是否采用<code>START TRANSACTION</code>或者<code>BEGIN</code>的方式来开启事务，都需要用<code>COMMIT</code>进行提交，让事务生效，使用<code>ROLLBACK</code>对事务进行回滚。</p>
<p>当我们设置<code>autocommit=1</code>时，每条 SQL 语句都会自动进行提交。<br>不过这时，如果你采用<code>START TRANSACTION</code>或者<code>BEGIN</code>的方式来显式地开启事务，那么这个事务只有在<code>COMMIT</code>时才会生效，在<code>ROLLBACK</code>时才会回滚。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在做数据库操作的时候，可能会失败，但正是因为有事务的存在，即使在数据库操作失败的情况下，也能保证数据的一致性。同样，多个应用程序访问数据库的时候，事务可以提供隔离，保证事务之间不被干扰。最后，事务一旦提交，结果就会是永久性的，这就意味着，即使系统崩溃了，数据库也可以对数据进行恢复。</p>
<p>在使用事务的过程中，我们会采用控制流语句对事务进行操作，不过在实际操作中，不一定每次使用<code>COMMIT</code>或<code>ROLLBACK</code>都会成功，你还需要知道当前系统的事务执行方式，也就是一些常用的参数情况，比如 MySQL 中的<code>autocommit</code>和<code>completion_type</code>等。</p>
<p>事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 事务隔离"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"
    >SQL 事务隔离</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/" class="article-date">
  <time datetime="2020-03-05T06:12:04.000Z" itemprop="datePublished">2020-03-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="事务并发处理可能存在的异常都有哪些？"><a href="#事务并发处理可能存在的异常都有哪些？" class="headerlink" title="事务并发处理可能存在的异常都有哪些？"></a>事务并发处理可能存在的异常都有哪些？</h1><p>在了解数据库隔离级别之前，我们需要了解设定事务的隔离级别都要解决哪些可能存在的问题，也就是事务并发处理时会存在哪些异常情况。实际上，SQL-92 标准中已经对 3 种异常情况进行了定义，这些异常情况级别分别为脏读（<code>Dirty Read</code>）、不可重复读（<code>Nnrepeatable Read</code>）和幻读（Phantom Read）。</p>
<p>脏读、不可重复读和幻读都代表了什么，我用一个例子来给你讲解下。比如说我们有个英雄表<code>heros_temp</code>，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">张飞</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">关羽</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">刘备</td>
</tr>
</tbody></table>
<p>这张英雄表，我们会记录很多英雄的姓名，假设我们不对事务进行隔离操作，那么数据库在进行事务的并发处理时会出现怎样的情况？</p>
<p>第一天，小张访问数据库，正在进行事务操作，往里面写入一个新的英雄“吕布”：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> heros_temp <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;吕布&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当小张还没有提交该事务的时候，小李又对数据表进行了访问，他想看下这张英雄表里都有哪些英雄：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> heros_temp;</span><br></pre></td></tr></table></figure>
<p>这时，小李看到的结果如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">张飞</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">关羽</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">刘备</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">吕布</td>
</tr>
</tbody></table>
<p>你有没有发现什么异常？这个时候小张还没有提交事务，但是小李却读到了小张还没有提交的数据，这种现象我们称之为“脏读”。</p>
<p>那么什么是不可重复读呢？</p>
<p>第二天，小张想查看<code>id=1</code>的英雄是谁，于是他进行了 SQL 查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> heros_temp <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<table>
<thead>
<tr>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">张飞</td>
</tr>
</tbody></table>
<p>然而此时，小李开始了一个事务操作，他对<code>id=1</code>的英雄姓名进行了修改，把原来的“张飞”改成了“张翼德”：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">UPDATE</span> heros_temp <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张翼德&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>然后小张再一次进行查询，同样也是查看<code>id=1</code>的英雄是谁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> heros_temp <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<table>
<thead>
<tr>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">张翼德</td>
</tr>
</tbody></table>
<p>这个时候你会发现，两次查询的结果并不一样。小张会想这是怎么回事呢？他明明刚执行了一次查询，马上又进行了一次查询，结果两次的查询结果不同。实际上小张遇到的情况我们称之为“不可重复读”，也就是同一条记录，两次读取的结果不同。</p>
<p>什么是幻读？</p>
<p>第三天，小张想要看下数据表里都有哪些英雄，他开始执行下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> heros_temp;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">张飞</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">关羽</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">刘备</td>
</tr>
</tbody></table>
<p>这时当小张执行完之后，小李又开始了一个事务，往数据库里插入一个新的英雄“吕布”：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> heros_temp <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;吕布&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>不巧的是，小张这时忘记了英雄都有哪些，又重新执行了一遍查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> heros_temp;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">张飞</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">关羽</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">刘备</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">吕布</td>
</tr>
</tbody></table>
<p>他发现这一次查询多了一个英雄，原来只有 3 个，现在变成了 4 个。这种异常情况我们称之为“幻读”。</p>
<p>我来总结下这三种异常情况的特点：</p>
<p>脏读：读到了其他事务还没有提交的数据。<br>不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。<br>幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。</p>
<h2 id="事务隔离的级别有哪些？"><a href="#事务隔离的级别有哪些？" class="headerlink" title="事务隔离的级别有哪些？"></a>事务隔离的级别有哪些？</h2><p>脏读、不可重复读和幻读这三种异常情况，是在 SQL-92 标准中定义的，同时 SQL-92 标准还定义了 4 种隔离级别来解决这些异常情况。</p>
<p>解决异常数量从少到多的顺序（比如读未提交可能存在 3 种异常，可串行化则不会存在这些异常）决定了隔离级别的高低，这四种隔离级别从低到高分别是：读未提交（<code>READ UNCOMMITTED</code>）、读已提交（<code>READ COMMITTED</code>）、可重复读（<code>REPEATABLE READ</code>）和可串行化（<code>SERIALIZABLE</code>）。这些隔离级别能解决的异常情况如下表所示：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（READ UNCOMMITTED）</td>
<td align="center">允许</td>
<td align="center">允许</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="center">读已提交（READ COMMITTED）</td>
<td align="center">禁止</td>
<td align="center">允许</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="center">可重复读（REPEATABLE READ）</td>
<td align="center">禁止</td>
<td align="center">禁止</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="center">可串行化（SERIALIZABLE）</td>
<td align="center">禁止</td>
<td align="center">禁止</td>
<td align="center">禁止</td>
</tr>
</tbody></table>
<p>你能看到可串行化能避免所有的异常情况，而读未提交则允许异常情况发生。</p>
<p>关于这四种级别，我来简单讲解下。</p>
<p>读未提交，也就是允许读到未提交的数据，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。</p>
<p>读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于 RDBMS 中常见的默认隔离级别（比如说 Oracle 和 SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在 SQL 查询的时候编写带加锁的 SQL 语句（我会在进阶篇里讲加锁）。</p>
<p>可重复读，保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL 默认的隔离级别就是可重复读。</p>
<p>可串行化，将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。</p>
<h1 id="使用-MySQL-客户端来模拟三种异常"><a href="#使用-MySQL-客户端来模拟三种异常" class="headerlink" title="使用 MySQL 客户端来模拟三种异常"></a>使用 MySQL 客户端来模拟三种异常</h1><p>首先我们需要一个英雄数据表<code>heros_temp</code>，具体表结构和数据，你可以从GitHub上下载<code>heros_temp.sql</code>文件。你也可以执行下面的 SQL 文件，来完成<code>heros_temp</code>数据表的创建。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for heros_temp</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `heros_temp`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `heros_temp`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of heros_temp</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `heros_temp` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;张飞&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `heros_temp` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;关羽&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `heros_temp` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;刘备&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>模拟的时候我们需要开两个 MySQL 客户端，分别是客户端 1 和客户端 2。</p>
<p>在客户端 1 中，我们先来查看下当前会话的隔离级别，使用命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>然后你能看到当前的隔离级别是<code>REPEATABLE-READ</code>，也就是可重复读。</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img1.png" class="">

<p>现在我们把隔离级别降到最低，设置为<code>READ UNCOMMITTED</code>（读未提交）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>
<p>然后再查看下当前会话（SESSION）下的隔离级别，结果如下：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img2.png" class="">

<p>因为 MySQL 默认是事务自动提交，这里我们还需要将 autocommit 参数设置为 0，命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然后我们再来查看 SESSION 中的 autocommit 取值，结果如下：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img3.png" class="">

<p>接着我们以同样的操作启动客户端 2，也就是将隔离级别设置为<code>READ UNCOMMITTED</code>（读未提交），<code>autocommit</code>设置为 0。</p>
<h2 id="模拟“脏读”"><a href="#模拟“脏读”" class="headerlink" title="模拟“脏读”"></a>模拟“脏读”</h2><p>我们在客户端 2 中开启一个事务，在<code>heros_temp</code>表中写入一个新的英雄“吕布”，注意这个时候不要提交。</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img4.png" class="">

<p>然后我们在客户端 1 中，查看当前的英雄表：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img5.png" class="">

<p>你能发现客户端 1 中读取了客户端 2 未提交的新英雄“吕布”，实际上客户端 2 可能马上回滚，从而造成了“脏读”。</p>
<h2 id="模拟“不可重复读”"><a href="#模拟“不可重复读”" class="headerlink" title="模拟“不可重复读”"></a>模拟“不可重复读”</h2><p>我们用客户端 1 来查看<code>id=1</code>的英雄：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img6.png" class="">

<p>然后用客户端 2 对<code>id=1</code>的英雄姓名进行修改：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img7.png" class="">

<p>这时用客户端 1 再次进行查询：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img8.png" class="">

<p>你能发现对于客户端 1 来说，同一条查询语句出现了“不可重复读”。</p>
<h2 id="模拟“幻读”"><a href="#模拟“幻读”" class="headerlink" title="模拟“幻读”"></a>模拟“幻读”</h2><p>我们先用客户端 1 查询数据表中的所有英雄：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img9.png" class="">

<p>然后用客户端 2，开始插入新的英雄“吕布”：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img10.png" class="">

<p>这时，我们再用客户端 1 重新进行查看：</p>
<img src="/2020/03/05/SQL/SQL%20%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/img11.png" class="">

<p>你会发现数据表多出一条数据。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 查询优化器工作原理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"
    >SQL 查询优化器工作原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2020-03-04T05:24:06.000Z" itemprop="datePublished">2020-03-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>我们总是希望数据库可以运行得更快，也就是响应时间更快，吞吐量更大。想要达到这样的目的，我们一方面需要高并发的事务处理能力，另一方面需要创建合适的索引，让数据的查找效率最大化。事务和索引的使用是数据库中的两个重要核心，事务可以让数据库在增删查改的过程中，保证数据的正确性和安全性，而索引可以帮数据库提升数据的查找效率。</p>
<p>如果我们想要知道如何获取更高的 SQL 查询性能，最好的方式就是理解数据库是如何进行查询优化和执行的。</p>
<h1 id="什么是查询优化器"><a href="#什么是查询优化器" class="headerlink" title="什么是查询优化器"></a>什么是查询优化器</h1><p>了解查询优化器的作用之前，我们先来看看一条 SQL 语句的执行都需要经历哪些环节，如下图所示：</p>
<img src="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img1.png" class="">

<p>一条 SQL 查询语句首先会经过分析器，进行语法分析和语义检查。语法分析是检查 SQL 拼写和语法是否正确，语义检查是检查 SQL 中的访问对象是否存在。比如我们在写<code>SELECT</code>语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查可以保证 SQL 语句没有错误，最终得到一棵语法分析树，然后经过查询优化器得到查询计划，最后交给执行器进行执行。</p>
<p>查询优化器的目标是找到执行 SQL 查询的最佳执行计划，执行计划就是查询树，它由一系列物理操作符组成，这些操作符按照一定的运算关系组成查询的执行计划。在查询优化器中，可以分为逻辑查询优化阶段和物理查询优化阶段。</p>
<p>逻辑查询优化就是通过改变 SQL 语句的内容来使得 SQL 查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对 SQL 语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p>
<p>逻辑查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。</p>
<img src="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img2.png" class="">

<p>在这两个阶段中，查询重写属于代数级、语法级的优化，也就是属于逻辑范围内的优化，而基于代价的估算模型是从连接路径中选择代价最小的路径，属于物理层面的优化。</p>
<h2 id="查询优化器的两种优化方式"><a href="#查询优化器的两种优化方式" class="headerlink" title="查询优化器的两种优化方式"></a>查询优化器的两种优化方式</h2><p>查询优化器的目的就是生成最佳的执行计划，而生成最佳执行计划的策略通常有以下两种方式。</p>
<p>第一种是基于规则的优化器（<code>RBO，Rule-Based Optimizer</code>），规则就是人们以往的经验，或者是采用已经被证明是有效的方式。通过在优化器里面嵌入规则，来判断 SQL 查询符合哪种规则，就按照相应的规则来制定执行计划，同时采用启发式规则去掉明显不好的存取路径。</p>
<p>第二种是基于代价的优化器（<code>CBO，Cost-Based Optimizer</code>），这里会根据代价评估模型，计算每条可能的执行计划的代价，也就是 COST，从中选择代价最小的作为执行计划。相比于 RBO 来说，CBO 对数据更敏感，因为它会利用数据表中的统计信息来做判断，针对不同的数据表，查询得到的执行计划可能是不同的，因此制定出来的执行计划也更符合数据表的实际情况。</p>
<p>但我们需要记住，SQL 是面向集合的语言，并没有指定执行的方式，因此在优化器中会存在各种组合的可能。我们需要通过优化器来制定数据表的扫描方式、连接方式以及连接顺序，从而得到最佳的 SQL 执行计划。</p>
<p>RBO 的方式更像是一个出租车老司机，凭借自己的经验来选择从 A 到 B 的路径。而 CBO 更像是手机导航，通过数据驱动，来选择最佳的执行路径。</p>
<h2 id="CBO-是如何统计代价的"><a href="#CBO-是如何统计代价的" class="headerlink" title="CBO 是如何统计代价的"></a>CBO 是如何统计代价的</h2><p>大部分 RDBMS 都支持基于代价的优化器（CBO），CBO 随着版本的迭代也越来越成熟，但是 CBO 依然存在缺陷。通过对 CBO 工作原理的了解，我们可以知道 CBO 可能存在的不足有哪些，有助于让我们知道优化器是如何确定执行计划的。</p>
<h2 id="能调整的代价模型的参数有哪些"><a href="#能调整的代价模型的参数有哪些" class="headerlink" title="能调整的代价模型的参数有哪些"></a>能调整的代价模型的参数有哪些</h2><p>MySQL 中的 COST Model就是优化器用来统计各种步骤的代价模型，在 5.7.10 版本之后，MySQL 会引入两张数据表，里面规定了各种步骤预估的代价（Cost Value），我们可以从<code>mysql.server_cost</code>和<code>mysql.engine_cost</code>这两张表中获得这些步骤的代价：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.server_cost</span><br></pre></td></tr></table></figure>

<img src="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img3.png" class="">

<p><code>server_cost</code>数据表是在<code>server</code>层统计的代价，具体的参数含义如下：</p>
<ol>
<li><code>disk_temptable_create_cost</code>，表示临时表文件（MyISAM 或 InnoDB）的创建代价，默认值为 20。</li>
<li><code>disk_temptable_row_cost</code>，表示临时表文件（MyISAM 或 InnoDB）的行代价，默认值 0.5。</li>
<li><code>key_compare_cost</code>，表示键比较的代价。键比较的次数越多，这项的代价就越大，这是一个重要的指标，默认值 0.05。</li>
<li><code>memory_temptable_create_cost</code>，表示内存中临时表的创建代价，默认值 1。</li>
<li><code>memory_temptable_row_cost</code>，表示内存中临时表的行代价，默认值 0.1。</li>
<li><code>row_evaluate_cost</code>，统计符合条件的行代价，如果符合条件的行数越多，那么这一项的代价就越大，因此这是个重要的指标，默认值 0.1。</li>
</ol>
<p>由这张表中可以看到，如果想要创建临时表，尤其是在磁盘中创建相应的文件，代价还是很高的。</p>
<p>然后我们看下在存储引擎层都包括了哪些代价：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span> <span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.engine_cost</span><br></pre></td></tr></table></figure>
<img src="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img4.png" class="">

<p><code>engine_cost</code>主要统计了页加载的代价，一个页的加载根据页所在位置的不同，读取的位置也不同，可以从磁盘 I&#x2F;O 中获取，也可以从内存中读取。因此在<code>engine_cost</code>数据表中对这两个读取的代价进行了定义：</p>
<ul>
<li><code>io_block_read_cost</code>，从磁盘中读取一页数据的代价，默认是 1。</li>
<li><code>memory_block_read_cost</code>，从内存中读取一页数据的代价，默认是 0.25。</li>
</ul>
<p>既然 MySQL 将这些代价参数以数据表的形式呈现给了我们，我们就可以根据实际情况去修改这些参数。因为随着硬件的提升，各种硬件的性能对比也可能发生变化，比如针对普通硬盘的情况，可以考虑适当增加<code>io_block_read_cost</code>的数值，这样就代表从磁盘上读取一页数据的成本变高了。当我们执行全表扫描的时候，相比于范围查询，成本也会增加很多。</p>
<p>比如我想将<code>io_block_read_cost</code>参数设置为 2.0，那么使用下面这条命令就可以：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.engine_cost</span><br><span class="line">  <span class="keyword">SET</span> cost_value <span class="operator">=</span> <span class="number">2.0</span></span><br><span class="line">  <span class="keyword">WHERE</span> cost_name <span class="operator">=</span> <span class="string">&#x27;io_block_read_cost&#x27;</span>;</span><br><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure>

<img src="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img5.png" class="">

<p>我们对<code>mysql.engine_cost</code>中的<code>io_block_read_cost</code>参数进行了修改，然后使用<code>FLUSH OPTIMIZER_COSTS</code>更新内存，然后再查看<code>engine_cost</code>数据表，发现<code>io_block_read_cost</code>参数中的<code>cost_value</code>已经调整为 2.0。</p>
<p>如果我们想要专门针对某个存储引擎，比如 InnoDB 存储引擎设置<code>io_block_read_cost</code>，比如设置为 2，可以这样使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.engine_cost(engine_name, device_type, cost_name, cost_value, last_update, comment)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="string">&#x27;InnoDB&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;io_block_read_cost&#x27;</span>, <span class="number">2</span>,</span><br><span class="line">  <span class="built_in">CURRENT_TIMESTAMP</span>, <span class="string">&#x27;Using a slower disk for InnoDB&#x27;</span>);</span><br><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure>
<p>然后我们再查看一下<code>mysql.engine_cost</code>数据表：</p>
<img src="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img6.png" class="">

<p>从图中你能看到针对 InnoDB 存储引擎可以设置专门的<code>io_block_read_cost</code>参数值。</p>
<h2 id="代价模型如何计算"><a href="#代价模型如何计算" class="headerlink" title="代价模型如何计算"></a>代价模型如何计算</h2><p>总代价的计算是一个比较复杂的过程，上面只是列出了一些常用的重要参数，我们可以根据情况对它们进行调整，也可以使用默认的系统参数值。</p>
<p>那么总的代价是如何进行计算的呢？计算模型，如下图所示：</p>
<img src="/2020/03/04/SQL/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/img7.png" class="">

<p>你可以简单地认为，总的执行代价等于 I&#x2F;O 代价 +CPU 代价。在这里<code>PAGE FETCH</code>就是 I&#x2F;O 代价，也就是页面加载的代价，包括数据页和索引页加载的代价。<code>W*(RSI CALLS)</code>就是 CPU 代价。<code>W</code>在这里是个权重因子，表示了 CPU 到 I&#x2F;O 之间转化的相关系数，<code>RSI CALLS</code>代表了 CPU 的代价估算，包括了键比较（<code>compare key</code>）以及行估算（<code>row evaluating</code>）的代价。</p>
<p>关于<code>W</code>和<code>RSI CALLS</code>的英文解释：<code>W is an adjustable weight between I/O and CPU utilization. The number of RSI calls is used to approximate CPU utilization</code>。</p>
<p>另外需要说明的是，在 MySQL5.7 版本之后，代价模型又进行了完善，不仅考虑到了 I&#x2F;O 和 CPU 开销，还对内存计算和远程操作的代价进行了统计，也就是说总代价的计算公式演变成下面这样：</p>
<p>总代价 &#x3D; I&#x2F;O 代价 + CPU 代价 + 内存代价 + 远程代价</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 范式设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/02/SQL/SQL%20%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/"
    >SQL 范式设计</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/02/SQL/SQL%20%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-03-02T08:24:06.000Z" itemprop="datePublished">2020-03-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>范式是数据表设计的基本原则，又很容易被忽略。很多时候，当数据库运行了一段时间之后，我们才发现数据表设计得有问题。重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站正常的访问。所以在开始设置数据库的时候，我们就需要重视数据表的设计。</p>
<h1 id="数据库的设计范式都包括哪些"><a href="#数据库的设计范式都包括哪些" class="headerlink" title="数据库的设计范式都包括哪些"></a>数据库的设计范式都包括哪些</h1><p>我们在设计关系型数据库模型的时候，需要对关系内部各个属性之间联系的合理化程度进行定义，这就有了不同等级的规范要求，这些规范要求被称为范式（NF）。你可以把范式理解为，一张数据表的设计结构需要满足的某种设计标准的级别。</p>
<p>目前关系型数据库一共有 6 种范式，按照范式级别，从低到高分别是：1NF（第一范式）、2NF（第二范式）、3NF（第三范式）、BCNF（巴斯 - 科德范式）、4NF（第四范式）和 5NF（第五范式，又叫做完美范式）。</p>
<p>数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，比如满足 2NF 的一定满足 1NF，满足 3NF 的一定满足 2NF，依次类推。</p>
<p>你可能会问，这么多范式是不是都要掌握呢？</p>
<p>一般来说数据表的设计应尽量满足 3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。</p>
<img src="/2020/03/02/SQL/SQL%20%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/img1.jpeg" class="">

<h1 id="数据表中的那些键"><a href="#数据表中的那些键" class="headerlink" title="数据表中的那些键"></a>数据表中的那些键</h1><p>范式的定义会使用到主键和候选键（因为主键和候选键可以唯一标识元组），数据库中的键（Key）由一个或者多个属性组成。数据表中常用的几种键和属性的定义：</p>
<ul>
<li>超键：能唯一标识元组的属性集叫做超键。</li>
<li>候选键：如果超键不包括多余的属性，那么这个超键就是候选键。</li>
<li>主键：用户可以从候选键中选择一个作为主键。</li>
<li>外键：如果数据表 R1 中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1 的外键。</li>
<li>主属性：包含在任一候选键中的属性称为主属性。</li>
<li>非主属性：与主属性相对，指的是不包含在任何一个候选键中的属性。</li>
</ul>
<p>通常，我们也将候选键称之为“码”，把主键也称为“主码”。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。</p>
<p>比如有一个 NBA 的球员表（<code>player</code>）和球队表（<code>team</code>）。这里我可以把球员表定义为包含球员编号、姓名、身份证号、年龄和球队编号；球队表包含球队编号、主教练和球队所在地。</p>
<p>对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。</p>
<p>候选键就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</p>
<p>主键是我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</p>
<p>外键就是球员表中的球队编号。</p>
<p>在<code>player</code>表中，主属性是（球员编号）（身份证号），其他的属性（姓名）（年龄）（球队编号）都是非主属性。</p>
<h1 id="从-1NF-到-3NF"><a href="#从-1NF-到-3NF" class="headerlink" title="从 1NF 到 3NF"></a>从 1NF 到 3NF</h1><p>1NF 指的是数据库表中的任何属性都是原子性的，不可再分。这很好理解，我们在设计某个字段的时候，对于字段 X 来说，就不能把字段 X 拆分成字段 X-1 和字段 X-2。事实上，任何的 DBMS 都会满足第一范式的要求，不会将字段进行拆分。</p>
<p>2NF 指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系。所谓完全依赖不同于部分依赖，也就是不能仅依赖候选键的一部分属性，而必须依赖全部属性。</p>
<p>这里我举一个没有满足 2NF 的例子，比如说我们设计一张球员比赛表<code>player_game</code>，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键来决定如下的关系：</p>
<p>(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</p>
<p>上面这个关系说明球员编号和比赛编号的组合决定了球员的姓名、年龄、比赛时间、比赛地点和该比赛的得分数据。</p>
<p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的对应关系：</p>
<p>(球员编号) → (姓名，年龄)</p>
<p>(比赛编号) → (比赛时间, 比赛场地)</p>
<p>也就是说候选键中的某个字段决定了非主属性。你也可以理解为，对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p>
<ol>
<li>数据冗余：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。</li>
<li>插入异常：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。</li>
<li>删除异常：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。</li>
<li>更新异常：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调整，否则就会出现一场比赛时间不同的情况。</li>
</ol>
<p>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。</p>
<p>球员<code>player</code>表包含球员编号、姓名和年龄等属性；比赛<code>game</code>表包含比赛编号、比赛时间和比赛场地等属性；球员比赛关系<code>player_game</code>表包含球员编号、比赛编号和得分等属性。</p>
<p>这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。某种程度上 2NF 是对 1NF 原子性的升级。1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，也就是说一张表只表达一个意思。</p>
<p>3NF 在满足 2NF 的同时，对任何非主属性都不传递依赖于候选键。也就是说不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于候选键的情况。</p>
<p>我们用球员<code>player</code>表举例子，这张表包含的属性包括球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出来，如下图所示：</p>
<img src="/2020/03/02/SQL/SQL%20%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/img2.jpeg" class="">

<p>你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依赖于球员编号，因此不符合 3NF 的要求。</p>
<p>如果要达到 3NF 的要求，需要把数据表拆成下面这样：</p>
<p>球员表的属性包括球员编号、姓名和球队名称；球队表的属性包括球队名称、球队主教练。</p>
<p>总结，1NF 需要保证表中每个属性都保持原子性；2NF 需要保证表中的非主属性与候选键完全依赖；3NF 需要保证表中的非主属性与候选键不存在传递依赖。</p>
<h1 id="BCNF（巴斯范式）"><a href="#BCNF（巴斯范式）" class="headerlink" title="BCNF（巴斯范式）"></a>BCNF（巴斯范式）</h1><p>如果数据表的关系模式符合 3NF 的要求，就不存在问题了吗？我们来看下这张仓库管理关系<code>warehouse_keeper</code>表：</p>
<table>
<thead>
<tr>
<th align="center">仓库名</th>
<th align="center">管理员</th>
<th align="center">物品名</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">北京仓</td>
<td align="center">张三</td>
<td align="center">iphone XR</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">北京仓</td>
<td align="center">张三</td>
<td align="center">iphone7</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">上海仓</td>
<td align="center">李四</td>
<td align="center">iphone 7p</td>
<td align="center">30</td>
</tr>
<tr>
<td align="center">上海仓</td>
<td align="center">李四</td>
<td align="center">iphone8</td>
<td align="center">40</td>
</tr>
</tbody></table>
<p>在这个数据表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。</p>
<p>仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个属性。</p>
<p>这样，我们就可以找到数据表的候选键是（管理员，物品名）和（仓库名，物品名），</p>
<p>然后我们从候选键中选择一个作为主键，比如（仓库名，物品名）。</p>
<p>在这里，主属性是包含在任一候选键中的属性，也就是仓库名，管理员和物品名。非主属性是数量这个属性。</p>
<p>如何判断一张表的范式呢？我们需要根据范式的等级，从低到高来进行判断。</p>
<p>首先，数据表每个属性都是原子性的，符合 1NF 的要求；其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量，因此，数据表符合 2NF 的要求；最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。</p>
<p>既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？我们来看下下面的情况：</p>
<p>增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现插入异常；<br>如果仓库更换了管理员，我们就可能会修改数据表中的多条记录；<br>如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。<br>你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。</p>
<p>这种情况下该怎么解决呢？</p>
<p>首先我们需要确认造成异常的原因：主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系，这样就有可能导致上面的异常情况。人们在 3NF 的基础上进行了改进，提出了BCNF，也叫做巴斯 - 科德范式，它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</p>
<p>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：</p>
<p>仓库表：（仓库名，管理员）</p>
<p>库存表：（仓库名，物品名，数量）</p>
<p>这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。</p>
<h1 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h1><p>尽管围绕着数据表的设计有很多范式，但事实上，我们在设计数据表的时候却不一定要参照这些标准。</p>
<p>我们在之前已经了解了越高阶的范式得到的数据表越多，数据冗余度越低。但有时候，我们在设计数据表的时候，还需要为了性能和读取效率违反范式化的原则。反范式就是相对范式化而言的，换句话说，就是允许少量的冗余，通过空间来换时间。</p>
<p>如果我们想对查询效率进行优化，有时候反范式优化也是一种优化思路。</p>
<p>比如我们想要查询某个商品的前 1000 条评论，会涉及到两张表。</p>
<p>商品评论表<code>product_comment</code>，对应的字段名称及含义如下：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">comment_id</th>
<th align="center">product_id</th>
<th align="center">comment_text</th>
<th align="center">comment_time</th>
<th align="center">user_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">商品评论ID</td>
<td align="center">商品ID</td>
<td align="center">评论内容</td>
<td align="center">评论时间</td>
<td align="center">用户ID</td>
</tr>
</tbody></table>
<p>用户表<code>user</code>，对应的字段名称及含义如下：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">uer_id</th>
<th align="center">user_name</th>
<th align="center">create_time</th>
</tr>
</thead>
<tbody><tr>
<td align="center">含义</td>
<td align="center">用户ID</td>
<td align="center">用户昵称</td>
<td align="center">注册时间</td>
</tr>
</tbody></table>
<p>下面，我们就用这两张表模拟一下反范式优化。</p>
<h2 id="实验数据：模拟两张百万量级的数据表"><a href="#实验数据：模拟两张百万量级的数据表" class="headerlink" title="实验数据：模拟两张百万量级的数据表"></a>实验数据：模拟两张百万量级的数据表</h2><p>为了更好地进行 SQL 优化实验，我们需要给用户表和商品评论表随机模拟出百万量级的数据。我们可以通过存储过程来实现模拟数据。</p>
<p>下面是给用户表随机生成 100 万用户的代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `insert_many_user`(<span class="keyword">IN</span> <span class="keyword">start</span> <span class="type">INT</span>(<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> date_start DATETIME <span class="keyword">DEFAULT</span> (<span class="string">&#x27;2017-01-01 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> date_temp DATETIME;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> date_start;</span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> date_add(date_temp, <span class="type">interval</span> RAND()<span class="operator">*</span><span class="number">60</span> <span class="keyword">second</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(user_id, user_name, create_time)</span><br><span class="line"><span class="keyword">VALUES</span>((<span class="keyword">start</span><span class="operator">+</span>i), CONCAT(<span class="string">&#x27;user_&#x27;</span>,i), date_temp);</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>我用<code>date_start</code>变量来定义初始的注册时间，时间为 2017 年 1 月 1 日 0 点 0 分 0 秒，然后用<code>date_temp</code>变量计算每个用户的注册时间，新的注册用户与上一个用户注册的时间间隔为 60 秒内的随机值。然后使用<code>REPEAT … UNTIL … END REPEAT</code>循环，对<code>max_num</code>个用户的数据进行计算。在循环前，我们将<code>autocommit</code>设置为 0，这样等计算完成再统一插入，执行效率更高。</p>
<p>然后我们来运行<code>call insert_many_user(10000, 1000000);</code>调用存储过程。这里需要通过<code>start</code>和<code>max_num</code>两个参数对初始的<code>user_id</code>和要创建的用户数量进行设置。运行结果：</p>
<img src="/2020/03/02/SQL/SQL%20%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/img3.png" class="">

<p>你能看到在 MySQL 里，创建 100 万的用户数据用时 1 分 37 秒。</p>
<p>接着我们再来给商品评论表<code>product_comment</code>随机生成 100 万条商品评论。这里我们设置为给某一款商品评论，比如<code>product_id=10001</code>。评论的内容为随机的 20 个字母。以下是创建随机的 100 万条商品评论的存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `insert_many_product_comments`(<span class="keyword">IN</span> <span class="keyword">START</span> <span class="type">INT</span>(<span class="number">10</span>), <span class="keyword">IN</span> max_num <span class="type">INT</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> date_start DATETIME <span class="keyword">DEFAULT</span> (<span class="string">&#x27;2018-01-01 00:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> date_temp DATETIME;</span><br><span class="line"><span class="keyword">DECLARE</span> comment_text <span class="type">VARCHAR</span>(<span class="number">25</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> user_id <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> date_start;</span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> date_temp <span class="operator">=</span> date_add(date_temp, <span class="type">INTERVAL</span> RAND()<span class="operator">*</span><span class="number">60</span> <span class="keyword">SECOND</span>);</span><br><span class="line"><span class="keyword">SET</span> comment_text <span class="operator">=</span> substr(MD5(RAND()),<span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">SET</span> user_id <span class="operator">=</span> <span class="built_in">FLOOR</span>(RAND()<span class="operator">*</span><span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_comment(comment_id, product_id, comment_text, comment_time, user_id)</span><br><span class="line"><span class="keyword">VALUES</span>((<span class="keyword">START</span><span class="operator">+</span>i), <span class="number">10001</span>, comment_text, date_temp, user_id);</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>同样的，我用<code>date_start</code>变量来定义初始的评论时间。这里新的评论时间与上一个评论的时间间隔还是 60 秒内的随机值，商品评论表中的<code>user_id</code>为随机值。我们使用<code>REPEAT … UNTIL … END REPEAT</code>循环，来对<code>max_num</code>个商品评论的数据进行计算。</p>
<p>然后调用存储过程，运行结果如下：</p>
<img src="/2020/03/02/SQL/SQL%20%E8%8C%83%E5%BC%8F%E8%AE%BE%E8%AE%A1/img4.png" class="">

<p>MySQL 一共花了 2 分 7 秒完成了商品评论数据的创建。</p>
<h2 id="反范式优化实验对比"><a href="#反范式优化实验对比" class="headerlink" title="反范式优化实验对比"></a>反范式优化实验对比</h2><p>如果我们想要查询某个商品<code>ID</code>，比如 10001 的前 1000 条评论，需要写成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.comment_text, p.comment_time, u.user_name <span class="keyword">FROM</span> product_comment <span class="keyword">AS</span> p </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">user</span> <span class="keyword">AS</span> u </span><br><span class="line"><span class="keyword">ON</span> p.user_id <span class="operator">=</span> u.user_id </span><br><span class="line"><span class="keyword">WHERE</span> p.product_id <span class="operator">=</span> <span class="number">10001</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> p.comment_id <span class="keyword">DESC</span> LIMIT <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>运行结果（1000 条数据行）：</p>
<table>
<thead>
<tr>
<th align="center">comment_text</th>
<th align="center">comment_time</th>
<th align="center">user_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">462eed7ac6e79129a79</td>
<td align="center">2018-12-14 04:53:25</td>
<td align="center">user_546655</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">52f6a51769daf701bc68</td>
<td align="center">2018-12-13 20:35:28</td>
<td align="center">user_698675</td>
</tr>
</tbody></table>
<p>运行时长为 0.395 秒，查询效率并不高。</p>
<p>这是因为在实际生活中，我们在显示商品评论的时候，通常会显示这个用户的昵称，而不是用户<code>ID</code>，因此我们还需要关联<code>product_comment</code>和<code>user</code>这两张表来进行查询。当表数据量不大的时候，查询效率还好，但如果表数据量都超过了百万量级，查询效率就会变低。这是因为查询会在<code>product_comment</code>表和<code>user</code>表这两个表上进行聚集索引扫描，然后再嵌套循环，这样一来查询所耗费的时间就有几百毫秒甚至更多。对于网站的响应来说，这已经很慢了，用户体验会非常差。</p>
<p>如果我们想要提升查询的效率，可以允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段，在<code>product_comment</code>数据表的基础上增加<code>user_name</code>字段，就得到了<code>product_comment2</code>数据表。</p>
<p>你可以在百度网盘中下载这三张数据表<code>product_comment、product_comment2</code>和<code>user</code>表，密码为<code>n3l8</code>。</p>
<p>这样一来，只需单表查询就可以得到数据集结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_text, comment_time, user_name <span class="keyword">FROM</span> product_comment2 <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">10001</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> comment_id <span class="keyword">DESC</span> LIMIT <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>优化之后只需要扫描一次聚集索引即可，运行时间为 0.039 秒，查询时间是之前的 1&#x2F;10。 你能看到，在数据量大的情况下，查询效率会有显著的提升。</p>
<h2 id="反范式存在的问题-amp-适用场景"><a href="#反范式存在的问题-amp-适用场景" class="headerlink" title="反范式存在的问题 &amp; 适用场景"></a>反范式存在的问题 &amp; 适用场景</h2><p>从上面的例子中可以看出，反范式可以通过空间换时间，提升查询的效率，但是反范式也会带来一些新问题。</p>
<p>在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂。比如采用存储过程来支持数据的更新、删除等额外操作，很容易增加系统的维护成本。</p>
<p>比如用户每次更改昵称的时候，都需要执行存储过程来更新，如果昵称更改频繁，会非常消耗系统资源。</p>
<p>那么反范式优化适用于哪些场景呢？</p>
<p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</p>
<p>当冗余信息有价值或者能大幅度提高查询效率的时候，我们就可以采取反范式的优化。</p>
<p>此外反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p>
<p>数据仓库和数据库在使用上的区别：</p>
<ul>
<li>数据库设计的目的在于捕获数据，而数据仓库设计的目的在于分析数据；</li>
<li>数据库对数据的增删改实时性要求强，需要存储在线的用户数据，而数据仓库存储的一般是历史数据；</li>
<li>数据库设计需要尽量避免冗余，但为了提高查询效率也允许一定的冗余度，而数据仓库在设计上更偏向采用反范式设计。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/浏览器工作原理——HTTP演进"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/"
    >浏览器工作原理——HTTP演进</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/" class="article-date">
  <time datetime="2020-03-02T03:26:19.000Z" itemprop="datePublished">2020-03-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>学习 HTTP 的最佳途径就是了解其发展史，所以接下来，从浏览器发展的视角来和你聊聊 HTTP 演进。下面分别是即将完成使命的 HTTP&#x2F;1、正在向我们走来的 HTTP&#x2F;2，以及未来的 HTTP&#x2F;3。</p>
<h1 id="超文本传输协议-HTTP-x2F-0-9"><a href="#超文本传输协议-HTTP-x2F-0-9" class="headerlink" title="超文本传输协议 HTTP&#x2F;0.9"></a>超文本传输协议 HTTP&#x2F;0.9</h1><p>HTTP&#x2F;0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为超文本传输协议。整体来看，它的实现也很简单，采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。</p>
<p>下面我们就来看看 HTTP&#x2F;0.9 的一个完整的请求流程。</p>
<ul>
<li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li>
<li>建立好连接之后，会发送一个 GET 请求行的信息，如<code>GET /index.html</code>用来获取<code>index.html</code>。</li>
<li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li>
<li>HTML 文档传输完成后，断开连接。</li>
</ul>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img1.png" class="" title="HTTP&#x2F;0.9 请求流程">

<p>总的来说，当时的需求很简单，就是用来传输体积很小的 HTML 文件，所以 HTTP&#x2F;0.9 的实现有以下三个特点。</p>
<ul>
<li>第一个是只有一个请求行，并没有HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。</li>
<li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>
<li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li>
</ul>
<h1 id="被浏览器推动的-HTTP-x2F-1-0"><a href="#被浏览器推动的-HTTP-x2F-1-0" class="headerlink" title="被浏览器推动的 HTTP&#x2F;1.0"></a>被浏览器推动的 HTTP&#x2F;1.0</h1><p>万维网的高速发展带来了很多新的需求，而 HTTP&#x2F;0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP&#x2F;1.0 诞生的原因。不过在详细分析 HTTP&#x2F;1.0 之前，我们先来分析下新兴网络都带来了哪些新需求。</p>
<p>首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP&#x2F;1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</p>
<p>那么该如何实现多种类型文件的下载呢？</p>
<p>HTTP 是浏览器和服务器之间的通信语言，不过 HTTP&#x2F;0.9 在建立好连接之后，只会发送类似<code>GET /index.html</code>的简单请求命令，并没有其他途径告诉服务器更多的信息，如文件编码、文件类型等。同样，服务器是直接返回数据给浏览器的，也没有其他途径告诉浏览器更多的关于服务器返回的文件信息。</p>
<p>这种简单的交流型形式无疑不能满足传输多种类型文件的需求，那为了让客户端和服务器能更深入地交流，HTTP&#x2F;1.0 引入了请求头和响应头，它们都是以为<code>Key-Value</code>形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP&#x2F;1.0 具体的请求流程，你可以参考下图。</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img2.png" class="" title="HTTP&#x2F;1.0 的请求流程">

<p>有了请求头和响应头，浏览器和服务器就能进行更加深入的交流了。</p>
<p>那 HTTP&#x2F;1.0 是怎么通过请求头和响应头来支持多种不同类型的数据呢？</p>
<p>要支持多种类型的文件，我们就需要解决以下几个问题。</p>
<ul>
<li>首先，浏览器需要知道服务器返回的数据是什么类型的，然后浏览器才能根据不同的数据类型做针对性的处理。</li>
<li>其次，由于万维网所支持的应用变得越来越广，所以单个文件的数据量也变得越来越大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。</li>
<li>再次，由于万维网是支持全球范围的，所以需要提供国际化的支持，服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面。</li>
<li>最后，由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。</li>
</ul>
<p>基于以上问题，HTTP&#x2F;1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accept: text/html</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-Charset: ISO-8859-1,utf-8</span><br><span class="line">accept-language: zh-CN,zh</span><br></pre></td></tr></table></figure>
<p>其中第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用<code>gzip、deflate</code>或者<code>br</code>其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1，第四行是表示期望页面的优先语言是中文。</p>
<p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是<code>gzip</code>，但是服务器不支持<code>gzip</code>，只支持<code>br</code>压缩，那么它会通过响应头中的<code>content-encoding</code>字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content-encoding: br</span><br><span class="line">content-type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>
<p>其中第一行表示服务器采用了<code>br</code>的压缩方法，第二行表示服务器返回的是<code>html</code>文件，并且该文件的编码类型是 UTF-8。</p>
<p>有了响应头的信息，浏览器就会使用<code>br</code>方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP&#x2F;1.0 支持多文件的一个基本的处理流程。</p>
<p>HTTP&#x2F;1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性：</p>
<p>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。<br>为了减轻服务器的压力，在 HTTP&#x2F;1.0 中提供了<code>Cache</code>机制，用来缓存已经下载过的数据。<br>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP&#x2F;1.0 的请求头中还加入了用户代理的字段。</p>
<h1 id="缝缝补补的-HTTP-x2F-1-1"><a href="#缝缝补补的-HTTP-x2F-1-1" class="headerlink" title="缝缝补补的 HTTP&#x2F;1.1"></a>缝缝补补的 HTTP&#x2F;1.1</h1><p>不过随着技术的继续发展，需求也在不断迭代更新，很快 HTTP&#x2F;1.0 也不能满足需求了，所以 HTTP&#x2F;1.1 又在 HTTP&#x2F;1.0 的基础之上做了大量的更新。</p>
<h2 id="1-改进持久连接"><a href="#1-改进持久连接" class="headerlink" title="1. 改进持久连接"></a>1. 改进持久连接</h2><p>HTTP&#x2F;1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img3.png" class="" title="HTTP&#x2F;1.0 的短连接">

<p>在当时，由于通信的文件比较小，而且每个页面的引用也不多，所以这种传输形式没什么大问题。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。</p>
<p>为了解决这个问题，HTTP&#x2F;1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img4.png" class="" title="HTTP&#x2F;1.0 的持久连接">

<p>从上图可以看出，HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。</p>
<p>持久连接在 HTTP&#x2F;1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上<code>Connection: close</code>。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p>
<h2 id="2-提供虚拟主机的支持"><a href="#2-提供虚拟主机的支持" class="headerlink" title="2. 提供虚拟主机的支持"></a>2. 提供虚拟主机的支持</h2><p>在 HTTP&#x2F;1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p>
<p>因此，HTTP&#x2F;1.1 的请求头中增加了<code>Host</code>字段，用来表示当前的域名地址，这样服务器就可以根据不同的<code>Host</code>值做不同的处理。</p>
<h2 id="3-对动态生成的内容提供了完美支持"><a href="#3-对动态生成的内容提供了完美支持" class="headerlink" title="3. 对动态生成的内容提供了完美支持"></a>3. 对动态生成的内容提供了完美支持</h2><p>在设计 HTTP&#x2F;1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p>
<p>HTTP&#x2F;1.1 通过引入<code>Chunk transfer</code>机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p>
<h2 id="4-客户端-Cookie、安全机制"><a href="#4-客户端-Cookie、安全机制" class="headerlink" title="4. 客户端 Cookie、安全机制"></a>4. 客户端 Cookie、安全机制</h2><p>除此之外，HTTP&#x2F;1.1 还引入了客户端 Cookie 机制和安全机制。</p>
<h1 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h1><h2 id="HTTP-x2F-1-1-的主要问题"><a href="#HTTP-x2F-1-1-的主要问题" class="headerlink" title="HTTP&#x2F;1.1 的主要问题"></a>HTTP&#x2F;1.1 的主要问题</h2><p>虽然 HTTP&#x2F;1.1 采取了很多优化资源加载速度的策略，也取得了一定的效果，但是 HTTP&#x2F;1.1对带宽的利用率却并不理想，这也是 HTTP&#x2F;1.1 的一个核心问题。</p>
<p>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</p>
<p>之所以说 HTTP&#x2F;1.1 对带宽的利用率不理想，是因为 HTTP&#x2F;1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M&#x2F;S，而采用 HTTP&#x2F;1.1 时，也许在加载页面资源时最大只能使用到 2.5M&#x2F;S，很难将 12.5M 全部用满。</p>
<p>之所以会出现这个问题，主要是由以下三个原因导致的。</p>
<h4 id="第一个原因，TCP-的慢启动。"><a href="#第一个原因，TCP-的慢启动。" class="headerlink" title="第一个原因，TCP 的慢启动。"></a>第一个原因，TCP 的慢启动。</h4><p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p>
<p>你可以把每个 TCP 发送数据的过程看成是一辆车的启动过程，当刚进入公路时，会有从 0 到一个稳定速度的提速过程，TCP 的慢启动就类似于该过程。</p>
<p>慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。</p>
<p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p>
<h4 id="第二个原因，同时开启了多条-TCP-连接，那么这些连接会竞争固定的带宽。"><a href="#第二个原因，同时开启了多条-TCP-连接，那么这些连接会竞争固定的带宽。" class="headerlink" title="第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。"></a>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</h4><p>你可以想象一下，系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p>
<p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p>
<h4 id="第三个原因，HTTP-x2F-1-1-队头阻塞的问题。"><a href="#第三个原因，HTTP-x2F-1-1-队头阻塞的问题。" class="headerlink" title="第三个原因，HTTP&#x2F;1.1 队头阻塞的问题。"></a>第三个原因，HTTP&#x2F;1.1 队头阻塞的问题。</h4><p>我们知道在 HTTP&#x2F;1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p>
<p>这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。</p>
<p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p>
<p>但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。</p>
<h2 id="HTTP-x2F-2-的多路复用"><a href="#HTTP-x2F-2-的多路复用" class="headerlink" title="HTTP&#x2F;2 的多路复用"></a>HTTP&#x2F;2 的多路复用</h2><p>HTTP&#x2F;1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP&#x2F;1.1 的机制导致的。</p>
<p>那么该如何去解决这些问题呢？</p>
<p>虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以我们就要想办法去规避 TCP 的慢启动和 TCP 连接之间的竞争问题。</p>
<p>基于此，HTTP&#x2F;2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。</p>
<p>另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP&#x2F;2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。</p>
<p>所以，HTTP&#x2F;2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题。可以参考下图：</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img5.png" class="" title="HTTP&#x2F;2 的多路复用">

<p>该图就是 HTTP&#x2F;2 最核心、最重要且最具颠覆性的多路复用机制。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p>
<p>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p>
<p>HTTP&#x2F;2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p>
<h2 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h2><p>现在我们知道为了解决 HTTP&#x2F;1.1 存在的问题，HTTP&#x2F;2 采用了多路复用机制，那 HTTP&#x2F;2 是怎么实现多路复用的呢？你可以先看下面这张图：</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img6.png" class="" title="HTTP&#x2F;2 协议栈">

<p>从图中可以看出，HTTP&#x2F;2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP&#x2F;2 的请求和接收过程。</p>
<ul>
<li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li>
<li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li>
<li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li>
<li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li>
<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>
<li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li>
</ul>
<p>从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。</p>
<p>HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP&#x2F;2 引入了二进制分帧层，不过 HTTP&#x2F;2 的语义和 HTTP&#x2F;1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用<code>Cookie</code>来保持登录状态，依然可以使用<code>Cache</code>来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着我们不需要为 HTTP&#x2F;2 去重建生态，并且 HTTP&#x2F;2 推广起来会也相对更轻松了。</p>
<h2 id="HTTP-x2F-2-其他特性"><a href="#HTTP-x2F-2-其他特性" class="headerlink" title="HTTP&#x2F;2 其他特性"></a>HTTP&#x2F;2 其他特性</h2><p>通过上面的分析，我们知道了多路复用是 HTTP&#x2F;2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP&#x2F;2 还附带实现了很多其他功能，下面我们就来简要了解下。</p>
<h4 id="1-可以设置请求的优先级"><a href="#1-可以设置请求的优先级" class="headerlink" title="1. 可以设置请求的优先级"></a>1. 可以设置请求的优先级</h4><p>我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。</p>
<p>为了解决这个问题，HTTP&#x2F;2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p>
<h4 id="2-服务器推送"><a href="#2-服务器推送" class="headerlink" title="2. 服务器推送"></a>2. 服务器推送</h4><p>除了设置请求的优先级外，HTTP&#x2F;2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p>
<h4 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h4><p>无论是 HTTP&#x2F;1.1 还是 HTTP&#x2F;2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP&#x2F;2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。</p>
<h1 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h1><p>HTTP&#x2F;2 的一个核心特性是使用了多路复用技术，因此它可以通过一个 TCP 连接来发送多个 URL 请求。多路复用技术能充分利用带宽，最大限度规避了 TCP 的慢启动所带来的问题，同时还实现了头部压缩、服务器推送等功能，使得页面资源的传输速度得到了大幅提升。在 HTTP&#x2F;1.1 时代，为了提升并行下载效率，浏览器为每个域名维护了 6 个 TCP 连接；而采用 HTTP&#x2F;2 之后，浏览器只需要为每个域名维护 1 个 TCP 持久连接，同时还解决了 HTTP&#x2F;1.1 队头阻塞的问题。</p>
<p>从目前的情况来看，HTTP&#x2F;2 似乎可以完美取代 HTTP&#x2F;1 了，不过 HTTP&#x2F;2 依然存在一些缺陷，于是就有了 HTTP&#x2F;3。我们先来看看 HTTP&#x2F;2 到底有什么缺陷。</p>
<h2 id="TCP-的队头阻塞"><a href="#TCP-的队头阻塞" class="headerlink" title="TCP 的队头阻塞"></a>TCP 的队头阻塞</h2><p>虽然 HTTP&#x2F;2 解决了应用层面的队头阻塞问题，不过和 HTTP&#x2F;1.1 一样，HTTP&#x2F;2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。你可以把 TCP 连接看成是两台计算机之前的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。</p>
<p>接下来我们就来分析下 HTTP&#x2F;1.1 协议栈中 TCP 是如何传输数据的。为直观理解，你可以参考下图：</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img7.png" class="" title="正常情况下的 TCP 传输数据过程">

<p>通过上图你会发现，从一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。</p>
<p>不过，如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。为了直观理解，你可以参考下图：</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img8.png" class="" title="TCP 丢包状态">

<p>我们就把在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。</p>
<p>那队头阻塞是怎么影响 HTTP&#x2F;2 传输的呢？首先我们来看正常情况下 HTTP&#x2F;2 是怎么传输多路请求的，为了直观理解，你可以参考下图：</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img9.png" class="" title="HTTP&#x2F;2 多路复用">

<p>通过该图，我们知道在 HTTP&#x2F;2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP&#x2F;1.1，使用 HTTP&#x2F;1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p>
<p>所以随着丢包率的增加，HTTP&#x2F;2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP&#x2F;1.1 的传输效率反而比 HTTP&#x2F;2 表现得更好。</p>
<h2 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h2><p>除了 TCP 队头阻塞之外，TCP 的握手过程也是影响传输效率的一个重要因素。</p>
<p>为了搞清楚 TCP 协议建立连接的延迟问题，我们还是先来了解下下网络延迟的概念，这会有助于你对后面内容的理解。网络延迟又称为 RTT（<code>Round Trip Time</code>）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT（如下图）。RTT 是反映网络性能的一个重要指标。</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img10.png" class="" title="网络延时">

<p>那建立 TCP 连接时，需要花费多少个 RTT 呢？下面我们来计算下。</p>
<p>我们知道 HTTP&#x2F;1 和 HTTP&#x2F;2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p>
<ol>
<li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li>
<li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT。</li>
</ol>
<p>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。这个时间也许用户还可以接受，但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到“慢”了。</p>
<h2 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h2><p>现在我们知道了 TCP 协议存在队头阻塞和建立连接延迟等缺点，那我们是不是可以通过改进 TCP 协议来解决这些问题呢？</p>
<p>答案是：非常困难。之所以这样，主要有两个原因。</p>
<p>第一个是中间设备的僵化。要搞清楚什么是中间设备僵化，我们先要弄明白什么是中间设备。我们知道互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备。</p>
<p>这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。</p>
<p>所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p>
<p>除了中间设备僵化外，操作系统也是导致 TCP 协议僵化的另外一个原因。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。</p>
<h2 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h2><p>HTTP&#x2F;2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，我们几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。</p>
<p>因此，HTTP&#x2F;3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为QUIC 协议。关于 HTTP&#x2F;2 和 HTTP&#x2F;3 协议栈的比较，你可以参考下图：</p>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img11.png" class="" title="HTTP&#x2F;2 和 HTTP&#x2F;3 协议栈">

<p>通过上图我们可以看出，HTTP&#x2F;3 中的 QUIC 协议集合了以下几点功能。</p>
<ul>
<li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</li>
<li>集成了 TLS 加密功能。</li>
<li>实现了 HTTP&#x2F;2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</li>
</ul>
<img src="/2020/03/02/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94HTTP%E6%BC%94%E8%BF%9B/img12.png" class="" title="QUIC 协议的多路复用">

<ul>
<li>实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</li>
</ul>
<h2 id="HTTP-x2F-3-的挑战"><a href="#HTTP-x2F-3-的挑战" class="headerlink" title="HTTP&#x2F;3 的挑战"></a>HTTP&#x2F;3 的挑战</h2><p>通过上面的分析，我们相信在技术层面，HTTP&#x2F;3 是个完美的协议。不过要将 HTTP&#x2F;3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面。</p>
<p>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP&#x2F;3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</p>
<p>第二，部署 HTTP&#x2F;3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</p>
<p>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于万维网的快速崛起，带来了大量新的需求，其中最核心的一个就是需要支持多种类型的文件下载， 为此 HTTP&#x2F;1.0 中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP&#x2F;1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。</p>
<p>但随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于 HTTP&#x2F;1.0 推出了 HTTP&#x2F;1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。除此之外，HTTP&#x2F;1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。</p>
<p>虽然 HTTP&#x2F;1.1 在 HTTP&#x2F;1.0 的基础之上做了大量的优化，但是由于一些效率问题始终很难解决，所以最终还是被 HTTP&#x2F;2 所取代。<br>我们首先分析了影响 HTTP&#x2F;1.1 效率的三个主要因素：TCP 的慢启动、多条 TCP 连接竞争带宽和队头阻塞。</p>
<p>接下来我们分析了 HTTP&#x2F;2 是如何采用多路复用机制来解决这些问题的。多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率。</p>
<p>然后我们分析了 HTTP&#x2F;2 中所存在的一些问题，主要包括了 TCP 的队头阻塞、建立 TCP 连接的延时、TCP 协议僵化等问题。</p>
<p>这些问题都是 TCP 的内部问题，因此要解决这些问题就要优化 TCP 或者“另起炉灶”创造新的协议。由于优化 TCP 协议存在着诸多挑战，所以官方选择了创建新的 QUIC 协议。</p>
<p>HTTP&#x2F;3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP&#x2F;2 的多路复用 +TLS 等功能”的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP&#x2F;2 还更加高效的网络。</p>
<p>虽说这套协议解决了 HTTP&#x2F;2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="tag">浏览器工作原理与实践</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 存储过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/13/SQL/SQL%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"
    >SQL 存储过程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/13/SQL/SQL%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2020-02-13T07:14:27.000Z" itemprop="datePublished">2020-02-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是存储过程，如何创建一个存储过程"><a href="#什么是存储过程，如何创建一个存储过程" class="headerlink" title="什么是存储过程，如何创建一个存储过程"></a>什么是存储过程，如何创建一个存储过程</h1><p>存储过程的思想很简单，就是 SQL 语句的封装。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。存储过程实际上由 SQL 语句和流控制语句共同组成。</p>
<p>我们先来看下如何定义一个存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([参数列表])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  需要执行的语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们使用<code>CREATE PROCEDURE</code>创建一个存储过程，后面是存储过程的名称，以及过程所带的参数，可以包括输入参数和输出参数。最后由<code>BEGIN</code>和<code>END</code>来定义我们所要执行的语句块。</p>
<p>和视图一样，我们可以删除已经创建的存储过程，使用的是<code>DROP PROCEDURE</code>。如果要更新存储过程，我们需要使用<code>ALTER PROCEDURE</code>。</p>
<p>知道了如何创建，更新和删除一个存储过程，下面我们来看下如何实现一个简单的存储过程。比如我想做一个累加运算，计算<code>1+2+…+n</code>等于多少，我们可以通过参数<code>n</code>来表示想要累加的个数，那么如何用存储过程实现这一目的呢？这里我做一个<code>add_num</code>的存储过程，具体的代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `add_num`(<span class="keyword">IN</span> n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> i <span class="type">INT</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> sum <span class="type">INT</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">SET</span> sum <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  WHILE i <span class="operator">&lt;=</span> n DO</span><br><span class="line">    <span class="keyword">SET</span> sum <span class="operator">=</span> sum <span class="operator">+</span> i;</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">END</span> WHILE;</span><br><span class="line">  <span class="keyword">SELECT</span> sum;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>当我们需要再次使用这个存储过程的时候，直接使用<code>CALL add_num(50);</code>即可。这里我传入的参数为 50，也就是统计<code>1+2+…+50 </code>的积累之和，查询结果为：</p>
<table>
<thead>
<tr>
<th align="center">sum</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1275</td>
</tr>
</tbody></table>
<p>这就是一个简单的存储过程，除了理解<code>1+2+…+n</code>的实现过程，还有两点你需要理解，一个是<code>DELIMITER</code>定义语句的结束符，另一个是存储过程的三种参数类型。</p>
<p>我们先来看下<code>DELIMITER</code>的作用。如果你使用 Navicat 这个工具来管理 MySQL 执行存储过程，那么直接执行上面这段代码就可以了。如果用的是 MySQL，你还需要用<code>DELIMITER</code>来临时定义新的结束符。因为默认情况下 SQL 采用（;）作为结束符，这样当存储过程中的每一句 SQL 结束之后，采用（;）作为结束符，就相当于告诉 SQL 可以执行这一句了。但是存储过程是一个整体，我们不希望 SQL 逐条执行，而是采用存储过程整段执行的方式，因此我们就需要临时定义新的<code>DELIMITER</code>，新的结束符可以用（&#x2F;&#x2F;）或者（$$）。如果你用的是 MySQL，那么上面这段代码，应该写成下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `add_num`(<span class="keyword">IN</span> n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> i <span class="type">INT</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> sum <span class="type">INT</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">SET</span> sum <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  WHILE i <span class="operator">&lt;=</span> n DO</span><br><span class="line">    <span class="keyword">SET</span> sum <span class="operator">=</span> sum <span class="operator">+</span> i;</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">END</span> WHILE;</span><br><span class="line">  <span class="keyword">SELECT</span> sum;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>首先我用（&#x2F;&#x2F;）作为结束符，又在整个存储过程结束后采用了（&#x2F;&#x2F;）作为结束符号，告诉 SQL 可以执行了，然后再将结束符还原成默认的（;）。</p>
<p>需要注意的是，如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置<code>DELIMITER</code>为其他符号，我们不需要再进行<code>DELIMITER</code>的操作。</p>
<p>我们再来看下存储过程的 3 种参数类型。在刚才的存储过程中，我们使用了<code>IN</code>类型的参数，另外还有<code>OUT</code>类型和<code>INOUT</code>类型，作用如下：</p>
<table>
<thead>
<tr>
<th align="center">参数类型</th>
<th align="center">是否返回</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>IN</code></td>
<td align="center">否</td>
<td align="center">向存储过程传入参数，存储过程中修改该参数的值，不能被返回</td>
</tr>
<tr>
<td align="center"><code>OUT</code></td>
<td align="center">是</td>
<td align="center">把存储过程计算的结果放到该参数中，调用者可以得到返回值</td>
</tr>
<tr>
<td align="center"><code>INOUT</code></td>
<td align="center">是</td>
<td align="center"><code>IN</code>和<code>OUT</code>的结合，既用于存储过程的传入参数，同时又可以把计算结果放到参数中，调用者可以得到返回值</td>
</tr>
</tbody></table>
<p><code>IN</code>和<code>OUT</code>的结合，既用于存储过程的传入参数，同时又可以把计算结果放到参数中，调用者可以得到返回值。</p>
<p>你能看到，<code>IN</code>参数必须在调用存储过程时指定，而在存储过程中修改该参数的值不能被返回。而<code>OUT</code>参数和<code>INOUT</code>参数可以在存储过程中被改变，并可返回。</p>
<p>举个例子，这里会用到王者荣耀的英雄数据表<code>heros</code>。假设我想创建一个存储类型<code>get_hero_scores</code>，用来查询某一类型英雄中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，那么该怎么写呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> `get_hero_scores`(</span><br><span class="line">  <span class="keyword">OUT</span> max_max_hp <span class="type">FLOAT</span>,</span><br><span class="line">  <span class="keyword">OUT</span> min_max_mp <span class="type">FLOAT</span>,</span><br><span class="line">  <span class="keyword">OUT</span> avg_max_attack <span class="type">FLOAT</span>,  </span><br><span class="line">  s <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hp_max), <span class="built_in">MIN</span>(mp_max), <span class="built_in">AVG</span>(attack_max) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> role_main <span class="operator">=</span> s <span class="keyword">INTO</span> max_max_hp, min_max_mp, avg_max_attack;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>你能看到我定义了 4 个参数类型，其中 3 个为<code>OUT</code>类型，分别为<code>max_max_hp、min_max_mp</code>和<code>avg_max_attack</code>，另一个参数<code>s</code>为<code>IN</code>类型。</p>
<p>这里我们从<code>heros</code>数据表中筛选主要英雄定位为<code>s</code>的英雄数据，即筛选条件为<code>role_main=s</code>，提取这些数据中的最大的最大生命值，最小的最大魔法值，以及平均最大攻击值，分别赋值给变量<code>max_max_hp、min_max_mp</code>和<code>avg_max_attack</code>。</p>
<p>然后我们就可以调用存储过程，使用下面这段代码即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> get_hero_scores(<span class="variable">@max</span>_max_hp, <span class="variable">@min</span>_max_mp, <span class="variable">@avg</span>_max_attack, <span class="string">&#x27;战士&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@max</span>_max_hp, <span class="variable">@min</span>_max_mp, <span class="variable">@avg</span>_max_attack;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<table>
<thead>
<tr>
<th align="center">@max_max_hp</th>
<th align="center">@min_max_mp</th>
<th align="center">@avg_max_attack</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8050</td>
<td align="center">0</td>
<td align="center">342.1666564941406</td>
</tr>
</tbody></table>
<h1 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h1><p>常用的流控制语句：</p>
<ol>
<li><code>BEGIN…END</code>：<code>BEGIN…END</code>中间包含了多个语句，每个语句都以（;）号为结束符。</li>
<li><code>DECLARE</code>：<code>DECLARE</code>用来声明变量，使用的位置在于<code>BEGIN…END</code>语句中间，而且需要在其他语句使用之前进行变量的声明。</li>
<li><code>SET</code>：赋值语句，用于对变量进行赋值。</li>
<li><code>SELECT…INTO</code>：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</li>
<li><code>IF…THEN…ENDIF</code>：条件判断语句，我们还可以在<code>IF…THEN…ENDIF</code>中使用<code>ELSE</code>和<code>ELSEIF</code>来进行条件判断。</li>
<li><code>CASE：CASE</code>语句用于多条件的分支判断，使用的语法是下面这样的。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> </span><br><span class="line">	  <span class="keyword">WHEN</span> expression1 <span class="keyword">THEN</span> ...</span><br><span class="line">	  <span class="keyword">WHEN</span> expression2 <span class="keyword">THEN</span> ...</span><br><span class="line">	  ...</span><br><span class="line">  <span class="keyword">ELSE</span> </span><br><span class="line">  <span class="comment">--ELSE 语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure></li>
<li><code>LOOP、LEAVE</code>和<code>ITERATE：LOOP</code>是循环语句，使用<code>LEAVE</code>可以跳出循环，使用<code>ITERATE</code>则可以进入下一次循环。你可以把<code>LEAVE</code>理解为<code>BREAK</code>，把<code>ITERATE</code>理解为<code>CONTINUE</code>。</li>
<li><code>REPEAT…UNTIL…END REPEAT</code>：这是一个循环语句，首先会执行一次循环，然后在<code>UNTIL</code>中进行表达式的判断，如果满足条件就退出，即<code>END REPEAT</code>；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</li>
<li><code>WHILE…DO…END WHILE</code>：这也是循环语句，和<code>REPEAT</code>循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。</li>
</ol>
<h1 id="关于存储过程使用的争议"><a href="#关于存储过程使用的争议" class="headerlink" title="关于存储过程使用的争议"></a>关于存储过程使用的争议</h1><p>尽管存储过程有诸多优点，但是对于存储过程的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p>
<p>我们得从存储过程的特点来找答案。</p>
<p>你能看到存储过程有很多好处。</p>
<p>首先存储过程可以一次编译多次使用。存储过程只在创造时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。其次它可以减少开发工作量。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。还有一点，存储过程的安全性强，我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。最后它可以减少网络传输量，因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。同时在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p>
<p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<p>它的可移植性差，存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
<p>其次调试困难，只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。</p>
<p>此外，存储过程的版本管理也很困难，比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
<p>最后它不适合高并发的场景，高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。</p>
<p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/25/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/27/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>