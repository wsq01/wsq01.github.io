<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-微服务/微服务治理的手段有哪些"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%9A%84%E6%89%8B%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B/" class="article-date">
  <time datetime="2022-10-29T09:05:55.848Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>单体应用改造为微服务架构后，服务调用由本地调用变成远程调用，服务消费者 A 需要通过注册中心去查询服务提供者 B 的地址，然后发起调用，这个看似简单的过程就可能会遇到下面几种情况，比如：</p>
<ul>
<li>注册中心宕机；</li>
<li>服务提供者 B 有节点宕机；</li>
<li>服务消费者 A 和注册中心之间的网络不通；</li>
<li>服务提供者 B 和注册中心之间的网络不通；</li>
<li>服务消费者 A 和服务提供者 B 之间的网络不通；</li>
<li>服务提供者 B 有些节点性能变慢；</li>
<li>服务提供者 B 短时间内出现问题。</li>
</ul>
<p>可见，一次服务调用，服务提供者、注册中心、网络这三者都可能会有问题，此时服务消费者应该如何处理才能确保调用成功呢？这就是服务治理要解决的问题。<br>接下来我们一起来看看常用的服务治理手段。</p>
<h1 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h1><p>服务调用失败一般是由两类原因引起的，一类是服务提供者自身出现问题，如服务器宕机、进程意外退出等；一类是网络问题，如服务提供者、注册中心、服务消费者这三者任意两者之间的网络出现问题。</p>
<p>无论是服务提供者自身出现问题还是网络发生问题，都有两种节点管理手段。</p>
<ul>
<li><ol>
<li>注册中心主动摘除机制<br>这种机制要求服务提供者定时的主动向注册中心汇报心跳，注册中心根据服务提供者节点最近一次汇报心跳的时间与上一次汇报心跳时间做比较，如果超出一定时间，就认为服务提供者出现问题，继而把节点从服务列表中摘除，并把最近的可用服务节点列表推送给服务消费者。</li>
</ol>
</li>
<li><ol start="2">
<li>服务消费者摘除机制<br>虽然注册中心主动摘除机制可以解决服务提供者节点异常的问题，但如果是因为注册中心与服务提供者之间的网络出现异常，最坏的情况是注册中心会把服务节点全部摘除，导致服务消费者没有可用的服务节点调用，但其实这时候服务提供者本身是正常的。所以，将存活探测机制用在服务消费者这一端更合理，如果服务消费者调用服务提供者节点失败，就将这个节点从内存中保存的可用服务提供者节点列表中移除。</li>
</ol>
</li>
</ul>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>一般情况下，服务提供者节点不是唯一的，多是以集群的方式存在，尤其是对于大规模的服务调用来说，服务提供者节点数目可能有上百上千个。由于机器采购批次的不同，不同服务节点本身的配置也可能存在很大差异，新采购的机器 CPU 和内存配置可能要高一些，同等请求量情况下，性能要好于旧的机器。对于服务消费者而言，在从服务列表中选取可用节点时，如果能让配置较高的新机器多承担一些流量的话，就能充分利用新机器的性能。这就需要对负载均衡算法做一些调整。</p>
<p>常用的负载均衡算法主要包括以下几种。</p>
<ul>
<li><ol>
<li>随机算法<br>顾名思义就是从可用的服务节点中随机选取一个节点。一般情况下，随机算法是均匀的，也就是说后端服务节点无论配置好坏，最终得到的调用量都差不多。</li>
</ol>
</li>
<li><ol start="2">
<li>轮询算法<br>就是按照固定的权重，对可用服务节点进行轮询。如果所有服务节点的权重都是相同的，则每个节点的调用量也是差不多的。但可以给某些硬件配置较好的节点的权重调大些，这样的话就会得到更大的调用量，从而充分发挥其性能优势，提高整体调用的平均性能。</li>
</ol>
</li>
<li><ol start="3">
<li>最少活跃调用算法<br>这种算法是在服务消费者这一端的内存里动态维护着同每一个服务节点之间的连接数，当调用某个服务节点时，就给与这个服务节点之间的连接数加 1，调用返回后，就给连接数减 1。然后每次在选择服务节点时，根据内存里维护的连接数倒序排列，选择连接数最小的节点发起调用，也就是选择了调用量最小的服务节点，性能理论上也是最优的。</li>
</ol>
</li>
<li><ol start="4">
<li>一致性 Hash 算法<br>指相同参数的请求总是发到同一服务节点。当某一个服务节点出现故障时，原本发往该节点的请求，基于虚拟节点机制，平摊到其他节点上，不会引起剧烈变动。</li>
</ol>
</li>
</ul>
<p>这几种算法的实现难度也是逐步提升的，所以选择哪种节点选取的负载均衡算法要根据实际场景而定。如果后端服务节点的配置没有差异，同等调用量下性能也没有差异的话，选择随机或者轮询算法比较合适；如果后端服务节点存在比较明显的配置和性能差异，选择最少活跃调用算法比较合适。</p>
<h1 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h1><p>对于服务消费者而言，在内存中的可用服务节点列表中选择哪个节点不仅由负载均衡算法决定，还由路由规则确定。</p>
<p>所谓的路由规则，就是通过一定的规则如条件表达式或者正则表达式来限定服务节点的选择范围。</p>
<p>为什么要制定路由规则呢？主要有两个原因。</p>
<h2 id="1-业务存在灰度发布的需求"><a href="#1-业务存在灰度发布的需求" class="headerlink" title="1. 业务存在灰度发布的需求"></a>1. 业务存在灰度发布的需求</h2><p>比如，服务提供者做了功能变更，但希望先只让部分人群使用，然后根据这部分人群的使用反馈，再来决定是否做全量发布。这个时候，就可以通过类似按尾号进行灰度的规则限定只有一定比例的人群才会访问新发布的服务节点。</p>
<h2 id="2-多机房就近访问的需求"><a href="#2-多机房就近访问的需求" class="headerlink" title="2. 多机房就近访问的需求"></a>2. 多机房就近访问的需求</h2><p>据我所知，大部分业务规模中等及以上的互联网公司，为了业务的高可用性，都会将自己的业务部署在不止一个 IDC 中。这个时候就存在一个问题，不同 IDC 之间的访问由于要跨 IDC，通过专线访问，尤其是 IDC 相距比较远时延迟就会比较大，比如北京和广州的专线延迟一般在 30ms 左右，这对于某些延时敏感性的业务是不可接受的，所以就要一次服务调用尽量选择同一个 IDC 内部的节点，从而减少网络耗时开销，提高性能。这时一般可以通过 IP 段规则来控制访问，在选择服务节点时，优先选择同一 IP 段的节点。</p>
<p>那么路由规则该如何配置呢？一般有两种配置方式。</p>
<ul>
<li><ol>
<li>静态配置<br>就是在服务消费者本地存放服务调用的路由规则，在服务调用期间，路由规则不会发生改变，要想改变就需要修改服务消费者本地配置，上线后才能生效。</li>
</ol>
</li>
<li><ol start="2">
<li>动态配置<br>这种方式下，路由规则是存在注册中心的，服务消费者定期去请求注册中心来保持同步，要想改变服务消费者的路由配置，可以通过修改注册中心的配置，服务消费者在下一个同步周期之后，就会请求注册中心来更新配置，从而实现动态更新。</li>
</ol>
</li>
</ul>
<h1 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h1><p>服务调用并不总是一定成功的，可能因为服务提供者节点自身宕机、进程异常退出或者服务消费者与提供者之间的网络出现故障等原因。对于服务调用失败的情况，需要有手段自动恢复，来保证调用成功。</p>
<p>常用的手段主要有以下几种。</p>
<ul>
<li>FailOver：失败自动切换。就是服务消费者发现调用失败或者超时后，自动从可用的服务节点列表总选择下一个节点重新发起调用，也可以设置重试的次数。这种策略要求服务调用的操作必须是幂等的，也就是说无论调用多少次，只要是同一个调用，返回的结果都是相同的，一般适合服务调用是读请求的场景。</li>
<li>FailBack：失败通知。就是服务消费者调用失败或者超时后，不再重试，而是根据失败的详细信息，来决定后续的执行策略。比如对于非幂等的调用场景，如果调用失败后，不能简单地重试，而是应该查询服务端的状态，看调用到底是否实际生效，如果已经生效了就不能再重试了；如果没有生效可以再发起一次调用。</li>
<li>FailCache：失败缓存。就是服务消费者调用失败或者超时后，不立即发起重试，而是隔一段时间后再次尝试发起调用。比如后端服务可能一段时间内都有问题，如果立即发起重试，可能会加剧问题，反而不利于后端服务的恢复。如果隔一段时间待后端节点恢复后，再次发起调用效果会更好。</li>
<li>FailFast：快速失败。就是服务消费者调用一次失败后，不再重试。实际在业务执行时，一般非核心业务的调用，会采用快速失败策略，调用失败后一般就记录下失败日志就返回了。</li>
</ul>
<p>它们的使用场景是不同的，一般情况下对于幂等的调用，可以选择 FailOver 或者 FailCache，非幂等的调用可以选择 FailBack 或者 FailFast。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面这些服务治理的手段是最常用的手段，它们从不同角度来确保服务调用的成功率。节点管理是从服务节点健康状态角度来考虑，负载均衡和服务路由是从服务节点访问优先级角度来考虑，而服务容错是从调用的健康状态角度来考虑，可谓是殊途同归。</p>
<p>在实际的微服务架构实践中，上面这些服务治理手段一般都会在服务框架中默认集成了，比如阿里开源的服务框架 Dubbo、微博开源的服务框架 Motan 等，不需要业务代码去实现。如果想自己实现服务治理的手段，可以参考这些开源服务框架的实现。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-微服务/服务发布和引用的实践"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time datetime="2022-10-29T09:05:55.848Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="XML-配置方式的服务发布和引用流程"><a href="#XML-配置方式的服务发布和引用流程" class="headerlink" title="XML 配置方式的服务发布和引用流程"></a>XML 配置方式的服务发布和引用流程</h1><h2 id="1-服务提供者定义接口"><a href="#1-服务提供者定义接口" class="headerlink" title="1. 服务提供者定义接口"></a>1. 服务提供者定义接口</h2><p>服务提供者发布服务之前首先要定义接口，声明接口名、传递参数以及返回值类型，然后把接口打包成 JAR 包发布出去。</p>
<p>比如下面这段代码，声明了接口<code>UserLastStatusService</code>，包含两个方法<code>getLastStatusId</code>和<code>getLastStatusIds</code>，传递参数一个是<code>long</code>值、一个是<code>long</code>数组，返回值一个是<code>long</code>值、一个是<code>map</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.weibo.api.common.status.service;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserLastStatusService</span> &#123;</span><br><span class="line">    * <span class="meta">@param</span> uids</span><br><span class="line">    * <span class="meta">@return</span></span><br><span class="line">    */</span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastStatusId</span><span class="params">(<span class="type">long</span> uid)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> uids</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;Long, Long&gt; <span class="title function_">getLastStatusIds</span><span class="params">(<span class="type">long</span>[] uids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-服务提供者发布接口"><a href="#2-服务提供者发布接口" class="headerlink" title="2. 服务提供者发布接口"></a>2. 服务提供者发布接口</h2><p>服务提供者发布的接口是通过在服务发布配置文件中定义接口来实现的。</p>
<p>下面是一个具体的服务发布配置文件<code>user-last-status.xml</code>，它定义了要发布的接口<code>userLastStatusLocalService</code>，对外暴露的协议是 Motan 协议，端口是 8882。并且针对两个方法<code>getLastStatusId</code>和<code>getLastStatusIds</code>，通过<code>requestTimeout=&quot;300&quot;</code>单独定义了超时时间是 300ms，通过<code>retries=&quot;0&quot;</code>单独定义了调用失败后重试次数为 0，也就是不重试。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:service</span> <span class="attr">ref</span>=<span class="string">&quot;userLastStatusLocalService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">requestTimeout</span>=<span class="string">&quot;50&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span>    <span class="attr">interface</span>=<span class="string">&quot;com.weibo.api.common.status.service.UserLastStatusService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">basicService</span>=<span class="string">&quot;serviceBasicConfig&quot;</span> <span class="attr">export</span>=<span class="string">&quot;motan:8882&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getLastStatusId&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getLastStatusIds&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">motan:service</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后服务发布者在进程启动的时候，会加载配置文件<code>user-last-status.xml</code>，把接口对外暴露出去。</p>
<h2 id="3-服务消费者引用接口"><a href="#3-服务消费者引用接口" class="headerlink" title="3. 服务消费者引用接口"></a>3. 服务消费者引用接口</h2><p>服务消费者引用接口是通过在服务引用配置文件中定义要引用的接口，并把包含接口定义的 JAR 包引入到代码依赖中。</p>
<p>下面我再以一个具体的服务引用配置文件<code>user-last-status-client.xml</code>来给你讲解，它定义服务消费者引用了接口<code>commonUserLastStatusService</code>，接口通信协议是 Motan。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:protocol</span> <span class="attr">name</span>=<span class="string">&quot;motan&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span> <span class="attr">loadbalance</span>=<span class="string">&quot;$&#123;service.loadbalance.name&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">motan:basicReferer</span> <span class="attr">id</span>=<span class="string">&quot;userLastStatusServiceClientBasicConfig&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">protocol</span>=<span class="string">&quot;motan&quot;</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 导出接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">motan:referer</span> <span class="attr">id</span>=<span class="string">&quot;commonUserLastStatusService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;com.weibo.api.common.status.service.UserLastStatusService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">basicReferer</span>=<span class="string">&quot;userLastStatusServiceClientBasicConfig&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后服务消费者在进程启动时，会加载配置文件<code>user-last-status-client.xml</code>来完成服务引用。</p>
<p>服务发布和引用流程看似比较简单，但在实际使用过程中，还是有很多坑的，比如在实际项目中经常会遇到这个问题：一个服务包含了多个接口，可能有上行接口也可能有下行接口，每个接口都有超时控制以及是否重试等配置，如果有多个服务消费者引用这个服务，是不是每个服务消费者都必须在服务引用配置文件中定义？</p>
<h1 id="服务发布和引用的那些坑"><a href="#服务发布和引用的那些坑" class="headerlink" title="服务发布和引用的那些坑"></a>服务发布和引用的那些坑</h1><p>在一个服务被多个服务消费者引用的情况下，由于业务经验的参差不齐，可能不同的服务消费者对服务的认知水平不一，比如某个服务可能调用超时了，最好可以重试来提供调用成功率。但可能有的服务消费者会忽视这一点，并没有在服务引用配置文件中配置接口调用超时重试的次数，因此最好是可以在服务发布的配置文件中预定义好类似超时重试次数，即使服务消费者没有在服务引用配置文件中定义，也能继承服务提供者的定义。这就是下面要讲的服务发布预定义配置。</p>
<h2 id="1-服务发布预定义配置"><a href="#1-服务发布预定义配置" class="headerlink" title="1. 服务发布预定义配置"></a>1. 服务发布预定义配置</h2><p>以下面的服务发布配置文件<code>server.xml</code>为例，它提供了一个服务<code>contentSliceRPCService</code>，并且明确了其中三个方法的调用超时时间为 500ms 以及超时重试次数为 3。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">motan:service</span> <span class="attr">ref</span>=<span class="string">&quot;contentSliceRPCService&quot;</span>       <span class="attr">interface</span>=<span class="string">&quot;cn.sina.api.data.service.ContentSliceRPCService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">basicService</span>=<span class="string">&quot;serviceBasicConfig&quot;</span> <span class="attr">export</span>=<span class="string">&quot;motan:8882&quot;</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;saveContent&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;deleteContent&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;updateContent&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">retries</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">motan:service</span>&gt;</span></span><br><span class="line">假设服务引用的配置文件 client.xml 的内容如下，那么服务消费者就会默认继承服务发布配置文件中设置的方法调用的超时时间以及超时重试次数。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">motan:referer</span> <span class="attr">id</span>=<span class="string">&quot;contentSliceRPCService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;cn.sina.api.data.service.ContentSliceRPCService&quot;</span>     <span class="attr">basicReferer</span>=<span class="string">&quot;contentSliceClientBasicConfig&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">motan:referer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过服务发布预定义配置可以解决多个服务消费者引用服务可能带来的配置复杂的问题，这样是不是最优的解决方案呢？</p>
<p>实际上我还遇到过另外一种极端情况，一个服务提供者发布的服务有上百个方法，并且每个方法都有各自的超时时间、重试次数等信息。服务消费者引用服务时，完全继承了服务发布预定义的各项配置。这种情况下，服务提供者所发布服务的详细配置信息都需要存储在注册中心中，这样服务消费者才能在实际引用时从服务发布预定义配置中继承各种配置。</p>
<p>这里就存在一种风险，当服务提供者发生节点变更，尤其是在网络频繁抖动的情况下，所有的服务消费者都会从注册中心拉取最新的服务节点信息，就包括了服务发布配置中预定的各项接口信息，这个信息不加限制的话可能达到 1M 以上，如果同时有上百个服务消费者从注册中心拉取服务节点信息，在注册中心机器部署为百兆带宽的情况下，很有可能会导致网络带宽打满的情况发生。</p>
<p>面对这种情况，最好的办法是把服务发布端的详细服务配置信息转移到服务引用端，这样的话注册中心中就不需要存储服务提供者发布的详细服务配置信息了。这就是下面要讲的服务引用定义配置。</p>
<h2 id="2-服务引用定义配置"><a href="#2-服务引用定义配置" class="headerlink" title="2. 服务引用定义配置"></a>2. 服务引用定义配置</h2><p>以下面的服务发布配置文件为例，它详细定义了服务 userInfoService 的各个方法的配置信息，比如超时时间和重试次数等。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">motan:service</span> <span class="attr">ref</span>=<span class="string">&quot;userInfoService&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;50&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span>                   <span class="attr">interface</span>=<span class="string">&quot;cn.sina.api.user.service.UserInfoService&quot;</span> <span class="attr">basicService</span>=<span class="string">&quot;serviceBasicConfig&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;addUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;updateUserPortrait&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;modifyUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;addUserTags&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;delUserTags&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;processUserCacheByNewMyTriggerQ&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;modifyObjectUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;addObjectUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;updateObjectUserPortrait&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;updateObjectManager&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;deleteObjectManager&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAttr&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAttrList&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getAllUserAttr&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAttr2&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">motan:service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以像下面一样，把服务 userInfoService 的详细配置信息转移到服务引用配置文件中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">motan:referer</span> <span class="attr">id</span>=<span class="string">&quot;userInfoService&quot;</span> <span class="attr">interface</span>=<span class="string">&quot;cn.sina.api.user.service.UserInfoService&quot;</span> <span class="attr">basicReferer</span>=<span class="string">&quot;userClientBasicConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;addUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;updateUserPortrait&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;modifyUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;addUserTags&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;delUserTags&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;processUserCacheByNewMyTriggerQ&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;modifyObjectUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;addObjectUserInfo&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;updateObjectUserPortrait&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;updateObjectManager&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;deleteObjectManager&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAttr&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAttrList&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getAllUserAttr&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">motan:method</span> <span class="attr">name</span>=<span class="string">&quot;getUserAttr2&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;300&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">motan:referer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样的话，服务发布配置文件可以简化为下面这段代码，是不是信息精简了许多。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">motan:service</span> <span class="attr">ref</span>=<span class="string">&quot;userInfoService&quot;</span> <span class="attr">requestTimeout</span>=<span class="string">&quot;50&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;2&quot;</span>                   <span class="attr">interface</span>=<span class="string">&quot;cn.sina.api.user.service.UserInfoService&quot;</span> <span class="attr">basicService</span>=<span class="string">&quot;serviceBasicConfig&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">motan:service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在进行类似的服务详细信息配置，由服务发布配置文件迁移到服务引用配置文件的过程时，尤其要注意迁移步骤问题，这就是接下来我要给你讲的服务配置升级问题。</p>
<h2 id="3-服务配置升级"><a href="#3-服务配置升级" class="headerlink" title="3. 服务配置升级"></a>3. 服务配置升级</h2><p>由于引用服务的服务消费者众多，并且涉及多个部门，升级步骤就显得异常重要，通常可以按照下面步骤操作。</p>
<p>各个服务消费者在服务引用配置文件中添加服务详细信息。</p>
<p>服务提供者升级两台服务器，在服务发布配置文件中删除服务详细信息，并观察是否所有的服务消费者引用时都包含服务详细信息。</p>
<p>如果都包含，说明所有服务消费者均完成升级，那么服务提供者就可以删除服务发布配置中的服务详细信息。</p>
<p>如果有不包含服务详细信息的服务消费者，排查出相应的业务方进行升级，直至所有业务方完成升级。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>XML 配置方式的服务发布和引用的具体流程，简单来说就是服务提供者定义好接口，并且在服务发布配置文件中配置要发布的接口名，在进程启动时加载服务发布配置文件就可以对外提供服务了。而服务消费者通过在服务引用配置文件中定义相同的接口名，并且在服务引用配置文件中配置要引用的接口名，在进程启动时加载服务引用配置文件就可以引用服务了。</p>
<p>在业务具体实践过程中可能会遇到引用服务的服务消费者众多，对业务的敏感度参差不齐的问题，所以在服务发布的时候，最好预定义好接口的各种配置。在服务规模不大，业务比较简单的时候，这样做比较合适。但是对于复杂业务，虽然服务发布时预定义好接口的各种配置，但在引用的服务消费者众多且同时访问的时候，可能会引起网络风暴。这种情况下，比较保险的方式是，把接口的各种配置放在服务引用配置文件里。</p>
<p>在进行服务配置升级过程时，要考虑好步骤，在所有服务消费者完成升级之前，服务提供者还不能把服务的详细信息去掉，否则可能会导致没有升级的服务消费者引用异常。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-微服务/如何搭建微服务治理平台"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/" class="article-date">
  <time datetime="2022-10-29T09:05:55.819Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>单体应用改造为微服务架构后，服务调用从本地调用变成了远程方法调用后，面临的各种不确定因素变多了，一方面你需要能够监控各个服务的实时运行状态、服务调用的链路和拓扑图；另一方面你需要在出现故障时，能够快速定位故障的原因并可以通过诸如降级、限流、切流量、扩容等手段快速干预止损。这个时候就需要微服务治理平台了。</p>
<h1 id="微服务治理平台的基本功能"><a href="#微服务治理平台的基本功能" class="headerlink" title="微服务治理平台的基本功能"></a>微服务治理平台的基本功能</h1><p>你可能先会问，到底什么是微服务治理平台？根据我的理解，微服务治理平台就是与服务打交道的统一入口，无论是开发人员还是运维人员，都能通过这个平台对服务进行各种操作，比如开发人员可以通过这个平台对服务进行降级操作，运维人员可以通过这个平台对服务进行上下线操作，而不需要关心这个操作背后的具体实现。</p>
<p>接下来我就结合下面这张图，给你介绍一下一个微服务治理平台应该具备哪些基本功能。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/img1.png" class="">

<ol>
<li>服务管理</li>
</ol>
<p>通过微服务治理平台，可以调用注册中心提供的各种管理接口来实现服务的管理。根据我的经验，服务管理一般包括以下几种操作：</p>
<p>服务上下线。当上线一个新服务的时候，可以通过调用注册中心的服务添加接口，新添加一个服务，同样要下线一个已有服务的时候，也可以通过调用注册中心的服务注销接口，删除一个服务。</p>
<p>节点添加 &#x2F; 删除。当需要给服务新添加节点时候，可以通过调用注册中心的节点注册接口，来给服务新增加一个节点。而当有故障节点出现或者想临时下线一些节点时，可以通过调用注册中心的节点反注册接口，来删除节点。</p>
<p>服务查询。这个操作会调用注册中心的服务查询接口，可以查询当前注册中心里共注册了多少个服务，每个服务的详细信息。</p>
<p>服务节点查询。这个操作会调用注册中心的节点查询接口，来查询某个服务下一共有多少个节点。</p>
<ol start="2">
<li>服务治理</li>
</ol>
<p>通过微服务治理平台，可以调用配置中心提供的接口，动态地修改各种配置来实现服务的治理。根据我的经验，常用的服务治理手段包括以下几种：</p>
<p>限流。一般是在系统出现故障的时候，比如像微博因为热点突发事件的发生，可能会在短时间内流量翻几倍，超出系统的最大容量。这个时候就需要调用配置中心的接口，去修改非核心服务的限流阈值，从而减少非核心服务的调用，给核心服务留出充足的冗余度。</p>
<p>降级。跟限流一样，降级也是系统出现故障时的应对方案。要么是因为突发流量的到来，导致系统的容量不足，这时可以通过降级一些非核心业务，来增加系统的冗余度；要么是因为某些依赖服务的问题，导致系统被拖慢，这时可以降级对依赖服务的调用，避免被拖死。</p>
<p>切流量。通常为了服务的异地容灾考虑，服务部署在不止一个 IDC 内。当某个 IDC 因为电缆被挖断、机房断电等不可抗力时，需要把故障 IDC 的流量切换到其他正常 IDC，这时候可以调用配置中心的接口，向所有订阅了故障 IDC 服务的消费者下发指令，将流量统统切换到其他正常 IDC，从而避免服务消费者受影响。</p>
<ol start="3">
<li>服务监控</li>
</ol>
<p>微服务治理平台一般包括两个层面的监控。一个是整体监控，比如服务依赖拓扑图，将整个系统内服务间的调用关系和依赖关系进行可视化的展示；一个是具体服务监控，比如服务的 QPS、AvgTime、P999 等监控指标。其中整体监控可以使用服务追踪系统提供的服务依赖拓扑图，而具体服务监控则可以通过 Grafana 等监控系统 UI 来展示。</p>
<ol start="4">
<li>问题定位</li>
</ol>
<p>微服务治理平台实现问题定位，可以从两个方面来进行。一个是宏观层面，即通过服务监控来发觉异常，比如某个服务的平均耗时异常导致调用失败；一个是微观层面，即通过服务追踪来具体定位一次用户请求失败具体是因为服务调用全链路的哪一层导致的。</p>
<ol start="5">
<li>日志查询</li>
</ol>
<p>微服务治理平台可以通过接入类似 ELK 的日志系统，能够实时地查询某个用户的请求的详细信息或者某一类用户请求的数据统计。</p>
<ol start="6">
<li>服务运维</li>
</ol>
<p>微服务治理平台可以调用容器管理平台，来实现常见的运维操作。根据我的经验，服务运维主要包括下面几种操作：</p>
<p>发布部署。当服务有功能变更，需要重新发布部署的时候，可以调用容器管理平台分批按比例进行重新部署，然后发布到线上。</p>
<p>扩缩容。在流量增加或者减少的时候，需要相应地增加或者缩减服务在线上部署的实例，这时候可以调用容器管理平台来扩容或者缩容。</p>
<h1 id="如何搭建微服务治理平台"><a href="#如何搭建微服务治理平台" class="headerlink" title="如何搭建微服务治理平台"></a>如何搭建微服务治理平台</h1><p>微服务治理平台之所以能够实现上面所说的功能，关键之处就在于它能够封装对微服务架构内的各个基础设施组件的调用，从而对外提供统一的服务操作 API，而且还提供了可视化的界面，以方便开发人员和运维人员操作。</p>
<p>根据我的经验，一个微服务治理平台的组成主要包括三部分：Web Portal 层、API 层以及数据存储 DB 层，结合下面这张图我来详细讲解下每一层该如何实现。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/img2.png" class="">

<p>第一层：Web Portal。也就是微服务治理平台的前端展示层，一般包含以下几个功能界面：</p>
<p>服务管理界面，可以进行节点的操作，比如查询节点、删除节点。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/img3.png" class="">

<p>服务治理界面，可以进行服务治理操作，比如切流量、降级等，还可以查看操作记录。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/img4.png" class="">

<p>服务监控界面，可以查看服务的详细信息，比如 QPS、AvgTime、耗时分布区间以及 P999 等。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/img5.png" class="">

<p>服务运维界面，可以执行服务的扩缩容操作，还可以查看扩缩容的操作历史。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%B9%B3%E5%8F%B0/img6.png" class="">

<p>第二层，API。也就是微服务治理平台的后端服务层，这一层对应的需要提供 Web Portal 接口以调用，对应的一般包含下面几个接口功能：</p>
<p>添加服务接口。这个接口会调用注册中心提供的服务添加接口来新发布一个服务。</p>
<p>删除服务接口。这个接口会调用注册中心提供的服务注销接口来下线一个服务。</p>
<p>服务降级 &#x2F; 限流 &#x2F; 切流量接口。这几个接口会调用配置中心提供的配置修改接口，来修改对应服务的配置，然后订阅这个服务的消费者就会从配置中心拉取最新的配置，从而实现降级、限流以及流量切换。</p>
<p>服务扩缩容接口。这个接口会调用容器平台提供的扩缩容接口，来实现服务的实例添加和删除。</p>
<p>服务部署接口。这个接口会调用容器平台提供的上线部署接口，来实现服务的线上部署。</p>
<p>第三层，DB。也就是微服务治理平台的数据存储层，因为微服务治理平台不仅需要调用其他组件提供的接口，还需要存储一些基本信息，主要分为以下几种：</p>
<p>用户权限。因为微服务治理平台的功能十分强大，所以要对用户的权限进行管理。一般可以分为可浏览、可更改以及管理员三个权限。而且还需要对可更改的权限进行细分，按照不同服务的负责人进行权限划分，一个人只能对它负责的服务的进行更改操作，而不能修改其他人负责的服务。</p>
<p>操作记录。用来记录下用户在平台上所进行的变更操作，比如降级记录、扩缩容记录、切流量记录等。</p>
<p>元数据。主要是用来把服务在各个系统中对应的记录映射到微服务治理平台中，统一进行管理。比如某个服务在监控系统里可能有个特殊标识，在注册中心里又使用了另外一个标识，为了统一就需要在微服务治理平台统一进行转换，然后进行数据串联。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-微服务/如何将注册中心落地"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0/" class="article-date">
  <time datetime="2022-10-29T09:05:55.815Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在落地注册中心的过程中，我们需要解决一系列的问题，包括如何存储服务信息、如何注册节点、如何反注册、如何查询节点信息以及如何订阅服务变更等。</p>
<h1 id="注册中心如何存储服务信息"><a href="#注册中心如何存储服务信息" class="headerlink" title="注册中心如何存储服务信息"></a>注册中心如何存储服务信息</h1><p>服务信息除了包含节点信息（IP 和端口号）以外，还包含其他一些信息，比如请求失败时重试的次数、请求结果是否压缩等信息。因此服务信息通常用 JSON 字符串来存储，包含多个字段，每个字段代表不同的含义。</p>
<p>除此之外，服务一般会分成多个不同的分组，每个分组的目的不同。一般来说有下面几种分组方式。</p>
<ul>
<li>核心与非核心，从业务的核心程度来分。</li>
<li>机房，从机房的维度来分。</li>
<li>线上环境与测试环境，从业务场景维度来区分。</li>
</ul>
<p>所以注册中心存储的服务信息一般包含三部分内容：分组、服务名以及节点信息，节点信息又包括节点地址和节点其他信息。从注册中心中获取的信息结构大致如下图所示。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0/img1.png" class="">

<p>具体存储的时候，一般是按照“服务 - 分组 - 节点信息”三层结构来存储，可以用下图来描述。Service 代表服务的具体分组，Cluster 代表服务的接口名，节点信息用 KV 存储。</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0/img2.jpg" class="">

<p>搞清楚了注册中心存储服务信息的原理后，再来看下注册中心具体是如何工作的，包括四个流程。</p>
<ul>
<li>服务提供者注册流程。</li>
<li>服务提供者反注册流程。</li>
<li>服务消费者查询流程。</li>
<li>服务消费者订阅变更流程。</li>
</ul>
<h1 id="注册中心是如何工作的"><a href="#注册中心是如何工作的" class="headerlink" title="注册中心是如何工作的"></a>注册中心是如何工作的</h1><h2 id="1-如何注册节点"><a href="#1-如何注册节点" class="headerlink" title="1. 如何注册节点"></a>1. 如何注册节点</h2><p>服务注册流程：</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0/img3.png" class="">

<p>服务注册流程主要有下面几个步骤：</p>
<ul>
<li>首先查看要注册的节点是否在白名单内？如果不在就抛出异常，在的话继续下一步。</li>
<li>其次要查看注册的 Cluster（服务的接口名）是否存在？如果不存在就抛出异常，存在的话继续下一步。</li>
<li>然后要检查 Service（服务的分组）是否存在？如果不存在则抛出异常，存在的话继续下一步。</li>
<li>最后将节点信息添加到对应的 Service 和 Cluster 下面的存储中。</li>
</ul>
<h2 id="2-如何反注册"><a href="#2-如何反注册" class="headerlink" title="2. 如何反注册"></a>2. 如何反注册</h2><p>服务提供者节点反注册的流程：</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0/img4.png" class="">

<p>节点反注册流程主要包含下面几个步骤：</p>
<ul>
<li>查看 Service（服务的分组）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>查看 Cluster（服务的接口名）是否存在，不存在就抛出异常，存在就继续下一步。</li>
<li>删除存储中 Service 和 Cluster 下对应的节点信息。</li>
<li>更新 Cluster 的 sign 值。</li>
</ul>
<h2 id="3-如何查询节点信息"><a href="#3-如何查询节点信息" class="headerlink" title="3. 如何查询节点信息"></a>3. 如何查询节点信息</h2><p>服务消费者从注册中心查询服务提供者的节点信息流程：</p>
<p>服务消费者查询节点信息主要分为下面几个步骤：</p>
<p>首先从 localcache（本机内存）中查找，如果没有就继续下一步。这里为什么服务消费者要把服务信息存在本机内存呢？主要是因为服务节点信息并不总是时刻变化的，并不需要每一次服务调用都要调用注册中心获取最新的节点信息，只需要在本机内存中保留最新的服务提供者的节点列表就可以。</p>
<p>接着从 snapshot（本地快照）中查找，如果没有就继续下一步。这里为什么服务消费者要在本地磁盘存储一份服务提供者的节点信息的快照呢？这是因为服务消费者同注册中心之间的网络不一定总是可靠的，服务消费者重启时，本机内存中还不存在服务提供者的节点信息，如果此时调用注册中心失败，那么服务消费者就拿不到服务节点信息了，也就没法调用了。本地快照就是为了防止这种情况的发生，即使服务消费者重启后请求注册中心失败，依然可以读取本地快照，获取到服务节点信息。</p>
<h2 id="4-如何订阅服务变更"><a href="#4-如何订阅服务变更" class="headerlink" title="4. 如何订阅服务变更"></a>4. 如何订阅服务变更</h2><p>服务消费者订阅服务提供者的变更信息流程：</p>
<img src="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E5%B0%86%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%90%BD%E5%9C%B0/img5.png" class="">

<p>主要分为下面几个步骤：</p>
<ul>
<li>服务消费者从注册中心获取了服务的信息后，就订阅了服务的变化，会在本地保留 Cluster 的<code>sign</code>值。</li>
<li>服务消费者每隔一段时间，调用<code>getSign()</code>函数，从注册中心获取服务端该 Cluster 的<code>sign</code>值，并与本地保留的<code>sign</code>值做对比，如果不一致，就从服务端拉取新的节点信息，并更新<code>localcache</code>和<code>snapshot</code>。</li>
</ul>
<h1 id="注册与发现的几个问题"><a href="#注册与发现的几个问题" class="headerlink" title="注册与发现的几个问题"></a>注册与发现的几个问题</h1><h2 id="1-多注册中心"><a href="#1-多注册中心" class="headerlink" title="1. 多注册中心"></a>1. 多注册中心</h2><p>理论上对于一个服务消费者来说，同一个注册中心交互是最简单的。但是不可避免的是，服务消费者可能订阅了多个服务，多个服务可能是由多个业务部门提供的，而且每个业务部门都有自己的注册中心，提供的服务只在自己的注册中心里有记录。这样的话，就要求服务消费者要具备在启动时，能够从多个注册中心订阅服务的能力。</p>
<p>根据我的经验，还有一种情况是，一个服务提供者提供了某个服务，可能作为静态服务对外提供，有可能又作为动态服务对外提供，这两个服务部署在不同的注册中心，所以要求服务提供者在启动的时候，要能够同时向多个注册中心注册服务。</p>
<p>也就是说，对于服务消费者来说，要能够同时从多个注册中心订阅服务；对于服务提供者来说，要能够同时向多个注册中心注册服务。</p>
<h2 id="2-并行订阅服务"><a href="#2-并行订阅服务" class="headerlink" title="2. 并行订阅服务"></a>2. 并行订阅服务</h2><p>通常一个服务消费者订阅了不止一个服务，在我经历的一个项目中，一个服务消费者订阅了几十个不同的服务，每个服务都有自己的方法列表以及节点列表。服务消费者在服务启动时，会加载订阅的服务配置，调用注册中心的订阅接口，获取每个服务的节点列表并初始化连接。</p>
<p>最开始我们采用了串行订阅的方式，每订阅一个服务，服务消费者调用一次注册中心的订阅接口，获取这个服务的节点列表并初始化连接，总共需要执行几十次这样的过程。在某些服务节点的初始化连接过程中，出现连接超时的情况，后续所有的服务节点的初始化连接都需要等待它完成，导致服务消费者启动变慢，最后耗费了将近五分钟时间来完成所有服务节点的初始化连接过程。</p>
<p>后来我们改成了并行订阅的方式，每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了 30 秒以内。</p>
<h2 id="3-批量反注册服务"><a href="#3-批量反注册服务" class="headerlink" title="3. 批量反注册服务"></a>3. 批量反注册服务</h2><p>通常一个服务提供者节点提供不止一个服务，所以注册和反注册都需要多次调用注册中心。在与注册中心的多次交互中，可能由于网络抖动、注册中心集群异常等原因，导致个别调用失败。对于注册中心来说，偶发的注册调用失败对服务调用基本没有影响，其结果顶多就是某一个服务少了一个可用的节点。但偶发的反注册调用失败会导致不可用的节点残留在注册中心中，变成“僵尸节点”，但服务消费者端还会把它当成“活节点”，继续发起调用，最终导致调用失败。</p>
<p>以前我们的业务中经常遇到这个问题，需要定时去清理注册中心中的“僵尸节点”。后来我们通过优化反注册逻辑，对于下线机器、节点销毁的场景，通过调用注册中心提供的批量反注册接口，一次调用就可以把该节点上提供的所有服务同时反注册掉，从而避免了“僵尸节点”的出现。</p>
<h2 id="4-服务变更信息增量更新"><a href="#4-服务变更信息增量更新" class="headerlink" title="4. 服务变更信息增量更新"></a>4. 服务变更信息增量更新</h2><p>服务消费者端启动时，除了会查询订阅服务的可用节点列表做初始化连接，还会订阅服务的变更，每隔一段时间从注册中心获取最新的服务节点信息标记 sign，并与本地保存的 sign 值作比对，如果不一样，就会调用注册中心获取最新的服务节点信息。</p>
<p>一般情况下，按照这个过程是没问题的，但是在网络频繁抖动时，服务提供者上报给注册中心的心跳可能会一会儿失败一会儿成功，这时候注册中心就会频繁更新服务的可用节点信息，导致服务消费者频繁从注册中心拉取最新的服务可用节点信息，严重时可能产生网络风暴，导致注册中心带宽被打满。</p>
<p>为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-微服务/如何使用服务路由"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/" class="article-date">
  <time datetime="2022-10-29T09:05:55.808Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求。</p>
<h1 id="服务路由的应用场景"><a href="#服务路由的应用场景" class="headerlink" title="服务路由的应用场景"></a>服务路由的应用场景</h1><p>服务路由主要有以下几种应用场景：</p>
<ul>
<li>分组调用。一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。</li>
<li>灰度发布。在服务上线发布的过程中，一般需要先在一小部分规模的服务节点上先发布服务，然后验证功能是否正常。如果正常的话就继续扩大发布范围；如果不正常的话，就需要排查问题，解决问题后继续发布。这个过程就叫作灰度发布，也叫金丝雀部署。</li>
<li>流量切换。在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。</li>
<li>读写分离。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。</li>
</ul>
<h1 id="服务路由的规则"><a href="#服务路由的规则" class="headerlink" title="服务路由的规则"></a>服务路由的规则</h1><p>服务路由主要有两种规则：一种是条件路由，一种是脚本路由。</p>
<h2 id="1-条件路由"><a href="#1-条件路由" class="headerlink" title="1. 条件路由"></a>1. 条件路由</h2><p>条件路由是基于条件表达式的路由规则，以下面的条件路由为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition://0.0.0.0/dubbo.test.interfaces.TestService?category=routers&amp;dynamic=true&amp;priority=2&amp;enabled=true&amp;rule=&quot; + URL.encode(&quot; host = 10.20.153.10=&gt; host = 10.20.153.11&quot;)</span><br></pre></td></tr></table></figure>
<p>这里面<code>condition://</code>代表了这是一段用条件表达式编写的路由规则，具体的规则是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host = 10.20.153.10 =&gt; host = 10.20.153.11</span><br></pre></td></tr></table></figure>
<p>分隔符“&#x3D;&gt;”前面是服务消费者的匹配条件，后面是服务提供者的过滤条件。当服务消费者节点满足匹配条件时，就对该服务消费者执行后面的过滤规则。那么上面这段表达式表达的意义就是 IP 为“10.20.153.10”的服务消费者都调用 IP 为“10.20.153.11”的服务提供者节点。</p>
<p>如果服务消费者的匹配条件为空，就表示对所有的服务消费者应用，就像下面的表达式一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host ！= 10.20.153.11</span><br></pre></td></tr></table></figure>
<p>如果服务提供者的过滤条件为空，就表示禁止服务消费者访问，就像下面的表达式一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host = 10.20.153.10=&gt;</span><br></pre></td></tr></table></figure>
<p>下面举一些 Dubbo 框架中的条件路由，来给你讲解下条件路由的具体应用场景。</p>
<ul>
<li>排除某个服务节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt; host != 172.22.3.91</span><br></pre></td></tr></table></figure>
一旦这条路由规则被应用到线上，所有的服务消费者都不会访问 IP 为 172.22.3.91 的服务节点，这种路由规则一般应用在线上流量排除预发布机以及摘除某个故障节点的场景。</li>
<li>白名单和黑名单功能<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host != 10.20.153.10,10.20.153.11 =&gt;</span><br></pre></td></tr></table></figure>
这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者可以发起服务调用以外，其他服务消费者都不可以，主要用于白名单访问逻辑，比如某个后台服务只允许特定的几台机器才可以访问，这样的话可以机器控制访问权限。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host = 10.20.153.10,10.20.153.11 =&gt;</span><br></pre></td></tr></table></figure>
同理，这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者不能发起服务调用以外，其他服务消费者都可以，也就是实现了黑名单功能，比如线上经常会遇到某些调用方不管是出于有意还是无意的不合理调用，影响了服务的稳定性，这时候可以通过黑名单功能暂时予以封杀。</li>
<li>机房隔离<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host = 172.22.3.* =&gt; host = 172.22.3.*</span><br></pre></td></tr></table></figure>
这条路由规则意思是 IP 网段为 172.22.3.* 的服务消费者，才可以访问同网段的服务节点，这种规则一般应用于服务部署在多个 IDC，理论上同一个 IDC 内的调用性能要比跨 IDC 调用性能要好，应用这个规则是为了实现同 IDC 就近访问。</li>
<li>读写分离<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method = find*,list*,get*,is* =&gt; host =172.22.3.94,172.22.3.95</span><br><span class="line">method != find*,list*,get*,is* =&gt; host = 172.22.3.97,172.22.3.98</span><br></pre></td></tr></table></figure>
这条路由规则意思是<code>find*、get*、is*</code>等读方法调用 IP 为 172.22.3.94 和 172.22.3.95 的节点，除此以外的写方法调用 IP 为 172.22.3.97 和 172.22.3.98 的节点。对于大部分互联网业务来说，往往读请求要远远大于写请求，而写请求的重要性往往要远远高于读请求，所以需要把读写请求进行分离，以避免读请求异常影响到写请求，这时候就可以应用这种规则。</li>
</ul>
<h2 id="2-脚本路由"><a href="#2-脚本路由" class="headerlink" title="2. 脚本路由"></a>2. 脚本路由</h2><p>脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 JavaScript、Groovy、JRuby 等。以下面的脚本路由规则为例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;script://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=&quot; + URL.encode(&quot;（function route(invokers) &#123; ... &#125; (invokers)）&quot;)</span><br></pre></td></tr></table></figure>
<p>这里面<code>script://</code>就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 JavaScript 编写的 route() 方法表达的意思是，只有 IP 为 10.20.153.10 的服务消费者可以发起服务调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">route</span>(<span class="params">invokers</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> java.<span class="property">util</span>.<span class="title class_">ArrayList</span>(invokers.<span class="title function_">size</span>());</span><br><span class="line">  <span class="keyword">for</span>(i =<span class="number">0</span>; i &lt; invokers.<span class="title function_">size</span>(); i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;10.20.153.10&quot;</span>.<span class="title function_">equals</span>(invokers.<span class="title function_">get</span>(i).<span class="title function_">getUrl</span>().<span class="title function_">getHost</span>()))&#123; </span><br><span class="line">       result.<span class="title function_">add</span>(invokers.<span class="title function_">get</span>(i));</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125; (invokers)）;</span><br></pre></td></tr></table></figure>
<p>既然服务路由是通过路由规则来实现的，那么服务消费者该如何获取路由规则呢？</p>
<h1 id="服务路由的获取方式"><a href="#服务路由的获取方式" class="headerlink" title="服务路由的获取方式"></a>服务路由的获取方式</h1><p>服务路由的获取方式主要有三种：</p>
<ul>
<li>本地配置<br>顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。</li>
<li>配置中心管理<br>这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。</li>
<li>动态下发<br>这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。</li>
</ul>
<p>上面三种方式实际使用时，还是有一定区别的。</p>
<p>一般来讲，服务路由最好是存储在配置中心中，由配置中心来统一管理。这样的话，所有的服务消费者就不需要在本地管理服务路由，因为大部分的服务消费者并不关心服务路由的问题，或者说也不需要去了解其中的细节。通过配置中心，统一给各个服务消费者下发统一的服务路由，节省了沟通和管理成本。</p>
<p>但也不排除某些服务消费者有特定的需求，需要定制自己的路由规则，这个时候就适合通过本地配置来定制。</p>
<p>而动态下发可以理解为一种高级功能，它能够动态地修改路由规则，在某些业务场景下十分有用。比如某个数据中心存在问题，需要把调用这个数据中心的服务消费者都切换到其他数据中心，这时就可以通过动态下发的方式，向配置中心下发一条路由规则，将所有调用这个数据中心的请求都迁移到别的地方。</p>
<p>当然，这三种方式也可以一起使用，这个时候服务消费者的判断优先级是本地配置 &gt; 动态下发 &gt; 配置中心管理。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>服务路由的作用，简单来讲就是为了实现某些调用的特殊需求，比如分组调用、灰度发布、流量切换、读写分离等。在业务规模比较小的时候，可能所有的服务节点都部署在一起，也就不需要服务路由。但随着业务规模的扩大、服务节点增多，尤其是涉及多数据中心部署的情况，把服务节点按照数据中心进行分组，或者按照业务的核心程度进行分组，对提高服务的可用性是十分有用的。以微博业务为例，有的服务不仅进行了核心服务和非核心服务分组，还针对私有云和公有云所处的不同数据中心也进行了分组，这样的话就可以将服务之间的调用尽量都限定在同一个数据中心内部，最大限度避免跨数据中心的网络延迟、抖动等影响。</p>
<p>而服务路由具体是在本地配置，还是在配置中心统一管理，也是视具体业务需求而定的。如果没有定制化的需求，建议把路由规则都放到配置中心中统一存储管理。而动态下发路由规则对于服务治理十分有帮助，当数据中心出现故障的时候，可以实现动态切换流量，还可以摘除一些有故障的服务节点。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-密码技术/密钥"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E9%92%A5/" class="article-date">
  <time datetime="2022-10-29T09:05:55.746Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是密钥"><a href="#什么是密钥" class="headerlink" title="什么是密钥"></a>什么是密钥</h1><p>在使用对称密码、公钥密码、消息认证码、数字签名等密码技术都需要一个称为密钥的巨大数字。然而，数字本身的大小并不重要，重要的是密钥空间的大小，也就是可能出现的密钥的总数量，因为密钥空间越大，进行暴力破解就越困难。密钥空间的大小由密钥长度决定。</p>
<h2 id="DES-的密钥"><a href="#DES-的密钥" class="headerlink" title="DES 的密钥"></a>DES 的密钥</h2><p>对称密码 DES 的密钥的实质长度为 56 比特(7字节)。一个 DES 密钥可表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 二进制</span><br><span class="line">01010001 11101100 01001011 00010010 00111101 01000010 00000011</span><br><span class="line">// 十六进制</span><br><span class="line">51 EC 4B 12 3D 42 03</span><br><span class="line">// 十进制</span><br><span class="line">2305928028626269955</span><br></pre></td></tr></table></figure>
<h2 id="3DES-的密钥"><a href="#3DES-的密钥" class="headerlink" title="3DES 的密钥"></a>3DES 的密钥</h2><p>在对称密码三重 DES 中，包括使用两个 DES 密钥的 DES-EDE2 和使用三个 DES密钥的 DES-EDE3 两种方式。</p>
<p>DES-EDE2 的密钥的实质长度为 112 比特(14字节)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51 EC 4B 12 3D 42 03 30 04 D8 98 95 93 3F</span><br></pre></td></tr></table></figure>
<p>DES-EDE3 的密钥的实质长度为 168 比特(21字节)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51 EC 4B 12 3D 42 03 30 04 D8 98 95 93 3F 24 9F 61 2A 2F D9 96</span><br></pre></td></tr></table></figure>
<h2 id="AES-的密钥"><a href="#AES-的密钥" class="headerlink" title="AES 的密钥"></a>AES 的密钥</h2><p>对称密码 AES 的密钥长度可以从 128、192和256比特中进行选择，当密钥长度为 256 比特时，其长度如下面这个数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51 EC 4B 12 3D 42 03 30 04 D8 98 95 93 3F 24 9F 61 2A 2F D9 96 B9 42 DC FD A0 AE F4 5D 60 51 F1</span><br></pre></td></tr></table></figure>
<h1 id="各种不同的密钥"><a href="#各种不同的密钥" class="headerlink" title="各种不同的密钥"></a>各种不同的密钥</h1><h2 id="对称密码的密钥与公钥密码的密钥"><a href="#对称密码的密钥与公钥密码的密钥" class="headerlink" title="对称密码的密钥与公钥密码的密钥"></a>对称密码的密钥与公钥密码的密钥</h2><p>对称密码中，加密和解密使用同一个密钥，密钥必须对发送者和接收者以外的人保密，否则第三方就能解密密文了。</p>
<img src="/2022/10/29/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E9%92%A5/img1.png" class="">

<p>公钥密码中，加密和解密使用的是不同的密钥，用于加密的密钥称为公钥，用于解密的密钥称为私钥。公钥和私钥之间具有深刻的数学关系，因此也称为密钥对。</p>
<img src="/2022/10/29/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E9%92%A5/img2.png" class="">

<h2 id="消息认证码的密钥与数字签名的密钥"><a href="#消息认证码的密钥与数字签名的密钥" class="headerlink" title="消息认证码的密钥与数字签名的密钥"></a>消息认证码的密钥与数字签名的密钥</h2><p>消息认证码中，发送者和接收者使用共享的密钥来进行认证。消息认证码只能由持有合法密钥的人计算出来。将消息认证码附加在通信报文后面，就可以识别通信内容是否被篡改或伪装。消息认证码的密钥必须对发送者和接收者之外的人保密，否则就会产生篡改和伪装的风险。</p>
<img src="/2022/10/29/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E9%92%A5/img3.png" class="">

<p>数字签名中，签名的生成和验证使用不同的密钥。只有持有私钥的本人才能够生成签名，验证签名使用的是公钥，任何人都能够验证签名。</p>
<h2 id="用于确保机密性的密钥与用于认证的密钥"><a href="#用于确保机密性的密钥与用于认证的密钥" class="headerlink" title="用于确保机密性的密钥与用于认证的密钥"></a>用于确保机密性的密钥与用于认证的密钥</h2><p>对称密码和公钥密码的密钥都是用于确保机密性的密钥，如果不知道用于解密的合法密钥，就无法得知明文的内容。</p>
<p>消息认证码和数字签名所使用的密钥，则是用于认证的密钥。如果不知道合法的密钥，就无法篡改数据，也无法伪装本人的身份。</p>
<img src="/2022/10/29/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E9%92%A5/img4.png" class="">

<h2 id="会话密钥与主密钥"><a href="#会话密钥与主密钥" class="headerlink" title="会话密钥与主密钥"></a>会话密钥与主密钥</h2><p>当我们访问以<code>https://</code>开头的网页时，浏览器和服务器之间会进行基于 SSL&#x2F;TLS 的加密通信。在这样的通信中所使用的密钥是仅限于本次通信的一次性密钥，下次通信时就不能使用了。像这样每次通信只能使用一次的密钥为会话密钥(<code>session key</code>)。</p>
<p>由于会话密钥只在本次通信中有效，万一窃听者获取了本次通信的会话密钥，也只能破译本次通信的内容，下次通信中会使用新的密钥，因此其他通信的机密性不会受到破坏。</p>
<p>相对于每次通信都更换的会话密钥，一直被重复使用的密钥称为主密钥。</p>
<h2 id="用于加密内容的密钥与用于加密密钥的密钥"><a href="#用于加密内容的密钥与用于加密密钥的密钥" class="headerlink" title="用于加密内容的密钥与用于加密密钥的密钥"></a>用于加密内容的密钥与用于加密密钥的密钥</h2><p>一般来说，加密的对象是用户直接使用的信息，这种情况下所使用的密钥称为CEK(Contents Encrypting Key，内容加密密钥)；用于加密密钥的密钥则称为KEK(Key Encrypting Key，密钥加密密钥)。</p>
<img src="/2022/10/29/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E9%92%A5/img5.png" class="">

<p>在很多情况下，会话密钥都是被作为 CEK 使用的，而主密钥则是被作为 KEK 使用的。</p>
<h1 id="密钥的管理"><a href="#密钥的管理" class="headerlink" title="密钥的管理"></a>密钥的管理</h1><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><h2 id="配送密钥"><a href="#配送密钥" class="headerlink" title="配送密钥"></a>配送密钥</h2><h2 id="更新密钥"><a href="#更新密钥" class="headerlink" title="更新密钥"></a>更新密钥</h2><h2 id="保存密钥"><a href="#保存密钥" class="headerlink" title="保存密钥"></a>保存密钥</h2><h2 id="作废密钥"><a href="#作废密钥" class="headerlink" title="作废密钥"></a>作废密钥</h2><h1 id="Diffie-Hellman-密钥交换"><a href="#Diffie-Hellman-密钥交换" class="headerlink" title="Diffie-Hellman 密钥交换"></a>Diffie-Hellman 密钥交换</h1><h1 id="基于口令的密码（PBE）"><a href="#基于口令的密码（PBE）" class="headerlink" title="基于口令的密码（PBE）"></a>基于口令的密码（PBE）</h1><p>基于口令的密码(Password Based Encryption，PBE)就是一种根据口令生成密钥并用该密钥进行加密的方法。其中加密和解密使用同一个密钥。</p>
<h2 id="PBE-加密"><a href="#PBE-加密" class="headerlink" title="PBE 加密"></a>PBE 加密</h2><img src="/2022/10/29/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%86%E9%92%A5/img6.png" class="">

<p>PBE 加密包括 3 个步骤：</p>
<ol>
<li>生成 KEK</li>
<li>生成会话密钥并加密</li>
<li>加密消息</li>
</ol>
<h3 id="1-生成-KEK"><a href="#1-生成-KEK" class="headerlink" title="1.生成 KEK"></a>1.生成 KEK</h3><p>首先，伪随机数生成器会生成一个被称为盐的随机数。将盐和口令一起输入单向散列函数，得到的散列值就是用来加密密钥的密钥(KEK)。</p>
<h3 id="2-生成会话秘钥并加密"><a href="#2-生成会话秘钥并加密" class="headerlink" title="2.生成会话秘钥并加密"></a>2.生成会话秘钥并加密</h3><p>使用伪随机数生成器生成会话密钥，会话密钥是用来加密消息的密钥(CEK)。</p>
<p>会话密钥需要用步骤 1 中生成的 KEK 进行加密，并和盐一起保存在安全的地方。会话密钥加密后，KEK 就会被丢弃，因为 KEK 没有必要保存下来，只要通过盐和口令就可以重建 KEK。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-vue/vue 组件深入"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/vue/vue%20%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5/" class="article-date">
  <time datetime="2022-10-29T09:05:55.688Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><h2 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h2><p>在注册一个组件的时候，我们始终需要给它一个名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>该组件名就是<code>Vue.component</code>的第一个参数。</p>
<h2 id="组件名大小写"><a href="#组件名大小写" class="headerlink" title="组件名大小写"></a>组件名大小写</h2><p>定义组件名的方式有两种：</p>
<h4 id="使用短横线分隔命名"><a href="#使用短横线分隔命名" class="headerlink" title="使用短横线分隔命名"></a>使用短横线分隔命名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>当使用短横线分隔命名定义一个组件时，必须在引用这个自定义元素时使用短横线分隔命名，例如 <code>&lt;my-component-name&gt;</code>。</p>
<h4 id="使用驼峰式命名"><a href="#使用驼峰式命名" class="headerlink" title="使用驼峰式命名"></a>使用驼峰式命名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyComponentName&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>当使用驼峰式命名定义一个组件时，引用这个自定义元素时两种命名法都可以使用。也就是说<code>&lt;my-component-name&gt;</code>和<code>&lt;MyComponentName&gt;</code>都是可接受的。注意，尽管如此，直接在DOM(即非字符串的模板)中使用时只有短横线分隔命名是有效的。</p>
<h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ... 选项 ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这些组件是全局注册的。也就是说它们在注册之后可以用在任何新创建的<code>Vue</code>根实例 (<code>new Vue</code>)的模板中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-a&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;component-b&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>在所有子组件中也是如此，也就是说这两个组件在各自内部也都可以相互使用。</p>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>通过一个普通的JavaScript对象来定义组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ComponentA</span> = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ComponentB</span> = &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>components</code>选项中定义要使用的组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span></span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: <span class="title class_">ComponentA</span>,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: <span class="title class_">ComponentB</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于<code>components</code>对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。<br>注意局部注册的组件在其子组件中不可用。例如，如果你希望<code>ComponentA</code>在<code>ComponentB</code>中可用，则你需要这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ComponentA</span> = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ComponentB</span> = &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>:<span class="title class_">ComponentA</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者通过Babel和webpack使用ES2015模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&#x27;./ComponentA.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">ComponentA</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对象中放一个类似<code>ComponentA</code>的变量名其实是<code>ComponentA: ComponentA</code>的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>
<h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><h2 id="在模块系统中局部注册"><a href="#在模块系统中局部注册" class="headerlink" title="在模块系统中局部注册"></a>在模块系统中局部注册</h2><p>创建一个<code>components</code>目录，并将每个组件放置在其各自的文件中。<br>然后在局部注册之前导入每个你想使用的组件。例如，在一个假设的<code>ComponentB.js</code>或<code>ComponentB.vue</code>文件中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentA</span> <span class="keyword">from</span> <span class="string">&#x27;./ComponentA&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ComponentC</span> <span class="keyword">from</span> <span class="string">&#x27;./ComponentC&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">ComponentA</span>,</span><br><span class="line">    <span class="title class_">ComponentC</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>ComponentA</code>和<code>ComponentC</code>都可以在<code>ComponentB</code>的模板中使用了。</p>
<h2 id="基础组件的自动化全局注册"><a href="#基础组件的自动化全局注册" class="headerlink" title="基础组件的自动化全局注册"></a>基础组件的自动化全局注册</h2><p>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。<br>所以会导致很多组件里都会有一个包含基础组件的长列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">BaseButton</span> <span class="keyword">from</span> <span class="string">&#x27;./BaseButton.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">BaseIcon</span> <span class="keyword">from</span> <span class="string">&#x27;./BaseIcon.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">BaseInput</span> <span class="keyword">from</span> <span class="string">&#x27;./BaseInput.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">BaseButton</span>,</span><br><span class="line">    <span class="title class_">BaseIcon</span>,</span><br><span class="line">    <span class="title class_">BaseInput</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而只是用于模板中的一小部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseInput v-model=&quot;searchText&quot; @keydown.enter=&quot;search&quot;/&gt;</span><br><span class="line">&lt;BaseButton @click=&quot;search&quot;&gt;</span><br><span class="line">  &lt;BaseIcon name=&quot;search&quot;/&gt;</span><br><span class="line">&lt;/BaseButton&gt;</span><br></pre></td></tr></table></figure>
<p>如果你使用了webpack，那么就可以使用<code>require.context</code>只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 <code>src/main.js</code>) 中全局导入基础组件的示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">&#x27;lodash/upperFirst&#x27;</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">&#x27;lodash/camelCase&#x27;</span></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.<span class="title function_">context</span>(</span><br><span class="line">  <span class="string">&#x27;./components&#x27;</span>,  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="literal">false</span>,  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  <span class="regexp">/Base[A-Z]\w+\.(vue|js)$/</span></span><br><span class="line">)</span><br><span class="line">requireComponent.<span class="title function_">keys</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line">  <span class="comment">// 获取组件的PascalCase命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = <span class="title function_">upperFirst</span>(</span><br><span class="line">    <span class="title function_">camelCase</span>(</span><br><span class="line">      <span class="comment">// 剥去文件名开头的 `&#x27;./` 和结尾的扩展名</span></span><br><span class="line">      fileName.<span class="title function_">replace</span>(<span class="regexp">/^\.\/(.*)\.\w+$/</span>, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">component</span>(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过export default导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用.default，否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.<span class="property">default</span> || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>全局注册的行为必须在根<code>Vue</code>实例(通过<code>new Vue</code>)创建之前发生。</p>
<h1 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h1><h2 id="Prop的大小写"><a href="#Prop的大小写" class="headerlink" title="Prop的大小写"></a>Prop的大小写</h2><p>HTML中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用DOM中的模板时，驼峰命名法的<code>prop</code>名需要使用其等价的短横线分隔命名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 在JavaScript中是驼峰命名法的</span></span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;postTitle&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;!-- 在 <span class="variable constant_">HTML</span>中是短横线分隔命名的 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">&quot;hello!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果使用字符串模板，那么这个限制就不存在了。</p>
<h2 id="静态和动态的Prop"><a href="#静态和动态的Prop" class="headerlink" title="静态和动态的Prop"></a>静态和动态的Prop</h2><p>可以像这样给<code>prop</code>传入一个静态的值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">&quot;My journey with Vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>prop</code>还可以通过<code>v-bind</code>动态赋值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>任何类型的值都可以传给一个<code>prop</code>。</p>
<h4 id="传入一个数字"><a href="#传入一个数字" class="headerlink" title="传入一个数字"></a>传入一个数字</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便42是静态的，我们仍然需要v-bind来告诉Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个JavaScript表达式而不是一个字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">&quot;42&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">&quot;post.likes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="传入一个布尔值"><a href="#传入一个布尔值" class="headerlink" title="传入一个布尔值"></a>传入一个布尔值</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含该prop没有值的情况在内，都意味着true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">favorited</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即便false是静态的，我们仍然需要v-bind来告诉Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-bind:favorited</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-bind:favorited</span>=<span class="string">&quot;post.currentUserFavorited&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="传入一个数组"><a href="#传入一个数组" class="headerlink" title="传入一个数组"></a>传入一个数组</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便数组是静态的，我们仍然需要v-bind来告诉Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个JavaScript表达式而不是一个字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">&quot;[234, 266, 273]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">&quot;post.commentIds&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="传入一个对象"><a href="#传入一个对象" class="headerlink" title="传入一个对象"></a>传入一个对象</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便对象是静态的，我们仍然需要v-bind来告诉Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个JavaScript表达式而不是一个字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comments</span>=<span class="string">&quot;&#123; id: 1, title: &#x27;My Journey with Vue&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:post</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="传入一个对象的所有属性"><a href="#传入一个对象的所有属性" class="headerlink" title="传入一个对象的所有属性"></a>传入一个对象的所有属性</h4><p>如果你想要将一个对象的所有属性都作为<code>prop</code>传入，可以使用不带参数的<code>v-bind</code>(取代<code>v-bind:prop-name</code>)。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#x27;My Journey with Vue&#x27;</span><br><span class="line">&#125;</span><br><span class="line">//下面的模板：</span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">//等价于：</span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;post.id&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;post.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>所有的<code>prop</code>都使得其父子<code>prop</code>之间形成了一个单向下行绑定：父级<code>prop</code>的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生更新时，子组件中所有的<code>prop</code>都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变<code>prop</code>。如果你这样做了，<code>Vue</code>会在浏览器的控制台中发出警告。<br>这里有两种常见的试图改变一个<code>prop</code>的情形：</p>
<ol>
<li>这个<code>prop</code>用来传递一个初始值；这个子组件接下来希望将其作为一个本地的<code>prop</code>数据来使用。在这种情况下，最好定义一个本地的<code>data</code>属性并将这个<code>prop</code>用作其初始值。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line"><span class="attr">data</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">initialCounter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这个<code>prop</code>以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个<code>prop</code>的值来定义一个计算属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedSize</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意在JavaScript中对象和数组是通过引用传入的，所以对于一个数组或对象类型的<code>prop</code>来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</li>
</ol>
<h2 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h2><p>我们可以为组件的<code>prop</code>指定需求。如果有一个需求没有被满足，则<code>Vue</code>会在浏览器控制台中警告你。<br>为了定制<code>prop</code>的验证方式，可以为<code>props</code>中的值提供一个带有验证需求的对象，而不是一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 匹配任何类型)</span></span><br><span class="line">    <span class="attr">propA</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    <span class="attr">propB</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    <span class="attr">propD</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    <span class="attr">propE</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组且一定会从一个工厂函数返回默认值</span></span><br><span class="line">      <span class="attr">default</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    <span class="attr">propF</span>: &#123;</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当<code>prop</code>验证失败的时候，(开发环境构建版本的)<code>Vue</code>将会产生一个控制台的警告。<br>注意那些<code>prop</code>会在一个组件实例创建之前进行验证，所以实例的属性 (如<code>data</code>、<code>computed</code>等) 在<code>default</code>或<code>validator</code>函数中是不可用的。</p>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p><code>type</code>可以是下列原生构造函数中的一个：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Function</code>、<code>Object</code>、<code>Array</code>、<code>Symbol</code>。<br>额外的，<code>type</code>还可以是一个自定义的构造函数，并且通过<code>instanceof</code>来进行检查确认。例如，给定下列现成的构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (firstName, lastName) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">author</span>: <span class="title class_">Person</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来验证<code>author prop</code>的值是否是通过<code>new Person</code>创建的。</p>
<h2 id="非Prop的特性"><a href="#非Prop的特性" class="headerlink" title="非Prop的特性"></a>非Prop的特性</h2><p>一个非<code>prop</code>特性是指传向一个组件，但是该组件并没有相应<code>prop</code>定义的特性。<br>因为显式定义的<code>prop</code>适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上。<br>例如，想象一下你通过一个Bootstrap插件使用了一个第三方的<code>&lt;bootstrap-data-input&gt;</code>组件，这个插件需要在其<code>&lt;input&gt;</code>上用到一个<code>data-date-picker</code>特性。我们可以将这个特性添加到你的组件实例上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span> <span class="attr">data-date-picker</span>=<span class="string">&quot;activated&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后这个<code>data-date-picker=&quot;activated&quot;</code>特性就会自动添加到<code>&lt;bootstrap-date-input&gt;</code>的根元素上。</p>
<h4 id="替换-x2F-合并已有的特性"><a href="#替换-x2F-合并已有的特性" class="headerlink" title="替换&#x2F;合并已有的特性"></a>替换&#x2F;合并已有的特性</h4><p>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span></span></span><br><span class="line"><span class="tag"> <span class="attr">data-date-picker</span>=<span class="string">&quot;activated&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">class</span>=<span class="string">&quot;date-picker-theme-dark&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们定义了两个不同的 <code>class</code> 的值：</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数特性来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code> 和 <code>style</code> 特性会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
<h4 id="禁用特性继承"><a href="#禁用特性继承" class="headerlink" title="禁用特性继承"></a>禁用特性继承</h4><p>如果你不希望组件的根元素继承特性，你可以设置在组件的选项中设置<code>inheritAttrs: false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这尤其适合配合实例的<code>$attrs</code>属性使用，该属性包含了传递给一个组件的特性名和特性值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">class</span>: <span class="string">&#x27;username-input&#x27;</span>,</span><br><span class="line"> <span class="attr">placeholder</span>: <span class="string">&#x27;Enter your username&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些特性会被赋予哪个元素。在撰写基础组件的时候是常会用到的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的HTML元素，而不会担心哪个元素是真正的根元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;username-input&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><h2 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h2><p><code>Vue</code>实现了一套内容分发的API，将<code>&lt;slot&gt;</code>元素作为承载分发内容的出口。<br>它允许你像这样合成组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后你在<code>&lt;navigation-link&gt;</code>的模板中可能会写为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当组件渲染的时候，这个<code>&lt;slot&gt;</code>元素将会被替换为<code>Your Profile</code>。插槽内可以包含任何模板代码，包括 HTML。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>甚至其它的组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个图标的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">font-awesome-icon</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>&lt;navigation-link&gt;</code>没有包含一个<code>&lt;slot&gt;</code>元素，则任何传入它的内容都会被抛弃。</p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>有些时候我们需要多个插槽。例如，一个假设的<code>&lt;base-layout&gt;</code>组件多模板如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于这样的情况，<code>&lt;slot&gt;</code>元素有一个特殊的特性：<code>name</code>。这个特性可以用来定义额外的插槽。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在向具名插槽提供内容的时候，我们可以在一个父组件的<code>&lt;template&gt;</code>元素上使用<code>slot</code>特性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另一种<code>slot</code>特性的用法是直接用在一个普通的元素上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们还是可以保留一个未命名插槽，这个插槽是默认插槽，也就是说它会作为所有未匹配到插槽的内容的统一出口。上述两个示例渲染出来的HTML都将会是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="插槽的默认内容"><a href="#插槽的默认内容" class="headerlink" title="插槽的默认内容"></a>插槽的默认内容</h2><p>有的时候为插槽提供默认的内容是很有用的。例如，一个<code>&lt;submit-button&gt;</code>组件可能希望这个按钮的默认内容是<code>Submit</code>，但是同时允许用户覆写为<code>Save、Upload</code>或别的内容。<br>可以在<code>&lt;slot&gt;</code>标签内部指定默认的内容来做到这一点。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果父组件为这个插槽提供了内容，则默认的内容会被替换掉。</p>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><h2 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h2><p>跟组件和<code>prop</code>不同，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。如果触发一个驼峰式命名名字的事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;myEvent&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>则监听这个名字的短横线分隔命名版本是不会有任何效果的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:my-event</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>跟组件和<code>prop</code>不同，事件名不会被用作一个JavaScript变量名或属性名，所以就没有理由使用驼峰式命名了。并且<code>v-on</code>事件监听器在DOM模板中会被自动转换为全小写 (因为HTML是大小写不敏感的)，所以<code>v-on:myEvent</code>将会变成<code>v-on:myevent</code>——导致<code>myEvent</code>不可能被监听到。<br>因此，我们推荐你始终使用短横线分隔命名的事件名。</p>
<h2 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的v-model</h2><p>一个组件上的<code>v-model</code>默认会利用名为 <code>value</code>的<code>prop</code>和名为<code>input</code>的事件，但是像单选框、复选框等类型的输入控件可能会将<code>value</code>特性用于不同的目的。<code>model</code>选项可以用来避免这样的冲突：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">checked</span>: <span class="title class_">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在在这个组件上使用<code>v-model</code>的时候：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;lovingVue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>lovingVue</code>的值将会传入这个名为<code>checked</code>的<code>prop</code>。同时当<code>&lt;base-checkbox&gt;</code>触发一个<code>change</code>事件并附带一个新的值的时候，这个<code>lovingVue</code>的属性将会被更新。<br>注意你仍然需要在组件的<code>props</code>选项里声明<code>checked</code>这个<code>prop</code>。</p>
<h2 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h2><p>要在一个组件的根元素上直接监听一个原生事件。可以使用<code>-on</code>的<code>.native</code>修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有的时候这是很有用的，不过在你尝试监听一个类似<code>&lt;input&gt;</code>的非常特定的元素时，这并不是个好主意。比如上述<code>&lt;base-input&gt;</code>组件可能做了如下重构，所以根元素实际上是一个<code>&lt;label&gt;</code>元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时，父级的<code>.native</code>监听器将静默失败。它不会产生任何报错，但是<code>onFocus</code>处理函数不会被调用。<br>为了解决这个问题，Vue提供了一个<code>$listeners</code>属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">focus</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  <span class="attr">input</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个<code>$listeners</code>属性，你就可以配合<code>v-on=&quot;$listeners&quot;</code>将所有的事件监听器指向这个组件的某个特定的子元素。对于类似<code>&lt;input&gt;</code>的你希望它也可以配合<code>v-model</code>工作的组件来说，为这些监听器创建一个类似下述<code>inputListeners</code>的计算属性通常是非常有用的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inheritAttrs</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">inputListeners</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="variable language_">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$listeners</span>,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          <span class="attr">input</span>: <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">            vm.$emit(<span class="string">&#x27;input&#x27;</span>, event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on=&quot;inputListeners&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在<code>&lt;base-input&gt;</code>组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的<code>&lt;input&gt;</code>元素一样使用了：所有跟它相同的特性和监听器的都可以工作。</p>
<h2 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h2><p>在有些情况下，我们可能需要对一个<code>prop</code>进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。<br>我们推荐以<code>update:my-prop-name</code>的模式触发事件取而代之。举个例子，在一个包含<code>title prop</code>的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, newTitle)</span><br></pre></td></tr></table></figure>
<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag"> <span class="attr">v-bind:title</span>=<span class="string">&quot;doc.title&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">v-on:update:title</span>=<span class="string">&quot;doc.title = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">&quot;doc.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当我们用一个对象同时设置多个<code>prop</code>的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">&quot;doc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样会把<code>doc</code>对象中的每一个属性 (如<code>title</code>) 都作为一个独立的<code>prop</code>传进去，然后各自添加用于更新的<code>v-on</code>监听器。<br>将<code>v-bind.sync</code>用在一个字面量的对象上，例如<code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-vue/vue 开发技巧"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/vue/vue%20%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" class="article-date">
  <time datetime="2022-10-29T09:05:55.687Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="避免v-if和v-for一起使用"><a href="#避免v-if和v-for一起使用" class="headerlink" title="避免v-if和v-for一起使用"></a>避免v-if和v-for一起使用</h1><p>为什么要避免<code>v-if</code>和<code>v-for</code>在同一个元素上同时使用呢？因为在 vue 的源码中有一段代码时对指令的优先级的处理，这段代码是先处理<code>v-for</code>再处理<code>v-if</code>的。所以如果我们在同一层中一起使用两个指令，会出现一些不必要的性能问题，比如这个列表有一百条数据，再某种情况下，它们都不需要显示，当 vue 还是会循环这个 100 条数据显示，再去判断<code>v-if</code>，因此，我们应该避免这种情况的出现。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不好的🌰 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">&quot;status&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 100&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 好的🌰 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;status&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-for</span>=<span class="string">&quot;item in 100&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-others/有趣的网站"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/others/%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%AB%99/" class="article-date">
  <time datetime="2022-10-29T09:05:55.638Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="正则表达式搜索网站"><a href="#正则表达式搜索网站" class="headerlink" title="正则表达式搜索网站"></a>正则表达式搜索网站</h1><p>项目：<a target="_blank" rel="noopener" href="https://github.com/geongeorge/i-hate-regex">https://github.com/geongeorge/i-hate-regex</a><br>网站：<a target="_blank" rel="noopener" href="https://ihateregex.io/expr/phone">https://ihateregex.io/expr/phone</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-others/小程序接口问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/10/29/others/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2022-10-29T09:05:55.636Z" itemprop="datePublished">2022-10-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-蓝牙打印"><a href="#1-蓝牙打印" class="headerlink" title="1.蓝牙打印"></a>1.蓝牙打印</h2><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/3534846-5f4eb4d3de66d0a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>暂无接口</p>
<h2 id="2-首页列表接口"><a href="#2-首页列表接口" class="headerlink" title="2.首页列表接口"></a>2.首页列表接口</h2><h4 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.zjcoldcloud.com/xiandun/public/index.php/index/device/device_list?openid=owUdO5al4WDF6rHgqfzkTsCYNlTY&amp;offset=0</span><br></pre></td></tr></table></figure>
<p>接口返回参数如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;guigexinghao&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ZL-TH10TP&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;daoqishijian&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-06-23 00:00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;beizhu&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">35856</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;zhiding&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;shebeibianhao&quot;</span><span class="punctuation">:</span> <span class="string">&quot;500317&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2019-11-02 23:57:39&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_servicetime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2019-11-02 23:58:03&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_temperature01&quot;</span><span class="punctuation">:</span> <span class="number">28.8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_temperature02&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_humidity&quot;</span><span class="punctuation">:</span> <span class="number">47.4</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_jingdu&quot;</span><span class="punctuation">:</span> <span class="number">113.53752136</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_weidu&quot;</span><span class="punctuation">:</span> <span class="number">23.14853668</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_power&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_yuliu01&quot;</span><span class="punctuation">:</span> <span class="number">204</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_yuliu02&quot;</span><span class="punctuation">:</span> <span class="number">157</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;last_shujuchangdu&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hegewendu_xiaxian&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hegewendu_shangxian&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;baojingwendu_xiaxian&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;baojingwendu_shangxian&quot;</span><span class="punctuation">:</span> <span class="number">27</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;model_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TH&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;is_master&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;jihuoshiian&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2020-06-23 10:58:03&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;广东省广州市萝岗区云埔一路16-18号广州达意隆包装机械股份有限公司西87米&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hegewenduqujian&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24-26℃&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;baojingwenduqujian&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24-27℃&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;xiangzistate&quot;</span><span class="punctuation">:</span> <span class="string">&quot;close&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;xinhaoqiangdu&quot;</span><span class="punctuation">:</span> <span class="number">29</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>缺少温湿度报警阈值、温湿度超温报警开关、在线离线、电量下线.<br>相关字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 温度1、2</span></span><br><span class="line">baojingwendu_shangxian_baojing</span><br><span class="line">baojingwendu_xiaxian_baojing</span><br><span class="line">baojingwendu_shangxian</span><br><span class="line">baojingwendu_xiaxian</span><br><span class="line">baojingwendu_two_xiaxian_baojing</span><br><span class="line">baojingwendu_two_shangxian_baojing</span><br><span class="line">baojingwendu_two_xiaxian</span><br><span class="line">baojingwendu_two_shangxian</span><br><span class="line"><span class="comment">// 湿度</span></span><br><span class="line">chaodishidubaojing</span><br><span class="line">chaogaoshidubaojing</span><br><span class="line">chaodishidubaojingfazhi</span><br><span class="line">chaogaoshidubaojingfazhi</span><br><span class="line"><span class="comment">// 电量</span></span><br><span class="line">dianliang_xiaxian_baojing</span><br><span class="line">dianliang_xiaxian</span><br></pre></td></tr></table></figure>

<h2 id="3-设备参数设置"><a href="#3-设备参数设置" class="headerlink" title="3.设备参数设置"></a>3.设备参数设置</h2><h4 id="相关接口-1"><a href="#相关接口-1" class="headerlink" title="相关接口"></a>相关接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.zjcoldcloud.com/xiandun/public/index.php/index/device/update_device</span><br></pre></td></tr></table></figure>
<h4 id="相关字段"><a href="#相关字段" class="headerlink" title="相关字段"></a>相关字段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yejianshangchuankaiguan</span><br><span class="line">dingshifasong</span><br></pre></td></tr></table></figure>
<h4 id="参数效果图"><a href="#参数效果图" class="headerlink" title="参数效果图"></a>参数效果图</h4><p><img src="https://upload-images.jianshu.io/upload_images/3534846-0b6e6b1f5008db6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-0c8b76fc2cf4ab30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-67d34b577366dc49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-e7b8b3c7b7a4c161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>定时推送时间添加能成功，删除不成功，接口返回success<br>夜间上传开关设置不成功，接口返回success</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>