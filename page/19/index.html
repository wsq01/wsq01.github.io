<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-java/基础/Java泛型和枚举"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/10/java/%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%9E%9A%E4%B8%BE/"
    >Java 泛型和枚举</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/10/java/%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%9E%9A%E4%B8%BE/" class="article-date">
  <time datetime="2020-10-10T03:31:41.000Z" itemprop="datePublished">2020-10-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Java 集合有个缺点，就是把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了<code>Object</code>类型（其运行时类型没变）。</p>
<p>Java 集合之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性，但这样做带来如下两个问题：</p>
<ol>
<li>集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存<code>Dog</code>对象的集合，但程序也可以轻易地将<code>Cat</code>对象“丢”进去，所以可能引发异常。</li>
<li>由于把对象“丢进”集合时，集合丢失了对象的状态信息，集合只知道它盛装的是<code>Object</code>，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发<code>ClassCastException</code>异常。</li>
</ol>
<p>为了解决上述问题，Java 提供了泛型。泛型可以在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高了代码的重用率。</p>
<h2 id="泛型集合"><a href="#泛型集合" class="headerlink" title="泛型集合"></a>泛型集合</h2><p>泛型本质上是提供类型的“类型参数”，也就是参数化类型。我们可以为类、接口或方法指定一个类型参数，通过这个参数限制操作的数据类型，从而保证类型转换的绝对安全。</p>
<p>下面将结合泛型与集合编写一个案例实现图书信息输出。</p>
<ol>
<li>首先需要创建一个表示图书的实体类<code>Book</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> Id; <span class="comment">// 图书编号</span></span><br><span class="line">  <span class="keyword">private</span> String Name; <span class="comment">// 图书名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> Price; <span class="comment">// 图书价格</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> price)</span> &#123; <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.Id = id;</span><br><span class="line">    <span class="built_in">this</span>.Name = name;</span><br><span class="line">    <span class="built_in">this</span>.Price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">// 重写 toString()方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.Id + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.Name + <span class="string">&quot;，&quot;</span> + <span class="built_in">this</span>.Price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>Book</code>作为类型创建<code>Map</code>和<code>List</code>两个泛型集合，然后向集合中添加图书元素，最后输出集合中的内容。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test14</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建3个Book对象</span></span><br><span class="line">    <span class="type">Book</span> <span class="variable">book1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>, <span class="string">&quot;唐诗三百首&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2</span>, <span class="string">&quot;小星星&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">3</span>, <span class="string">&quot;成语大全&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Map&lt;Integer, Book&gt; books = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Book&gt;(); <span class="comment">// 定义泛型 Map 集合</span></span><br><span class="line">    books.put(<span class="number">1001</span>, book1); <span class="comment">// 将第一个 Book 对象存储到 Map 中</span></span><br><span class="line">    books.put(<span class="number">1002</span>, book2); <span class="comment">// 将第二个 Book 对象存储到 Map 中</span></span><br><span class="line">    books.put(<span class="number">1003</span>, book3); <span class="comment">// 将第三个 Book 对象存储到 Map 中</span></span><br><span class="line">    System.out.println(<span class="string">&quot;泛型Map存储的图书信息如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer id : books.keySet()) &#123;</span><br><span class="line">      <span class="comment">// 遍历键</span></span><br><span class="line">      System.out.print(id + <span class="string">&quot;——&quot;</span>);</span><br><span class="line">      System.out.println(books.get(id)); <span class="comment">// 不需要类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Book&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Book&gt;(); <span class="comment">// 定义泛型的 List 集合</span></span><br><span class="line">    bookList.add(book1);</span><br><span class="line">    bookList.add(book2);</span><br><span class="line">    bookList.add(book3);</span><br><span class="line">    System.out.println(<span class="string">&quot;泛型List存储的图书信息如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bookList.size(); i++) &#123;</span><br><span class="line">      System.out.println(bookList.get(i)); <span class="comment">// 这里不需要类型转换</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在该示例中，第 7 行代码创建了一个键类型为<code>Integer</code>、值类型为<code>Book</code>的泛型集合，即指明了该<code>Map</code>集合中存放的键必须是<code>Integer</code>类型、值必须为<code>Book</code>类型，否则编译出错。在获取<code>Map</code>集合中的元素时，不需要将<code>books.get(id);</code>获取的值强制转换为<code>Book</code>类型，程序会隐式转换。在创建<code>List</code>集合时，同样使用了泛型，因此在获取集合中的元素时也不需要将<code>bookList.get(i)</code>代码强制转换为<code>Book</code>类型，程序会隐式转换。</li>
</ol>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">泛型Map存储的图书信息如下：</span><br><span class="line">1001——1, 唐诗三百首，8</span><br><span class="line">1003——3, 成语大全，22</span><br><span class="line">1002——2, 小星星，12</span><br><span class="line">泛型List存储的图书信息如下：</span><br><span class="line">1, 唐诗三百首，8</span><br><span class="line">2, 小星星，12</span><br><span class="line">3, 成语大全，22</span><br></pre></td></tr></table></figure>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>除了可以定义泛型集合之外，还可以直接限定泛型类的类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class_name</span>&lt;data_type1,data_type2,…&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code>表示类的名称，<code>data_ type1</code>等表示类型参数。Java 泛型支持声明一个以上的类型参数，只需要将类型用逗号隔开即可。</p>
<p>泛型类一般用于类中的属性类型不确定的情况下。在声明属性时，使用下面的语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> data_type1 property_name1;</span><br><span class="line"><span class="keyword">private</span> data_type2 property_name2;</span><br></pre></td></tr></table></figure>
<p>该语句中的<code>data_type1</code>与类声明中的<code>data_type1</code>表示的是同一种数据类型。</p>
<p>在实例化泛型类时，需要指明泛型类中的类型参数，并赋予泛型类属性相应类型的值。例如，下面的示例代码创建了一个表示学生的泛型类，该类中包括 3 个属性，分别是姓名、年龄和性别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span>&lt;N, A, S&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> N name; <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">private</span> A age; <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">private</span> S sex; <span class="comment">// 性别</span></span><br><span class="line">  <span class="comment">// 创建类的构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(N name, A age, S sex)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面是上面3个属性的setter/getter方法</span></span><br><span class="line">  <span class="keyword">public</span> N <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(N name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> A <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(A age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> S <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(S sex)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建测试类。在测试类中调用<code>Stu</code>类的构造方法实例化<code>Stu</code>对象，并给该类中的 3 个属性赋予初始值，最终需要输出学生信息。测试类的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test14</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stu&lt;String, Integer, Character&gt; stu = <span class="keyword">new</span> <span class="title class_">Stu</span>&lt;String, Integer, Character&gt;(<span class="string">&quot;张晓玲&quot;</span>, <span class="number">28</span>, <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stu.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> stu.getAge();</span><br><span class="line">    <span class="type">Character</span> <span class="variable">sex</span> <span class="operator">=</span> stu.getSex();</span><br><span class="line">    System.out.println(<span class="string">&quot;学生信息如下：&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;学生姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age + <span class="string">&quot;，性别：&quot;</span> + sex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">学生信息如下：</span><br><span class="line">学生姓名：张晓玲，年龄：28，性别：女</span><br></pre></td></tr></table></figure>
<p>在该程序的<code>Stu</code>类中，定义了 3 个类型参数，分别使用<code>N、A</code>和<code>S</code>来代替，同时实现了这 3 个属性的<code>setter/getter</code>方法。在主类中，调用<code>Stu</code>类的构造函数创建了<code>Stu</code>类的对象，同时指定 3 个类型参数，分别为<code>String、Integer</code>和<code>Character</code>。在获取学生姓名、年龄和性别时，不需要类型转换，程序隐式地将<code>Object</code>类型的数据转换为相应的数据类型。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型同样可以在类中包含参数化的方法，而方法所在的类可以是泛型类，也可以不是泛型类。也就是说，是否拥有泛型方法，与其所在的类是不是泛型没有关系。</p>
<p>泛型方法使得该方法能够独立于类而产生变化。如果使用泛型方法可以取代类泛型化，那么就应该只使用泛型方法。另外，对一个<code>static</code>的方法而言，无法访问泛型类的类型参数。因此，如果<code>static</code>方法需要使用泛型能力，就必须使其成为泛型方法。</p>
<p>定义泛型方法的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问权限修饰符] [static] [final] &lt;类型参数列表&gt; 返回值类型 方法名([形式参数列表])</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List <span class="title function_">find</span><span class="params">(Class&lt;T&gt; cs,<span class="type">int</span> userId)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说编写 Java 泛型方法，其返回值类型至少有一个参数类型应该是泛型，而且类型应该是一致的，如果只有返回值类型或参数类型之一使用了泛型，那么这个泛型方法的使用就被限制了。</p>
<p>使用泛型方法打印图书信息。定义泛型方法，参数类型使用“T”来代替。在方法的主体中打印出图书信息。代码的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test16</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">List</span><span class="params">(T book)</span> &#123; <span class="comment">// 定义泛型方法</span></span><br><span class="line">    <span class="keyword">if</span> (book != <span class="literal">null</span>) &#123;</span><br><span class="line">      System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Book</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1</span>, <span class="string">&quot;细学 Java 编程&quot;</span>, <span class="number">28</span>);</span><br><span class="line">    List(stu); <span class="comment">// 调用泛型方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序中的<code>Book</code>类为前面示例中使用到的<code>Book</code>类。在该程序中定义了一个名称为<code>List</code>的方法，该方法的返回值类型为 void，类型参数使用“T”来代替。在调用该泛型方法时，将一个<code>Book</code>对象作为参数传递到该方法中，相当于指明了该泛型方法的参数类型为<code>Book</code>。</p>
<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 细学 Java 编程，28</span><br></pre></td></tr></table></figure>
<h2 id="泛型的高级用法"><a href="#泛型的高级用法" class="headerlink" title="泛型的高级用法"></a>泛型的高级用法</h2><p>泛型的用法非常灵活，除在集合、类和方法中使用外，还可以限制泛型可用类型、使用类型通配符、继承泛型类和实现泛型接口。</p>
<h3 id="限制泛型可用类型"><a href="#限制泛型可用类型" class="headerlink" title="限制泛型可用类型"></a>限制泛型可用类型</h3><p>在 Java 中默认可以使用任何类型来实例化一个泛型类对象。当然也可以对泛型类实例的类型进行限制，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名称&lt;T extends anyClass&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<code>anyClass</code>指某个接口或类。使用泛型限制后，泛型类的类型必须实现或继承<code>anyClass</code>这个接口或类。无论<code>anyClass</code>是接口还是类，在进行泛型限制时都必须使用<code>extends</code>关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制ListClass的泛型类型必须实现List接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListClass</span>&lt;T <span class="keyword">extends</span> <span class="title class_">List</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化使用ArrayList的泛型类ListClass，正确</span></span><br><span class="line">    ListClass&lt;ArrayList&gt; lc1 = <span class="keyword">new</span> <span class="title class_">ListClass</span>&lt;ArrayList&gt;();</span><br><span class="line">    <span class="comment">// 实例化使用LinkedList的泛型类LlstClass，正确</span></span><br><span class="line">    ListClass&lt;LinkedList&gt; lc2 = <span class="keyword">new</span> <span class="title class_">ListClass</span>&lt;LinkedList&gt;();</span><br><span class="line">    <span class="comment">// 实例化使用HashMap的泛型类ListClass，错误，因为HasMap没有实现List接口</span></span><br><span class="line">    <span class="comment">// ListClass&lt;HashMap&gt; lc3=new ListClass&lt;HashMap&gt;();</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，定义<code>ListClass</code>类时设置泛型类型必须实现<code>List</code>接口。例如，<code>ArrayList</code>和<code>LinkedList</code>都实现了<code>List</code>接口，所以可以实例化<code>ListClass</code>类。而<code>HashMap</code>没有实现<code>List</code>接口，所以在实例化<code>ListClass</code>类时会报错。</p>
<p>当没有使用<code>extends</code>关键字限制泛型类型时，其实是默认使用<code>Object</code>类作为泛型类型。因此，<code>Object</code>类下的所有子类都可以实例化泛型类对象。</p>
<h3 id="使用类型通配符"><a href="#使用类型通配符" class="headerlink" title="使用类型通配符"></a>使用类型通配符</h3><p>Java 中的泛型还支持使用类型通配符，它的作用是在创建一个泛型类对象时限制这个泛型类的类型必须实现或继承某个接口或类。</p>
<p>使用泛型类型通配符的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛型类名称&lt;? extends List&gt;a = null;</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;? extends List&gt;</code>作为一个整体表示类型未知，当需要使用泛型对象时，可以单独实例化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt;a = <span class="literal">null</span>;</span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">A</span>&lt;ArrayList&gt; ();    <span class="comment">// 正确</span></span><br><span class="line">b = <span class="keyword">new</span> <span class="title class_">A</span>&lt;LinkedList&gt; ();    <span class="comment">// 正确</span></span><br><span class="line">c = <span class="keyword">new</span> <span class="title class_">A</span>&lt;HashMap&gt; ();    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，同样由于<code>HashMap</code>类没有实现<code>List</code>接口，所以在编译时会报错。</p>
<h3 id="继承泛型类和实现泛型接口"><a href="#继承泛型类和实现泛型接口" class="headerlink" title="继承泛型类和实现泛型接口"></a>继承泛型类和实现泛型接口</h3><p>定义为泛型的类和接口也可以被继承和实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FatherClass</span>&lt;T1&gt;&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SonClass</span>&lt;T1,T2,T3&gt; extents FatherClass&lt;T1&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果要在<code>SonClass</code>类继承<code>FatherClass</code>类时保留父类的泛型类型，需要在继承时指定，否则直接使用<code>extends FatherClass</code>语句进行继承操作，此时<code>T1、T2</code>和<code>T3</code>都会自动变为<code>Object</code>，所以一般情况下都将父类的泛型类型保留。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">interface1</span>&lt;T1&gt;&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SubClass</span>&lt;T1,T2,T3&gt; <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">Interface1</span>&lt;T2&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。</p>
<h2 id="声明枚举"><a href="#声明枚举" class="headerlink" title="声明枚举"></a>声明枚举</h2><p>声明枚举时必须使用<code>enum</code>关键字，然后定义枚举的名称、可访问性、基础类型和成员等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>-modifiers <span class="keyword">enum</span> <span class="title class_">enumname</span>:<span class="keyword">enum</span>-base &#123;</span><br><span class="line">  <span class="keyword">enum</span>-body,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>enum-modifiers</code>表示枚举的修饰符主要包括<code>public、private</code>和<code>internal</code>；<code>enumname</code>表示声明的枚举名称；<code>enum-base</code>表示基础类型；<code>enum-body</code>表示枚举的成员，它是枚举类型的命名常数。</p>
<p>任意两个枚举成员不能具有相同的名称，且它的常数值必须在该枚举的基础类型的范围之内，多个枚举成员之间使用逗号分隔。</p>
<p>提示：如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是<code>int</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">  male,female;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  RED,BLUE,GREEN,BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后便可以通过枚举类型名直接引用常量，如<code>SexEnum.male、Color.RED</code>。</p>
<p>使用枚举还可以使<code>switch</code>语句的可读性更强：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Signal</span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个枚举类型</span></span><br><span class="line">  GREEN,YELLOW,RED</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrafficLight</span> &#123;</span><br><span class="line">  <span class="type">Signal</span> <span class="variable">color</span> <span class="operator">=</span> Signal.RED;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">      <span class="keyword">case</span> RED:</span><br><span class="line">        color = Signal.GREEN;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> YELLOW:</span><br><span class="line">        color = Signal.RED;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> GREEN:</span><br><span class="line">        color = Signal.YELLOW;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>Java 中的每一个枚举都继承自<code>java.lang.Enum</code>类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是<code>Enum</code>类的实例，这些枚举成员默认都被<code>final、public, static</code>修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可。</p>
<p>所有枚举实例都可以调用<code>Enum</code>类的方法，常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">values()</td>
<td align="center">以数组形式返回枚举类型的所有成员</td>
</tr>
<tr>
<td align="center">valueOf()</td>
<td align="center">将普通字符串转换为枚举实例</td>
</tr>
<tr>
<td align="center">compareTo()</td>
<td align="center">比较两个枚举成员在定义时的顺序</td>
</tr>
<tr>
<td align="center">ordinal()</td>
<td align="center">获取枚举成员的索引位置</td>
</tr>
</tbody></table>
<p>通过调用枚举类型实例的<code>values()</code>方法可以将枚举的所有成员以数组形式返回，也可以通过该方法获取枚举类型的成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Signal</span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个枚举类型</span></span><br><span class="line">  GREEN,YELLOW,RED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; Signal.values().length;i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;枚举成员：&quot;</span>+Signal.values()[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">枚举成员：GREEN</span><br><span class="line">枚举成员：YELLOW</span><br><span class="line">枚举成员：RED</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnum</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Sex</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个枚举</span></span><br><span class="line">    male,female;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    compare(Sex.valueOf(<span class="string">&quot;male&quot;</span>));    <span class="comment">// 比较</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compare</span><span class="params">(Sex s)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; Sex.values().length;i++) &#123;</span><br><span class="line">      System.out.println(s + <span class="string">&quot;与&quot;</span> + Sex.values()[i] + <span class="string">&quot;的比较结果是：&quot;</span> + s.compareTo(Sex.values()[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中使用<code>Sex.valueOf(&quot;male&quot;)</code>取出枚举成员<code>male</code>对应的值，再将该值与其他枚举成员进行比较。输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">male与male的比较结果是：0</span><br><span class="line">male与female的比较结果是：-1</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEnum1</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Signal</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个枚举类型</span></span><br><span class="line">    GREEN,YELLOW,RED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; Signal.values().length;i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;索引&quot;</span> + Signal.values()[i].ordinal()+<span class="string">&quot;，值：&quot;</span> + Signal.values()[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">索引0，值：GREEN</span><br><span class="line">索引1，值：YELLOW</span><br><span class="line">索引2，值：RED</span><br></pre></td></tr></table></figure>
<h2 id="为枚举添加方法"><a href="#为枚举添加方法" class="headerlink" title="为枚举添加方法"></a>为枚举添加方法</h2><p>Java 为枚举类型提供了一些内置的方法，同时枚举常量也可以有自己的方法。此时要注意必须在枚举实例的最后一个成员后添加分号，而且必须先定义枚举实例。</p>
<p>下面的代码创建了一个枚举类型<code>WeekDay</code>，而且在该类型中添加了自定义的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WeekDay</span> &#123;</span><br><span class="line">  Mon(<span class="string">&quot;Monday&quot;</span>),Tue(<span class="string">&quot;Tuesday&quot;</span>),Wed(<span class="string">&quot;Wednesday&quot;</span>),Thu(<span class="string">&quot;Thursday&quot;</span>),Fri(<span class="string">&quot;Friday&quot;</span>),Sat(<span class="string">&quot;Saturday&quot;</span>),Sun(<span class="string">&quot;Sunday&quot;</span>);</span><br><span class="line">  <span class="comment">// 以上是枚举的成员，必须先定义，而且使用分号结束</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String day;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">WeekDay</span><span class="params">(String day)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.day = day;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printDay</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(i) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(WeekDay.Mon);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(WeekDay.Tue);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        System.out.println(WeekDay.Wed);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        System.out.println(WeekDay.Thu);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(WeekDay.Fri);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        System.out.println(WeekDay.Sat);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        System.out.println(WeekDay.Sun);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;wrong number!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getDay</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> day;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面遍历该枚举中的所有成员，并调用<code>printDay()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(WeekDay day : WeekDay.values()) &#123;</span><br><span class="line">      System.out.println(day+<span class="string">&quot;====&gt;&quot;</span> + day.getDay());</span><br><span class="line">  &#125;</span><br><span class="line">  WeekDay.printDay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mon====&gt;Monday</span><br><span class="line">Tue====&gt;Tuesday</span><br><span class="line">Wed====&gt;Wednesday</span><br><span class="line">Thu====&gt;Thursday</span><br><span class="line">Fri====&gt;Friday</span><br><span class="line">Sat====&gt;Saturday</span><br><span class="line">Sun====&gt;Sunday</span><br><span class="line">Fri</span><br></pre></td></tr></table></figure>
<p>Java 中的<code>enum</code>还可以跟<code>Class</code>类一样覆盖基类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED(<span class="string">&quot;红色&quot;</span>,<span class="number">1</span>),GREEN(<span class="string">&quot;绿色&quot;</span>,<span class="number">2</span>),WHITE(<span class="string">&quot;白色&quot;</span>,<span class="number">3</span>),YELLOW(<span class="string">&quot;黄色&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Color</span><span class="params">(String name,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.index + <span class="string">&quot;-&quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Color.RED.toString());    <span class="comment">// 输出：1-红色</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EnumMap-与-EnumSet"><a href="#EnumMap-与-EnumSet" class="headerlink" title="EnumMap 与 EnumSet"></a>EnumMap 与 EnumSet</h2><p>为了更好地支持枚举类型，<code>java.util</code>中添加了两个新类：<code>EnumMap</code>和<code>EnumSet</code>。使用它们可以更高效地操作枚举类型。</p>
<h3 id="EnumMap-类"><a href="#EnumMap-类" class="headerlink" title="EnumMap 类"></a>EnumMap 类</h3><p><code>EnumMap</code>是专门为枚举类型量身定做的<code>Map</code>实现。虽然使用其他的<code>Map</code>（如<code>HashMap</code>）实现也能完成枚举类型实例到值的映射，但是使用<code>EnumMap</code>会更加高效。</p>
<p><code>HashMap</code>只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以<code>EnumMap</code>使用数组来存放与枚举类型对应的值，使得<code>EnumMap</code>的效率非常高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数据库类型枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DataBaseType</span> &#123;</span><br><span class="line">  MYSQUORACLE,DB2,SQLSERVER</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某类中定义的获取数据库URL的方法以及EnumMap的声明</span></span><br><span class="line"><span class="keyword">private</span> EnumMap&lt;DataBaseType,String&gt;urls = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;DataBaseType,String&gt;(DataBaseType.class);</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DataBaseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">  urls.put(DataBaseType.DB2,<span class="string">&quot;jdbc:db2://localhost:5000/sample&quot;</span>);</span><br><span class="line">  urls.put(DataBaseType.MYSQL,<span class="string">&quot;jdbc:mysql://localhost/mydb&quot;</span>);</span><br><span class="line">  urls.put(DataBaseType.ORACLE,<span class="string">&quot;jdbc:oracle:thin:@localhost:1521:sample&quot;</span>);</span><br><span class="line">  urls.put(DataBaseType.SQLSERVER,<span class="string">&quot;jdbc:microsoft:sqlserver://sql:1433;Database=mydb&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据不同的数据库类型，返回对应的URL</span></span><br><span class="line"><span class="comment">// @param type DataBaseType 枚举类新实例</span></span><br><span class="line"><span class="comment">// @return</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getURL</span><span class="params">(DataBaseType type)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.urls.get(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从本例中可以看出，使用<code>EnumMap</code>可以很方便地为枚举类型在不同的环境中绑定到不同的值上。</p>
<h3 id="EnumSet-类"><a href="#EnumSet-类" class="headerlink" title="EnumSet 类"></a>EnumSet 类</h3><p><code>EnumSet</code>是枚举类型的高性能<code>Set</code>实现，它要求放入它的枚举常量必须属于同一枚举类型。<code>EnumSet</code>提供了许多工厂方法以便于初始化。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">allOf(Class<E> element type)</td>
<td align="center">创建一个包含指定枚举类型中所有枚举成员的 EnumSet 对象</td>
</tr>
<tr>
<td align="center">complementOf(EnumSet<E> s)</td>
<td align="center">创建一个与指定 EnumSet 对象 s 相同的枚举类型 EnumSet 对象，并包含所有 s 中未包含的枚举成员</td>
</tr>
<tr>
<td align="center">copyOf(EnumSet<E> s)</td>
<td align="center">创建一个与指定 EnumSet 对象 s 相同的枚举类型 EnumSet 对象，并与 s 包含相同的枚举成员</td>
</tr>
<tr>
<td align="center">noneOf(&lt;Class<E> elementType)</td>
<td align="center">创建指定枚举类型的空 EnumSet 对象</td>
</tr>
<tr>
<td align="center">of(E first,e…rest)</td>
<td align="center">创建包含指定枚举成员的 EnumSet 对象</td>
</tr>
<tr>
<td align="center">range(E from ,E to)</td>
<td align="center">创建一个 EnumSet 对象，该对象包含了 from 到 to 之间的所有枚举成员</td>
</tr>
</tbody></table>
<p><code>EnumSet</code>作为<code>Set</code>接口实现，它支持对包含的枚举常量的遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Operation op:EnumSet.range(Operation.PLUS,Operation.MULTIPLY)) &#123;</span><br><span class="line">    doSomeThing(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/VPN"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/"
    >VPN</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/" class="article-date">
  <time datetime="2020-10-09T08:51:33.000Z" itemprop="datePublished">2020-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h1><p>VPN 技术还是企业比较常用的通信技术，如果一个企业的分公司和总部的互访，或者出差员工需要访问总部的网络，都会使用 VPN 技术。</p>
<p>在没有 VPN 之前，企业的总部和分部之间的互通都是采用运营商的 Internet 进行通信，那么 Internet 中往往是不安全的，通信的内容可能被窃取、修改等，从而造成安全事件。</p>
<p>那么有没有一种技术既能实现总部和分部间的互通，也能够保证数据传输的安全性呢？</p>
<p>当然有，那就是 VPN。VPN 通过在现有的 Internet 网中构建专用的虚拟网络，实现企业总部和分部的通信，解决了互通、安全、成本的问题。</p>
<h2 id="什么是-VPN"><a href="#什么是-VPN" class="headerlink" title="什么是 VPN"></a>什么是 VPN</h2><p><code>VPN(Virtual Private Network)</code>即虚拟专用网，指通过 VPN 技术在公有网络中构建专用的虚拟网络。</p>
<ul>
<li>专用：VPN 虚拟网络是专门为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信。</li>
<li>虚拟：相对于公有网络而言，VPN网络是虚拟的，是逻辑意义上的一个专网。</li>
</ul>
<p>RFC 指明了一些专用地址。专用地址只能用作本地地址而不能用作全球地址。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。</p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/img1.png" class="">

<p>采用这样的专用 IP 地址的互连网络称为专用互联网或就叫做专用网。</p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/img2.png" class="">

<p>如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么所有通过互联网传送的数据都必须加密。</p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/img3.png" class="">

<h2 id="VPN技术优势"><a href="#VPN技术优势" class="headerlink" title="VPN技术优势"></a>VPN技术优势</h2><ul>
<li>安全：在远端用户、驻外机构、合作伙伴、供应商与公司总部之间建立可靠的连接，保证数据传输的安全性。这对于实现电子商务或金融网络与通讯网络的融合特别重要。</li>
<li>成本低：利用公共网络进行信息通讯，企业可以用更低的成本连接远程办事机构、出差人员和业务伙伴。</li>
<li>支持移动业务：支持出差 VPN 用户在任何时间、任何地点的移动接入，能够满足不断增长的移动业务需求。</li>
<li>可扩展性：由于 VPN 为逻辑上的网络，物理网络中增加或修改节点，不影响 VPN 的部署。</li>
</ul>
<h2 id="内联网和外联网"><a href="#内联网和外联网" class="headerlink" title="内联网和外联网"></a>内联网和外联网</h2><p>它们都是基于 TCP&#x2F;IP 协议的。</p>
<p>由部门 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联网(<code>intranet</code>)，表示部门 A 和 B 都是在同一个机构的内部。一个机构和某些外部机构共同建立的虚拟专用网 VPN 又称为外联网(<code>extranet</code>)。 </p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/img4.png" class="">

<p>远程接入 VPN 可以满足外部流动员工访问公司网络的需求。</p>
<p>在外地工作的员工拨号接入互联网，而驻留在员工 PC 机中的 VPN 软件可在员工的 PC 机和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容是保密的，员工们感到好像就是使用公司内部的本地网络。 </p>
<h2 id="VPN分类"><a href="#VPN分类" class="headerlink" title="VPN分类"></a>VPN分类</h2><h3 id="根据-VPN-建设单位不同进行划分"><a href="#根据-VPN-建设单位不同进行划分" class="headerlink" title="根据 VPN 建设单位不同进行划分"></a>根据 VPN 建设单位不同进行划分</h3><h4 id="1-租用运营商VPN专线搭建企业网络"><a href="#1-租用运营商VPN专线搭建企业网络" class="headerlink" title="1. 租用运营商VPN专线搭建企业网络"></a>1. 租用运营商VPN专线搭建企业网络</h4><p>运营商的专线网络大多数都是使用的MPLS VPN。</p>
<p>企业通过购买运营商提供的 VPN 专线服务实现总部和分部间的通信需求。VPN网关为运营商所有。</p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/5.png" class="">

<h4 id="2-企业自建VPN网络"><a href="#2-企业自建VPN网络" class="headerlink" title="2. 企业自建VPN网络"></a>2. 企业自建VPN网络</h4><p>企业自己基于 Internet 自建 VPN 网络，常见的如 IPsec VPN、GRE VPN、L2TP VPN。</p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/6.png" class="">

<h3 id="根据组网方式进行划分"><a href="#根据组网方式进行划分" class="headerlink" title="根据组网方式进行划分"></a>根据组网方式进行划分</h3><ol>
<li>远程访问VPN<br>这种方式适用于出差员工拨号接入 VPN 的方式，员工可以在只要有 Internet 的地方都可以通过 VPN 接入访问内网资源。<br>最常见的就是SSL VPN、L2TP VPN。</li>
<li>站点到站点的VPN<br>这种方式适用于企业两个局域网互通的情况。例如企业的分部访问总部。最常见的就是 MPLS VPN、IPSEC VPN。</li>
</ol>
<h3 id="根据工作网络层次进行划分"><a href="#根据工作网络层次进行划分" class="headerlink" title="根据工作网络层次进行划分"></a>根据工作网络层次进行划分</h3><p>VPN可以按照工作层次进行划分：</p>
<ul>
<li>应用层：SSL VPN</li>
<li>网络层：IPSEC VPN 、GRE VPN</li>
<li>数据链路层：L2TP VPN、PPTP VPN</li>
</ul>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/7.png" class="">

<h2 id="VPN关键技术"><a href="#VPN关键技术" class="headerlink" title="VPN关键技术"></a>VPN关键技术</h2><h3 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h3><p>VPN技术的基本原理其实就是用的隧道技术，就类似于火车的轨道、地铁的轨道一样，从 A 站点到 B 站点都是直通的，不会堵车。对于乘客而言，就是专车。</p>
<p>隧道技术其实就是对传输的报文进行封装，利用公网的建立专用的数据传输通道，从而完成数据的安全可靠性传输。</p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/8.png" class="">

<p>可以看到原始报文在隧道的一端进行封装，封装后的数据在公网上传输，在隧道另一端进行解封装，从而实现了数据的安全传输。</p>
<p>隧道通过隧道协议实现。如<code>GRE（Generic Routing Encapsulation）、L2TP（Layer 2 Tunneling Protocol）</code>等。</p>
<p>隧道协议通过在隧道的一端给数据加上隧道协议头，即进行封装，使这些被封装的数据能都在某网络中传输，并且在隧道的另一端去掉该数据携带的隧道协议头，即进行解封装。</p>
<img src="/2020/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/VPN/9.png" class="">

<h3 id="身份认证、数据加密、数据验证"><a href="#身份认证、数据加密、数据验证" class="headerlink" title="身份认证、数据加密、数据验证"></a>身份认证、数据加密、数据验证</h3><p>身份认证、数据加密、数据验证可以有效保证 VPN 网络和数据的安全性。</p>
<ul>
<li>身份认证：VPN网关对接入VPN的用户进行身份认证，保证接入的用户都是合法用户。</li>
<li>数据加密：将明文通过加密技术成密文，哪怕信息被获取了，也无法识别。</li>
<li>数据验证：通过数据验证技术验证报文的完整性和真伪进行检查，防止数据被篡改。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">VPN</th>
<th align="center">用户身份认证</th>
<th align="center">数据加密和验证</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GRE</td>
<td align="center">不支持</td>
<td align="center">支持简单的关键字验证、校验和验证</td>
<td align="center">可结合 IPSec 使用</td>
</tr>
<tr>
<td align="center">L2TP</td>
<td align="center">支持基于 PPP 的CHAP、PAP、EAP 认证</td>
<td align="center">不支持</td>
<td align="center">可结合 IPSec 使用</td>
</tr>
<tr>
<td align="center">IPSec</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持预共享密钥验证或证书验证；支持 IKEv2 的 EAP 认证</td>
</tr>
<tr>
<td align="center">SSL</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持用户名&#x2F;密码或证书认证</td>
</tr>
<tr>
<td align="center">MPLS</td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">一般运行在专用的 VPN 骨干网络</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java 集合"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/09/java/%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/"
    >Java 集合</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/09/java/%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2020-10-09T03:31:41.000Z" itemprop="datePublished">2020-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在编程时，可以使用数组来保存多个对象，但数组长度不可变化，一旦在初始化数组时指定了数组长度，这个数组长度就是不可变的。如果需要保存数量变化的数据，数组就有点无能为力了。而且数组无法保存具有映射关系的数据。</p>
<p>为了保存数量不确定的数据，以及保存具有映射关系的数据（也被称为关联数组），Java 提供了集合类。集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。Java 所有的集合类都位于<code>java.util</code>包下，提供了一个表示和操作对象集合的统一构架，包含大量集合接口，以及这些接口的实现类和操作它们的算法。</p>
<p>集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象（实际上保存的是对象的引用变量），而集合里只能保存对象（实际上只是保存对象的引用变量，但通常习惯上认为集合里保存的是对象）。</p>
<p>Java 集合类型分为<code>Collection</code>和<code>Map</code>，它们是 Java 集合的根接口，这两个接口又包含了一些子接口或实现类。下图分别为<code>Collection</code>和<code>Map</code>的子接口及其实现类。黄色块为集合的接口，蓝色块为集合的实现类。</p>
<img src="/2020/10/09/java/%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/1.png" class="" title="Collection接口基本结构">
<img src="/2020/10/09/java/%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/2.png" class="" title="Map接口基本结构">

<p>Java集合接口的作用：</p>
<table>
<thead>
<tr>
<th align="center">接口名称</th>
<th align="center">作    用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Iterator</code>接口</td>
<td align="center">集合的输出接口，主要用于遍历输出（即迭代访问）<code>Collection</code>集合中的元素，<code>Iterator</code>对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现<code>Collection</code>时就必须实现<code>Iterator</code>接口。</td>
</tr>
<tr>
<td align="center"><code>Collection</code>接口</td>
<td align="center">是<code>List、Set</code>和<code>Queue</code>的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象。一般很少直接使用此接口直接操作。</td>
</tr>
<tr>
<td align="center"><code>Queue</code>接口</td>
<td align="center"><code>Queue</code>是 Java 提供的队列实现，有点类似于<code>List</code>。</td>
</tr>
<tr>
<td align="center"><code>Dueue</code>接口</td>
<td align="center">是<code>Queue</code>的一个子接口，为双向队列。</td>
</tr>
<tr>
<td align="center"><code>List</code>接口</td>
<td align="center">是有序集合，允许有相同的元素。使用<code>List</code>能够精确地控制每个元素插入的位置，用户能够使用索引（元素在<code>List</code>中的位置，类似于数组下标）来访问<code>List</code>中的元素，与数组类似。</td>
</tr>
<tr>
<td align="center"><code>Set</code>接口</td>
<td align="center">不能包含重复的元素。</td>
</tr>
<tr>
<td align="center"><code>Map</code>接口</td>
<td align="center">是存放一对值的最大接口，即接口中的每个元素都是一对，以<code>key➡value</code>的形式保存。</td>
</tr>
</tbody></table>
<p>对于<code>Set、List、Queue</code>和<code>Map</code>这 4 种集合，最常用的实现类分别是：</p>
<table>
<thead>
<tr>
<th align="center">类名称</th>
<th align="center">作    用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>HashSet</code></td>
<td align="center">为优化査询速度而设计的<code>Set</code>。它是基于<code>HashMap</code>实现的，<code>HashSet</code>底层使用<code>HashMap</code>来保存所有元素，实现比较简单</td>
</tr>
<tr>
<td align="center"><code>TreeSet</code></td>
<td align="center">实现了<code>Set</code>接口，是一个有序的<code>Set</code>，这样就能从<code>Set</code>里面提取一个有序序列</td>
</tr>
<tr>
<td align="center"><code>ArrayList</code></td>
<td align="center">一个用数组实现的<code>List</code>，能进行快速的随机访问，效率高而且实现了可变大小的数组</td>
</tr>
<tr>
<td align="center"><code>ArrayDueue</code></td>
<td align="center">是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素</td>
</tr>
<tr>
<td align="center"><code>LinkedList</code></td>
<td align="center">对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有<code>addFirst()、addLast()、getFirst()、getLast()、removeFirst()</code>和<code>removeLast()</code>等方法，能把它当成栈（<code>Stac</code>k）或队列（<code>Queue</code>）来用</td>
</tr>
<tr>
<td align="center"><code>HsahMap</code></td>
<td align="center">按哈希算法来存取键对象</td>
</tr>
<tr>
<td align="center"><code>TreeMap</code></td>
<td align="center">可以对键对象进行排序</td>
</tr>
</tbody></table>
<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p><code>Collection</code>接口是<code>List、Set</code>和<code>Queue</code>接口的父接口，通常情况下不被直接使用。<code>Collection</code>接口定义了一些通用的方法，通过这些方法可以实现对集合的基本操作。定义的方法既可用于操作<code>Set</code>集合，也可用于操作<code>List</code>和<code>Queue</code>集合。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>boolean add(E e)</code></td>
<td align="center">向集合中添加一个元素，如果集合对象被添加操作改变了，则返回 true。E 是元素的数据类型</td>
</tr>
<tr>
<td align="center"><code>boolean addAll(Collection c)</code></td>
<td align="center">向集合中添加集合 c 中的所有元素，如果集合对象被添加操作改变了，则返回 true。</td>
</tr>
<tr>
<td align="center"><code>void clear()</code></td>
<td align="center">清除集合中的所有元素，将集合长度变为 0。</td>
</tr>
<tr>
<td align="center"><code>boolean contains(Object o)</code></td>
<td align="center">判断集合中是否存在指定元素</td>
</tr>
<tr>
<td align="center"><code>boolean containsAll(Collection c)</code></td>
<td align="center">判断集合中是否包含集合 c 中的所有元素</td>
</tr>
<tr>
<td align="center"><code>boolean isEmpty()</code></td>
<td align="center">判断集合是否为空</td>
</tr>
<tr>
<td align="center"><code>Iterator&lt;E&gt; iterator()</code></td>
<td align="center">返回一个 Iterator 对象，用于遍历集合中的元素</td>
</tr>
<tr>
<td align="center"><code>boolean remove(Object o)</code></td>
<td align="center">从集合中删除一个指定元素，当集合中包含了一个或多个元素 o 时，该方法只删除第一个符合条件的元素，该方法将返回 true。</td>
</tr>
<tr>
<td align="center"><code>boolean removeAll(Collection c)</code></td>
<td align="center">从集合中删除所有在集合 c 中出现的元素（相当于把调用该方法的集合减去集合 c）。如果该操作改变了调用该方法的集合，则该方法返回 true。</td>
</tr>
<tr>
<td align="center"><code>boolean retainAll(Collection c)</code></td>
<td align="center">从集合中删除集合 c 里不包含的元素（相当于把调用该方法的集合变成该集合和集合 c 的交集），如果该操作改变了调用该方法的集合，则该方法返回 true。</td>
</tr>
<tr>
<td align="center"><code>int size()</code></td>
<td align="center">返回集合中元素的个数</td>
</tr>
<tr>
<td align="center"><code>Object[] toArray()</code></td>
<td align="center">把集合转换为一个数组，所有的集合元素变成对应的数组元素。</td>
</tr>
</tbody></table>
<p><code>Iterator</code>接口包含3个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Interface Interator&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// 返回将要访问的下一个对象</span></span><br><span class="line">  <span class="comment">// 如果已经到达了集合的尾部，将抛出一个NoSuchElement Exception。</span></span><br><span class="line">  E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">// 如果存在可访问的元素，返回true</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>; </span><br><span class="line">  <span class="comment">// 删除上次访问的对象。</span></span><br><span class="line">  <span class="comment">// 这个方法必须紧跟在访问一个元素之后执行。</span></span><br><span class="line">  <span class="comment">// 如果上次访问之后，集合已经发生了变化，这个方法将抛出一个llegalStateException。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>; <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反复调用<code>next()</code>方法，可以逐个访问集合中的每个元素。但是如果到达了集合的末尾，<code>next</code>方法将抛出一个<code>NoSuchElementException</code>。因此，需要在调用<code>next</code>之前调用<code>hasNext</code>方法。</p>
<p>如果迭代器对象还有多个供访问的元素，<code>haxNext</code>方法就返回<code>true</code>。如果想要查看集合中的所有元素，就请求一个迭代器，并在<code>hasNext</code>返回<code>true</code>时反复地调用<code>next</code>方法。当调用<code>next</code>时，迭代器会越过下一个元素，并返回刚刚越过的那个元素的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ArrayList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 创建集合 list1</span></span><br><span class="line">  <span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 创建集合 list2</span></span><br><span class="line">  list1.add(<span class="string">&quot;one&quot;</span>); <span class="comment">// 向 list1 添加一个元素</span></span><br><span class="line">  list1.add(<span class="string">&quot;two&quot;</span>); <span class="comment">// 向 list1 添加一个元素</span></span><br><span class="line">  list2.addAll(list1); <span class="comment">// 将 list1 的所有元素添加到 list2</span></span><br><span class="line">  list2.add(<span class="string">&quot;three&quot;</span>); <span class="comment">// 向 list2 添加一个元素</span></span><br><span class="line">  System.out.println(<span class="string">&quot;list2 集合中的元素如下：&quot;</span>);</span><br><span class="line">  <span class="type">Iterator</span> <span class="variable">it1</span> <span class="operator">=</span> list2.iterator();</span><br><span class="line">  <span class="keyword">while</span> (it1.hasNext()) &#123;</span><br><span class="line">    System.out.print(it1.next() + <span class="string">&quot;、&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Collection</code>是接口，不能对其实例化，所以上述代码中使用了<code>Collection</code>接口的<code>ArrayList</code>实现类来调用<code>Collection</code>的方法。结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list2 集合中的元素如下：</span><br><span class="line">one、two、three、</span><br></pre></td></tr></table></figure>
<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p><code>List</code>是一个有序、可重复的集合，集合中每个元素都有其对应的顺序索引。<code>List</code>集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。<code>List</code>集合默认按元素的添加顺序设置元素的索引，第一个添加到<code>List</code>集合中的元素的索引为 0，第二个为 1，依此类推。</p>
<p><code>List</code>实现了<code>Collection</code>接口，它主要有两个常用的实现类：<code>ArrayList</code>类和<code>LinkedList</code>类。</p>
<h2 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h2><p><code>ArrayList</code>类实现了可变数组的大小，存储在内的数据称为元素。它还提供了快速基于索引访问元素的方式，对尾部成员的增加和删除支持较好。使用<code>ArrayList</code>创建的集合，允许对集合中的元素进行快速的随机访问，不过，向<code>ArrayList</code>中插入与删除元素的速度相对较慢。</p>
<p><code>ArrayList</code>类的常用构造方法有如下两种重载形式：</p>
<ul>
<li><code>ArrayList()</code>：构造一个初始容量为 10 的空列表。</li>
<li><code>ArrayList(Collection&lt;?extends E&gt;c)</code>：构造一个包含指定<code>Collection</code>元素的列表，这些元素是按照该<code>Collection</code>的迭代器返回它们的顺序排列的。</li>
</ul>
<p><code>ArrayList</code>类除了包含<code>Collection</code>接口中的所有方法之外，还包括<code>List</code>接口中提供的方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>E get(int index)</code></td>
<td align="center">获取此集合中指定索引位置的元素，<code>E</code>为集合中元素的数据类型</td>
</tr>
<tr>
<td align="center"><code>int index(Object o)</code></td>
<td align="center">返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td>
</tr>
<tr>
<td align="center"><code>int lastIndexOf(Object o)</code></td>
<td align="center">返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td>
</tr>
<tr>
<td align="center"><code>E set(int index, Eelement)</code></td>
<td align="center">将此集合中指定索引位置的元素修改为<code>element</code>参数指定的对象。此方法返回此集合中指定索引位置的原元素</td>
</tr>
<tr>
<td align="center"><code>List&lt;E&gt; subList(int fromlndex, int tolndex)</code></td>
<td align="center">返回一个新的集合，新集合中包含<code>fromlndex</code>和<code>tolndex</code>索引之间的所有元素。包含<code>fromlndex</code>处的元素，不包含<code>tolndex</code>索引处的元素</td>
</tr>
</tbody></table>
<p>注意：当调用<code>List</code>的<code>set(int index, Object element)</code>方法来改变<code>List</code>集合指定索引处的元素时，指定的索引必须是<code>List</code>集合的有效索引。例如集合长度为 4，就不能指定替换索引为 4 处的元素，也就是说这个方法不会改变<code>List</code>集合的长度。</p>
<h2 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h2><p><code>LinkedList</code>类采用链表结构保存对象，这种结构的优点是便于向集合中插入或者删除元素。需要频繁向集合中插入和删除元素时，使用<code>LinkedList</code>类比<code>ArrayList</code>类效果高，但是<code>LinkedList</code>类随机访问元素的速度则相对较慢。这里的随机访问是指检索集合中特定索引位置的元素。</p>
<p><code>LinkedList</code>类除了包含<code>Collection</code>接口和<code>List</code>接口中的所有方法之外，还特别提供了下面的方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>void addFirst(E e)</code></td>
<td align="center">将指定元素添加到此集合的开头</td>
</tr>
<tr>
<td align="center"><code>void addLast(E e)</code></td>
<td align="center">将指定元素添加到此集合的末尾</td>
</tr>
<tr>
<td align="center"><code>E getFirst()</code></td>
<td align="center">返回此集合的第一个元素</td>
</tr>
<tr>
<td align="center"><code>E getLast()</code></td>
<td align="center">返回此集合的最后一个元素</td>
</tr>
<tr>
<td align="center"><code>E removeFirst()</code></td>
<td align="center">删除此集合中的第一个元素</td>
</tr>
<tr>
<td align="center"><code>E removeLast()</code></td>
<td align="center">删除此集合中的最后一个元素</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; products = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;(); <span class="comment">// 创建集合对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;六角螺母&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;10A 电缆线&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;5M 卷尺&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;4CM 原木方板&quot;</span>);</span><br><span class="line">    products.add(p1); <span class="comment">// 将 p1 对象添加到 LinkedList 集合中</span></span><br><span class="line">    products.add(p2); <span class="comment">// 将 p2 对象添加到 LinkedList 集合中</span></span><br><span class="line">    products.add(p3); <span class="comment">// 将 p3 对象添加到 LinkedList 集合中</span></span><br><span class="line">    products.add(p4); <span class="comment">// 将 p4 对象添加到 LinkedList 集合中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">p5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;标准文件夹小柜&quot;</span>);</span><br><span class="line">    products.addLast(p5); <span class="comment">// 向集合的末尾添加p5对象</span></span><br><span class="line">    System.out.print(<span class="string">&quot;*************** 商品信息 ***************&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\n目前商品有：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.size(); i++) &#123;</span><br><span class="line">      System.out.print(products.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n第一个商品的名称为：&quot;</span> + products.getFirst());</span><br><span class="line">    System.out.println(<span class="string">&quot;最后一个商品的名称为：&quot;</span> + products.getLast());</span><br><span class="line">    products.removeLast(); <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除最后的元素，目前商品有：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.size(); i++) &#123;</span><br><span class="line">      System.out.print(products.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedList&lt;String&gt;</code>中的<code>&lt;String&gt;</code>是 Java 中的泛型，用于指定集合中元素的数据类型，例如这里指定元素类型为<code>String</code>，则该集合中不能添加非<code>String</code>类型的元素。</p>
<h2 id="ArrayList-类和-LinkedList-类的区别"><a href="#ArrayList-类和-LinkedList-类的区别" class="headerlink" title="ArrayList 类和 LinkedList 类的区别"></a>ArrayList 类和 LinkedList 类的区别</h2><p><code>ArrayList</code>与<code>LinkedList</code>都是<code>List</code>接口的实现类，因此都实现了<code>List</code>的所有未实现的方法，只是实现的方式有所不同。</p>
<p><code>ArrayList</code>是基于动态数组数据结构的实现，访问元素速度优于<code>LinkedList</code>。<code>LinkedList</code>是基于链表数据结构的实现，占用的内存空间比较大，但在批量插入或删除数据时优于<code>ArrayList</code>。</p>
<p>对于快速访问对象的需求，使用<code>ArrayList</code>实现执行效率上会比较好。需要频繁向集合中插入和删除元素时，使用<code>LinkedList</code>类比<code>ArrayList</code>类效果高。</p>
<p>不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。</p>
<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p><code>Set</code>集合类似于一个罐子，程序可以依次把多个对象“丢进”<code>Set</code>集合，而<code>Set</code>集合通常不能记住元素的添加顺序。也就是说<code>Set</code>集合中的对象不按特定的方式排序，只是简单地把对象加入集合。<code>Set</code>集合中不能包含重复的对象，并且最多只允许包含一个<code>null</code>元素。</p>
<p><code>Set</code>实现了<code>Collection</code>接口，它主要有两个常用的实现类：<code>HashSet</code>类和<code>TreeSet</code>类。</p>
<h2 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h2><p><code>HashSet</code>是按照<code>Hash</code>算法来存储集合中的元素。因此具有很好的存取和查找性能。</p>
<p><code>HashSet</code>具有以下特点：</p>
<ul>
<li>不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。</li>
<li><code>HashSet</code>不是同步的，如果多个线程同时访问或修改一个<code>HashSet</code>，则必须通过代码来保证其同步。</li>
<li>集合元素值可以是<code>null</code>。</li>
</ul>
<p>当向<code>HashSet</code>集合中存入一个元素时，<code>HashSet</code>会调用该对象的<code>hashCode()</code>方法来得到该对象的<code>hashCode</code>值，然后根据该<code>hashCode</code>值决定该对象在<code>HashSet</code>中的存储位置。如果有两个元素通过<code>equals()</code>方法比较返回的结果为<code>true</code>，但它们的<code>hashCode</code>不相等，<code>HashSet</code>将会把它们存储在不同的位置，依然可以添加成功。</p>
<p>也就是说，两个对象的<code>hashCode</code>值相等且通过<code>equals()</code>方法比较返回结果为<code>true</code>，则<code>HashSet</code>集合认为两个元素相等。</p>
<p>在<code>HashSet</code>类中实现了<code>Collection</code>接口中的所有方法。<code>HashSet</code>类的常用构造方法重载形式如下。</p>
<ul>
<li><code>HashSet()</code>：构造一个新的空的<code>Set</code>集合。</li>
<li><code>HashSet(Collection&lt;? extends E&gt;c)</code>：构造一个包含指定<code>Collection</code>集合元素的新<code>Set</code>集合。其中，<code>&lt; &gt;</code>中的<code>extends</code>表示<code>HashSet</code>的父类，即指明该<code>Set</code>集合中存放的集合元素类型。<code>c</code>表示其中的元素将被存放在此<code>Set</code>集合中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();    <span class="comment">// 调用无参的构造函数创建HashSet对象</span></span><br><span class="line">HashSet&lt;String&gt; hss = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();    <span class="comment">// 创建泛型的 HashSet 集合对象</span></span><br></pre></td></tr></table></figure>
<h2 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h2><p><code>TreeSet</code>类同时实现了<code>Set</code>接口和<code>SortedSet</code>接口。<code>SortedSet</code>接口是<code>Set</code>接口的子接口，可以实现对集合进行自然排序，因此使用<code>TreeSet</code>类实现的<code>Set</code>接口默认情况下是自然排序的，这里的自然排序指的是升序排序。</p>
<p><code>TreeSet</code>只能对实现了<code>Comparable</code>接口的类对象进行排序，因为<code>Comparable</code>接口中有一个<code>compareTo(Object o)</code>方法用于比较两个对象的大小。例如<code>a.compareTo(b)</code>，如果 a 和 b 相等，则该方法返回 0；如果 a 大于 b，则该方法返回大于 0 的值；如果 a 小于 b，则该方法返回小于 0 的值。</p>
<p>表列举了 JDK 类库中实现<code>Comparable</code>接口的类，以及这些类对象的比较方式。</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">比较方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">包装类（BigDecimal、Biglnteger、 Byte、<br>Double、Float、Integer、Long 及 Short)</td>
<td align="center">按数字大小比较</td>
</tr>
<tr>
<td align="center">Character</td>
<td align="center">按字符的 Unicode 值的数字大小比较</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">按字符串中字符的 Unicode 值的数字大小比较</td>
</tr>
<tr>
<td align="center">TreeSet</td>
<td align="center">类除了实现 Collection 接口的所有方法之外，还提供了如表 2 所示的方法。</td>
</tr>
</tbody></table>
<p><code>TreeSet</code>类除了实现<code>Collection</code>接口的所有方法之外，还提供了如表所示的方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E first()</td>
<td align="center">返回此集合中的第一个元素。其中，E 表示集合中元素的数据类型</td>
</tr>
<tr>
<td align="center">E last()</td>
<td align="center">返回此集合中的最后一个元素</td>
</tr>
<tr>
<td align="center">E poolFirst()</td>
<td align="center">获取并移除此集合中的第一个元素</td>
</tr>
<tr>
<td align="center">E poolLast()</td>
<td align="center">获取并移除此集合中的最后一个元素</td>
</tr>
<tr>
<td align="center"><code>SortedSet&lt;E&gt; subSet(E fromElement,E toElement)</code></td>
<td align="center">返回一个新的集合，新集合包含原集合中 fromElement 对象与 toElement对象之间的所有对象。包含 fromElement 对象，不包含 toElement 对象</td>
</tr>
<tr>
<td align="center"><code>SortedSet&lt;E&gt; headSet&lt;E toElement&gt;</code></td>
<td align="center">返回一个新的集合，新集合包含原集合中 toElement 对象之前的所有对象。不包含 toElement 对象</td>
</tr>
<tr>
<td align="center"><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code></td>
<td align="center">返回一个新的集合，新集合包含原集合中 fromElement 对象之后的所有对象。包含 fromElement 对象注意：表面上看起来这些方法很多，其实很简单。因为 TreeSet 中的元素是有序的，所以增加了访问第一个、前一个、后一个、最后一个元素的方法，并提供了 3 个从 TreeSet 中截取子 TreeSet 的方法。</td>
</tr>
</tbody></table>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><p><code>Map</code>是一种键-值对（<code>key-value</code>）集合，<code>Map</code>集合中的每一个元素都包含一个键（<code>key</code>）对象和一个值（<code>value</code>）对象。用于保存具有映射关系的数据。</p>
<p><code>Map</code>集合里保存着两组值，一组值用于保存<code>Map</code>里的<code>key</code>，另外一组值用于保存<code>Map</code>里的<code>value</code>，<code>key</code>和<code>value</code>都可以是任何引用类型的数据。<code>Map</code>的<code>key</code>不允许重复，<code>value</code>可以重复，即同一个<code>Map</code>对象的任何两个<code>key</code>通过<code>equals</code>方法比较总是返回<code>false</code>。</p>
<p><code>Map</code>中的<code>key</code>和<code>value</code>之间存在单向一对一关系，即通过指定的<code>key</code>，总能找到唯一的、确定的<code>value</code>。从<code>Map</code>中取出数据时，只要给出指定的<code>key</code>，就可以取出对应的<code>value</code>。</p>
<p><code>Map</code>接口主要有两个实现类：<code>HashMap</code>类和<code>TreeMap</code>类。其中，<code>HashMap</code>类按哈希算法来存取键对象，而<code>TreeMap</code>类可以对键对象进行排序。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void clear()</td>
<td align="center">删除该 Map 对象中的所有 key-value 对。</td>
</tr>
<tr>
<td align="center">boolean containsKey(Object key)</td>
<td align="center">查询 Map 中是否包含指定的 key，如果包含则返回 true。</td>
</tr>
<tr>
<td align="center">boolean containsValue(Object value)</td>
<td align="center">查询 Map 中是否包含一个或多个 value，如果包含则返回 true。</td>
</tr>
<tr>
<td align="center">V get(Object key)</td>
<td align="center">返回 Map 集合中指定键对象所对应的值。V 表示值的数据类型</td>
</tr>
<tr>
<td align="center">V put(K key, V value)</td>
<td align="center">向 Map 集合中添加键-值对，如果当前 Map 中已有一个与该 key 相等的 key-value 对，则新的 key-value 对会覆盖原来的 key-value 对。</td>
</tr>
<tr>
<td align="center">void putAll(Map m)</td>
<td align="center">将指定 Map 中的 key-value 对复制到本 Map 中。</td>
</tr>
<tr>
<td align="center">V remove(Object key)</td>
<td align="center">从 Map 集合中删除 key 对应的键-值对，返回 key 对应的 value，如果该 key 不存在，则返回 null</td>
</tr>
<tr>
<td align="center">boolean remove(Object key, Object value)</td>
<td align="center">这是 Java 8 新增的方法，删除指定 key、value 所对应的 key-value 对。如果从该 Map 中成功地删除该 key-value 对，该方法返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="center">Set entrySet()</td>
<td align="center">返回 Map 集合中所有键-值对的 Set 集合，此 Set 集合中元素的数据类型为 Map.Entry</td>
</tr>
<tr>
<td align="center">Set keySet()</td>
<td align="center">返回 Map 集合中所有键对象的 Set 集合</td>
</tr>
<tr>
<td align="center">boolean isEmpty()</td>
<td align="center">查询该 Map 是否为空（即不包含任何 key-value 对），如果为空则返回 true。</td>
</tr>
<tr>
<td align="center">int size()</td>
<td align="center">返回该 Map 里 key-value 对的个数</td>
</tr>
<tr>
<td align="center">Collection values()</td>
<td align="center">返回该 Map 里所有 value 组成的 Collection</td>
</tr>
</tbody></table>
<p><code>Map</code>集合最典型的用法就是成对地添加、删除<code>key-value</code>对，接下来即可判断该<code>Map</code>中是否包含指定<code>key</code>，也可以通过<code>Map</code>提供的<code>keySet()</code>方法获取所有<code>key</code>组成的集合，进而遍历<code>Map</code>中所有的<code>key-value</code>对。</p>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>每名学生都有属于自己的唯一编号，即学号。在毕业时需要将该学生的信息从系统中移除。使用<code>HashMap</code>来存储学生信息，其键为学生学号，值为姓名。毕业时，需要用户输入学生的学号，并根据学号进行删除操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">users</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    users.put(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;张浩太&quot;</span>); <span class="comment">// 将学生信息键值对存储到Map中</span></span><br><span class="line">    users.put(<span class="string">&quot;22&quot;</span>, <span class="string">&quot;刘思诚&quot;</span>);</span><br><span class="line">    users.put(<span class="string">&quot;33&quot;</span>, <span class="string">&quot;王强文&quot;</span>);</span><br><span class="line">    users.put(<span class="string">&quot;44&quot;</span>, <span class="string">&quot;李国量&quot;</span>);</span><br><span class="line">    users.put(<span class="string">&quot;55&quot;</span>, <span class="string">&quot;王路路&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;******** 学生列表 ********&quot;</span>);</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> users.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 遍历 Map</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> users.get(key);</span><br><span class="line">      System.out.println(<span class="string">&quot;学号：&quot;</span> + key + <span class="string">&quot;，姓名:&quot;</span> + val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要删除的学号：&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">    <span class="keyword">if</span> (users.containsKey(String.valueOf(num))) &#123; <span class="comment">// 判断是否包含指定键</span></span><br><span class="line">      users.remove(String.valueOf(num)); <span class="comment">// 如果包含就删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;该学生不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;******** 学生列表 ********&quot;</span>);</span><br><span class="line">    it = users.keySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> users.get(key);</span><br><span class="line">      System.out.println(<span class="string">&quot;学号：&quot;</span> + key + <span class="string">&quot;，姓名：&quot;</span> + val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该程序中，两次使用<code>while</code>循环遍历<code>HashMap</code>集合。当有学生毕业时，用户需要输入该学生的学号，根据学号使用<code>HashMap</code>类的<code>remove()</code>方法将对应的元素删除。</p>
<blockquote>
<p>注意：<code>TreeMap</code>类的使用方法与<code>HashMap</code>类相同，唯一不同的是<code>TreeMap</code>类可以对键对象进行排序。</p>
</blockquote>
<h2 id="遍历Map集合的四种方式"><a href="#遍历Map集合的四种方式" class="headerlink" title="遍历Map集合的四种方式"></a>遍历Map集合的四种方式</h2><p><code>Map</code>集合的遍历与<code>List</code>和<code>Set</code>集合不同。<code>Map</code>有两组值，因此遍历时可以只遍历值的集合，也可以只遍历键的集合，也可以同时遍历。<code>Map</code>以及实现<code>Map</code>的接口类（如<code>HashMap、TreeMap、LinkedHashMap、Hashtable</code>等）都可以用以下几种方式遍历。</p>
<h3 id="1-在for循环中使用entries实现Map的遍历（最常见和最常用的）。"><a href="#1-在for循环中使用entries实现Map的遍历（最常见和最常用的）。" class="headerlink" title="1.在for循环中使用entries实现Map的遍历（最常见和最常用的）。"></a>1.在<code>for</code>循环中使用<code>entries</code>实现<code>Map</code>的遍历（最常见和最常用的）。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">mapValue</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(mapKey + <span class="string">&quot;：&quot;</span> + mapValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用for-each循环遍历key或者values，一般适用于只需要Map中的key或者value时使用。性能上比entrySet较好。"><a href="#2-使用for-each循环遍历key或者values，一般适用于只需要Map中的key或者value时使用。性能上比entrySet较好。" class="headerlink" title="2.使用for-each循环遍历key或者values，一般适用于只需要Map中的key或者value时使用。性能上比entrySet较好。"></a>2.使用<code>for-each</code>循环遍历<code>key</code>或者<code>values</code>，一般适用于只需要<code>Map</code>中的<code>key</code>或者<code>value</code>时使用。性能上比<code>entrySet</code>较好。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line"><span class="comment">// 打印键集合</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">  System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印值集合</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123;</span><br><span class="line">  System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用迭代器（Iterator）遍历"><a href="#3-使用迭代器（Iterator）遍历" class="headerlink" title="3.使用迭代器（Iterator）遍历"></a>3.使用迭代器（Iterator）遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">  Entry&lt;String, String&gt; entry = entries.next();</span><br><span class="line">  <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">  System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。"><a href="#4-通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。" class="headerlink" title="4.通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。"></a>4.通过键找值遍历，这种方式的效率比较低，因为本身从键取值是耗时的操作。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">  System.out.println(key+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Collections类操作集合"><a href="#Collections类操作集合" class="headerlink" title="Collections类操作集合"></a>Collections类操作集合</h1><p><code>Collections</code>类是 Java 提供的一个操作<code>Set、List</code>和<code>Map</code>等集合的工具类。<code>Collections</code>类提供了许多操作集合的静态方法，借助这些静态方法可以实现集合元素的排序、查找替换和复制等操作。</p>
<h2 id="排序（正向和逆向）"><a href="#排序（正向和逆向）" class="headerlink" title="排序（正向和逆向）"></a>排序（正向和逆向）</h2><p><code>Collections</code>提供了如下方法用于对<code>List</code>集合元素进行排序。</p>
<ul>
<li><code>void reverse(List list)</code>：对指定<code>List</code>集合元素进行逆向排序。</li>
<li><code>void shuffle(List list)</code>：对<code>List</code>集合元素进行随机排序（<code>shuffle</code>方法模拟了“洗牌”动作）。</li>
<li><code>void sort(List list)</code>：根据元素的自然顺序对指定<code>List</code>集合的元素按升序进行排序。</li>
<li><code>void sort(List list, Comparator c)</code>：根据指定<code>Comparator</code>产生的顺序对<code>List</code>集合元素进行排序。</li>
<li><code>void swap(List list, int i, int j)</code>：将指定<code>List</code>集合中的<code>i</code>处元素和<code>j</code>处元素进行交换。</li>
<li><code>void rotate(List list, int distance)</code>：当<code>distance</code>为正数时，将<code>list</code>集合的后<code>distance</code>个元素“整体”移到前面；当<code>distance</code>为负数时，将<code>list</code>集合的前<code>distance</code>个元素“整体”移到后面。该方法不会改变集合的长度。</li>
</ul>
<p>下面程序简单示范了利用<code>Collections</code>工具类来操作<code>List</code>集合。</p>
<p>编写一个程序，对用户输入的 5 个商品价格进行排序后输出。这里要求使用<code>Collections</code>类中<code>sort()</code>方法按从低到高的顺序对其进行排序，最后将排序后的成绩输出。</p>
<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">List</span> <span class="variable">prices</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;请输入第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 个商品的价格：&quot;</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">      prices.add(Integer.valueOf(p)); <span class="comment">// 将录入的价格保存到List集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(prices); <span class="comment">// 调用sort()方法对集合进行排序</span></span><br><span class="line">    System.out.println(<span class="string">&quot;价格从低到高的排列为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">      System.out.print(prices.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，循环录入 5 个价格，并将每个价格都存储到已定义好的<code>List</code>集合<code>prices</code>中，然后使用<code>Collections</code>类的<code>sort()</code>方法对该集合元素进行升序排序。最后使用<code>for</code>循环遍历<code>users</code>集合，输出该集合中的元素。</p>
<p>该程序的执行结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请输入第 1 个商品的价格：</span><br><span class="line">85</span><br><span class="line">请输入第 2 个商品的价格：</span><br><span class="line">48</span><br><span class="line">请输入第 3 个商品的价格：</span><br><span class="line">66</span><br><span class="line">请输入第 4 个商品的价格：</span><br><span class="line">80</span><br><span class="line">请输入第 5 个商品的价格：</span><br><span class="line">18</span><br><span class="line">价格从低到高的排列为：</span><br><span class="line">18    48    66    80    85</span><br></pre></td></tr></table></figure>
<p>循环录入 5 个商品的名称，并按录入时间的先后顺序进行降序排序，即后录入的先输出。</p>
<p>下面编写程序，使用<code>Collections</code>类的<code>reverse()</code>方法对保存到<code>List</code>集合中的 5 个商品名称进行反转排序，并输出排序后的商品信息。具体的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">List</span> <span class="variable">students</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;******** 商品信息 ********&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;请输入第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 个商品的名称：&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next();</span><br><span class="line">      students.add(name); <span class="comment">// 将录入的商品名称存到List集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(students); <span class="comment">// 调用reverse()方法对集合元素进行反转排序</span></span><br><span class="line">    System.out.println(<span class="string">&quot;按录入时间的先后顺序进行降序排列为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      System.out.print(students.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先循环录入 5 个商品的名称，并将这些名称保存到<code>List</code>集合中，然后调用<code>Collections</code>类中的<code>reverse()</code>方法对该集合元素进行反转排序。最后使用<code>for</code>循环将排序后的集合元素输出。</p>
<p>执行该程序，输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">******** 商品信息 ********</span><br><span class="line">请输入第 1 个商品的名称：</span><br><span class="line">果粒橙</span><br><span class="line">请输入第 2 个商品的名称：</span><br><span class="line">冰红茶</span><br><span class="line">请输入第 3 个商品的名称：</span><br><span class="line">矿泉水</span><br><span class="line">请输入第 4 个商品的名称：</span><br><span class="line">软面包</span><br><span class="line">请输入第 5 个商品的名称：</span><br><span class="line">巧克力</span><br><span class="line">按录入时间的先后顺序进行降序排列为：</span><br><span class="line">巧克力    软面包    矿泉水    冰红茶    果粒橙   </span><br></pre></td></tr></table></figure>
<h2 id="查找、替换操作"><a href="#查找、替换操作" class="headerlink" title="查找、替换操作"></a>查找、替换操作</h2><p><code>Collections</code>还提供了如下常用的用于查找、替换集合元素的方法。</p>
<ul>
<li><code>int binarySearch(List list, Object key)</code>：使用二分搜索法搜索指定的<code>List</code>集合，以获得指定对象在<code>List</code>集合中的索引。如果要使该方法可以正常工作，则必须保证<code>List</code>中的元素已经处于有序状态。</li>
<li><code>Object max(Collection coll)</code>：根据元素的自然顺序，返回给定集合中的最大元素。</li>
<li><code>Object max(Collection coll, Comparator comp)</code>：根据<code>Comparator</code>指定的顺序，返回给定集合中的最大元素。</li>
<li><code>Object min(Collection coll)</code>：根据元素的自然顺序，返回给定集合中的最小元素。</li>
<li><code>Object min(Collection coll, Comparator comp)</code>：根据<code>Comparator</code>指定的顺序，返回给定集合中的最小元素。</li>
<li><code>void fill(List list, Object obj)</code>：使用指定元素<code>obj</code>替换指定<code>List</code>集合中的所有元素。</li>
<li><code>int frequency(Collection c, Object o)</code>：返回指定集合中指定元素的出现次数。</li>
<li><code>int indexOfSubList(List source, List target)</code>：返回子<code>List</code>对象在父<code>List</code>对象中第一次出现的位置索引；如果父<code>List</code> 中没有出现这样的子<code>List</code>，则返回 -1。</li>
<li><code>int lastIndexOfSubList(List source, List target)</code>：返回子<code>List</code>对象在父<code>List</code>对象中最后一次出现的位置索引；如果父<code>List</code>中没有岀现这样的子<code>List</code>，则返回 -1。</li>
<li><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：使用一个新值<code>newVal</code>替换<code>List</code>对象的所有旧值<code>oldVal</code>。</li>
</ul>
<p>下面程序简单示范了<code>Collections</code>工具类的用法。</p>
<p>编写一个程序，要求用户输入 3 个商品名称，然后使用<code>Collections</code>类中的<code>fill()</code>方法对商品信息进行重置操作，即将所有名称都更改为“未填写”。具体的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">List</span> <span class="variable">products</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;******** 商品信息 ********&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;请输入第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 个商品的名称：&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next();</span><br><span class="line">      products.add(name); <span class="comment">// 将用户录入的商品名称保存到List集合中</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;重置商品信息，将所有名称都更改为&#x27;未填写&#x27;&quot;</span>);</span><br><span class="line">    Collections.fill(products, <span class="string">&quot;未填写&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;重置后的商品信息为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.size(); i++) &#123;</span><br><span class="line">      System.out.print(products.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先循环录入 3 个商品名称，并将这些商品信息存储到<code>List</code>集合中，然后调用<code>Collections</code>类中的<code>fill()</code>方法将该集合中的所有元素值替换为“未填写”。最后使用<code>for</code>循环将替换后的集合元素输出。</p>
<p>运行该程序，执行结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">******** 商品信息 ********</span><br><span class="line">请输入第 1 个商品的名称：</span><br><span class="line">苏打水</span><br><span class="line">请输入第 2 个商品的名称：</span><br><span class="line">矿泉水</span><br><span class="line">请输入第 3 个商品的名称：</span><br><span class="line">冰红茶</span><br><span class="line">重置商品信息，将所有名称都更改为&#x27;未填写&#x27;</span><br><span class="line">重置后的商品信息为：</span><br><span class="line">未填写    未填写    未填写    </span><br></pre></td></tr></table></figure>
<p>在一个集合中保存 4 个数据，分别输出最大最小元素和指定数据在集合中出现的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">nums</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    nums.add(<span class="number">2</span>);</span><br><span class="line">    nums.add(-<span class="number">5</span>);</span><br><span class="line">    nums.add(<span class="number">3</span>);</span><br><span class="line">    nums.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(nums); <span class="comment">// 输出：[2, -5, 3, 0]</span></span><br><span class="line">    System.out.println(Collections.max(nums)); <span class="comment">// 输出最大元素，将输出 3</span></span><br><span class="line">    System.out.println(Collections.min(nums)); <span class="comment">// 输出最小元素，将输出-5</span></span><br><span class="line">    Collections.replaceAll(nums, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 将 nums中的 0 使用 1 来代替</span></span><br><span class="line">    System.out.println(nums); <span class="comment">// 输出：[2, -5, 3, 1]</span></span><br><span class="line">    <span class="comment">// 判断-5在List集合中出现的次数，返回1</span></span><br><span class="line">    System.out.println(Collections.frequency(nums, -<span class="number">5</span>));</span><br><span class="line">    Collections.sort(nums); <span class="comment">// 对 nums集合排序</span></span><br><span class="line">    System.out.println(nums); <span class="comment">// 输出：[-5, 1, 2, 3]</span></span><br><span class="line">    <span class="comment">// 只有排序后的List集合才可用二分法查询，输出3</span></span><br><span class="line">    System.out.println(Collections.binarySearch(nums, <span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，向<code>List</code>集合中添加 4 个数据，然后调用<code>Collections</code>类中的<code>max()</code>和<code>min()</code>方法输出集合中的最大最小元素，<code>replaceAll()</code>替换元素，<code>frequency()</code>判断指定数据在<code>List</code>集合中出现的次数，最后用<code>binarySearch()</code>进行二分法查询。</p>
<p>运行上述程序，执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[2, -5, 3, 0]</span><br><span class="line">3</span><br><span class="line">-5</span><br><span class="line">[2, -5, 3, 1]</span><br><span class="line">1</span><br><span class="line">[-5, 1, 2, 3]</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><code>Collections</code>类的<code>copy()</code>静态方法用于将指定集合中的所有元素复制到另一个集合中。执行<code>copy()</code>方法后，目标集合中每个已复制元素的索引将等同于源集合中该元素的索引。</p>
<p><code>copy()</code>方法的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List &lt;? <span class="built_in">super</span> T&gt; dest,List&lt;? extends T&gt; src)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>dest</code>表示目标集合对象，<code>src</code>表示源集合对象。</p>
<p>注意：目标集合的长度至少和源集合的长度相同，如果目标集合的长度更长，则不影响目标集合中的其余元素。如果目标集合长度不够而无法包含整个源集合元素，程序将抛出<code>IndexOutOfBoundsException</code>异常。</p>
<p>在一个集合中保存了 5 个商品名称，现在要使用<code>Collections</code>类中的<code>copy()</code>方法将其中的 3 个替换掉。具体实现的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">List</span> <span class="variable">srcList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">List</span> <span class="variable">destList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    destList.add(<span class="string">&quot;苏打水&quot;</span>);</span><br><span class="line">    destList.add(<span class="string">&quot;木糖醇&quot;</span>);</span><br><span class="line">    destList.add(<span class="string">&quot;方便面&quot;</span>);</span><br><span class="line">    destList.add(<span class="string">&quot;火腿肠&quot;</span>);</span><br><span class="line">    destList.add(<span class="string">&quot;冰红茶&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;原有商品如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; destList.size(); i++) &#123;</span><br><span class="line">      System.out.println(destList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入替换的商品名称：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;第 &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 个商品：&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next();</span><br><span class="line">      srcList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用copy()方法将当前商品信息复制到原有商品信息集合中</span></span><br><span class="line">    Collections.copy(destList, srcList);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前商品有：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; destList.size(); i++) &#123;</span><br><span class="line">      System.out.print(destList.get(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先创建了两个<code>List</code>对象<code>srcList</code>和<code>destList</code>，并向<code>destList</code>集合中添加了 5 个元素，向<code>srcList</code>集合中添加了 3 个元素，然后调用<code>Collections</code>类中<code>copy()</code>方法将<code>srcList</code>集合中的全部元素复制到<code>destList</code>集合中。由于<code>destList</code>集合中含有 5 个元素，故最后两个元素不会被覆盖。</p>
<p>运行该程序，具体的执行结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原有商品如下：</span><br><span class="line">苏打水</span><br><span class="line">木糖醇</span><br><span class="line">方便面</span><br><span class="line">火腿肠</span><br><span class="line">冰红茶</span><br><span class="line">输入替换的商品名称：</span><br><span class="line">第 1 个商品：</span><br><span class="line">燕麦片</span><br><span class="line">第 2 个商品：</span><br><span class="line">八宝粥</span><br><span class="line">第 3 个商品：</span><br><span class="line">软面包</span><br><span class="line">当前商品有：</span><br><span class="line">燕麦片    八宝粥    软面包    火腿肠    冰红茶</span><br></pre></td></tr></table></figure>
<h1 id="Iterator（迭代器）遍历Collection集合元素"><a href="#Iterator（迭代器）遍历Collection集合元素" class="headerlink" title="Iterator（迭代器）遍历Collection集合元素"></a>Iterator（迭代器）遍历Collection集合元素</h1><p><code>Iterator</code>（迭代器）是一个接口，它的作用就是遍历容器的所有元素，也是 Java 集合框架的成员，但它与<code>Collection</code>和<code>Map</code>系列的集合不一样，<code>Collection</code>和<code>Map</code>系列集合主要用于盛装其他对象，而<code>Iterator</code>则主要用于遍历（即迭代访问）<code>Collection</code>集合中的元素。</p>
<p><code>Iterator</code>接口隐藏了各种<code>Collection</code>实现类的底层细节，向应用程序提供了遍历<code>Collection</code>集合元素的统一编程接口。<code>Iterator</code>接口里定义了如下 4 个方法。</p>
<ul>
<li><code>boolean hasNext()</code>：如果被迭代的集合元素还没有被遍历完，则返回<code>true</code>。</li>
<li><code>Object next()</code>：返回集合里的下一个元素。</li>
<li><code>void remove()</code>：删除集合里上一次<code>next</code>方法返回的元素。</li>
<li><code>void forEachRemaining(Consumer action)</code>：这是 Java 8 为<code>Iterator</code>新增的默认方法，该方法可使用<code>Lambda</code>表达式来遍历集合元素。</li>
</ul>
<p>下面程序示范了通过<code>Iterator</code>接口来遍历集合元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">objs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网Java教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C语言教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C++教程&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用forEach()方法遍历集合</span></span><br><span class="line">    <span class="comment">// 获取books集合对应的迭代器</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> objs.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// it.next()方法返回的数据类型是Object类型，因此需要强制类型转换</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">      System.out.println(obj);</span><br><span class="line">      <span class="keyword">if</span> (obj.equals(<span class="string">&quot;C语言中文网C语言教程&quot;</span>)) &#123;</span><br><span class="line">          <span class="comment">// 从集合中删除上一次next()方法返回的元素</span></span><br><span class="line">          it.remove();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对book变量赋值，不会改变集合元素本身</span></span><br><span class="line">      obj = <span class="string">&quot;C语言中文网Python语言教程&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(objs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看出，<code>Iterator</code>仅用于遍历集合，如果需要创建<code>Iterator</code>对象，则必须有一个被迭代的集合。没有集合的<code>Iterator</code>没有存在的价值。</p>
<p>注意：<code>Iterator</code>必须依附于<code>Collection</code>对象，若有一个<code>Iterator</code>对象，则必然有一个与之关联的<code>Collection</code>对象。<code>Iterator</code>提供了两个方法来迭代访问<code>Collection</code>集合里的元素，并可通过 remove() 方法来删除集合中上一次 next() 方法返回的集合元素。</p>
<p>上面程序中第 24 行代码对迭代变量<code>obj</code>进行赋值，但当再次输岀<code>objs</code>集合时，会看到集合里的元素没有任何改变。所以当使用<code>Iterator</code>对集合元素进行迭代时，<code>Iterator</code>并不是把集合元素本身传给了迭代变量，而是把集合元素的值传给了迭代变量，所以修改迭代变量的值对集合元素本身没有任何影响。</p>
<p>当使用<code>Iterator</code>迭代访问<code>Collection</code>集合元素时，<code>Collection</code>集合里的元素不能被改变，只有通过<code>Iterator</code>的<code>remove()</code>方法删除上一次<code>next()</code>方法返回的集合元素才可以，否则将会引发<code>“java.util.ConcurrentModificationException”</code>异常。下面程序示范了这一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorErrorTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">objs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网Java教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C语言教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C++教程&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取books集合对应的迭代器</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> objs.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">      System.out.println(obj);</span><br><span class="line">      <span class="keyword">if</span> (obj.equals(<span class="string">&quot;C语言中文网C++教程&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 使用Iterator迭代过程中，不可修改集合元素，下面代码引发异常</span></span><br><span class="line">        objs.remove(obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网C++教程</span><br><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</span><br><span class="line">        at java.util.HashMap$HashIterator.nextNode(Unknown Source)</span><br><span class="line">        at java.util.HashMap$KeyIterator.next(Unknown Source)</span><br><span class="line">        at IteratorErrorTest.main(IteratorErrorTest.java:15)</span><br></pre></td></tr></table></figure>
<p>上面程序中第 15 行代码位于<code>Iterator</code>迭代块内，也就是在<code>Iterator</code>迭代<code>Collection</code>集合过程中修改了<code>Collection</code>集合，所以程序将在运行时引发异常。</p>
<p>Iterator 迭代器采用的是快速失败（fail-fast）机制，一旦在迭代过程中检测到该集合已经被修改（通常是程序中的其他线程修改），程序立即引发 ConcurrentModificationException 异常，而不是显示修改后的结果，这样可以避免共享资源而引发的潜在问题。<br>快速失败（fail-fast）机制，是 Java Collection 集合中的一种错误检测机制。</p>
<p>注意：上面程序如果改为删除“C语言中文网C语言教程”字符串，则不会引发异常。这样可能有些读者会“心存侥幸”地想，在迭代时好像也可以删除集合元素啊。实际上这是一种危险的行为。对于 HashSet 以及后面的 ArrayList 等，迭代时删除元素都会导致异常。只有在删除集合中的某个特定元素时才不会抛出异常，这是由集合类的实现代码决定的，程序员不应该这么做。</p>
<h1 id="使用Lambda表达式遍历Collection集合"><a href="#使用Lambda表达式遍历Collection集合" class="headerlink" title="使用Lambda表达式遍历Collection集合"></a>使用Lambda表达式遍历Collection集合</h1><p>Java 8 为 Iterable 接口新增了一个<code>forEach(Consumer action)</code>默认方法，该方法所需参数的类型是一个函数式接口，而<code>Iterable</code>接口是 Collection 接口的父接口，因此 Collection 集合也可直接调用该方法。</p>
<p>当程序调用<code>Iterable</code>的<code>forEach(Consumer action)</code>遍历集合元素时，程序会依次将集合元素传给<code>Consumer</code>的<code>accept(T t)</code>方法（该接口中唯一的抽象方法）。正因为<code>Consumer</code>是函数式接口，因此可以使用<code>Lambda</code>表达式来遍历集合元素。</p>
<p>如下程序示范了使用<code>Lambda</code>表达式来遍历集合元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionEach</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">objs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网Java教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C语言教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C++教程&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用forEach()方法遍历集合</span></span><br><span class="line">    objs.forEach(obj -&gt; System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span> + obj));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">迭代集合元素：C语言中文网C++教程</span><br><span class="line">迭代集合元素：C语言中文网C语言教程</span><br><span class="line">迭代集合元素：C语言中文网Java教程</span><br></pre></td></tr></table></figure>
<p>上面程序中粗体字代码调用了<code>Iterable</code>的<code>forEach()</code>默认方法来遍历集合元素，传给该方法的参数是一个 Lambda 表达式，该 Lambda 表达式的目标类型是 Comsumer。forEach() 方法会自动将集合元素逐个地传给 Lambda 表达式的形参，这样 Lambda 表达式的代码体即可遍历到集合元素了。</p>
<h1 id="使用Lambda表达式遍历Iterator迭代器"><a href="#使用Lambda表达式遍历Iterator迭代器" class="headerlink" title="使用Lambda表达式遍历Iterator迭代器"></a>使用Lambda表达式遍历Iterator迭代器</h1><p>Java 8 为 Iterator 引入了一个<code>forEachRemaining(Consumer action)</code>默认方法，该方法所需的<code>Consumer</code>参数同样也是函数式接口。当程序调用 Iterator 的<code>forEachRemaining(Consumer action)</code>遍历集合元素时，程序会依次将集合元素传给<code>Consumer</code>的<code>accept(T t)</code>方法（该接口中唯一的抽象方法）。<br><code>java.util.function</code>中的<code>Function、Supplier、Consumer、Predicate</code>和其他函数式接口被广泛用在支持<code>Lambda</code>表达式的 API 中。<code>“void accept(T t);”</code>是<code>Consumer</code>的核心方法，用来对给定的参数<code>T</code>执行定义操作。</p>
<p>如下程序示范了使用 Lambda 表达式来遍历集合元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorEach</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">objs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    objs.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;ccc++教程&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取objs集合对应的迭代器</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> objs.iterator();</span><br><span class="line">    <span class="comment">// 使用Lambda表达式（目标类型是Comsumer）来遍历集合元素</span></span><br><span class="line">    it.forEachRemaining(obj -&gt; System.out.println(<span class="string">&quot;迭代集合元素：&quot;</span> + obj));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中第 11 行代码调用了<code>Iterator</code>的<code>forEachRemaining()</code>方法来遍历集合元素，传给该方法的参数是一个<code>Lambda</code>表达式，该<code>Lambda</code>表达式的目标类型是<code>Consumer</code>，因此上面代码也可用于遍历集合元素。</p>
<h1 id="使用foreach循环遍历Collection集合"><a href="#使用foreach循环遍历Collection集合" class="headerlink" title="使用foreach循环遍历Collection集合"></a>使用foreach循环遍历Collection集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForeachTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">objs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网Java教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C语言教程&quot;</span>);</span><br><span class="line">    objs.add(<span class="string">&quot;C语言中文网C++教程&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object obj : objs) &#123;</span><br><span class="line">        <span class="comment">// 此处的obj变量也不是集合元素本身</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">obj1</span> <span class="operator">=</span> (String) obj;</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        <span class="keyword">if</span> (obj1.equals(<span class="string">&quot;C语言中文网Java教程&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 下面代码会引发 ConcurrentModificationException 异常</span></span><br><span class="line">            objs.remove(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(objs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网C++教程</span><br><span class="line">C语言中文网C语言教程</span><br><span class="line">C语言中文网Java教程</span><br><span class="line">[C语言中文网C++教程, C语言中文网C语言教程]</span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>foreach</code>循环来迭代访问<code>Collection</code>集合里的元素更加简洁。与使用<code>Iterator</code>接口迭代访问集合元素类似的是，<code>foreach</code>循环中的迭代变量也不是集合元素本身，系统只是依次把集合元素的值赋给迭代变量，因此在<code>foreach</code>循环中修改迭代变量的值也没有任何实际意义。</p>
<p>同样，当使用<code>foreach</code>循环迭代访问集合元素时，该集合也不能被改变，否则将引发<code>ConcurrentModificationException</code>异常。所以上面程序中第 14 行代码处将引发该异常。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/网络层——IP多播"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/"
    >网络层——IP多播</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/" class="article-date">
  <time datetime="2020-09-29T03:27:09.000Z" itemprop="datePublished">2020-09-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="IP-多播的基本概念"><a href="#IP-多播的基本概念" class="headerlink" title="IP 多播的基本概念"></a>IP 多播的基本概念</h1><p>IP 多播 (<code>multicast</code>，以前曾译为组播) 目的：更好地支持一对多通信。</p>
<p>一对多通信：一个源点发送到许多个终点。例如，实时信息的交付（如新闻、股市行情等），软件更新，交互式会议及其他多媒体通信。</p>
<img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/img1.png" class="">
<img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/img2.png" class="">

<p>在互联网上进行多播就叫做 IP 多播。互联网范围的多播要靠路由器来实现。</p>
<h2 id="多播-IP-地址"><a href="#多播-IP-地址" class="headerlink" title="多播 IP 地址"></a>多播 IP 地址</h2><p>IP 多播所传送的分组需要使用多播 IP 地址。</p>
<p>在多播数据报的目的地址写入的是多播组的标识符。多播组的标识符就是 IP 地址中的 D 类地址（多播地址）。每一个 D 类地址标志一个多播组。</p>
<p>多播地址只能用于目的地址，不能用于源地址。</p>
<h2 id="多播数据报"><a href="#多播数据报" class="headerlink" title="多播数据报"></a>多播数据报</h2><p>多播数据报和一般的 IP 数据报的区别就是它使用 D 类 IP 地址作为目的地址，并且首部中的协议字段值是 2，表明使用网际组管理协议 IGMP。</p>
<p>多播数据报也是“尽最大努力交付”，不保证一定能够交付多播组内的所有成员。</p>
<p>对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。</p>
<h1 id="在局域网上进行硬件多播"><a href="#在局域网上进行硬件多播" class="headerlink" title="在局域网上进行硬件多播"></a>在局域网上进行硬件多播</h1><p>互联网号码指派管理局 IANA 拥有的以太网地址块的高 24 位为<code>00-00-5E</code>。因此 TCP&#x2F;IP 协议使用的以太网地址块的范围是从<code>00-00-5E-00-00-00</code>到<code>00-00-5E-FF-FF-FF</code>。</p>
<p>不难看出，在每一个地址中，只有23位可用作多播。</p>
<p>D 类 IP 地址可供分配的有 28 位，在这 28 位中的前 5 位不能用来构成以太网硬件地址。</p>
<p>D 类 IP 地址与以太网多播地址的映射关系：</p>
<img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/img3.png" class="">

<p>由于多播 IP 地址与以太网硬件地址的映射关系不是唯一的，因此收到多播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p>
<h1 id="网际组管理协议-IGMP-和多播路由选择协议"><a href="#网际组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="网际组管理协议 IGMP 和多播路由选择协议"></a>网际组管理协议 IGMP 和多播路由选择协议</h1><h2 id="IP-多播需要两种协议"><a href="#IP-多播需要两种协议" class="headerlink" title="IP 多播需要两种协议"></a>IP 多播需要两种协议</h2><p>为了使路由器知道多播组成员的信息，需要利用网际组管理协议 IGMP(<code>Internet Group Management Protocol</code>)。</p>
<p>连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。 </p>
<img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/img4.png" class="">

<h3 id="IGMP-的使用范围"><a href="#IGMP-的使用范围" class="headerlink" title="IGMP 的使用范围"></a>IGMP 的使用范围</h3><p>IGMP 并非在互联网范围内对所有多播组成员进行管理的协议。</p>
<p>IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上。</p>
<p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。</p>
<h3 id="多播路由选择协议更为复杂"><a href="#多播路由选择协议更为复杂" class="headerlink" title="多播路由选择协议更为复杂"></a>多播路由选择协议更为复杂</h3><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/img5.png" class="">

<p>多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</p>
<p>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。</p>
<p>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。 </p>
<h2 id="网际组管理协议-IGMP"><a href="#网际组管理协议-IGMP" class="headerlink" title="网际组管理协议 IGMP"></a>网际组管理协议 IGMP</h2><p>和 ICMP 相似，IGMP 使用 IP 数据报传递其报文（即 IGMP 报文加上 IP 首部构成 IP 数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。 </p>
<p>IGMP 工作可分为两个阶段</p>
<h4 id="第一阶段：加入多播组。"><a href="#第一阶段：加入多播组。" class="headerlink" title="第一阶段：加入多播组。"></a>第一阶段：加入多播组。</h4><p>当某个主机加入新的多播组时，该主机应向多播组的多播地址发送 IGMP 报文，声明自己要成为该组的成员。</p>
<p>本地的多播路由器收到 IGMP 报文后，将组成员关系转发给互联网上的其他多播路由器。</p>
<h4 id="第二阶段：探询组成员变化情况。"><a href="#第二阶段：探询组成员变化情况。" class="headerlink" title="第二阶段：探询组成员变化情况。"></a>第二阶段：探询组成员变化情况。</h4><p>因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。</p>
<p>只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。</p>
<p>但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</p>
<p>在主机和多播路由器之间的所有通信都是使用 IP 多播。</p>
<p>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒发送一次。</p>
<p>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。 </p>
<p>在 IGMP 的询问报文中有一个数值 N，它指明一个最长响应时间（默认值为 10 秒）。当收到询问时，主机在 0 到 N 之间随机选择发送响应所需经过的时延。对应于最小时延的响应最先发送。</p>
<p>同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。</p>
<h2 id="多播路由选择"><a href="#多播路由选择" class="headerlink" title="多播路由选择"></a>多播路由选择</h2><p>多播路由选择协议尚未标准化。</p>
<p>一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。</p>
<p>多播路由选择实际上就是要找出以源主机为根结点的多播转发树。</p>
<p>在多播转发树上的路由器不会收到重复的多播数据报。</p>
<p>对不同的多播组对应于不同的多播转发树。</p>
<p>同一个多播组，对不同的源点也会有不同的多播转发树。</p>
<p>多播路由选择协议在转发多播数据报时使用三种方法：</p>
<ul>
<li>洪泛与剪除</li>
<li>隧道技术</li>
<li>基于核心的发现技术</li>
</ul>
<h3 id="1-洪泛与剪除"><a href="#1-洪泛与剪除" class="headerlink" title="(1) 洪泛与剪除"></a>(1) 洪泛与剪除</h3><p>这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。</p>
<p>一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。</p>
<p>为了避免兜圈子，采用了叫做反向路径广播 RPB(<code>Reverse Path Broadcasting</code>) 的策略。 </p>
<p>RPB 的要点：<br>路由器收到多播数据报时，先检查它是否是从源点经最短路径传送来的。</p>
<p>若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。</p>
<p>如果存在几条同样长度的最短路径，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。 </p>
<p>最后就得出了用来转发多播数据报的多播转发树，以后就按这个多播转发树转发多播数据报。避免了多播数据报的兜圈子，同时每一个路由器也不会接收重复的多播数据报。</p>
<p>如果在多播转发树上的某个路由器发现它的下游树枝（即叶节点方向）已没有该多播组的成员，就应把它和下游的树枝一起剪除。</p>
<p>当某个树枝有新增加的组成员时，可以再接入到多播转发树上。</p>
<img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/img6.png" class="">

<h3 id="2-隧道技术-tunneling"><a href="#2-隧道技术-tunneling" class="headerlink" title="(2) 隧道技术 (tunneling)"></a>(2) 隧道技术 (tunneling)</h3><img src="/2020/09/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94IP%E5%A4%9A%E6%92%AD/img7.png" class="">

<h3 id="3-基于核心的发现技术"><a href="#3-基于核心的发现技术" class="headerlink" title="(3) 基于核心的发现技术"></a>(3) 基于核心的发现技术</h3><p>这种方法对于多播组的大小在较大范围内变化时都适合。</p>
<p>这种方法是对每一个多播组 G 指定一个核心路由器，给出它的 IP 单播地址。</p>
<p>核心路由器按照前面讲过的方法创建出对应于多播组 G 的转发树。 </p>
<h3 id="几种多播路由选择协议"><a href="#几种多播路由选择协议" class="headerlink" title="几种多播路由选择协议"></a>几种多播路由选择协议</h3><p>距离向量多播路由选择协议 DVMRP(<code>Distance Vector Multicast Routing Protocol</code>)<br>基于核心的转发树 CBT(<code>Core Based Tree</code>)<br>开放最短通路优先的多播扩展 MOSPF(<code>Multicast Extensions to OSPF</code>)<br>协议无关多播-稀疏方式 PIM-SM(<code>Protocol Independent Multicast-Sparse Mode</code>)<br>协议无关多播-密集方式 PIM-DM(<code>Protocol Independent Multicast-Dense Mode</code>)</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/网络层——路由选择协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/"
    >网络层——路由选择协议</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-09-26T09:11:08.000Z" itemprop="datePublished">2020-09-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>路由选择协议是讨论路由表中的路由是怎样得出来的。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h2><p>路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。</p>
<p>一个理想的路由算法有如下特点：</p>
<ul>
<li>算法必须是正确的和完整的。沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li>
<li>算法在计算上应简单。路由选择的计算不应使网络通信量增加太多的额外开销。</li>
<li>算法应能适应通信量和网络拓扑的变化，要有自适应性。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。</li>
<li>算法应具有稳定性。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li>
<li>算法应是公平的。路由选择算法应对所有用户（除对少数优先级高的用户）都是平等的。</li>
<li>算法应是最佳的。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。</li>
</ul>
<p>不存在一种绝对的最佳路由算法。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</p>
<p>实际的路由选择算法，应尽可能接近于理想的算法。</p>
<p>路由选择是个非常复杂的问题，它是网络中的所有结点共同协调工作的结果。路由选择的环境往往是不断变化的，而这种变化有时无法事先知道。 </p>
<h3 id="从路由算法的自适应性考虑"><a href="#从路由算法的自适应性考虑" class="headerlink" title="从路由算法的自适应性考虑"></a>从路由算法的自适应性考虑</h3><p>从路由算法能否随网络的通信量或拓扑自适应的进行调整变化划分有两类：</p>
<ul>
<li>静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。适用于简单的小网络。</li>
<li>动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。适用于较复杂的大网络。</li>
</ul>
<h2 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h2><p>互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。</p>
<p>互联网采用分层次的路由选择协议原因：</p>
<ol>
<li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li>
<li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。</li>
</ol>
<p>为此，可以把整个互联网划分为许多小的自治系统。</p>
<h3 id="自治系统-AS-Autonomous-System"><a href="#自治系统-AS-Autonomous-System" class="headerlink" title="自治系统 AS (Autonomous System)"></a>自治系统 AS (Autonomous System)</h3><p>自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS 之间的路由。</p>
<p>尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img1.png" class="">

<h3 id="互联网有两大类路由选择协议："><a href="#互联网有两大类路由选择协议：" class="headerlink" title="互联网有两大类路由选择协议："></a>互联网有两大类路由选择协议：</h3><ul>
<li>内部网关协议 IGP(<code>Interior Gateway Protocol</code>)，在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li>
<li>外部网关协议 EGP(<code>External Gateway Protocol</code>)，若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 BGP-4。</li>
</ul>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img2.png" class="">

<p>自治系统之间的路由选择也叫做域间路由选择，在自治系统内部的路由选择叫做域内路由选择。</p>
<h3 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h3><img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img3.png" class="">

<h1 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h1><p>路由信息协议 RIP(<code>Routing Information Protocol</code>) 是内部网关协议 IGP 中最先得到广泛使用的协议。</p>
<p>RIP 是一种分布式的、基于距离矢量算法的路由选择协议。使用跳数作为度量来衡量到达目的网络的距离。</p>
<p>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。</p>
<p>RIP 距离定义：从一路由器到直接连接的网络的距离定义为 0；从一路由器到非直接连接的网络的距离定义为所经过的路由器数加 1；</p>
<p>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p>
<p>RIP 允许一条路径最多只能包含 15 个路由器。因此，“距离”的最大值为 16 时即相当于不可达。可见 RIP 只适用于小型互联网。</p>
<p>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。 </p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>路由器启动时，路由表中只会包含直连路由。</p>
<p>运行 RIP 之后：</p>
<ol>
<li>路由器会发送<code>Request</code>报文，用来请求邻居路由器的 RIP 路由。</li>
<li>运行 RIP 的邻居路由器收到该<code>Request</code>报文后，会根据自己的路由表，生成<code>Response</code>报文进行回复。</li>
<li>路由器在收到<code>Response</code>报文后，会将相应的路由添加到自己的路由表中。</li>
</ol>
<p>RIP 网络稳定以后，每个路由器会周期性地向邻居路由器通告自己的整张路由表中的路由信息，默认周期为 30 秒。邻居路由器根据收到的路由信息刷新自己的路由表。</p>
<h3 id="RIP协议度量——跳数"><a href="#RIP协议度量——跳数" class="headerlink" title="RIP协议度量——跳数"></a>RIP协议度量——跳数</h3><p>RIP 使用跳数作为度量值来衡量到达目的网络的距离。</p>
<p>在 RIP 中，路由器到与它直接相连网络的跳数为 0，每经过一个路由器后跳数加 1。为限制收敛时间，RIP 规定跳数的取值范围为 0~15 之间的整数，大于 15 的跳数被定义为无穷大，即目的网络或主机不可达。</p>
<h3 id="路由更新原则"><a href="#路由更新原则" class="headerlink" title="路由更新原则"></a>路由更新原则</h3><p>路由器从某一邻居路由器收到路由更新报文时，将根据以下原则更新本路由器的 RIP 路由表：</p>
<ol>
<li>对于本路由表中已有的路由项，当该路由项的下一跳是该邻居路由器时，不论度量值将增大或是减少，都更新该路由项。度量值相同时只将其老化定时器清零。路由表中的每一路由项都对应了一个老化定时器，当路由项在 180 秒内没有任何更新时，定时器超时，该路由项的度量值变为不可达。</li>
<li>当该路由项的下一跳不是该邻居路由器时，如果度量值将减少，则更新该路由项。</li>
<li>对于本路由表中不存在的路由项，如果度量值小于 16，则在路由表中增加该路由项。</li>
<li>某路由项的度量值变为不可达后，该路由会在<code>Response</code>报文中发布四次（120 秒），然后从路由表中清除。</li>
</ol>
<h3 id="RIP-协议的三个特点"><a href="#RIP-协议的三个特点" class="headerlink" title="RIP 协议的三个特点"></a>RIP 协议的三个特点</h3><ul>
<li>仅和相邻路由器交换信息。 </li>
<li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 </li>
<li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li>
</ul>
<h3 id="RIPV1和RIPv2"><a href="#RIPV1和RIPv2" class="headerlink" title="RIPV1和RIPv2"></a>RIPV1和RIPv2</h3><p>RIP 分为两个版本。RIPv1 使用本地广播地址<code>255.255.255.255</code>发布路由信息，默认的路由更新周期为 30s，持有时间为 180s。也就是说，RIP 路由器每 30s 向所有邻居发送一次路由更新报文，如果在 180s 之内没有从某个邻居接收到路由更新报文，则认为该邻居已经不存在了。这时如果从其他邻居收到了有关同一目标的路由更新报文，则用新的路由信息替换已失效的路由表项，否则，对应的路由表项被删除。</p>
<p>RIP 以跳步计数来度量路由费用，显然这不是最好的度量标准。例如，若有两条到达同一目标的连接，一条是经过两跳的 10M 以太网连接，另一条是经过一跳的 64k WAN 连接，则 RIP 会选取 WAN 连接作为最佳路由。在 RIP 协议中，15 跳是最大跳数，16 跳是不可到达网络，经过 16 跳的任何分组将被路由器丢弃。</p>
<p>RIPv1 是有类别的协议，这意味着配置 RIPv1 时必须使用 A、B 或 C 类 IP 地址和子网掩码，例如不能把子网掩码<code>255.255.255.0</code>用于 B 类网络<code>172.16.0.0</code>。对于同一目标，RIP 路由表项中最多可以有 6 条等费用的通路，虽然默认是 4 条。RIP 可以实现等费用通路的负载均衡，这种机制提供了链路冗余功能，以对付可能出现的连接失效，但是 RIP 不支持不等费用通路的负载均衡。</p>
<p>RIPv2 基本上还是一个距离矢量路由协议，但是有 3 个方面的改进。首先是它使用组播而不是广播来传播路由更新报文，并且采用了触发更新机制来加速路由收敛，即出现路由变化时立即向邻居发送路由更新报文，而不必等待更新周期是否到达。其次是 RIPv2 是一个无类别的协议，可以使用可变长子网掩码（VLSM），也支持无类别域间路由（CIDR），这些功能使得网络的设计更具伸缩性。第3个增强是 RIPv2 支持认证，使用经过散列的口令字来限制路由更新信息的传播。</p>
<h2 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h2><p>路由器收到相邻路由器（其地址为 X）的一个 RIP 报文：</p>
<ol>
<li>先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。</li>
<li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：</li>
</ol>
<ul>
<li>若项目中的目的网络不在路由表中，则把该项目加到路由表中。</li>
<li>否则，若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。</li>
<li>否则，若收到项目中的距离小于路由表中的距离，则进行更新，</li>
<li>否则，什么也不做。</li>
</ul>
<ol start="3">
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为 16（表示不可达）。</li>
<li>返回。</li>
</ol>
<p>距离向量算法的要点是这样的：设X是结点 A 到 B 的最短路径上的一个结点。若把路径 A→B 拆成两段路径 A→X 和 X→B，则每一段路径 A→X 和 X→B 也都分别是结点 A 到 X 和结点 X 到 B 的最短路径。</p>
<p>RIP 协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。</p>
<p>虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p>
<p>已知路由器 R6 有表<code>a</code>所示的路由表。现在收到相邻路由器 R4 发来的路由更新信息。试更新路由器 R6 的路由表。</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img4.png" class="">
<br>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img5.png" class="">

<h2 id="RIP-协议的报文格式"><a href="#RIP-协议的报文格式" class="headerlink" title="RIP 协议的报文格式"></a>RIP 协议的报文格式</h2><p>RIP 报文封装在 UDP 数据报中发送，占用端口号 520。RIP 报文由首部和路由部分组成。</p>
<p>RIP 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是<code>4+20x25=504</code>字节。如超过，必须再用一个 RIP 报文来传送。</p>
<h2 id="RIP-环路问题"><a href="#RIP-环路问题" class="headerlink" title="RIP 环路问题"></a>RIP 环路问题</h2><p>RIP 协议特点：好消息传播得快，坏消息传播得慢。</p>
<p>RIP 存在的一个问题：当网络出现故障时，要经过比较长的时间 (例如数分钟) 才能将此信息传送到所有的路由器。</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img7.png" class="">
<br>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img8.png" class="">
<br>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img9.png" class="">
<br>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img10.png" class="">
<br>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img11.png" class="">
<br>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img12.png" class="">
### RIP 协议的优缺点
优点：开销较小，易于配置、管理和实现。
缺点：
* RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。这使得 RIP 协议不适于大型网络。
* 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 
* “坏消息传播得慢”，使更新过程的收敛时间过长。

<h1 id="内部网关协议-OSPF"><a href="#内部网关协议-OSPF" class="headerlink" title="内部网关协议 OSPF"></a>内部网关协议 OSPF</h1><p>开放最短路径优先 OSPF(<code>Open Shortest Path First</code>)是为克服 RIP 的缺点开发出来的。“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“最短路径优先”是因为使用了最短路径算法 SPF。</p>
<p>采用分布式的链路状态协议(<code>link state protocol</code>)。 </p>
<p>注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p>
<h2 id="三个要点"><a href="#三个要点" class="headerlink" title="三个要点"></a>三个要点</h2><ol>
<li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。</li>
<li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓”链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”。 </li>
<li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li>
</ol>
<h2 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h2><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</p>
<p>这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。因此，每一个路由器都知道全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表。</p>
<p>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。</p>
<p>OSPF 的更新过程收敛得快是其重要优点。</p>
<h2 id="OSPF-的区域"><a href="#OSPF-的区域" class="headerlink" title="OSPF 的区域"></a>OSPF 的区域</h2><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域。</p>
<p>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。</p>
<p>区域也不能太大，在一个区域内的路由器最好不超过 200 个。 </p>
<h2 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h2><p>OSPF 划分为两种不同的区域</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img13.png" class="">

<p>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。</p>
<p>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</p>
<p>为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用层次结构的区域划分。</p>
<p>在上层的区域叫做主干区域。主干区域的标识符规定为<code>0.0.0.0</code>。主干区域的作用是用来连通其他在下层的区域。</p>
<p>其他区域来的信息都由区域边界路由器进行概括。路由器 R3、R4、R7 都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做主干路由器，如 R3，R4，R5，R6和R7。一个主干路由器可以同时是区域边界路由器，如 R3，R4 和 R7。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做自治系统边界路由器（R6）。</p>
<p>OSPF 不用 UDP 而是直接用 IP 数据报传送（其 IP 数据报首部的协议字段值为 89）。</p>
<p>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p>
<p>OSPF 分组使用 24 字节的固定长度首部，分组的数据部分可以是五种类型分组中的一种。下面简单介绍 OSPF首部各字段的意义。</p>
<ol>
<li>版本：当前的版本号是 2。</li>
<li>类型：可以是五种类型分组中的一种。</li>
<li>分组长度：包括 OSPF 首部在内的分组长度，以字节为单位。</li>
<li>路由器标识符：标志发送该分组的路由器的接口的IP地址。</li>
<li>区域标识符：分组属于的区域的标识符</li>
<li>检验和：用来检测分组中的差错。</li>
<li>鉴别类型：目前只有两种，0（不用）和 1（口令）。</li>
<li>鉴别：鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令。</li>
</ol>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img14.png" class="">

<p>除了以上的几个基本特点外，OSPF 还具有下列的一些特点∶</p>
<ul>
<li>OSPF 对不同的链路可根据 IP 分组的不同服务类型而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。</li>
<li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的负载平衡。</li>
<li>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。因而保证了仅在可信赖的路由器之间交换链路状态信息。</li>
<li>支持可变长度的子网划分和无分类编址 CIDR。</li>
<li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。</li>
</ul>
<h2 id="OSPF-的五种分组类型"><a href="#OSPF-的五种分组类型" class="headerlink" title="OSPF 的五种分组类型"></a>OSPF 的五种分组类型</h2><ul>
<li>类型1，问候 (<code>Hello</code>) 分组，用来发现和维持邻站的可达性。</li>
<li>类型2，数据库描述(<code>Database Description</code>)分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li>
<li>类型3，链路状态请求(<code>Link State Request</code>)分组，向对方请求发送某些链路状态项目的详细信息。</li>
<li>类型4，链路状态更新(<code>Link State Update</code>)分组，用洪泛法对全网更新链路状态。路由器使用这种分组将其链路状态通知给邻站。</li>
<li>类型5，链路状态确认(<code>Link State Acknowledgment</code>)分组，对链路更新分组的确认。</li>
</ul>
<p>OSPF 规定，每两个相邻路由器每隔 10 秒钟要交换一次问候分组。这样就能确知哪些邻站是可达的。对相邻路由器来说，”可达”是最基本的要求，因为只有可达邻站的链路状态信息才存入链路状态数据库（路由表就是根据链路状态数据库计算出来的）。在正常情况下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重新计算路由表。</p>
<p>其他的四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的链路状态数据库的内容是一样的。两个同步的路由器叫做”完全邻接的”路由器。不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有达到一致。</p>
<h3 id="OSPF-的基本操作"><a href="#OSPF-的基本操作" class="headerlink" title="OSPF 的基本操作"></a>OSPF 的基本操作</h3><p>当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工作，以及将数据发往相邻路由器所需的”代价”。如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态数据库。但这样做开销太大，因此 OSPF 采用下面的办法。</p>
<p>OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息、（以及其序号）已经写入了数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img15.png" class="">

<p>在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，用洪泛法向全网更新链路状态。</p>
<p>设路由器 R 用洪泛法发出链路状态更新分组。图中用一些小的箭头表示更新分组。第一次先发给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上游路由器除外。可靠的洪泛法是在收到更新分组后要发送确认（收到重复的更新分组只需要发送一次确认）。图中的空心箭头表示确认分组。</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img16.png" class="">

<p>为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。</p>
<p>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF  协议要比距离向量协议 RIP 好得多。</p>
<p>OSPF 没有“坏消息传播得慢”的问题，其响应网络变化的时间小于 100 ms。 </p>
<p>若<code>N</code>个路由器连接在一个以太网上，则每个路由器要向其他<code>(N -1)</code>个路由器发送链路状态信息，因而共有<code>N(N-1)</code>个链路状态要在这个以太网上传送。OSPF 协议对这种多点接入的局域网采用了指定的路由器的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</p>
<h1 id="外部网关协议-BGP"><a href="#外部网关协议-BGP" class="headerlink" title="外部网关协议 BGP"></a>外部网关协议 BGP</h1><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 </p>
<p>BGP 较新版本是BGP-4。可以将 BGP-4 简写为 BGP。 </p>
<p>互联网的规模太大，使得自治系统之间路由选择非常困难。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。</p>
<p>当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。比较合理的做法是在 AS 之间交换“可达性”信息。</p>
<p>自治系统之间的路由选择必须考虑有关策略。由于相互连接的网络的性能相差很大，根据最短距离（即最少跳数）找出来的路径，可能并不合适。也有的路径的使用代价很高或很不安全。有一种情况，如自治系统 AS1 要发送数据报给自治系统 AS2，本来最好是经过自治系统 AS3。但 AS3 不愿意让这些数据报通过本自治系统的网络，因为”这是他们的事情，和我们没有关系。”但另一方面，自治系统 AS3 愿意让某些相邻自治系统的数据报通过自己的网络，特别是对那些付了服务费的某些自治系统更是如此。因此，自治系统之间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、安全或经济方面的考虑。这些策略都是由网络管理人员对每一个路由器进行设置的，但这些策略并不是自治系统之间的路由选择协议本身。</p>
<p>因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。</p>
<p>BGP 采用了路径向量路由选择协议。</p>
<p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人”。</p>
<p>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。 </p>
<p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接（端口号为 179），然后在此连接上交换 BGP 报文以建立 BGP 会话，利用 BGP 会话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。</p>
<p>使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。</p>
<p>BGP 发言人和自治系统 AS 的关系：</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img17.png" class="">

<p>每一个 BGP 发言人除了必须运行 BGP 协议外，还必须运行该自治系统所使用的内部网关协议，如 OSPF 或 RIP。</p>
<p>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。</p>
<p>当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各 AS 的较好路由。</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img18.png" class="">
<br>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img19.png" class="">

<p>自治系统 AS2 的 BGP 发言人通知主干网 AS1 的 BGP 发言人：“要到达网络 N1、N2、N3 和 N4 可经过 AS2。” 主干网在收到这个通知后，就发出通知∶”要到达网络N1、N2，N3 和 N4 可沿路径（AS1，AS2）。”</p>
<p>主干网还可发出通知：“要到达网络 N5、N6 和 N7 可沿路径（AS1, AS3）。” </p>
<h2 id="BGP-协议的特点"><a href="#BGP-协议的特点" class="headerlink" title="BGP 协议的特点"></a>BGP 协议的特点</h2><p>BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。</p>
<p>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。</p>
<p>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。由于使用了路径向量的信息，就可以很容易地避免产生兜圈子的路由。如果一个BGP 发言人收到了其他 BGP 发言人发来的路径通知，它就要检查一下本自治系统是否在此通知的路径中。如果在这条路径中，就不能采用这条路径（因为会兜圈子）。</p>
<p>在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p>
<p>BGP-4 共使用四种报文：</p>
<ul>
<li>打开 (<code>OPEN</code>) 报文，用来与相邻的另一个 BGP 发言人建立关系。</li>
<li>更新 (<code>UPDATE</code>) 报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li>
<li>保活 (<code>KEEPALIVE</code>) 报文，用来确认打开报文和周期性地证实邻站关系。</li>
<li>通知 (<code>NOTIFICATION</code>) 报文，用来发送检测到的差错。</li>
</ul>
<p>若两个邻站属于两个不同 AS，而其中一个邻站打算和另一个邻站定期地交换路由信息，这就应当有一个商谈的过程（因为很可能对方路由器的负荷已很重因而不愿意再加重负担）。因此，一开始向邻站进行商谈时就必须发送<code>OPEN</code>报文。如果邻站接受这种邻站关系，就用<code>KEEPALIVE</code>报文响应。这样，两个 BGP 发言人的邻站关系就建立了。</p>
<p>一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存在的，且一直在保持这种邻站关系。为此，这两个 BGP 发言人彼此要周期性地交换<code>KEEPALIVE</code>报文（一般每隔30秒）。<code>KEEPALIVE</code>报文只有 19 字节长（只用 BGP 报文的通用首部），因此不会造成网络上太大的开销。</p>
<p><code>UPDATE</code>报文是 BGP 协议的核心内容。BGP 发言人可以用<code>UPDATE</code>报文撤销它以前曾经通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路由时，每个更新报文只能增加一条。BGP 可以很容易地解决距离向量路由选择算法中的”坏消息传播得慢”这一问题。当某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很容易选择出新的路由。距离向量算法往往不能给出正确的选择，是因为这些算法不能指出哪些邻站到目的站的路由是独立的。</p>
<p>BGP 报文具有通用首部，其长度为 19 字节。通用首部分为三个字段。标记字段为 16 字节长，用来鉴别收到的 BGP 报文（这是假定将来有人会发明出合理的鉴别方案）。当不使用鉴别时，标记字段要置为全 1。长度字段指出包括通用首部在内的整个 BGP 报文以字节为单位的长度，最小值是 19，最大值是 4096。类型字段的值为 1 到 4，分别对应于四种 BGP 报文中的一种。</p>
<img src="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/img20.png" class="">

<p><code>OPEN</code>报文共有 6 个字段，即</p>
<ul>
<li>版本（1 字节，现在的值是 4）</li>
<li>本自治系统号（2 字节，使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配）</li>
<li>保持时间（2 字节，以秒计算的保持为邻站关系的时间）</li>
<li>BGP 标识符（4 字节，通常就是该路由器的 IP 地址）</li>
<li>可选参数长度（1 字节）</li>
<li>可选参数。</li>
</ul>
<p><code>UPDATE</code>报文共有 5 个字段，即</p>
<ul>
<li>不可行路由长度（2 字节，指明下一个字段的长度）</li>
<li>撤销的路由（列出所有要撤销的路由）</li>
<li>路径属性总长度（2 字节，指明下一个字段的长度）</li>
<li>路径属性（定义在这个报文中增加的路径的属性）</li>
<li>网络层可达性信息 NLRI （<code>Network Layer Reachability Information</code>）。</li>
</ul>
<p>最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀。</p>
<p><code>KEEPALIVE</code>报文只有 BGP 的 19 字节长的通用首部。</p>
<p><code>NOTIFICATION</code>报文有3个字段，即差错代码（1 字节）、差错子代码（1 字节）和差错数据（给出有关差错的诊断信息）。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java异常处理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/25/java/%E5%9F%BA%E7%A1%80/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"
    >Java 异常处理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/25/java/%E5%9F%BA%E7%A1%80/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2020-09-25T11:08:23.000Z" itemprop="datePublished">2020-09-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Java 中的异常是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类，这可以让程序具有极好的容错性且更加健壮。 </p>
<p>一个异常的产生，主要有如下三种原因：</p>
<ul>
<li>Java 内部错误发生异常，Java 虚拟机产生的异常。</li>
<li>编写的程序代码中的错误所产生的异常，例如空指针异常、数组越界异常等。</li>
<li>通过<code>throw</code>语句手动生成的异常，一般用来告知该方法的调用者一些必要信息。</li>
</ul>
<p>Java 通过面向对象的方法来处理异常。在一个方法的运行过程中，如果发生了异常，则这个方法会产生代表该异常的一个对象，并把它交给运行时的系统，运行时系统寻找相应的代码来处理这一异常。</p>
<h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><p>为了能够及时有效地处理程序中的运行错误，Java 专门引入了异常类。在 Java 中所有异常类型都是内置类<code>java.lang.Throwable</code>类的子类，即<code>Throwable</code>位于异常类层次结构的顶层。<code>Throwable</code>类下有两个异常分支<code>Exception</code>和<code>Error</code>。</p>
<p><code>Throwable</code>类是所有异常和错误的超类，下面有<code>Error</code>和<code>Exception</code>两个子类分别表示错误和异常。其中异常类<code>Exception</code>又分为运行时异常和非运行时异常，这两种异常有很大的区别，也称为不检查异常（<code>Unchecked Exception</code>）和检查异常（<code>Checked Exception</code>）。</p>
<ul>
<li><code>Exception</code>类用于用户程序可能出现的异常情况，它也是用来创建自定义异常类型类的类。</li>
<li><code>Error</code>定义了在通常环境下不希望被程序捕获的异常。一般指的是 JVM 错误，如堆栈溢出。</li>
</ul>
<p>运行时异常都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException、IndexOutOfBoundsException</code>等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般由程序逻辑错误引起，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>非运行时异常是指<code>RuntimeException</code>以外的异常，类型上都属于<code>Exception</code>类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如<code>IOException、ClassNotFoundException</code>等以及用户自定义的<code>Exception</code>异常（一般情况下不自定义检查异常）。</p>
<p>常见运行时异常：</p>
<table>
<thead>
<tr>
<th align="center">异常类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ArithmeticException</td>
<td align="center">算术错误异常，如以零做除数</td>
</tr>
<tr>
<td align="center">ArraylndexOutOfBoundException</td>
<td align="center">数组索引越界</td>
</tr>
<tr>
<td align="center">ArrayStoreException</td>
<td align="center">向类型不兼容的数组元素赋值</td>
</tr>
<tr>
<td align="center">ClassCastException</td>
<td align="center">类型转换异常</td>
</tr>
<tr>
<td align="center">IllegalArgumentException</td>
<td align="center">使用非法实参调用方法</td>
</tr>
<tr>
<td align="center">lIIegalStateException</td>
<td align="center">环境或应用程序处于不正确的状态</td>
</tr>
<tr>
<td align="center">lIIegalThreadStateException</td>
<td align="center">被请求的操作与当前线程状态不兼容</td>
</tr>
<tr>
<td align="center">IndexOutOfBoundsException</td>
<td align="center">某种类型的索引越界</td>
</tr>
<tr>
<td align="center">NullPointerException</td>
<td align="center">尝试访问 null 对象成员，空指针异常</td>
</tr>
<tr>
<td align="center">NegativeArraySizeException</td>
<td align="center">再负数范围内创建的数组</td>
</tr>
<tr>
<td align="center">NumberFormatException</td>
<td align="center">数字转化格式异常，比如字符串到 float 型数字的转换无效</td>
</tr>
<tr>
<td align="center">TypeNotPresentException</td>
<td align="center">类型未找到</td>
</tr>
</tbody></table>
<p>常见非运行时异常：</p>
<table>
<thead>
<tr>
<th align="center">异常类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ClassNotFoundException</td>
<td align="center">没有找到类</td>
</tr>
<tr>
<td align="center">IllegalAccessException</td>
<td align="center">访问类被拒绝</td>
</tr>
<tr>
<td align="center">InstantiationException</td>
<td align="center">试图创建抽象类或接口的对象</td>
</tr>
<tr>
<td align="center">InterruptedException</td>
<td align="center">线程被另一个线程中断</td>
</tr>
<tr>
<td align="center">NoSuchFieldException</td>
<td align="center">请求的域不存在</td>
</tr>
<tr>
<td align="center">NoSuchMethodException</td>
<td align="center">请求的方法不存在</td>
</tr>
<tr>
<td align="center">ReflectiveOperationException</td>
<td align="center">与反射有关的异常的超类</td>
</tr>
</tbody></table>
<h1 id="Error和Exception的异同"><a href="#Error和Exception的异同" class="headerlink" title="Error和Exception的异同"></a>Error和Exception的异同</h1><p><code>Error</code>（错误）和<code>Exception</code>（异常）都是<code>java.lang.Throwable</code>类的子类，在 Java 代码中只有继承了<code>Throwable</code>类的实例才能被<code>throw</code>或者<code>catch</code>。</p>
<p><code>Exception</code>和<code>Error</code>体现了 Java 平台设计者对不同异常情况的分类，<code>Exception</code>是程序正常运行过程中可以预料到的意外情况，并且应该被开发者捕获，进行相应的处理。<code>Error</code>是指正常情况下不大可能出现的情况，绝大部分的<code>Error</code>都会导致程序处于非正常、不可恢复状态。所以不需要被捕获。</p>
<p><code>Error</code>错误是任何处理技术都无法恢复的情况，肯定会导致程序非正常终止。并且<code>Error</code>错误属于未检查类型，大多数发生在运行时。<code>Exception</code>又分为可检查（<code>checked</code>）异常和不检查（<code>unchecked</code>）异常，可检查异常在源码里必须显示的进行捕获处理，这里是编译期检查的一部分。不检查异常就是所谓的运行时异常，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译器强制要求。</p>
<p>如下是常见的<code>Error</code>和<code>Exception</code>：</p>
<ol>
<li>运行时异常（<code>RuntimeException</code>）：</li>
</ol>
<ul>
<li><code>NullPropagation</code>：空指针异常；</li>
<li><code>ClassCastException</code>：类型强制转换异常</li>
<li><code>IllegalArgumentException</code>：传递非法参数异常</li>
<li><code>IndexOutOfBoundsException</code>：下标越界异常</li>
<li><code>NumberFormatException</code>：数字格式异常</li>
</ul>
<ol start="2">
<li>非运行时异常：</li>
</ol>
<ul>
<li><code>ClassNotFoundException</code>：找不到指定<code>class</code>的异常</li>
<li><code>IOException</code>：IO 操作异常</li>
</ul>
<ol start="3">
<li>错误（<code>Error</code>）：</li>
</ol>
<ul>
<li><code>NoClassDefFoundError</code>：找不到<code>class</code>定义异常</li>
<li><code>StackOverflowError</code>：深递归导致栈被耗尽而抛出的异常</li>
<li><code>OutOfMemoryError</code>：内存溢出异常</li>
</ul>
<p>下面代码会导致 Java 堆栈溢出错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过无限递归演示堆栈溢出错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackOverflow</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      test(i++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorEg</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行StackOverflow方法</span></span><br><span class="line">    StackOverflow.test(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">    at ch11.StackOverflow.test(ErrorEg.java:9)</span><br><span class="line">    at ch11.StackOverflow.test(ErrorEg.java:9)</span><br><span class="line">    at ch11.StackOverflow.test(ErrorEg.java:9)</span><br><span class="line">    at ch11.StackOverflow.test(ErrorEg.java:9)</span><br></pre></td></tr></table></figure>
<h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><p>Java 的异常处理通过 5 个关键字来实现：<code>try、catch、throw、throws</code>和<code>finally</code>。<code>try catch</code>语句用于捕获并处理异常，<code>finally</code>语句用于在任何情况下（除特殊情况外）都必须执行的代码，<code>throw</code>语句用于拋出异常，<code>throws</code>语句用于声明可能会出现的异常。</p>
<p>Java 的异常处理机制提供了一种结构性和控制性的方式来处理程序执行期间发生的事件。异常处理的机制如下：</p>
<ul>
<li>在方法中用<code>try catch</code>语句捕获并处理异常，<code>catch</code>语句可以有多个，用来匹配多个异常。</li>
<li>对于处理不了的异常或者要转型的异常，在方法的声明处通过<code>throws</code>语句拋出异常，即由上层的调用方法来处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//逻辑程序块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e) &#123;</span><br><span class="line">  <span class="comment">//处理代码块1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e) &#123;</span><br><span class="line">  <span class="comment">//处理代码块2</span></span><br><span class="line">  <span class="keyword">throw</span>(e);    <span class="comment">// 再抛出这个&quot;异常&quot;</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//释放资源代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try catch语句"></a>try catch语句</h1><p>在 Java 中通常采用<code>try catch</code>语句来捕获异常并处理。把可能引发异常的语句封装在<code>try</code>语句块中，用以捕获可能发生的异常。<code>catch</code>后的<code>()</code>里放匹配的异常类，指明<code>catch</code>语句可以处理的异常类型，发生异常时产生异常类的实例化对象。</p>
<p>如果<code>try</code>语句块中发生异常，那么一个相应的异常对象就会被拋出，然后<code>catch</code>语句就会依据所拋出异常对象的类型进行捕获，并处理。处理之后，程序会跳过<code>try</code>语句块中剩余的语句，转到<code>catch</code>语句块后面的第一条语句开始执行。</p>
<p>如果<code>try</code>语句块中没有异常发生，那么<code>try</code>块正常结束，后面的<code>catch</code>语句块被跳过，程序将从<code>catch</code>语句块后的第一条语句开始执行。</p>
<p>在上面语法的处理代码块 1 中，可以使用以下 3 个方法输出相应的异常信息。</p>
<ul>
<li><code>printStackTrace()</code>方法：指出异常的类型、性质、栈层次及出现在程序中的位置。</li>
<li><code>getMessage()</code>方法：输出错误的性质。</li>
<li><code>toString()</code>方法：给出异常的类型与性质。</li>
</ul>
<p>编写一个录入学生姓名、年龄和性别的程序，要求能捕捉年龄不为数字时的异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;---------学生信息录入---------------&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 获取学生姓名</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 获取学生年龄</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 获取学生性别</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;请输入学生姓名：&quot;</span>);</span><br><span class="line">      name = scanner.next();</span><br><span class="line">      System.out.println(<span class="string">&quot;请输入学生年龄：&quot;</span>);</span><br><span class="line">      age = scanner.nextInt();</span><br><span class="line">      System.out.println(<span class="string">&quot;请输入学生性别：&quot;</span>);</span><br><span class="line">      sex = scanner.next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.out.println(<span class="string">&quot;输入有误！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄：&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在<code>main()</code>方法中使用<code>try catch</code>语句来捕获异常，将可能发生异常的<code>age = scanner.nextlnt();</code>代码放在了<code>try</code>块中，在<code>catch</code>语句中指定捕获的异常类型为<code>Exception</code>，并调用异常对象的<code>printStackTrace()</code>方法输出异常信息。</p>
<h2 id="多重catch语句"><a href="#多重catch语句" class="headerlink" title="多重catch语句"></a>多重catch语句</h2><p>如果<code>try</code>代码块中有很多语句会发生异常，而且发生的异常种类又很多。那么可以在<code>try</code>后面跟有多个<code>catch</code>代码块。</p>
<p>在多个<code>catch</code>代码块的情况下，当一个<code>catch</code>代码块捕获到一个异常时，其它的<code>catch</code>代码块就不再进行匹配。</p>
<p>注意：当捕获的多个异常类之间存在父子关系时，捕获异常时一般先捕获子类，再捕获父类。所以子类异常必须在父类异常的前面，否则子类捕获不到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> readDate();</span><br><span class="line">    System.out.println(<span class="string">&quot;读取的日期 = &quot;</span> + date);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">readDate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">readfile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">ir</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      readfile = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;readme.txt&quot;</span>);</span><br><span class="line">      ir = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(readfile);</span><br><span class="line">      in = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(ir);</span><br><span class="line">      <span class="comment">// 读取文件中的一行数据</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">      <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">      <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> df.parse(str);</span><br><span class="line">      <span class="keyword">return</span> date;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;处理FileNotFoundException...&quot;</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;处理IOException...&quot;</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;处理ParseException...&quot;</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过 Java I&#x2F;O（输入输出）流技术从文件<code>readme.txt</code>中读取字符串，然后解析成为日期。</p>
<p>在<code>try</code>代码块中调用<code>FileInputStream</code>构造方法可能会发生<code>FileNotFoundException</code>异常。调用<code>BufferedReader</code>输入流的<code>readLine()</code>方法可能会发生<code>IOException</code>异常。<code>FileNotFoundException</code>异常是<code>IOException</code>异常的子类，应该先捕获<code>FileNotFoundException</code>异常；后捕获 <code>IOException</code>异常。</p>
<p>如果将<code>FileNotFoundException</code>和<code>IOException</code>捕获顺序调换，那么捕获<code>FileNotFoundException</code>异常代码块将永远不会进入，<code>FileNotFoundException</code>异常处理永远不会执行。上述代码第 29 行<code>ParseException</code>异常与<code>IOException</code>和<code>FileNotFoundException</code>异常没有父子关系，所以捕获<code>ParseException</code>异常位置可以随意放置。</p>
<h1 id="try-catch-finally语句"><a href="#try-catch-finally语句" class="headerlink" title="try catch finally语句"></a>try catch finally语句</h1><p>在实际开发中，根据<code>try catch</code>语句的执行过程，<code>try</code>语句块和<code>catch</code>语句块有可能不被完全执行，而有些处理代码则要求必须执行。例如，程序在<code>try</code>块里打开了一些物理资源（如数据库连接、网络连接和磁盘文件等），这些物理资源都必须显式回收。</p>
<p>Java的垃圾回收机制不会回收任何物理资源，垃圾回收机制只回收堆内存中对象所占用的内存。</p>
<p>所以为了确保一定能回收<code>try</code>块中打开的物理资源，异常处理机制提供了<code>finally</code>代码块，并且 Java 7 之后提供了自动资源管理技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(ExceptionType e) &#123;</span><br><span class="line">  <span class="comment">// 处理异常语句</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 清理代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于以上格式，无论是否发生异常（除特殊情况外），<code>finally</code>语句块中的代码都会被执行。此外，<code>finally</code>语句也可以和<code>try</code>语句匹配使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 逻辑代码块</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 清理代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>try-catch-finally</code>语句时需注意以下几点：</p>
<ul>
<li>异常处理语法结构中只有<code>try</code>块是必需的，也就是说，如果没有<code>try</code>块，则不能有后面的<code>catch</code>块和<code>finally</code>块；</li>
<li><code>catch</code>块和<code>finally</code>块都是可选的，但<code>catch</code>块和<code>finally</code>块至少出现其中之一，也可以同时出现；</li>
<li>可以有多个<code>catch</code>块，捕获父类异常的<code>catch</code>块必须位于捕获子类异常的后面；</li>
<li>不能只有<code>try</code>块，既没有<code>catch</code>块，也没有<code>finally</code>块；</li>
<li>多个<code>catch</code>块必须位于<code>try</code>块之后，<code>finally</code>块必须位于所有的<code>catch</code>块之后。</li>
</ul>
<p><code>try catch finally</code>语句块的执行情况可以细分为以下 3 种情况：</p>
<ul>
<li>如果<code>try</code>代码块中没有拋出异常，则执行完<code>try</code>代码块之后直接执行<code>finally</code>代码块，然后执行<code>try catch finally</code>语句块之后的语句。</li>
<li>如果<code>try</code>代码块中拋出异常，并被<code>catch</code>子句捕捉，那么在拋出异常的地方终止<code>try</code>代码块的执行，转而执行相匹配的<code>catch</code>代码块，之后执行<code>finally</code>代码块。如果<code>finally</code>代码块中没有拋出异常，则继续执行<code>try catch finally</code>语句块之后的语句；如果<code>finally</code>代码块中拋出异常，则把该异常传递给该方法的调用者。</li>
<li>如果<code>try</code>代码块中拋出的异常没有被任何<code>catch</code>子句捕捉到，那么将直接执行<code>finally</code>代码块中的语句，并把该异常传递给该方法的调用者。</li>
</ul>
<p>除非在<code>try</code>块、<code>catch</code>块中调用了退出虚拟机的方法<code>System.exit(int status)</code>，否则不管在<code>try</code>块或者<code>catch</code>块中执行怎样的代码，出现怎样的情况，异常处理的<code>finally</code>块总会执行。</p>
<p>通常情况下不在<code>finally</code>代码块中使用<code>return</code>或<code>throw</code>等导致方法终止的语句，否则将会导致<code>try</code>和<code>catch</code>代码块中的<code>return</code>和<code>throw</code>语句失效。</p>
<h1 id="自动资源管理"><a href="#自动资源管理" class="headerlink" title="自动资源管理"></a>自动资源管理</h1><p>当程序使用<code>finally</code>块关闭资源时，程序会显得异常臃肿，例如以下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭磁盘文件，回收资源</span></span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 7 以前，上面程序中的<code>finally</code>代码块是不得不写的“臃肿代码”，为了解决这种问题，Java 7 增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文件，被称为自动资源管理。该特性是在<code>try</code>语句上的扩展，主要释放不再需要的文件或其他资源。</p>
<p>自动资源管理替代了<code>finally</code>代码块，并优化了代码结构和提高程序可读性。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (声明或初始化资源语句) &#123;</span><br><span class="line">    <span class="comment">// 可能会生成异常语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e1)&#123;</span><br><span class="line">    <span class="comment">// 处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable e2)&#123;</span><br><span class="line">    <span class="comment">// 处理异常e1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Throwable eN)&#123;</span><br><span class="line">    <span class="comment">// 处理异常eN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>try</code>代码块结束时，自动释放资源。不再需要显式的调用<code>close()</code>方法，该形式也称为“带资源的<code>try</code>语句”。</p>
<p>注意：</p>
<ul>
<li><code>try</code>语句中声明的资源被隐式声明为<code>final</code>，资源的作用局限于带资源的<code>try</code>语句。</li>
<li>可以在一条<code>try</code>语句中声明或初始化多个资源，每个资源以;隔开即可。</li>
<li>需要关闭的资源必须实现了<code>AutoCloseable</code>或<code>Closeable</code>接口。</li>
<li><code>Closeable</code>是<code>AutoCloseable</code>的子接口，<code>Closeable</code>接口里的<code>close()</code>方法声明抛出了<code>IOException</code>，因此它的实现类在实现<code>close()</code>方法时只能声明抛出<code>IOException</code>或其子类；<code>AutoCloseable</code>接口里的<code>close()</code>方法声明抛出了<code>Exception</code>，因此它的实现类在实现<code>close()</code>方法时可以声明抛出任何异常。</li>
</ul>
<p>下面示范如何使用自动关闭资源的<code>try</code>语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoCloseTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">      <span class="comment">// 声明、初始化两个可关闭的资源</span></span><br><span class="line">      <span class="comment">// try语句会自动关闭这两个资源</span></span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;AutoCloseTest.java&quot;</span>));</span><br><span class="line">      <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>))) &#123;</span><br><span class="line">      <span class="comment">// 使用两个资源</span></span><br><span class="line">      System.out.println(br.readLine());</span><br><span class="line">      ps.println(<span class="string">&quot;C语言中文网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中粗体字代码分别声明、初始化了两个 IO 流，<code>BufferedReader</code>和<code>PrintStream</code>都实现了<code>Closeable</code>接口，并在<code>try</code>语句中进行了声明和初始化，所以<code>try</code>语句会自动关闭它们。</p>
<p>自动关闭资源的<code>try</code>语句相当于包含了隐式的<code>finally</code>块（这个<code>finally</code>块用于关闭资源），因此这个<code>try</code>语句可以既没有<code>catch</code>块，也没有<code>finally</code>块。<br>Java 7 几乎把所有的“资源类”（包括文件 IO 的各种类、JDBC 编程的<code>Connection</code>和<code>Statement</code>等接口）进行了改写，改写后的资源类都实现了<code>AutoCloseable</code>或<code>Closeable</code>接口。</p>
<p>如果程序需要，自动关闭资源的<code>try</code>语句后也可以带多个<code>catch</code>块和一个<code>finally</code>块。</p>
<p>Java 9 再次增强了这种<code>try</code>语句。Java 9 不要求在<code>try</code>后的圆括号内声明并创建资源，只需要自动关闭的资源有<code>final</code>修饰或者是有效的<code>final (effectively final)</code>，Java 9 允许将资源变量放在<code>try</code>后的圆括号内。上面程序在 Java 9 中可改写为如下形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoCloseTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 有final修饰的资源</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;AutoCloseTest.java&quot;</span>));</span><br><span class="line">    <span class="comment">// 没有显式使用final修饰，但只要不对该变量重新赋值，该变量就是有效的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a. txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 只要将两个资源放在try后的圆括号内即可</span></span><br><span class="line">    <span class="keyword">try</span> (br; ps) &#123;</span><br><span class="line">      <span class="comment">// 使用两个资源</span></span><br><span class="line">      System.out.println(br.readLine());</span><br><span class="line">      ps.println(<span class="string">&quot;C语言中文网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="声明和抛出异常"><a href="#声明和抛出异常" class="headerlink" title="声明和抛出异常"></a>声明和抛出异常</h1><p>Java 中的异常处理除了捕获异常和处理异常之外，还包括声明异常和拋出异常。实现声明和抛出异常的关键字非常相似，它们是<code>throws</code>和<code>throw</code>。可以通过<code>throws</code>关键字在方法上声明该方法要拋出的异常，然后在方法内部通过<code>throw</code>拋出异常对象。</p>
<h2 id="throws-声明异常"><a href="#throws-声明异常" class="headerlink" title="throws 声明异常"></a>throws 声明异常</h2><p>当一个方法产生一个它不处理的异常时，那么就需要在该方法的头部声明这个异常，以便将该异常传递到方法的外部进行处理。使用<code>throws</code>声明的方法表示此方法不处理异常。<code>throws</code>具体格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType method_name(paramList) throws Exception 1,Exception2,…&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>returnType</code>表示返回值类型；<code>method_name</code>表示方法名；<code>paramList</code>表示参数列表；<code>Exception 1，Exception2，… </code>表示异常类。</p>
<p>如果有多个异常类，它们之间用逗号分隔。这些异常类可以是方法中调用了可能拋出异常的方法而产生的异常，也可以是方法体中生成并拋出的异常。</p>
<p>使用<code>throws</code>声明抛出异常的思路是，当前方法不知道如何处理这种类型的异常，该异常应该由向上一级的调用者处理；如果<code>main</code>方法也不知道如何处理这种类型的异常，也可以使用<code>throws</code>声明抛出异常，该异常将交给 JVM 处理。JVM 对异常的处理方法是，打印异常的跟踪栈信息，并中止程序运行，这就是前面程序在遇到异常后自动结束的原因。</p>
<p>创建一个<code>readFile()</code>方法，该方法用于读取文件内容，在读取的过程中可能会产生<code>IOException</code>异常，但是在该方法中不做任何的处理，而将可能发生的异常交给调用者处理。在<code>main()</code>方法中使用<code>try catch</code>捕获异常，并输出异常信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 定义方法时声明异常</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 创建 FileInputStream 实例对象</span></span><br><span class="line">    <span class="type">int</span> f;</span><br><span class="line">    <span class="keyword">while</span> ((f = file.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println((<span class="type">char</span>) f);</span><br><span class="line">      f = file.read();</span><br><span class="line">    &#125;</span><br><span class="line">    file.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Throws</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test04</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t.readFile(); <span class="comment">// 调用 readFHe()方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// 捕获异常</span></span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>throws</code>声明抛出异常时有一个限制，是方法重写中的一条规则：子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或相同，子类方法声明抛出的异常不允许比父类方法声明抛出的异常多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverrideThrows</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">OverrideThrows</span> &#123;</span><br><span class="line">  <span class="comment">// 子类方法声明抛出了比父类方法更大的异常</span></span><br><span class="line">  <span class="comment">// 所以下面方法出错</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中<code>Sub</code>子类中的<code>test()</code>方法声明抛出<code>Exception</code>，该<code>Exception</code>是其父类声明抛出异常<code>IOException</code>类的父类，这将导致程序无法通过编译。</p>
<p>所以在编写类继承代码时要注意，子类在重写父类带<code>throws</code>子句的方法时，子类方法声明中的<code>throws</code>子句不能出现父类对应方法的<code>throws</code>子句中没有的异常类型，因此<code>throws</code>子句可以限制子类的行为。也就是说，子类方法拋出的异常不能超过父类定义的范围。</p>
<h2 id="throw-拋出异常"><a href="#throw-拋出异常" class="headerlink" title="throw 拋出异常"></a>throw 拋出异常</h2><p><code>throw</code>语句用来直接拋出一个异常，后接一个可拋出的异常类对象，其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw ExceptionObject;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ExceptionObject</code>必须是<code>Throwable</code>类或其子类的对象。如果是自定义异常类，也必须是<code>Throwable</code>的直接或间接子类。例如，以下语句在编译时将会产生语法错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new String(&quot;拋出异常&quot;);    // String类不是Throwable类的子类</span><br></pre></td></tr></table></figure>
<p>当<code>throw</code>语句执行时，它后面的语句将不执行，此时程序转向调用者程序，寻找与之相匹配的<code>catch</code>语句，执行相应的异常处理程序。如果没有找到相匹配的<code>catch</code>语句，则再转向上一层的调用程序。这样逐层向上，直到最外层的异常处理程序终止程序并打印出调用栈情况。</p>
<p><code>throw</code>关键字不会单独使用，它的使用完全符合异常的处理机制，但是，一般来讲用户都在避免异常的产生，所以不会手工抛出一个新的异常类的实例，而往往会抛出程序中已经产生的异常类的实例。</p>
<p>在某仓库管理系统中，要求管理员的用户名需要由 8 位以上的字母或者数字组成，不能含有其他的字符。当长度在 8 位以下时拋出异常，并显示异常信息；当字符含有非字母或者数字时，同样拋出异常，显示异常信息。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateUserName</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (username.length() &gt; <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断用户名长度是否大于8位</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; username.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> username.charAt(i); <span class="comment">// 获取每一位字符</span></span><br><span class="line">        <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">          con = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          con = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;用户名只能由字母和数字组成！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;用户名长度必须大于 8 位！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> con;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test05</span> <span class="variable">te</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test05</span>();</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入用户名：&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> input.next();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">con</span> <span class="operator">=</span> te.validateUserName(username);</span><br><span class="line">      <span class="keyword">if</span> (con) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名输入正确！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>throws</code>关键字和<code>throw</code>关键字在使用上的几点区别如下：</p>
<ul>
<li><code>throws</code>用来声明一个方法可能抛出的所有异常信息，表示出现异常的一种可能性，但并不一定会发生这些异常；<code>throw</code>则是指拋出的一个具体的异常类型，执行<code>throw</code>则一定抛出了某种异常对象。<br>通常在一个方法（类）的声明处通过<code>throws</code>声明方法（类）可能拋出的异常信息，而在方法（类）内部通过<code>throw</code>声明一个具体的异常信息。</li>
<li><code>throws</code>通常不用显示地捕获异常，可由系统自动将所有捕获的异常信息抛给上级方法；<code>throw</code>则需要用户自己捕获相关的异常，而后再对其进行相关包装，最后将包装后的异常信息抛出。</li>
</ul>
<h1 id="多异常捕获"><a href="#多异常捕获" class="headerlink" title="多异常捕获"></a>多异常捕获</h1><p>多<code>catch</code>代码块虽然客观上提高了程序的健壮性，但是也导致了程序代码量大大增加。如果有些异常种类不同，但捕获之后的处理是相同的，例如以下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 可能会发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  <span class="comment">// 调用方法methodA处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  <span class="comment">// 调用方法methodA处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">  <span class="comment">// 调用方法methodA处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 个不同类型的异常，要求捕获之后的处理都是调用<code>methodA</code>方法。为了解决这种问题，Java 7 推出了多异常捕获技术，可以把这些异常合并处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 可能会发生异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ParseException e) &#123;</span><br><span class="line">  <span class="comment">// 调用方法methodA处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：由于<code>FileNotFoundException</code>属于<code>IOException</code>异常，<code>IOException</code>异常可以捕获它的所有子类异常。所以不能写成<code>FileNotFoundException | IOException | ParseException</code>。</p>
<p>使用一个<code>catch</code>块捕获多种类型的异常时需要注意如下两个地方。</p>
<ul>
<li>捕获多种类型的异常时，多种异常类型之间用竖线|隔开。</li>
<li>捕获多种类型的异常时，异常变量有隐式的<code>final</code>修饰，因此程序不能对异常变量重新赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">      <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">      System.out.println(<span class="string">&quot;您输入的两个数相除的结果是：&quot;</span> + c);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException | NumberFormatException | ArithmeticException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;程序发生了数组越界、数字格式异常、算术异常之一&quot;</span>);</span><br><span class="line">      <span class="comment">// 捕获多异常时，异常变量默认有final修饰</span></span><br><span class="line">      <span class="comment">// 所以下面代码有错</span></span><br><span class="line">      e = <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;未知异常&quot;</span>);</span><br><span class="line">      <span class="comment">// 捕获一种类型的异常时，异常变量没有final修饰</span></span><br><span class="line">      <span class="comment">// 所以下面代码完全正确</span></span><br><span class="line">      e = <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获多种类型的异常时，异常变量使用隐式的<code>final</code>修饰，因此上面程序的第 12 行代码将产生编译错误；捕获一种类型的异常时，异常变量没有<code>final</code>修饰，因此上面程序的第 17 行代码完全正确。</p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>如果 Java 提供的内置异常类型不能满足程序设计的需求，这时我们可以自己设计 Java 类库或框架，其中包括异常类型。实现自定义异常类需要继承<code>Exception</code>类或其子类，如果自定义运行时异常类需继承<code>RuntimeException</code>类或其子类。</p>
<p>自定义异常的语法形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class&gt; &lt;自定义异常名&gt; &lt;extends&gt; &lt;Exception&gt;</span><br></pre></td></tr></table></figure>
<p>一般将自定义异常类的类名命名为<code>XXXException</code>，其中<code>XXX</code>用来代表该异常的作用。</p>
<p>自定义异常类一般包含两个构造方法：一个是无参的默认构造方法，另一个构造方法以字符串的形式接收一个定制的异常消息，并将该消息传递给超类的构造方法。</p>
<p>创建一个名称为<code>IntegerRangeException</code>的自定义异常类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntegerRangeException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IntegerRangeException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IntegerRangeException</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个程序，对会员注册时的年龄进行验证，即检测是否在 0~100 岁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test07</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入您的年龄：&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      age = input.nextInt();    <span class="comment">// 获取年龄</span></span><br><span class="line">      <span class="keyword">if</span>(age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;您输入的年龄为负数！输入有误！&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(age &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;您输入的年龄大于100！输入有误！&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您的年龄为：&quot;</span>+age);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InputMismatchException e1) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;输入的年龄不是数字！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MyException e2) &#123;</span><br><span class="line">      System.out.println(e2.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入您的年龄：</span><br><span class="line">-2</span><br><span class="line">您输入的年龄为负数！输入有误！</span><br></pre></td></tr></table></figure>
<p>在该程序的主方法中，使用了<code>if…else if…else</code>语句结构判断用户输入的年龄是否为负数和大于 100 的数，如果是，则拋出自定义异常<code>MyException</code>，调用自定义异常类<code>MyException</code>中的含有一个<code>String</code>类型的构造方法。在<code>catch</code>语句块中捕获该异常，并调用<code>getMessage()</code>方法输出异常信息。</p>
<p>提示：因为自定义异常继承自<code>Exception</code>类，因此自定义异常类中包含父类所有的属性和方法。</p>
<h1 id="异常跟踪栈"><a href="#异常跟踪栈" class="headerlink" title="异常跟踪栈"></a>异常跟踪栈</h1><p>异常对象的<code>printStackTrace()</code>方法用于打印异常的跟踪栈信息，根据<code>printStackTrace()</code>方法的输出结果，可以找到异常的源头，并跟踪到异常一路触发的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelfException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">  SelfException() &#123;&#125;</span><br><span class="line">  SelfException(String msg) &#123;</span><br><span class="line">    <span class="built_in">super</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStackTraceTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    firstMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">firstMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    secondMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">secondMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    thirdMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thirdMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SelfException</span>(<span class="string">&quot;自定义异常信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面程序，会看到如下所示的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; Test.SelfException: 自定义异常信息</span><br><span class="line">        at Test.PrintStackTraceTest.thirdMethod(PrintStackTraceTest.java:26)</span><br><span class="line">        at Test.PrintStackTraceTest.secondMethod(PrintStackTraceTest.java:22)</span><br><span class="line">        at Test.PrintStackTraceTest.firstMethod(PrintStackTraceTest.java:18)</span><br><span class="line">        at Test.PrintStackTraceTest.main(PrintStackTraceTest.java:14)</span><br></pre></td></tr></table></figure>
<p>上面运行结果的第 2 行到第 5 行之间的内容是异常跟踪栈信息，从打印的异常信息我们可以看出，异常从<code>thirdMethod</code>方法开始触发，传到<code>secondMethod</code>方法，再传到<code>firstMethod</code>方法，最后传到<code>main</code>方法，在<code>main</code>方法终止，这个过程就是 Java 的异常跟踪栈。</p>
<p>面向对象的应用程序运行时，经常会发生一系列方法调用，从而形成“方法调用栈”，异常的传播则相反：只要异常没有被完全捕获（包括异常没有被捕获，或异常被处理后重新抛出了新异常），异常从发生异常的方法逐渐向外传播，首先传给该方法的调用者，该方法调用者再次传给其调用者……，直至最后传到<code>main</code>方法，如果<code>main</code>方法依然没有处理该异常，则 JVM 会中止该程序，并打印异常的跟踪栈信息。</p>
<p>异常跟踪栈信息的第一行一般详细显示异常的类型和异常的详细消息，接下来是所有异常的发生点，各行显示被调用方法中执行的停止位置，并标明类、类中的方法名、与故障点对应的文件的行。一行行地往下看，跟踪栈总是最内部的被调用方法逐渐上传，直到最外部业务操作的起点，通常就是程序的入口<code>main</code>方法或<code>Thread</code>类的<code>run</code>方法（多线程的情形）。</p>
<p>下面例子程序示范了多线程程序中发生异常的情形。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExceptionTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    firstMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    secondMethod();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">secondMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadExceptionTest</span>()).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">        at Test.ThreadExceptionTest.secondMethod(ThreadExceptionTest.java:14)</span><br><span class="line">        at Test.ThreadExceptionTest.firstMethod(ThreadExceptionTest.java:8)</span><br><span class="line">        at Test.ThreadExceptionTest.run(ThreadExceptionTest.java:4)</span><br><span class="line">        at java.lang.Thread.run(Unknown Source)</span><br></pre></td></tr></table></figure>
<p>多线程异常的跟踪栈，从发生异常的方法开始，到线程的<code>run</code>方法结束。从上面的运行结果可以看出，程序在<code>Thread</code>的<code>run</code>方法中出现了<code>ArithmeticException</code>异常，这个异常的源头是<code>ThreadExcetpionTest</code>的<code>secondMethod</code>方法，位于<code>ThreadExcetpionTest.java</code>文件的 14 行。这个异常传播到<code>Thread</code>类的<code>run</code>方法就会结束（如果该异常没有得到处理，将会导致该线程中止运行）。</p>
<p>调用<code>Exception</code>的<code>printStackTrace()</code>方法就是打印该异常的跟踪栈信息，也就会看到上面两个示例运行结果中的信息。当然，如果方法调用的层次很深，将会看到更加复杂的异常跟踪栈。</p>
<p>提示：虽然<code>printStackTrace()</code>方法可以很方便地用于追踪异常的发生情况，可以用它来调试程序，但在最后发布的程序中，应该避免使用它。应该对捕获的异常进行适当的处理，而不是简单地将异常的跟踪栈信息打印出来。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/网络层——子网和超网"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/"
    >网络层——子网和超网</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/" class="article-date">
  <time datetime="2020-09-24T02:59:23.000Z" itemprop="datePublished">2020-09-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h1><h2 id="从两级-IP-地址到三级-IP-地址"><a href="#从两级-IP-地址到三级-IP-地址" class="headerlink" title="从两级 IP 地址到三级 IP 地址"></a>从两级 IP 地址到三级 IP 地址</h2><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p>
<ul>
<li>IP 地址空间的利用率有时很低。 </li>
<li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li>
<li>两级的 IP 地址不够灵活。</li>
</ul>
<p>为解决上述问题，在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。这种做法叫做划分子网。</p>
<p>划分子网的基本思路：</p>
<ol>
<li>一个拥有很多物理网络的单位，可将所属的物理网络划分为若干个子网（<code>subnet</code>）。划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。</li>
<li>划分子网的方法是从主机号借用若干个位作为子网号<code>subnet-id</code>，而主机号<code>host-id</code>也就相应减少了若干个位。于是两级 IP 地址在本单位内部就变为三级 IP 地址：网络号、子网号和主机号。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP地址 ::= &#123;&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img1.png" class="">

<ol start="3">
<li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号<code>net-id</code>，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号<code>net-id</code>和子网号<code>subnet-id</code>找到目的子网。最后就将 IP 数据报直接交付目的主机。</li>
</ol>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img2.png" class="">

<p>上图表示某单位拥有一个 B 类 IP 地址，网络地址是<code>145.13.0.0</code>。凡目的地址是<code>145.13.x.x</code>的数据报都被送到这个网络上的路由器R1。</p>
<p>假定子网号占用 8 位，在增加了子网后，主机号就只有 8 位。所划分的三个子网分别是：<code>145.13.3.0，145.13.7.0，145.13.21.0</code>。整个网络对外部仍表现为一个网络，其网络地址仍然是<code>145.13.0.0</code>。<code>145.13.0.0</code>上的路由器在收到外来的数据报后，再根据数据报的目的地址把它转发到相应的子网。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img3.png" class="">

<p>当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址就变成了三级结构。划分子网只是把 IP 地址的主机号<code>host-id</code>这部分进行再划分，而不改变 IP 地址原来的网络号<code>net-id</code>。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。</p>
<p>使用子网掩码(<code>subnet mask</code>)可以找出 IP 地址中的子网部分。</p>
<p>规则：</p>
<ul>
<li>子网掩码长度 ＝ 32 位</li>
<li>子网掩码左边部分的一连串 1，对应于网络号和子网号</li>
<li>子网掩码右边部分的一连串 0，对应于主机号</li>
</ul>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img4.png" class="">
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img5.png" class="">

<h2 id="默认子网掩码"><a href="#默认子网掩码" class="headerlink" title="默认子网掩码"></a>默认子网掩码</h2><img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img6.png" class="">

<p>子网掩码是一个网络或一个子网的重要属性。</p>
<p>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</p>
<p>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</p>
<p>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</p>
<h2 id="子网划分方法"><a href="#子网划分方法" class="headerlink" title="子网划分方法"></a>子网划分方法</h2><p>有固定长度子网和变长子网两种子网划分方法。</p>
<p>在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的。</p>
<p>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法。</p>
<p>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img7.png" class="">

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>已知 IP 地址是<code>141.14.72.24</code>，子网掩码是<code>255.255.224.0</code>。试求网络地址。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img8.png" class="">

<p>上例中，若子网掩码改为<code>255.255.224.0</code>，试求网络地址，讨论所得结果。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img9.png" class="">

<p>不同的子网掩码得出相同的网络地址。但不同的掩码的效果是不同的。 </p>
<h1 id="使用子网时分组的转发"><a href="#使用子网时分组的转发" class="headerlink" title="使用子网时分组的转发"></a>使用子网时分组的转发</h1><p>在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事。但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。因此分组转发的算法也必须做相应的改动。</p>
<p>在划分子网情况下路由器转发分组的算法：</p>
<ol>
<li>从收到的分组的首部提取目的 IP 地址 D。</li>
<li>先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行3。</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行 4。</li>
<li>对路由表中的每一行，将子网掩码和 D 逐位相“与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 5。</li>
<li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行 6。</li>
<li>报告转发分组出错。</li>
</ol>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>已知互联网和路由器 R1 中的路由表。主机 H1 向 H2 发送分组。试讨论 R1 收到 H1 向 H2 发送的分组后查找路由表的过程。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img10.png" class="">

<p>主机 H1 要发送分组给 H2，要发送的分组的目的 IP 地址：<code>128.30.33.138</code>。因此 H1 首先检查主机<code>128.30.33.138</code>是否连接在本网络上<br>如果是，则直接交付；否则，就送交路由器 R1，并逐项查找路由表。</p>
<p>主机 H1 首先将本子网的子网掩码<code>255.255.255.128</code>与分组的 IP 地址<code>128.30.33.138</code>逐比特相与”(AND 操作) 。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img11.png" class="">

<p>得出<code>128.30.33.128</code>不等于H1的网络地址。因此 H1 必须把分组传送到路由器 R1 然后逐项查找路由表。</p>
<p>路由器 R1 收到分组后就用路由表中第 1 个项目的子网掩码和<code>128.30.33.138</code>逐比特 AND 操作。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img12.png" class="">
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img13.png" class="">

<h1 id="无分类编址-CIDR"><a href="#无分类编址-CIDR" class="headerlink" title="无分类编址 CIDR"></a>无分类编址 CIDR</h1><h2 id="网络前缀"><a href="#网络前缀" class="headerlink" title="网络前缀"></a>网络前缀</h2><p>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题：</p>
<ul>
<li>B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！</li>
<li>互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</li>
<li>整个 IPv4 的地址空间最终将全部耗尽。</li>
</ul>
<h3 id="IP-编址问题的演进"><a href="#IP-编址问题的演进" class="headerlink" title="IP 编址问题的演进"></a>IP 编址问题的演进</h3><p>RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用变长子网掩码 VLSM(<code>Variable Length Subnet Mask</code>)可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是无分类域间路由选择 CIDR(<code>Classless Inter-Domain Routing</code>)。</p>
<h3 id="CIDR-最主要的特点"><a href="#CIDR-最主要的特点" class="headerlink" title="CIDR 最主要的特点"></a>CIDR 最主要的特点</h3><h4 id="1-CIDR-消除了传统的-A-类、B-类和-C-类地址以及划分子网的概念，因而可以更加有效地分配-IPv4-的地址空间。"><a href="#1-CIDR-消除了传统的-A-类、B-类和-C-类地址以及划分子网的概念，因而可以更加有效地分配-IPv4-的地址空间。" class="headerlink" title="1. CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。"></a>1. CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。</h4><p>CIDR使用各种长度的“网络前缀”(<code>network-prefix</code>)来代替分类地址中的网络号和子网号。</p>
<p>IP 地址从三级编址（使用子网掩码）又回到了两级编址。</p>
<p>无分类的两级编址的记法是： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP地址 ::= &#123;&lt;网络前缀&gt;, &lt;主机号&gt;&#125; </span><br></pre></td></tr></table></figure>
<p>CIDR 使用“斜线记法”，它又称为 CIDR 记法，即在 IP 地址后面加上一个斜线“&#x2F;”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。例如：<code>220.78.168.0/24</code>。</p>
<h4 id="2-CIDR-把网络前缀都相同的连续的-IP-地址组成“CIDR-地址块”。"><a href="#2-CIDR-把网络前缀都相同的连续的-IP-地址组成“CIDR-地址块”。" class="headerlink" title="2. CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。"></a>2. CIDR 把网络前缀都相同的连续的 IP 地址组成“CIDR 地址块”。</h4><p><code>128.14.32.0/20</code>表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。这个地址块的起始地址是<code>128.14.32.0</code>。</p>
<p>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“&#x2F;20 地址块”。</p>
<p><code>128.14.32.0/20</code>地址块的最小地址：<code>128.14.32.0</code></p>
<p><code>128.14.32.0/20</code>地址块的最大地址：<code>128.14.47.255</code></p>
<p>全 0 和全 1 的主机号地址一般不使用。</p>
<h3 id="路由聚合-route-aggregation"><a href="#路由聚合-route-aggregation" class="headerlink" title="路由聚合 (route aggregation)"></a>路由聚合 (route aggregation)</h3><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。</p>
<p>路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p>
<p>路由聚合也称为构成超网(<code>supernetting</code>)。</p>
<p>CIDR 虽然不使用子网了，但仍然使用“掩码”这一名词（但不叫子网掩码）。</p>
<p>对于 &#x2F;20  地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。 </p>
<p>CIDR 记法的其他形式</p>
<p><code>10.0.0.0/10</code>可简写为<code>10/10</code>，也就是把点分十进制中低位连续的 0 省略。<br><code>10.0.0.0/10</code>隐含地指出 IP 地址<code>10.0.0.0</code>的掩码是<code>255.192.0.0</code>。此掩码可表示为：</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img14.png" class="">

<p>网络前缀的后面加一个星号 * 的表示方法，如<code>00001010 00*</code>，在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值。</p>
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img15.png" class="">

<p>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C  类地址。</p>
<p>这些 C 类地址合起来就构成了超网。</p>
<p>CIDR 地址块中的地址数一定是 2 的整数次幂。</p>
<p>网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</p>
<p>CIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。 </p>
<h3 id="CIDR-地址块划分举例"><a href="#CIDR-地址块划分举例" class="headerlink" title="CIDR 地址块划分举例"></a>CIDR 地址块划分举例</h3><img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img16.png" class="">

<p>这个 ISP 共有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目<code>206.0.64.0/18</code>就能找到该 ISP。 </p>
<h2 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h2><p>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。</p>
<p>应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配(<code>longest-prefix matching</code>)。</p>
<p>网络前缀越长，其地址块就越小，因而路由就越具体。</p>
<p>最长前缀匹配又称为最长匹配或最佳匹配。</p>
<h3 id="最长前缀匹配举例"><a href="#最长前缀匹配举例" class="headerlink" title="最长前缀匹配举例"></a>最长前缀匹配举例</h3><img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img17.png" class="">
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img18.png" class="">
<img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img19.png" class="">

<h2 id="使用二叉线索查找路由表"><a href="#使用二叉线索查找路由表" class="headerlink" title="使用二叉线索查找路由表"></a>使用二叉线索查找路由表</h2><p>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。 </p>
<p>为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是二叉线索 (<code>binary trie</code>)。<br>IP 地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。</p>
<p>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。</p>
<h3 id="用-5-个前缀构成的二叉线索"><a href="#用-5-个前缀构成的二叉线索" class="headerlink" title="用 5 个前缀构成的二叉线索"></a>用 5 个前缀构成的二叉线索</h3><img src="/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E2%80%94%E2%80%94%E5%AD%90%E7%BD%91%E5%92%8C%E8%B6%85%E7%BD%91/img20.png" class="">

<p>从二叉线索的根节点自顶向下的深度最多有 32 层，每一层对应于IP地址中的一位。一个IP地址存入二叉线索的规则很简单。先检查IP地址左边的第一位，如为 0，则第一层的节点就在根节点的左下方；如为 1，则在右下方。然后再检查地址的第二位，构造出第二层的节点。依此类推，直到唯一前缀的最后一位。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/IP详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/"
    >IP详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2020-09-20T06:32:13.000Z" itemprop="datePublished">2020-09-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>互联网使用的是 TCP&#x2F;IP 协议，其中 IP 协议又是最重要的协议之一。 IP 协议是基于 IP 地址将数据包发送给目的主机，能够让互联网上任何两台主机进行通信。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>IP 协议位于 OSI 参考模型的第三层，即网络层。网络层的主要作用是实现终端节点之间的通信。这种终端节点之间的通信，也叫点对点通信。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/2.png" class="">

<ul>
<li>主机：配置有 IP 地址，不进行路由控制的设备。</li>
<li>路由器：既有 IP 地址又具有路由控制功能的设备。</li>
<li>节点：主机和路由器的统称。</li>
</ul>
<h1 id="数据如何传输到目的地？"><a href="#数据如何传输到目的地？" class="headerlink" title="数据如何传输到目的地？"></a>数据如何传输到目的地？</h1><p>数据链路层实现两个直连设备之间的数据传输，网络层的 IP 协议实现没有直连的两个网络之间的数据传输。</p>
<p>以旅行为例，小美要去一个很远的地方旅行，先计划要乘坐的高铁、地铁、公交车，并且购买相应车票，再制定一个详细行程表，记录乘车时间。</p>
<p>高铁票、地铁票只能在一个区间内移动，就像网络上的数据链路。出发点就像源 MAC 地址，目的地就像目的 MAC 地址，整个行程表的作用就相当于网络层，出发点就像源 IP 地址，目的地就像目的 IP 地址。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/3.png" class="">

<p>小美如果只有行程表，没有车票，就无法乘坐交通工具到达目的地。相反，小美只有车票，不知道坐什么车，在哪里换乘，恐怕也到不了目的地。只有两者兼备，既有某个区间的车票又有整个旅行的行程表，才能保证到达目的地。网络中也需要数据链路层和网络层协同工作，才能实现最终目的地址的通信。</p>
<h1 id="IP-地址的基础知识"><a href="#IP-地址的基础知识" class="headerlink" title="IP 地址的基础知识"></a>IP 地址的基础知识</h1><p>在 TCP&#x2F;IP 通信中使用 IP 地址识别主机和路由器。 IP 地址是逻辑地址，需要手工配置或自动获取，为了保证正常通信，每个设备必须配置 IP 地址。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/4.png" class="">
<h2 id="IP-地址的定义"><a href="#IP-地址的定义" class="headerlink" title="IP 地址的定义"></a>IP 地址的定义</h2><p>IP 地址由 32 位二进制数组成。为了方便记录，将 32 位的 IP 地址分为 4 组，每 8 位为一组，每组以<code>.</code>隔开，再将每组数转换为十进制数。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/5.png" class="">
<h3 id="常用二进制数与十进制数的转换"><a href="#常用二进制数与十进制数的转换" class="headerlink" title="常用二进制数与十进制数的转换"></a>常用二进制数与十进制数的转换</h3><img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/5-1.png" class="">

<h3 id="IP-地址一共有多少个？"><a href="#IP-地址一共有多少个？" class="headerlink" title="IP 地址一共有多少个？"></a>IP 地址一共有多少个？</h3><p>将 IP 地址的32位二进制进行计算，得出约 43 亿个 IP 地址。</p>
<p>2<sup>32</sup> &#x3D; 4294967296</p>
<p>实际上，网络的发展超乎想象，互联网上的设备远超 43 亿，2019 年 11 月 25 日全球的 IPv4 地址已经彻底耗尽，但是直到现在大家仍然还在用 IPv4，并没有因为地址没了而无法上网。是因为除了 IPv6 之外，我们使用 NAT 技术缓解了地址不足的问题。</p>
<h2 id="IP-地址的组成"><a href="#IP-地址的组成" class="headerlink" title="IP 地址的组成"></a>IP 地址的组成</h2><p>IP 地址由网络号（网段地址）和主机号（主机地址）两部分组成。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/6.png" class="">

<p>网络号是设备所在区域的一种标识，网络号相同的设备位于同一个网段内，网络号不同的设备通过路由器实现通信。主机号是在同一个网段中不同设备的标识，不允许同一个网段内出现重复的主机号。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/7.png" class="">

<p>路由器是根据目的 IP 地址的网络号进行路由。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/8.png" class="">

<p>那么 IP 地址哪几位是网络号？哪几位是主机号？早期是以分类地址区分，现在是以子网掩码区分。</p>
<h2 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h2><p>IP 地址分为四类，分别是 A 类、B 类、C 类、D 类（还有一个保留的 E 类）。分类地址使用的是固定网络位数，A 类 8 位网络号，B 类 16 位网络号，C 类 24 位网络号。既可以通过判断分类地址类型（ A 类、B 类、C 类其中之一）识别出网络号，也可以通过子网掩码识别出网络号。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/9.png" class="">

<h3 id="A-类地址"><a href="#A-类地址" class="headerlink" title="A 类地址"></a>A 类地址</h3><p>A 类 IP 地址是首位以 0 开头的地址。从第 1 位到第 8 位是它的网络号，网络号的范围是<code>0~127</code>。其中 0 和 127 属于保留地址，减去两个保留地址，因此有 2<sup>8-1</sup>-2&#x3D;126 个可用的 A 类地址。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/10.png" class="">

<p>后 24 位是主机号，一个 A 类地址的主机地址数量就是 2<sup>24</sup>，即 16777216 个主机地址。其中主机位全为 0 和主机位全为 1 分别为网段地址和广播地址，不能分配给主机使用，每个 A 类地址可用的主机地址就是 2<sup>24</sup>-2 &#x3D; 16777214 个。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/11.png" class="">

<p>A 类地址的范围是<code>1.0.0.0 ~ 126.255.255.255</code>。</p>
<p>A 类地址子网掩码是<code>255.0.0.0</code>，也可写作<code>/8</code>。</p>
<h3 id="B-类地址"><a href="#B-类地址" class="headerlink" title="B 类地址"></a>B 类地址</h3><p>B 类 IP 地址是前两位以 10 开头的地址。从第 1 位到第 16 位是它的网络号，网络号的范围是<code>128.0~191.255</code>。其中<code>128.0</code>和<code>191.255</code>属于保留地址，减去两个保留地址，因此有 2<sup>16-2</sup>-2&#x3D;16382 个可用的 B 类地址。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/12.png" class="">

<p>后 16 位是主机号，一个 B 类地址的主机地址的数量就是 2<sup>16</sup>，即 65536 个主机地址。其中网段地址和广播地址不能分配给主机使用，每个 B 类地址可用的主机地址就是<code>65536–2=65534</code>个。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/13.png" class="">

<p>B 类地址的范围是<code>128.0.0.0~191.255.255.255</code>。</p>
<p>B 类地址子网掩码是<code>255.255.0.0</code>，也可写作<code>/16</code>。</p>
<h3 id="C-类地址"><a href="#C-类地址" class="headerlink" title="C 类地址"></a>C 类地址</h3><p>C 类 IP 地址是前三位以 110 开头的地址。从第 1 位到第 24 位是它的网络号，网络号的范围是<code>192.0.0~223.255.255</code>。其中<code>192.0.0</code>和<code>223.255.255</code>属于保留地址，减去两个保留地址，因此有 2<sup>24-3</sup>-2&#x3D;2097150 个可用的 C 类地址。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/14.png" class="">

<p>后 8 位是主机号，一个 C 类地址的主机地址的数量就是 2<sup>8</sup>，即 256 个主机地址。其中网段地址和广播地址不能分配给主机使用，每个 C 类地址可用的主机地址就是<code>256–2=254</code>个。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/15.png" class="">

<p>C 类地址的范围是<code>192.0.0.0 ~ 223.255.255.255</code>。</p>
<p>C 类地址子网掩码是<code>255.255.255.0</code>，也可写作<code>/24</code>。</p>
<h3 id="D-类地址"><a href="#D-类地址" class="headerlink" title="D 类地址"></a>D 类地址</h3><p>D 类 IP 地址是前四位以<code>1110</code>开头的地址。从第 1 位到第 32 位是它的网络号，网络号的范围是<code>224.0.0.0~239.255.255.255</code>。D 类地址没有主机号，用于组播。</p>
<p>当主机号全为 0 时，表示的是网段地址，非主机地址。当主机号全为 1 时是广播地址，也不是主机地址。因此在分配 IP 地址过程中，需要排除这两个地址。例如一个 C 类地址<code>192.168.1.0/24</code>最多只有 254 个可用主机地址，而不是 256 个。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/16.png" class="">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">IP 地址范围</th>
<th align="center">私有 IP 地址范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">0.0.0.0~127.255.255.255</td>
<td align="center">10.0.0.0~10.255.255.255</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">128.0.0.0~191.255.255.255</td>
<td align="center">172.16.0.0.0~172.31.255.255</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">192.0.0.0~223.255.255.255</td>
<td align="center">192.168.0.0~192.168.255.255</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">网络类别</th>
<th align="center">最大网络数</th>
<th align="center">第一个可用的网络号</th>
<th align="center">每个网络中最大的主机数</th>
<th align="center">每个网络中的最大主机数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">126(2<sup>7</sup> – 2)</td>
<td align="center">1</td>
<td align="center">126</td>
<td align="center">16,777,214</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">16,383(2<sup>14</sup> - 1)</td>
<td align="center">128.1</td>
<td align="center">191.255</td>
<td align="center">65,534</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">2,097,151(2<sup>21</sup> - 1)</td>
<td align="center">192.0.1</td>
<td align="center">223.255.255</td>
<td align="center">254</td>
</tr>
</tbody></table>
<p>一般不使用的特殊的 IP 地址，这些地址只能在特定的情况下使用：</p>
<table>
<thead>
<tr>
<th align="center">网络号</th>
<th align="center">主机号</th>
<th align="center">源地址使用</th>
<th align="center">目标地址使用</th>
<th align="center">代表的意思</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">可以</td>
<td align="center">不可</td>
<td align="center">在本网络上的本主机</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">主机号</td>
<td align="center">可以</td>
<td align="center">不可</td>
<td align="center">在本网络上的某台主机主机号</td>
</tr>
<tr>
<td align="center">全1</td>
<td align="center">全1</td>
<td align="center">不可</td>
<td align="center">可以</td>
<td align="center">只在本网络上进行广播（各路由器均不转发）</td>
</tr>
<tr>
<td align="center">网络号</td>
<td align="center">全1</td>
<td align="center">不可</td>
<td align="center">可以</td>
<td align="center">对 网络号 上的所有主机进行广播</td>
</tr>
<tr>
<td align="center">127</td>
<td align="center">非全0或全1的任何数</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">用于本地软件环回测试</td>
</tr>
</tbody></table>
<h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p>网段地址是主机号全为 0 的地址，表示某个网段，比如：网段地址<code>192.168.10.0/24</code>表示的是网络号为<code>192.168.10</code>的所有地址。</p>
<p>IP 地址中的主机号全部为 1 的就是广播地址，它是向同一个网段中的所有主机发送数据包。例如一个 B 类主机地址<code>172.20.1.100</code>的广播地址是<code>172.20.255.255</code>。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/17.png" class="">

<h2 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a>IP 组播</h2><p>组播用于将包发送给特定组内的所有主机。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/18.png" class="">

<p>组播使用 D 类地址。因此 IP 地址前四位是<code>1110</code>开头的，就是组播地址。剩下的 28 位就是组播的组编号。组播的地址范围是<code>224.0.0.0 ~ 239.255.255.255</code>，其中<code>224.0.0.0 ~ 224.0.0.255</code>既可以在同一个网段内实现组播，又可以跨网段给全网所有组员发送组播包。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/19.png" class="">

<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>早期网络地址采用固定网络位长度的方式，使 IPv4 地址遭到大量浪费。如今网段地址的长度可变，同时也需要一种标识来获取网段地址，以便路由器对数据包进行转发，这种识别码就是子网掩码。</p>
<p>子网掩码用 32 位的二进制表示，IP 地址的网段地址部分设置为 1，IP 地址的主机地址部分设置为 0。换句话说，IP 地址有多少位网段地址，子网掩码就有多少位取 1，其余都取 0。为了方便记录，每 8 位为一组，以<code>.</code>隔开，再转换为十进制数。</p>
<p>例如：<code>201.20.100.25</code>的子网掩码是<code>255.255.255.0</code>，算出它的网段地址。</p>
<p>将子网掩码和 IP 地址进行与（AND）运算，可得到这个 IP 地址的网段地址。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/20.png" class="">

<h3 id="与（AND）运算"><a href="#与（AND）运算" class="headerlink" title="与（AND）运算"></a>与（AND）运算</h3><p>IP 地址和子网掩码的二进制数，逐位进行计算。只有当 IP 地址和掩码都是 1 时，运算结果为 1。其余情况计算结果都为 0。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/21.png" class="">

<p>IP 地址的另一种表示方式是在每个 IP 地址后面追加网络号的位数用<code>/</code>隔开。例如：<code>201.20.100.25/255.255.255.0</code>可表示为<code>201.20.100.25/24</code>。</p>
<h2 id="CIDR-与-VLSM"><a href="#CIDR-与-VLSM" class="headerlink" title="CIDR 与 VLSM"></a>CIDR 与 VLSM</h2><p>解决 IP 地址浪费问题，除了使用子网掩码，还使用了 CIDR 和 VLSM 技术。</p>
<p>CIDR，即无类域间路由，采用任意长度分割 IP 地址的网络号和主机号。它有两个作用：</p>
<ul>
<li>把多个网段聚合到一起，生成一个更大的网段；</li>
<li>汇总路由表 IP 地址，分担路由表压力。</li>
</ul>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/22.png" class="">

<p>VLSM，即可变长子网掩码，它可以对 A、B、C 类地址再进行子网划分，以达到充分利用 IP 地址的目的。</p>
<p>假如一家企业有 100 台电脑，按以前的办法，只能分配一个 C 类地址<code>222.222.222.0</code>。但是 VLSM 可以在一个 C 类地址上划分出多个子网地址，再分配其中一个容纳主机数量与稍大于企业需求数量的子网地址给企业，这样就可以实现 IP 地址的合理使用。</p>
<p>计算容纳 100 台电脑的子网：使用主机号的位数计算出子网的主机地址数量。当主机号有 7 位时，有 126 个可用主机地址，可容纳 100 台电脑。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/23.png" class="">

<p>计算子网地址：当主机号有 7 位时，网络号有 32 – 7 &#x3D; 25 位，也就是<code>222.222.222.0/24</code>向主机位借了一位作为子网位，那么子网掩码也就是<code>255.255.255.128</code>。可分配<code>222.222.222.0/25</code>使用。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/24.png" class="">

<p><code>222.222.222.0/25</code>子网详情：</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25.png" class="">

<h3 id="CIDR-和-VLSM-的区别"><a href="#CIDR-和-VLSM-的区别" class="headerlink" title="CIDR 和 VLSM 的区别"></a>CIDR 和 VLSM 的区别</h3><p>CIDR 是主机号向网络号借位，目的是把几个网络汇总成一个大的网络，增加子网主机数量；</p>
<p>VLSM 是网络号向主机号借位，目的是把一个标准的网络划分成几个子网，减少子网主机数量。</p>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>子网划分是从 IP 地址主机位的最左边开始，把主机位划入网络位，得到多个子网地址。主机位变成网络位的部分叫做子网号，划分后的子网数量等于 2 的 N 次方，N 等于子网号的位数。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-1.png" class="">

<p>即每把一位主机位变成网络位，一个网段地址就变成两个子网地址，子网地址的地址数量只有原来网段地址的一半。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-2.png" class="">

<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>一个学校有 150 台电脑，有三个电脑室，每个电脑室 50 台电脑。使用私有地址 192.168.0.0&#x2F;24 给每个电脑室都分配一个网段地址。</p>
<p>网络规划步骤：</p>
<ol>
<li>每个电脑室 50 台电脑，计算出子网地址的主机位是 6 位。<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-3.png" class=""></li>
<li>计算子网地址的网络位，即 32 – 主机位 &#x3D; 26 位。</li>
<li>使用私网地址<code>192.168.0.0/24</code>分配三个主机位同为 26 位的子网地址。子网号有 2 位，因此可以划分出 4 个大小相同的子网地址。<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-4.png" class=""></li>
<li>按照子网号从小到大的顺序，分配 3 个子网地址给电脑室使用。即分配<code>192.168.0.0/26、192.168.0.64/26、192.168.0.128/26</code>这三个子网地址。<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-5.png" class=""></li>
</ol>
<h3 id="再来个栗子"><a href="#再来个栗子" class="headerlink" title="再来个栗子"></a>再来个栗子</h3><p>一个公司有 157 人，市场部 100 人，技术部 50 人，行政部 4 人，财务部 3 人，每人一台办公电脑。使用私有地址<code>192.168.100.0/24</code>分别为每个部门划分网络地址。</p>
<p>网络规划步骤：</p>
<ol>
<li>按照需要 IP 地址数量，从大到小依次进行子网划分。先计算有 100 人的市场部所需子网的主机位是 7 位。<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-6.png" class=""></li>
<li>计算市场部所需子网地址的网络位，即 32 – 主机位 &#x3D; 25 位。</li>
<li>使用私网地址<code>192.168.100.0/24</code>分配第一个主机位为 25 位的子网地址，即<code>192.168.100.0/25</code>。<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-7.png" class=""></li>
<li>保证与第一个子网地址不重复的前提下，使用未分配的子网值最小的子网地址，计算第二个需要分配的子网地址。即使用<code>192.168.100.128/25</code>分配第二个子网地址给技术部（50 人）使用。重复步骤 1 ~ 3，计算出第二个子网的主机位是 6 位，网络位是 26 位，第二个子网地址是<code>192.168.100.128/26</code>。<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-8.png" class=""></li>
<li>保证与前面两个子网地址不重复的前提下，使用未分配的子网值最小的子网地址，计算第三个需要分配的子网地址。即使用<code>192.168.100.192/26</code>分配第三个子网地址给行政部（4 人）使用。重复步骤 1 ~ 3，计算出第三个子网的主机位是 3 位，网络位是 29 位，第三个子网地址是<code>192.168.100.192/29</code>。</li>
<li>依次类推，计算给财务部（3 人）使用的第四个子网地址。得出第四个子网的主机位是 3 位，网络位是 29 位，第四个子网地址是<code>192.168.100.200/29</code>。<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-9.png" class=""></li>
</ol>
<h2 id="超网合并"><a href="#超网合并" class="headerlink" title="超网合并"></a>超网合并</h2><p>与子网划分相反，把一些小网络组合成一个大网络就是超网合并。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-10.png" class="">

<p><code>192.168.3.64/26</code>和<code>192.168.3.128/26</code>可以合并吗？</p>
<p><code>192.168.3.64/26</code>和<code>192.168.3.128/26</code>不能合并。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-11.png" class="">

<p>当子网掩码向左移动一位时，网络号不相同，无法合并；</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-12.png" class="">

<p>当子网掩码向左移动两位是，网络号是相同了，但是合并了四个网段，非<code>192.168.3.64/26</code>和<code>192.168.3.128/26</code>合并。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/25-13.png" class="">

<p>结论：子网掩码左移一位，且网络号相同，能够合并两个网段；左移两位，且网络号相同，能够合并四个网段；左移三位，能够合并八个网段。依次类推。</p>
<h2 id="公网地址与私有地址"><a href="#公网地址与私有地址" class="headerlink" title="公网地址与私有地址"></a>公网地址与私有地址</h2><p>IP 地址分为公网地址和私有地址。公网地址是在互联网上使用的，私有地址是在局域网中使用的。</p>
<p>公网地址由 Internet NIC 负责分配，通过它直接访问互联网。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/26.png" class="">

<p>私有地址是一段保留的 IP 地址。只在局域网中使用，无法在互联网上使用。但是私有地址可以通过 NAT 技术，将私有地址转换为公网地址接入互联网。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/27.png" class="">

<p>公网 IP 地址在互联网范围内是唯一的，私有 IP 地址只要在同一个局域网内唯一即可。在不同局域网内出现相同的私有 IP 不会影响使用。</p>
<h1 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h1><img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/img19.png" class="" title="IP数据报的格式">

<p>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。</p>
<h2 id="各字段含义"><a href="#各字段含义" class="headerlink" title="各字段含义"></a>各字段含义</h2><ol>
<li>版本：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。IPv4 的版本号是 4。</li>
<li>首部长度：占 4 位，可表示的最大数值是 15(1111) 个单位，一个单位是 4 字节，因此 IP 的首部长度的最大值是 60 字节。没有可选项的 IP 包，首部长度为 5，即 20 字节（<code>4×5=20</code>）。</li>
<li>区分服务：占 8 位，用来说明数据是要加速传输还是精确传输，以及数据在传输过程中是否遇到了拥塞。只有在使用区分服务（<code>DiffServ</code>）时，这个字段才起作用。在一般的情况下都不使用这个字段。 </li>
<li>总长度：占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 2<sup>16</sup> - 1 &#x3D; 65535 字节。总长度必须不超过最大传送单元 MTU。</li>
<li>标识：占 16 位，它是一个计数器，用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。通常，每发送一个 IP 包，它的值也逐渐递增。另外，即使 ID 相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。</li>
<li>标志：占 3 位，表示分片信息。每比特的具体含义：<table>
<thead>
<tr>
<th align="center">比特位</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">未使用，现在必须是 0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">表示是否可以进行分片<br>0——可以分片<br>1——不能分片</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">被分片时表示是否为最后一个包<br>0——最后一个分片包<br>1——分片中段的包</td>
</tr>
</tbody></table>
</li>
<li>片偏移：占 13 位，表示分片在整个数据包中的位置。作用是告诉重组分片的设备，应该按照什么样的顺序重组数据包。片偏移以 8 个字节为偏移单位。</li>
<li>生存时间：占 8 位，记为 TTL(<code>Time To Live</code>)，表示数据包可以经过的中转路由器数量。数据报能在因特网中经过的路由器的最大数值是 255。每经过一个路由器，TTL 会减少 1，直到变成 0 则丢弃改包，避免数据包在网络中无限传递。</li>
<li>协议：占 8 位，表示 IP 上一层所使用的协议。常见的 IP 上层协议有 TCP 和 UDP。</li>
<li>首部校验和：占 16 位，用来校验数据包的头部是否被破坏。设备会丢弃校验失败的数据包。IPv6 以取消头部校验和字段，通过上层的 TCP 或 UDP 校验协议是否正确。</li>
<li>源地址：占 32 位。表示发送端 IP 地址。</li>
<li>目的地址：占 32 位。表示接收端 IP 地址。</li>
<li>可选字段：选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。增加可选字段是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这个字段很少使用。在 IPv6 协议中已经取消。</li>
<li>填充：在有可选字段的情况下，头部长度不是 32 比特的整数倍时，通过向字段填充 0，调整为 32 比特的整数倍。</li>
</ol>
<h2 id="首部检验和的计算过程"><a href="#首部检验和的计算过程" class="headerlink" title="首部检验和的计算过程"></a>首部检验和的计算过程</h2><img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/img20.png" class="">

<h1 id="IP-分片与重组"><a href="#IP-分片与重组" class="headerlink" title="IP 分片与重组"></a>IP 分片与重组</h1><h2 id="数据链路不同，-MTU-则不同"><a href="#数据链路不同，-MTU-则不同" class="headerlink" title="数据链路不同， MTU 则不同"></a>数据链路不同， MTU 则不同</h2><p>每种数据链路的最大传输单元（MTU）不同，网络层的 IP 是数据链路的上一层，IP 通过分片屏蔽数据链路的差异，实现不同数据链路互通。从 IP 的上一层看，它完全可以忽略各个数据链路上的 MTU，只需要按照源 IP 地址发送的长度接收数据包。</p>
<table>
<thead>
<tr>
<th align="center">数据链路</th>
<th align="center">MTU(字节)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IP最大MTU</td>
<td align="center">65535</td>
</tr>
<tr>
<td align="center">IP over ATM</td>
<td align="center">9180</td>
</tr>
<tr>
<td align="center">FDDI</td>
<td align="center">4352</td>
</tr>
<tr>
<td align="center">以太网</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">PPP(Default)</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">IEEE 802.3 Ethernet</td>
<td align="center">1492</td>
</tr>
<tr>
<td align="center">PPPoE</td>
<td align="center">1492</td>
</tr>
<tr>
<td align="center">IP最小MTU</td>
<td align="center">68</td>
</tr>
</tbody></table>
<h2 id="IP-报文的分片与重组"><a href="#IP-报文的分片与重组" class="headerlink" title="IP 报文的分片与重组"></a>IP 报文的分片与重组</h2><p>当遇到 IP 数据包大于数据链路 MTU 时，往往无法直接发送出去，主机或路由器就会对 IP 数据包进行分片处理。</p>
<p>经过分片后的 IP 数据，只会在目标主机上进行重组，中途经过路由器时不会进行重组。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/28.png" class="">

<h2 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h2><p>分片机制有两点不足：</p>
<ul>
<li>加重路由器的处理性能；</li>
<li>在分片传输中，一旦某个分片丢失，会造成整个 IP 数据包作废。</li>
</ul>
<p>为了解决这个问题，要使用路径 MTU 发现（<code>Path MTU Discovery</code>）技术。路径 MTU 是指从发送端主机到接收端主机之间不需要分片时最大 MTU 值。即路径中存在的所有数据链路中最小的 MTU。路径 MTU 发现是从发送主机按照路径 MTU 的值将数据报分片后进行发送，避免在中途的路由器上进行分片处理。</p>
<img src="/2020/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E8%AF%A6%E8%A7%A3/29.png" class="">

<p>路径 MTU 发现的工作原理如下：<br>发送端主机发送 IP 数据包时将其头部的分片禁止标志位设置为 1 。根据这个标志位，途中的路由器即使收到需要分片的大包，也不会分片，而是直接将包丢弃。之后通过一个 ICMP 不可达消息将数据链路上 MTU 值给发送端主机。</p>
<p>发送端主机根据收到的 MTU 值对数据包进行分片处理，再把 IP 数据包发送给相同的目的主机。如此重复，直到数据包被发送到目标主机为止没有再收到任何 ICMP，就认为最后一次 ICMP 所通知的 MTU 即是一个合适的 MTU 值。MTU 值至少可以缓存约 10 分钟，在这 10 分钟内使用刚得到的 MTU，过了 10 分钟后就重新做一次路径 MTU 发现。</p>
<p>上面的例子是 UDP，如果是在 TCP 的情况下，根据路径 MTU 的大小计算出最大段长度（MSS），然后再根据这些信息进行数据包的发送。因此，在 TCP 中如果使用路径 MTU 发现，IP 层则不会再分片。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java继承和多态"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/19/java/%E5%9F%BA%E7%A1%80/Java%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"
    >Java 继承和多态</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/19/java/%E5%9F%BA%E7%A1%80/Java%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/" class="article-date">
  <time datetime="2020-09-19T09:08:23.000Z" itemprop="datePublished">2020-09-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h1><p>封装指将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问。</p>
<p>封装的特点：</p>
<ul>
<li>只能通过规定的方法访问数据。</li>
<li>隐藏类的实例细节，方便修改和实现。</li>
</ul>
<p>实现封装的步骤：</p>
<ul>
<li>修改属性的可见性来限制对属性的访问，一般设为<code>private</code>。</li>
<li>为每个属性创建一对赋值（<code>setter</code>）方法和取值（<code>getter</code>）方法，一般设为<code>public</code>，用于属性的读写。</li>
<li>在赋值和取值方法中，加入属性控制语句（对属性值的合法性进行判断）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">private</span> String phone; <span class="comment">// 联系电话</span></span><br><span class="line">  <span class="keyword">private</span> String address; <span class="comment">// 家庭住址</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="comment">// 对年龄进行限制</span></span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span> || age &gt; <span class="number">40</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;年龄必须在18到40之间！&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.age = <span class="number">20</span>; <span class="comment">// 默认年龄</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> phone;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.phone = phone;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.address = address;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>private</code>关键字修饰属性，这就意味着除了<code>Employee</code>类本身外，其他任何类都不可以访问这些属性。但是，可以通过这些属性的<code>setXxx()</code>方法来对其进行赋值，通过<code>getXxx()</code>方法来访问这些属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    people.setName(<span class="string">&quot;王丽丽&quot;</span>);</span><br><span class="line">    people.setAge(<span class="number">35</span>);</span><br><span class="line">    people.setPhone(<span class="string">&quot;13653835964&quot;</span>);</span><br><span class="line">    people.setAddress(<span class="string">&quot;河北省石家庄市&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + people.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;年龄：&quot;</span> + people.getAge());</span><br><span class="line">    System.out.println(<span class="string">&quot;电话：&quot;</span> + people.getPhone());</span><br><span class="line">    System.out.println(<span class="string">&quot;家庭住址：&quot;</span> + people.getAddress());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a>继承（extends）</h1><p>继承就是在已经存在类的基础上进行扩展，从而产生新的类。已经存在的类称为父类、基类或超类，而新产生的类称为子类或派生类。在子类中，不仅包含父类的属性和方法，还可以增加新的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">class</span> <span class="title class_">class_name</span> <span class="keyword">extends</span> <span class="title class_">extend_class</span> &#123;</span><br><span class="line">  <span class="comment">// 类的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code>表示子类（派生类）的名称；<code>extend_class</code>表示父类（基类）的名称；<code>extends</code>关键字直接跟在子类名之后，其后面是该类要继承的父类名称。</p>
<p>Java 的继承通过<code>extends</code>关键字来实现，<code>extends</code>的英文意思是扩展，而不是继承。<code>extends</code>很好的体现了子类和父类的关系，即子类是对父类的扩展，子类是一种特殊的父类。</p>
<p>类的继承不改变类成员的访问权限，也就是说，如果父类的成员是公有的、被保护的或默认的，它的子类仍具有相应的这些特性，并且子类不能获得父类的构造方法。</p>
<p>教师和学生都属于人，他们具有共同的属性：姓名、年龄、性别和身份证号，而学生还具有学号和所学专业两个属性，教师还具有教龄和所教专业两个属性。下面编写 Java 程序代码，使教师（<code>Teacher</code>）类和学生（<code>Student</code>）类都继承于人（<code>People</code>）类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">public</span> String sex; <span class="comment">// 性别</span></span><br><span class="line">  <span class="keyword">public</span> String sn; <span class="comment">// 身份证号</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name, <span class="type">int</span> age, String sex, String sn)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    <span class="built_in">this</span>.sn = sn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;\n年龄：&quot;</span> + age + <span class="string">&quot;\n性别：&quot;</span> + sex + <span class="string">&quot;\n身份证号：&quot;</span> + sn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String stuNo; <span class="comment">// 学号</span></span><br><span class="line">  <span class="keyword">private</span> String department; <span class="comment">// 所学专业</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex, String sn, String stuno, String department)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age, sex, sn); <span class="comment">// 调用父类中的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.stuNo = stuno;</span><br><span class="line">    <span class="built_in">this</span>.department = department;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;\n年龄：&quot;</span> + age + <span class="string">&quot;\n性别：&quot;</span> + sex + <span class="string">&quot;\n身份证号：&quot;</span> + sn + <span class="string">&quot;\n学号：&quot;</span> + stuNo + <span class="string">&quot;\n所学专业：&quot;</span> + department;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Student</code>类继承自<code>People</code>类，因此，在<code>Student</code>类中同样具有<code>People</code>类的属性和方法，这里重写了父类中的<code>toString()</code>方法。</p>
<p>注意：如果在父类中存在有参的构造方法而并没有重载无参的构造方法，那么在子类中必须含有有参的构造方法，因为如果在子类中不含有构造方法，默认会调用父类中无参的构造方法，而在父类中并没有无参的构造方法，因此会出错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> tYear; <span class="comment">// 教龄</span></span><br><span class="line">  <span class="keyword">private</span> String tDept; <span class="comment">// 所教专业</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, String sex, String sn, <span class="type">int</span> tYear, String tDept)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age, sex, sn); <span class="comment">// 调用父类中的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.tYear = tYear;</span><br><span class="line">    <span class="built_in">this</span>.tDept = tDept;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;\n年龄：&quot;</span> + age + <span class="string">&quot;\n性别:&quot;</span> + sex + <span class="string">&quot;\n身份证号：&quot;</span> + sn + <span class="string">&quot;\n教龄：&quot;</span> + tYear + <span class="string">&quot;\n所教专业：&quot;</span> + tDept;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写测试类<code>PeopleTest</code>，在该类中创建<code>People</code>类的不同对象，分别调用它们的<code>toString()</code>方法，输出不同的信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Student类对象</span></span><br><span class="line">    <span class="type">People</span> <span class="variable">stuPeople</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王丽丽&quot;</span>, <span class="number">23</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;410521198902145589&quot;</span>, <span class="string">&quot;00001&quot;</span>, <span class="string">&quot;计算机应用与技术&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------学生信息---------------------&quot;</span>);</span><br><span class="line">    System.out.println(stuPeople);</span><br><span class="line">    <span class="comment">// 创建Teacher类对象</span></span><br><span class="line">    <span class="type">People</span> <span class="variable">teaPeople</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;张文&quot;</span>, <span class="number">30</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;410521198203128847&quot;</span>, <span class="number">5</span>, <span class="string">&quot;计算机应用与技术&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------教师信息----------------------&quot;</span>);</span><br><span class="line">    System.out.println(teaPeople);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">----------------学生信息---------------------</span><br><span class="line">姓名：王丽丽</span><br><span class="line">年龄：23</span><br><span class="line">性别：女</span><br><span class="line">身份证号：410521198902145589</span><br><span class="line">学号：00001</span><br><span class="line">所学专业：计算机应用与技术</span><br><span class="line">----------------教师信息----------------------</span><br><span class="line">姓名：张文</span><br><span class="line">年龄：30</span><br><span class="line">性别:男</span><br><span class="line">身份证号：410521198203128847</span><br><span class="line">教龄：5</span><br><span class="line">所教专业：计算机应用与技术</span><br></pre></td></tr></table></figure>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，<code>extends</code>关键字后面只能有一个类名。但是它可以有多个间接的父类。</p>
<p>如果定义一个类时并未显式指定这个类的直接父类，则这个类默认继承<code>java.lang.Object</code>类。因此，<code>java.lang.Object</code>类是所有类的父类，要么是其直接父类，要么是其间接父类。因此所有的 Java 对象都可调用<code>java.lang.Object</code>类所定义的实例方法。</p>
<p>使用继承的注意点：</p>
<ul>
<li>子类一般比父类包含更多的属性和方法。</li>
<li>父类中的<code>private</code>成员在子类中是不可见的，因此在子类中不能直接使用它们。</li>
<li>父类和其子类间必须存在“是一个”即<code>is-a</code>的关系，否则不能用继承。但也并不是所有符合<code>is-a</code>关系的都应该用继承。例如，正方形是一个矩形，但不能让正方形类来继承矩形类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是正方形类继承图形类。</li>
<li>Java 只允许单一继承（即一个子类只能有一个直接父类）。</li>
</ul>
<h2 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h2><p>优点：</p>
<ul>
<li>实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。</li>
<li>提高代码维护性和可重用性。</li>
<li>提高代码的可扩展性，更好的实现父类的方法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li>
<li>降低代码灵活性。子类拥有父类的属性和方法后多了些约束。</li>
<li>增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。</li>
</ul>
<h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><p>由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用<code>super</code>关键字。<code>super</code>可以用来访问父类的构造方法、普通方法和属性。</p>
<p><code>super</code>关键字的功能：</p>
<ul>
<li>在子类的构造方法中显式的调用父类构造方法</li>
<li>访问父类的成员方法和变量。</li>
</ul>
<h2 id="super调用父类构造方法"><a href="#super调用父类构造方法" class="headerlink" title="super调用父类构造方法"></a>super调用父类构造方法</h2><p><code>super</code>关键字可以在子类的构造方法中显式地调用父类的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super(parameter-list);</span><br></pre></td></tr></table></figure>
<p>其中，<code>parameter-list</code>指定了父类构造方法中的所有参数。<code>super()</code>必须是在子类构造方法的方法体的第一行。</p>
<p>声明父类<code>Person</code>和子类<code>Student</code>，在<code>Person</code>类中定义一个带有参数的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>会发现<code>Student</code>类出现编译错误，提示必须显式定义构造方法，错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Implicit super constructor Person() is undefined for default constructor. Must define an explicit constructor</span><br></pre></td></tr></table></figure>
<p>在本例中 JVM 默认给<code>Student</code>类加了一个无参构造方法，而在这个方法中默认调用了<code>super()</code>，但是<code>Person</code>类中并不存在该构造方法，所以会编译错误。</p>
<p>如果一个类中没有写任何的构造方法，JVM 会生成一个默认的无参构造方法。在继承关系中，由于在子类的构造方法中，第一条语句默认为调用父类的无参构造方法（即默认为<code>super()</code>，一般这行代码省略了）。所以当在父类中定义了有参构造方法，但是没有定义无参构造方法时，编译器会强制要求我们定义一个相同参数类型的构造方法。</p>
<p>声明父类<code>Person</code>，类中定义两个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类<code>Student</code>继承了<code>Person</code>类，使用<code>super</code>语句来定义<code>Student</code>类的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String birth)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age); <span class="comment">// 调用父类中含有2个参数的构造方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex, String birth)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age, sex); <span class="comment">// 调用父类中含有3个参数的构造方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述<code>Student</code>类构造方法代码可以看出，<code>super</code>可以用来直接调用父类中的构造方法，使编写代码也更加简洁方便。</p>
<p>编译器会自动在子类构造方法的第一句加上<code>super();</code>来调用父类的无参构造方法，必须写在子类构造方法的第一句，也可以省略不写。通过<code>super</code>来调用父类其它构造方法时，只需要把相应的参数传过去。</p>
<h2 id="super访问父类成员"><a href="#super访问父类成员" class="headerlink" title="super访问父类成员"></a>super访问父类成员</h2><p>当子类的成员变量或方法与父类同名时，可以使用<code>super</code>关键字来访问。如果子类重写了父类的某一个方法，即子类和父类有相同的方法定义，但是有不同的方法体，此时，我们可以通过<code>super</code>来调用父类里面的这个方法。</p>
<p>使用<code>super</code>访问父类中的成员与<code>this</code>关键字的使用相似，只不过它引用的是子类的父类，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.member</span><br></pre></td></tr></table></figure>
<p>其中，<code>member</code>是父类中的属性或方法。使用<code>super</code>访问父类的属性和方法时不用位于第一行。</p>
<h2 id="super调用成员属性"><a href="#super调用成员属性" class="headerlink" title="super调用成员属性"></a>super调用成员属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学生年龄：&quot;</span> + <span class="built_in">super</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    stu.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="comment">// 学生年龄：12</span></span><br></pre></td></tr></table></figure>
<h2 id="super调用成员方法"><a href="#super调用成员方法" class="headerlink" title="super调用成员方法"></a>super调用成员方法</h2><p>可以使用<code>super</code>关键字访问父类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">message</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;This is person class&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">message</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;This is student class&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">    message();</span><br><span class="line">    <span class="built_in">super</span>.message();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    s.display();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is student class</span><br><span class="line">This is person class</span><br></pre></td></tr></table></figure>
<h2 id="super和this的区别"><a href="#super和this的区别" class="headerlink" title="super和this的区别"></a>super和this的区别</h2><p><code>this</code>指的是当前对象的引用，<code>super</code>是当前对象的父对象的引用。</p>
<p><code>super</code>关键字的用法：</p>
<ul>
<li><code>super.父类属性名</code>：调用父类中的属性</li>
<li><code>super.父类方法名</code>：调用父类中的方法</li>
<li><code>super()</code>：调用父类的无参构造方法</li>
<li><code>super(参数)</code>：调用父类的有参构造方法</li>
</ul>
<p>如果构造方法的第一行代码不是<code>this()</code>和<code>super()</code>，则系统会默认添加<code>super()</code>。</p>
<p><code>this</code>关键字的用法：</p>
<ul>
<li><code>this.属性名</code>：表示当前对象的属性</li>
<li><code>this.方法名(参数)</code>：表示调用当前对象的方法</li>
</ul>
<p>当局部变量和成员变量发生冲突时，使用<code>this.</code>进行区分。</p>
<p><code>super</code>和<code>this</code>关键字的异同，可简单总结为以下几条。</p>
<ul>
<li>子类和父类中变量或方法名称相同时，用<code>super</code>关键字来访问。可以理解为<code>super</code>是指向自己父类对象的一个指针。在子类中调用父类的构造方法。</li>
<li><code>this</code>是自身的一个对象，代表对象本身，可以理解为<code>this</code>是指向对象本身的一个指针。在同一个类中调用其它方法。</li>
<li><code>this</code>和<code>super</code>不能同时出现在一个构造方法里面，因为<code>this</code>必然会调用其它的构造方法，其它的构造方法中肯定会有<code>super</code>语句的存在，所以在同一个构造方法里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li><code>this()</code>和<code>super()</code>都指的是对象，所以，均不可以在<code>static</code>环境中使用，包括<code>static</code>变量、<code>static</code>方法和<code>static</code>语句块。</li>
<li>从本质上讲，<code>this</code>是一个指向对象本身的指针, 然而<code>super</code>是一个 Java 关键字。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类Animal的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name; <span class="comment">// 动物名字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类Cat的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String aname, String dname)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.name = aname; <span class="comment">// 通过super关键字来访问父类中的name属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = dname; <span class="comment">// 通过this关键字来访问本类中的name属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是&quot;</span> + <span class="built_in">super</span>.name + <span class="string">&quot;，我的名字叫&quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;动物&quot;</span>, <span class="string">&quot;喵星人&quot;</span>);</span><br><span class="line">    System.out.println(cat);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 我是动物，我的名字叫喵星人</span></span><br></pre></td></tr></table></figure>
<h1 id="对象类型转换"><a href="#对象类型转换" class="headerlink" title="对象类型转换"></a>对象类型转换</h1><p>将一个类型强制转换成另一个类型的过程被称为类型转换。对象类型转换，是指存在继承关系的对象，不是任意类型的对象。当对不存在继承关系的对象进行强制类型转换时，会抛出 Java 强制类型转换（<code>java.lang.ClassCastException</code>）异常。</p>
<p>Java 语言允许某个类型的引用变量引用子类的实例，而且可以对这个引用变量进行类型转换。Java 中引用类型之间的类型转换（前提是两个类是父子关系）主要有两种，分别是向上转型和向下转型。</p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>父类引用指向子类对象为向上转型，语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">fatherClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">sonClass</span>();</span><br></pre></td></tr></table></figure>
<p>其中，<code>fatherClass</code>是父类名称或接口名称，<code>obj</code>是创建的对象，<code>sonClass</code>是子类名称。</p>
<p>向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以调用父类类型中的所有成员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现。</p>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>与向上转型相反，子类对象指向父类引用为向下转型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sonClass</span> <span class="variable">obj</span> <span class="operator">=</span> (sonClass) fatherClass;</span><br></pre></td></tr></table></figure>
<p>其中，<code>fatherClass</code>是父类名称，<code>obj</code>是创建的对象，<code>sonClass</code>是子类名称。</p>
<p>向下转型可以调用子类类型中所有的成员，不过需要注意的是如果父类引用对象指向的是子类对象，那么在向下转型的过程中是安全的，也就是编译是不会出错误。但是如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现我们开始提到的 Java 强制类型转换异常，一般使用<code>instanceof</code>运算符来避免出此类错误。</p>
<p>例如，<code>Animal</code>类表示动物类，该类对应的子类有<code>Dog</code>类，使用对象类型表示如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();    <span class="comment">// 向上转型，把Dog类型转换为Animal类型</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal; <span class="comment">// 向下转型，把Animal类型转换为Dog类型</span></span><br></pre></td></tr></table></figure>
<p>例如，父类<code>Animal</code>和子类<code>Cat</code>中都定义了实例变量<code>name</code>、静态变量<code>staticName</code>、实例方法<code>eat()</code>和静态方法<code>staticEat()</code>。此外，子类<code>Cat</code>中还定义了实例变量<code>str</code>和实例方法<code>eatMethod()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 Animal </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Animal：动物&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticName</span> <span class="operator">=</span> <span class="string">&quot;Animal：可爱的动物&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Animal：吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticEat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Animal：动物在吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类 Cat： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Cat：猫&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Cat：可爱的小猫&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticName</span> <span class="operator">=</span> <span class="string">&quot;Dog：我是喵星人&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cat：吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticEat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cat：猫在吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cat：猫喜欢吃鱼&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal; <span class="comment">// 向下转型</span></span><br><span class="line">    System.out.println(animal.name); <span class="comment">// 输出Animal类的name变量</span></span><br><span class="line">    System.out.println(animal.staticName); <span class="comment">// 输出Animal类的staticName变量</span></span><br><span class="line">    animal.eat(); <span class="comment">// 输出Cat类的eat()方法</span></span><br><span class="line">    animal.staticEat(); <span class="comment">// 输出Animal类的staticEat()方法</span></span><br><span class="line">    System.out.println(cat.str); <span class="comment">// 调用Cat类的str变量</span></span><br><span class="line">    cat.eatMethod(); <span class="comment">// 调用Cat类的eatMethod()方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过引用类型变量来访问所引用对象的属性和方法时，Java 虚拟机将采用以下绑定规则：</p>
<ul>
<li>实例方法与引用变量实际引用的对象的方法进行绑定，这种绑定属于动态绑定，因为是在运行时由 Java 虚拟机动态决定的。例如，<code>animal.eat()</code>是将<code>eat()</code>方法与<code>Cat</code>类绑定。</li>
<li>静态方法与引用变量所声明的类型的方法绑定，这种绑定属于静态绑定，因为是在编译阶段已经做了绑定。例如，<code>animal.staticEat()</code>是将<code>staticEat()</code>方法与<code>Animal</code>类进行绑定。</li>
<li>成员变量（包括静态变量和实例变量）与引用变量所声明的类型的成员变量绑定，这种绑定属于静态绑定，因为在编译阶段已经做了绑定。例如，<code>animal.name</code>和<code>animal.staticName</code>都是与<code>Animal</code>类进行绑定。</li>
</ul>
<p>对于<code>Cat</code>类，运行时将会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animal：动物</span><br><span class="line">Animal：可爱的动物</span><br><span class="line">Cat：吃饭</span><br><span class="line">Animal：动物在吃饭</span><br><span class="line">Cat：可爱的小猫</span><br><span class="line">Cat：猫喜欢吃鱼</span><br></pre></td></tr></table></figure>
<h2 id="强制对象类型转换"><a href="#强制对象类型转换" class="headerlink" title="强制对象类型转换"></a>强制对象类型转换</h2><p>Java 编译器允许在具有直接或间接继承关系的类之间进行类型转换。对于向下转型，必须进行强制类型转换；对于向上转型，不必使用强制类型转换。</p>
<p>例如，对于一个引用类型的变量，Java 编译器按照它声明的类型来处理。如果使用<code>animal</code>调用<code>str</code>和<code>eatMethod()</code>方法将会出错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animal.str = <span class="string">&quot;&quot;</span>;    <span class="comment">// 编译出错，提示Animal类中没有str属性</span></span><br><span class="line">animal.eatMethod();    <span class="comment">// 编译出错，提示Animal类中没有eatMethod()方法</span></span><br></pre></td></tr></table></figure>
<p>如果要访问<code>Cat</code>类的成员，必须通过强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((Cat)animal).str = <span class="string">&quot;&quot;</span>;    <span class="comment">// 编译成功</span></span><br><span class="line">((Cat)animal).eatMethod();    <span class="comment">// 编译成功</span></span><br></pre></td></tr></table></figure>
<p>把<code>Animal</code>对象类型强制转换为<code>Cat</code>对象类型，这时上面两句编译成功。对于如下语句，由于使用了强制类型转换，所以也会编译成功：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;    <span class="comment">// 编译成功，将Animal对象类型强制转换为Cat对象类型</span></span><br></pre></td></tr></table></figure>
<p>类型强制转换时想运行成功就必须保证父类引用指向的对象一定是该子类对象，最好使用<code>instanceof</code>运算符判断后，再强转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">  <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal; <span class="comment">// 向下转型</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的对象可以转换成父类类型，而父类的对象实际上无法转换为子类类型。因为通俗地讲，父类拥有的成员子类肯定也有，而子类拥有的成员，父类不一定有。因此，对于向上转型，不必使用强制类型转换。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> cat;    <span class="comment">// 向上转型，不必使用强制类型转换</span></span><br></pre></td></tr></table></figure>
<p>如果两种类型之间没有继承关系，那么将不允许进行类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)dog;    <span class="comment">// 编译出错，不允许把Dog对象类型转换为Cat对象类型</span></span><br></pre></td></tr></table></figure>
<h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><p>Java 允许同一个类中定义多个同名方法，只要它们的形参列表不同即可。如果同一个类中包含了两个或两个以上方法名相同的方法，但形参列表不同，这种情况被称为方法重载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> i)</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> d)</span>&#123;…&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span>&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>它们之间就构成了方法的重载。实际调用时，根据实参的类型来决定调用哪一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">102</span>);    <span class="comment">// 调用println(int i)方法</span></span><br><span class="line">System.out.println(<span class="number">102.25</span>);    <span class="comment">// 调用println(double d)方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;价格为 102.25&quot;</span>);    <span class="comment">// 调用println(String s)方法</span></span><br></pre></td></tr></table></figure>
<p>方法重载的要求是两同一不同：同一个类中方法名相同，参数列表不同。至于方法的其他部分，如方法返回值类型、修饰符等，与方法重载没有任何关系。</p>
<p>使用方法重载其实就是避免出现繁多的方法名，有些方法的功能是相似的，如果重新建立一个方法，重新取个方法名称，会降低程序可读性。</p>
<h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><p>在子类中如果创建了一个与父类中相同名称、相同返回值类型、相同参数列表的方法，只是方法体中的实现不同，以实现不同于父类的功能，这种方式被称为方法重写（override），又称为方法覆盖。当父类中的方法无法满足子类需求或子类具有特有功能的时候，需要方法重写。</p>
<p>子类可以根据需要，定义特定于自己的行为。既沿袭了父类的功能名称，又根据子类的需要重新实现父类方法，从而进行扩展增强。</p>
<p>在重写方法时，需要遵循下面的规则：</p>
<ul>
<li>参数列表必须完全与被重写的方法参数列表相同。</li>
<li>返回的类型必须与被重写的方法的返回类型相同（返回值类型必须小于或者等于父类方法的返回值类型）。</li>
<li>访问权限不能比父类中被重写方法的访问权限更低（<code>public&gt;protected&gt;default&gt;private</code>）。</li>
<li>重写方法一定不能抛出新的检査异常或者比被重写方法声明更加宽泛的检査型异常。例如，父类的一个方法声明了一个检査异常<code>IOException</code>，在重写这个方法时就不能抛出<code>Exception</code>，只能拋出<code>IOException</code>的子类异常，可以抛出非检査异常。</li>
</ul>
<p>另外还要注意以下几条：</p>
<ul>
<li>重写的方法可以使用<code>@Override</code>注解来标识。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为<code>final</code>的方法不能被重写。</li>
<li>声明为<code>static</code>的方法不能被重写，但是能够再次声明。</li>
<li>构造方法不能被重写。</li>
<li>子类和父类在同一个包中时，子类可以重写父类的所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li>
<li>子类和父类不在同一个包中时，子类只能重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
<p>每种动物都有名字和年龄属性，但是喜欢吃的食物是不同的，比如狗喜欢吃骨头、猫喜欢吃鱼等，因此每种动物的介绍方式是不一样的。在父类<code>Animal</code>中定义<code>getInfo()</code>方法，并在子类<code>Cat</code>中重写该方法，实现猫的介绍方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name; <span class="comment">// 名字</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，今年&quot;</span> + age + <span class="string">&quot;岁了。&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String hobby;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age, String hobby)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age);</span><br><span class="line">    <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;喵！大家好！我叫&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;，我今年&quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot;岁了，我爱吃&quot;</span> + hobby + <span class="string">&quot;。&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小白&quot;</span>, <span class="number">2</span>, <span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">    System.out.println(animal.getInfo());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的结果如下：</span></span><br><span class="line">喵！大家好！我叫小白，我今年<span class="number">2</span>岁了，我爱吃鱼。</span><br></pre></td></tr></table></figure>
<p>如果子类中创建了一个成员变量，而该变量的类型和名称都与父类中的同名成员变量相同，我们则称作变量隐藏。</p>
<h1 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h1><p>多态性是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</p>
<p>多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。</p>
<p>实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。</p>
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li>
</ul>
<p>下面通过一个例子来演示重写如何实现多态性。例子使用了类的继承和运行时多态机制，具体步骤如下。</p>
<p>1）创建<code>Figure</code>类，在该类中首先定义存储二维对象的尺寸，然后定义有两个参数的构造方法，最后添加<code>area()</code>方法，该方法计算对象的面积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">  <span class="type">double</span> dim1;</span><br><span class="line">  <span class="type">double</span> dim2;</span><br><span class="line">  Figure(<span class="type">double</span> d1, <span class="type">double</span> d2) &#123;</span><br><span class="line">    <span class="comment">// 有参的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.dim1 = d1;</span><br><span class="line">    <span class="built_in">this</span>.dim2 = d2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 用于计算对象的面积</span></span><br><span class="line">    System.out.println(<span class="string">&quot;父类中计算对象面积的方法，没有实际意义，需要在子类中重写。&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）创建继承自<code>Figure</code>类的<code>Rectangle</code>子类，该类调用父类的构造方法，并且重写父类中的<code>area()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">  Rectangle(<span class="type">double</span> d1, <span class="type">double</span> d2) &#123;</span><br><span class="line">    <span class="built_in">super</span>(d1, d2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;长方形的面积：&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dim1 * <span class="built_in">super</span>.dim2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）创建继承自<code>Figure</code>类的<code>Triangle</code>子类，该类与<code>Rectangle</code>相似。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Figure</span> &#123;</span><br><span class="line">  Triangle(<span class="type">double</span> d1, <span class="type">double</span> d2) &#123;</span><br><span class="line">    <span class="built_in">super</span>(d1, d2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;三角形的面积：&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dim1 * <span class="built_in">super</span>.dim2 / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）创建<code>Test</code>测试类，在该类的<code>main()</code>方法中首先声明<code>Figure</code>类的变量<code>figure</code>，然后分别为<code>figure</code>变量指定不同的对象，并调用这些对象的<code>area()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Figure figure; <span class="comment">// 声明Figure类的变量</span></span><br><span class="line">    figure = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line">    System.out.println(figure.area());</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    figure = <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    System.out.println(figure.area());</span><br><span class="line">    System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    figure = <span class="keyword">new</span> <span class="title class_">Figure</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(figure.area());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以发现，无论<code>figure</code>变量的对象是<code>Rectangle</code>还是<code>Triangle</code>，它们都是<code>Figure</code>类的子类，因此可以向上转型为该类，从而实现多态。</p>
<p>5）输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">长方形的面积：</span><br><span class="line">81.0</span><br><span class="line">===============================</span><br><span class="line">三角形的面积：</span><br><span class="line">24.0</span><br><span class="line">===============================</span><br><span class="line">父类中计算对象面积的方法，没有实际意义，需要在子类中重写。</span><br><span class="line">0.0</span><br></pre></td></tr></table></figure>
<h1 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h1><p><code>instanceof</code>关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure>
<p>其中，<code>obj</code>是一个对象，<code>Class</code>表示一个类或接口。<code>obj</code>是<code>class</code>类（或接口）的实例或者子类实例时，结果<code>result</code>返回<code>true</code>，否则返回<code>false</code>。</p>
<p><code>instanceof</code>关键字的几种用法。</p>
<ol>
<li>声明一个<code>class</code>类的对象，判断<code>obj</code>是否为<code>class</code>类的实例对象（很普遍的一种用法）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span>  Integer);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>声明一个<code>class</code>接口实现类的对象<code>obj</code>，判断<code>obj</code>是否为<code>class</code>接口实现类的实例对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">System.out.println(arrayList <span class="keyword">instanceof</span> List);    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 或者反过来也是返回 true</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">System.out.println(list <span class="keyword">instanceof</span> ArrayList);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><code>obj</code>是<code>class</code>类的直接或间接子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> Man);    <span class="comment">// false</span></span><br><span class="line">System.out.println(p2 <span class="keyword">instanceof</span> Man);    <span class="comment">// true</span></span><br><span class="line">System.out.println(m1 <span class="keyword">instanceof</span> Man);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>值得注意的是<code>obj</code>必须为引用类型，不能是基本类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);    <span class="comment">// 编译不通过</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);    <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>instanceof</code>运算符只能用作对象的判断。</p>
<p>当<code>obj</code>为<code>null</code>时，直接返回<code>false</code>，因为<code>null</code>没有引用任何对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> <span class="literal">null</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>obj</code>的类型必须是引用类型或空类型，否则会编译错误。</p>
<p>当<code>class</code>为<code>null</code>时，会发生编译错误，所以<code>class</code>只能是类或者接口。</p>
<p>编译器会检查<code>obj</code>能否转换成右边的<code>class</code>类型，如果不能转换则直接报错，如果不能确定类型，则通过编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> String);    <span class="comment">// 编译报错</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List);    <span class="comment">// false</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List&lt;?&gt;);    <span class="comment">// false</span></span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> List&lt;Person&gt;);    <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>Person</code>的对象<code>p1</code>很明显不能转换为<code>String</code>对象，那么<code>p1 instanceof String</code>不能通过编译，但<code>p1 instanceof List</code>却能通过编译，而<code>instanceof List&lt;Person&gt;</code>又不能通过编译了。</p>
<p>可以理解成以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> result;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">  result = <span class="literal">false</span>;    <span class="comment">// 当obj为null时，直接返回false</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 判断obj是否可以强制转换为T</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> (T) obj; </span><br><span class="line">    result = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">    result = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>T</code>不为<code>null</code>和<code>obj</code>不为<code>null</code>时，如果<code>obj</code>可以转换为<code>T</code>而不引发异常（<code>ClassCastException</code>），则该表达式值为<code>true</code>，否则值为<code>false</code>。所以对于上面提出的问题就很好理解了，<code>p1 instanceof String</code>会编译报错，是因为<code>(String) p1</code>是不能通过编译的，而<code>(List) p1</code>可以通过编译。</p>
<p><code>instanceof</code>也经常和三目（条件）运算符一起使用，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A instanceof B ? A : C</span><br></pre></td></tr></table></figure>
<p>判断<code>A</code>是否可以转换为<code>B</code>，如果可以转换返回<code>A</code>，不可以转换则返回<code>C</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">animalCall</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">tip</span> <span class="operator">=</span> <span class="string">&quot;这个动物不是牛！&quot;</span>;</span><br><span class="line">    <span class="comment">// 判断参数a是不是Cow的对象</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">instanceof</span> Cow ? (Cow) a : tip;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Sheep</span> <span class="variable">sh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sheep</span>();</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    System.out.println(test.animalCall(sh));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cow</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Test</code>类的<code>main</code>函数中创建类<code>Sheep</code>的对象作为形参传递到<code>animalCall</code>方法中，因为<code>Sheep</code>类的对象不能转换为<code>Cow</code>类型，所以输出结果为“这个动物不是牛！”。</p>
<h1 id="抽象（abstract）类"><a href="#抽象（abstract）类" class="headerlink" title="抽象（abstract）类"></a>抽象（abstract）类</h1><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，那么这样的类称为抽象类。</p>
<p>抽象类的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">abstract</span>&gt; class &lt;class_name&gt; &#123;</span><br><span class="line">  &lt;<span class="keyword">abstract</span>&gt;&lt;type&gt;&lt;method_name&gt;(parameter-iist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>abstract</code>表示该类或该方法是抽象的；<code>class_name</code>表示抽象类的名称；<code>method_name</code>表示抽象方法名称，<code>parameter-list</code>表示方法参数列表。</p>
<p>如果一个方法使用<code>abstract</code>来修饰，则说明该方法是抽象方法，抽象方法只有声明没有实现。需要注意的是<code>abstract</code>关键字只能用于普通方法，不能用于<code>static</code>方法或者构造方法中。</p>
<p>抽象方法的 3 个特征如下：</p>
<ul>
<li>抽象方法没有方法体</li>
<li>抽象方法必须存在于抽象类中</li>
<li>子类重写父类时，必须重写父类所有的抽象方法</li>
</ul>
<p>注意：在使用<code>abstract</code>关键字修饰抽象方法时不能使用<code>private</code>修饰，因为抽象方法必须被子类重写，而如果使用了<code>private</code>声明，则子类是无法重写的。</p>
<p>抽象类的定义和使用规则如下：</p>
<ul>
<li>抽象类和抽象方法都要使用<code>abstract</code>关键字声明。</li>
<li>如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的。而一个抽象类中，可以有<code>0~n</code>个抽象方法，以及<code>0~n</code>个具体方法。</li>
<li>抽象类不能实例化，也就是不能使用<code>new</code>关键字创建对象。</li>
</ul>
<p>不同几何图形的面积计算公式是不同的，但是它们具有的特性是相同的，都具有长和宽这两个属性，也都具有面积计算的方法。那么可以定义一个抽象类，在该抽象类中含有两个属性和一个抽象方法<code>area()</code>，具体步骤如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> width; <span class="comment">// 几何图形的长</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> height; <span class="comment">// 几何图形的宽</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>; <span class="comment">// 定义抽象方法，计算面积</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(width, height);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写父类中的抽象方法，实现计算正方形面积的功能</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Triangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(width, height);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写父类中的抽象方法，实现计算三角形面积的功能</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * width * height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 创建正方形类对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;正方形的面积为：&quot;</span> + square.area());</span><br><span class="line">    <span class="type">Triangle</span> <span class="variable">triangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">// 创建三角形类对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;三角形的面积为：&quot;</span> + triangle.area());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该程序中，创建了 4 个类，分别为图形类<code>Shape</code>、正方形类<code>Square</code>、三角形类<code>Triangle</code>和测试类<code>ShapeTest</code>。其中图形类<code>Shape</code>是一个抽象类，创建了两个属性，分别为图形的长度和宽度，并通过构造方法<code>Shape()</code>给这两个属性赋值。</p>
<p>在<code>Shape</code>类的最后定义了一个抽象方法<code>area()</code>，用来计算图形的面积。在这里，<code>Shape</code>类只是定义了计算图形面积的方法，而对于如何计算并没有任何限制。也可以这样理解，抽象类<code>Shape</code>仅定义了子类的一般形式。</p>
<p>输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正方形的面积为：20.0</span><br><span class="line">三角形的面积为：5.0</span><br></pre></td></tr></table></figure>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>抽象类是从多个类中抽象出来的模板，如果将这种抽象进行的更彻底，则可以提炼出一种更加特殊的“抽象类”——接口（<code>Interface</code>）。它可以被理解为一种特殊的类，不同的是接口的成员没有执行体，是由全局常量和公共的抽象方法所组成。</p>
<h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>接口定义使用的关键字是<code>interface</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">interface</span> <span class="title class_">interface_name</span> [<span class="keyword">extends</span> <span class="title class_">interface1_name</span>[, interface2_name,…]] &#123;</span><br><span class="line">  <span class="comment">// 接口体，其中可以包含定义常量和声明方法</span></span><br><span class="line">  [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] <span class="type">type</span> <span class="variable">constant_name</span> <span class="operator">=</span> value;    <span class="comment">// 定义常量</span></span><br><span class="line">  [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] returnType <span class="title function_">method_name</span><span class="params">(parameter_list)</span>;    <span class="comment">// 声明方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对以上语法的说明如下：</p>
<ul>
<li><code>public</code>表示接口的修饰符，当没有修饰符时，则使用默认的修饰符，此时该接口的访问权限仅局限于所属的包；</li>
<li><code>interface_name</code>表示接口的名称。接口名只要是合法的标识符即可。</li>
<li><code>extends</code>表示接口的继承关系；</li>
<li><code>interface1_name</code>表示要继承的接口名称；</li>
<li><code>constant_name</code>表示变量名称，一般是<code>static</code>和<code>final</code>型的；</li>
<li><code>returnType</code>表示方法的返回值类型；</li>
<li><code>parameter_list</code>表示参数列表，在接口中的方法是没有方法体的。</li>
</ul>
<p>注意：一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</p>
<p>接口对于其声明、变量和方法都做了许多限制，这些限制作为接口的特征归纳如下：</p>
<ul>
<li>具有<code>public</code>访问控制符的接口，允许任何类使用；没有指定<code>public</code>的接口，其访问将局限于所属的包。</li>
<li>方法的声明不需要其他修饰符，在接口中声明的方法，将隐式地声明为公有的（<code>public</code>）和抽象的（<code>abstract</code>）。</li>
<li>在接口中声明的变量其实都是常量，接口中的变量声明，将隐式地声明为<code>public static final</code>，即常量，所以接口中定义的变量必须初始化。</li>
<li>接口没有构造方法，不能被实例化。</li>
<li>一个接口不能够实现另一个接口，但它可以继承多个其他接口。子接口可以对父接口的方法和常量进行重写。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentInterface</span> <span class="keyword">extends</span> <span class="title class_">PeopleInterface</span> &#123;</span><br><span class="line">  <span class="comment">// 接口 StudentInterface 继承 PeopleInterface</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;    <span class="comment">// 常量age重写父接口中的age常量</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>;    <span class="comment">// 方法getInfo()重写父接口中的getInfo()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;    <span class="comment">// 接口myInterface</span></span><br><span class="line">  String name;    <span class="comment">// 不合法，变量name必须初始化</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;    <span class="comment">// 合法，等同于 public static final int age = 20;</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span>;    <span class="comment">// 方法声明，等同于 public abstract void getInfo();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>接口的主要用途就是被实现类实现，一个类可以实现一个或多个接口，继承使用<code>extends</code>关键字，实现接口则使用<code>implements</code>关键字。类实现接口的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">public</span>&gt; class &lt;class_name&gt; [<span class="keyword">extends</span> <span class="title class_">superclass_name</span>] [<span class="keyword">implements</span> <span class="title class_">interface1_name</span>[, interface2_name…]] &#123;</span><br><span class="line">  <span class="comment">// 主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对以上语法的说明如下：</p>
<ul>
<li><code>public</code>：类的修饰符；</li>
<li><code>superclass_name</code>：需要继承的父类名称；</li>
<li><code>interface1_name</code>：要实现的接口名称。</li>
</ul>
<p>实现接口需要注意以下几点：</p>
<ul>
<li>实现接口与继承父类相似，一样可以获得所实现接口里定义的常量和方法。如果一个类需要实现多个接口，则多个接口之间以逗号分隔。</li>
<li>一个类可以继承一个父类，并同时实现多个接口，<code>implements</code>部分必须放在<code>extends</code>部分之后。</li>
<li>一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMath</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>;    <span class="comment">// 完成两个数的相加</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxNum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;    <span class="comment">// 获取较大的数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathClass</span> <span class="keyword">implements</span> <span class="title class_">IMath</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> num1;    <span class="comment">// 第 1 个操作数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> num2;    <span class="comment">// 第 2 个操作数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MathClass</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.num1 = num1;</span><br><span class="line">    <span class="built_in">this</span>.num2 = num2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现接口中的求和方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现接口中的获取较大数的方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxNum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现类中，所有的方法都使用了<code>public</code>访问修饰符声明。无论何时实现一个由接口定义的方法，它都必须实现为<code>public</code>，因为接口中的所有成员都显式声明为<code>public</code>。</p>
<p>最后创建测试类<code>NumTest</code>，实例化接口的实现类<code>MathClass</code>，调用该类中的方法并输出结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建实现类的对象</span></span><br><span class="line">    <span class="type">MathClass</span> <span class="variable">calc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathClass</span>(<span class="number">100</span>, <span class="number">300</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;100 和 300 相加结果是：&quot;</span> + calc.sum());</span><br><span class="line">    System.out.println(<span class="string">&quot;100 比较 300，哪个大：&quot;</span> + calc.maxNum(<span class="number">100</span>, <span class="number">300</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 和 300 相加结果是：400</span><br><span class="line">100 比较 300，哪个大：300</span><br></pre></td></tr></table></figure>
<p>在该程序中，首先定义了一个<code>IMath</code>的接口，在该接口中只声明了两个未实现的方法，这两个方法需要在接口的实现类中实现。在实现类<code>MathClass</code>中定义了两个私有的属性，并赋予两个属性初始值，同时创建了该类的构造方法。因为该类实现了<code>MathClass</code>接口，因此必须实现接口中的方法。在最后的测试类中，需要创建实现类对象，然后通过实现类对象调用实现类中的方法。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/以太网"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/"
    >以太网</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/" class="article-date">
  <time datetime="2020-09-18T03:32:13.000Z" itemprop="datePublished">2020-09-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>有线局域网中普遍使用以太网，以太网标准简单，传输速率高。</p>
<h2 id="以太网数据格式"><a href="#以太网数据格式" class="headerlink" title="以太网数据格式"></a>以太网数据格式</h2><p>当今最常用的以太网协议标准是 ETHERNET II 标准。 ETHERNET II 标准定义的数据帧格式如下图。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/3.png" class="">

<ul>
<li>前导码（<code>Preamble</code>）<br>前导码由 7 个字节组成，每个字节固定为<code>10101010</code>。之后的 1 个字节称为帧起始定界符，这个字节固定为 10101011。这 8 个字节表示以太网帧的开始，也是对端网卡能够确保与其同步的标志。帧起始定界符的最后两位比特被定义为 11，之后就是以太网数据帧的本体。<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/4.png" class=""></li>
<li>目的地址<br>目的地址由 6 个字节组成，用来标识数据帧的目的设备，类似于快递的收件人地址。</li>
<li>源地址<br>源地址由 6 个字节组成，用来标识数据帧的始发设备，类似于快递的发件人地址。</li>
<li>类型<br>类型字段由 2 个字节组成。类型字段是表明上一层（即网络层）的协议类型，可以让接收方使用相同的协议进行数据帧的解封装。</li>
<li>数据<br>帧头后就是数据。一个数据帧所能容纳的最大数据范围是 46 ～ 1500 个字节。如果数据部分不足 46 个字节，则填充这个数据帧，让它的长度可以满足最小长度的要求。</li>
<li>FCS（<code>Frame Check Sequence</code>）<br>FCS 由 4 个字节组成，位于数据帧的尾部，用来检查帧是否有所损坏。通过检查 FCS 字段的值将受到噪声干扰的错误帧丢弃。</li>
</ul>
<p>数据帧的各字段加起来一共是 64 字节，其中数据是 46 字节。再加上前导码就是 72 字节。因此最小的数据帧是 72 字节。在传输过程中，每个数据帧还有 12 字节的数据帧间隙，所以最小的可传输数据帧长度是 84 字节，即 672 比特。</p>
<h2 id="以太网数据帧类型"><a href="#以太网数据帧类型" class="headerlink" title="以太网数据帧类型"></a>以太网数据帧类型</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单播数据帧</td>
<td align="center">目的地址是广播和组播以外的数据帧</td>
</tr>
<tr>
<td align="center">广播数据帧</td>
<td align="center">目的地址是广播地址 (ff:ff:ff:ff) 的数据帧</td>
</tr>
<tr>
<td align="center">组播数据帧</td>
<td align="center">目的地址是组播地址的数据帧</td>
</tr>
<tr>
<td align="center">不完全帧</td>
<td align="center">包含头部、长度为63字节及以下的数据帧，由于冲突等原因形成的坏帧</td>
</tr>
<tr>
<td align="center">小巨人帧</td>
<td align="center">比 1518 字节稍大的数据帧，通常是指 1522 字节的数据帧</td>
</tr>
<tr>
<td align="center">巨型帧</td>
<td align="center">比 1518 字节大很多的数据帧</td>
</tr>
</tbody></table>
<h1 id="以太网标准"><a href="#以太网标准" class="headerlink" title="以太网标准"></a>以太网标准</h1><p>以太网原本是指使用 CSMA&#x2F;CD 的控制方式，实际速率为<code>10Mbit/s</code>的标准。随着技术的迭代，速率为<code>100Mbit/s</code>的快速以太网和速率为<code>1Gbit/s</code>的千兆以太网逐步登场。从快速以太网开始，采用了全双工通信方式，而不是 CSMA&#x2F;CD 技术的以太网。</p>
<p>到千兆以太网，半双工通信中还保留了 CSMA&#x2F;CD 技术规范。到了万兆以太网，就彻底移除 CSMA&#x2F;CD 规范，所有通信方式都采用全双工方式。</p>
<h2 id="以太网的分类"><a href="#以太网的分类" class="headerlink" title="以太网的分类"></a>以太网的分类</h2><img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/1.png" class="">

<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>IEEE 802.3 标准根据使用的传输线缆和传输速度的不同，有 10BASE-T、10BASE-TX 等名称。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/2.png" class="">

<p>IEEE 802.3 定义的链路速率：</p>
<table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">传输速率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1Mbit&#x2F;s</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10MBit&#x2F;s</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">100MBit&#x2F;s</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="center">1GBit&#x2F;s</td>
</tr>
<tr>
<td align="center">10G</td>
<td align="center">10GBit&#x2F;s</td>
</tr>
<tr>
<td align="center">40G</td>
<td align="center">40GBit&#x2F;s</td>
</tr>
<tr>
<td align="center">100G</td>
<td align="center">100GBit&#x2F;s</td>
</tr>
</tbody></table>
<p>IEEE 802.3 定义的调制方式：</p>
<table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">调制方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BASE</td>
<td align="center">BaseBand（基带信号），1 根线缆只传输 1 个信号</td>
</tr>
<tr>
<td align="center">BROAD</td>
<td align="center">BroadBand（宽频信号），1 根线缆能传输多个信号</td>
</tr>
</tbody></table>
<p>IEEE 802.3 定义的传输媒介：</p>
<table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">传输介质</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5</td>
<td align="center">最长为 500 米的粗同轴电缆</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">最长为 185 米的细同轴电缆</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">Twisted Pair，双绞线</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">Fiber，光纤</td>
</tr>
<tr>
<td align="center">K</td>
<td align="center">Copper Backplane，由铜线组成的背板</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">Bi-directional，1 芯单模光缆</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">Short Reach(100m)，2 芯多模光缆</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">Long Reach(10km)，2 芯单模或多模光缆</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">Extended Long Reach(40km)，2 芯单模光缆</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">Long Reach Simple Mode(70km)，2 芯单模光缆</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">Co-axial，2 芯平衡式屏蔽同轴线缆</td>
</tr>
<tr>
<td align="center">P</td>
<td align="center">PON，1 芯单模光缆，单点到多点</td>
</tr>
</tbody></table>
<p>IEEE 802.3 定义的编码体系：</p>
<table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">编码体系</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">在快速以太网时使用 4B&#x2F;5B 作为分组码 <br>在千兆以太网时使用8B&#x2F;10B 作为分组码</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">使用 64B&#x2F;66B 作为分组码</td>
</tr>
</tbody></table>
<p>IEEE 802.3 定义的lane：</p>
<table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">编码体系</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4 或者 10</td>
<td align="center">在同轴线缆中表示使用 4 个或 10 个 lane</td>
</tr>
<tr>
<td align="center">N(任意数字)</td>
<td align="center">在光纤中，lane 还可以表示波长数量，波长为 1 时可以省略</td>
</tr>
</tbody></table>
<h2 id="10Mbit-x2F-s-以太网的主要标准"><a href="#10Mbit-x2F-s-以太网的主要标准" class="headerlink" title="10Mbit&#x2F;s 以太网的主要标准"></a>10Mbit&#x2F;s 以太网的主要标准</h2><table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">制定时间</th>
<th align="center">IEEE 标准</th>
<th align="center">传输速率</th>
<th align="center">编码</th>
<th align="center">传输介质</th>
<th align="center">最大传输距离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10BASE5</td>
<td align="center">1983年</td>
<td align="center">IEEE 802.3</td>
<td align="center">10MBit&#x2F;s</td>
<td align="center">曼彻斯特</td>
<td align="center">粗同轴电缆</td>
<td align="center">500m</td>
</tr>
<tr>
<td align="center">10BASE2</td>
<td align="center">1988年</td>
<td align="center">IEEE 802.3a</td>
<td align="center">10MBit&#x2F;s</td>
<td align="center">曼彻斯特</td>
<td align="center">细同轴电缆</td>
<td align="center">185m</td>
</tr>
<tr>
<td align="center">10BASE-T</td>
<td align="center">1990年</td>
<td align="center">IEEE 802.3i</td>
<td align="center">10MBit&#x2F;s</td>
<td align="center">曼彻斯特</td>
<td align="center">双绞线</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">10BASE-F</td>
<td align="center">1993年</td>
<td align="center">IEEE 802.3j</td>
<td align="center">10MBit&#x2F;s</td>
<td align="center">曼彻斯特</td>
<td align="center">光纤</td>
<td align="center">2km</td>
</tr>
</tbody></table>
<h2 id="快速以太网的主要标准"><a href="#快速以太网的主要标准" class="headerlink" title="快速以太网的主要标准"></a>快速以太网的主要标准</h2><table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">制定时间</th>
<th align="center">IEEE 标准</th>
<th align="center">传输速率</th>
<th align="center">编码</th>
<th align="center">传输介质</th>
<th align="center">最大传输距离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100BASE-T</td>
<td align="center">1995年</td>
<td align="center">IEEE 802.3u</td>
<td align="center">100MBit&#x2F;s</td>
<td align="center">无</td>
<td align="center">双绞线</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">100BASE-TX</td>
<td align="center">1995年</td>
<td align="center">IEEE 802.3u</td>
<td align="center">100MBit&#x2F;s</td>
<td align="center">4B5B&#x2F;MLT-3</td>
<td align="center">双绞线<br>(2对5类)</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">100BASE-T4</td>
<td align="center">1995年</td>
<td align="center">IEEE 802.3u</td>
<td align="center">100MBit&#x2F;s</td>
<td align="center">8B6T&#x2F;PAM-3</td>
<td align="center">双绞线<br>(4对3类)</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">100BASE-FX</td>
<td align="center">1995年</td>
<td align="center">IEEE 802.3u</td>
<td align="center">100MBit&#x2F;s</td>
<td align="center">4B&#x2F;5B NRZI</td>
<td align="center">光缆<br>(MMF)</td>
<td align="center">400m(半双工)<br>2km(全双工)</td>
</tr>
<tr>
<td align="center">100BAEE-T2</td>
<td align="center">1998年</td>
<td align="center">IEEE 802.3y</td>
<td align="center">100MBit&#x2F;s</td>
<td align="center">PAM5x5</td>
<td align="center">双绞线<br>(2对3类)</td>
<td align="center">100m</td>
</tr>
</tbody></table>
<p>100BASE-T 是 100BASE-TX、100BASE-T4、100BASE-T2 的统称。目前 100BASE-T4、100BASE-T2 不再使用，主要使用 100BASE-TX。</p>
<h2 id="千兆以太网的主要标准"><a href="#千兆以太网的主要标准" class="headerlink" title="千兆以太网的主要标准"></a>千兆以太网的主要标准</h2><table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">制定时间</th>
<th align="center">IEEE 标准</th>
<th align="center">传输速率</th>
<th align="center">编码</th>
<th align="center">传输介质</th>
<th align="center">最大传输距离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000BASE-SX</td>
<td align="center">1998年</td>
<td align="center">IEEE 802.3z</td>
<td align="center">1GBit&#x2F;s</td>
<td align="center">8B10B&#x2F;NRZ</td>
<td align="center">MMF(波长850nm)</td>
<td align="center">500m</td>
</tr>
<tr>
<td align="center">1000BASE-LX</td>
<td align="center">1998年</td>
<td align="center">IEEE 802.3z</td>
<td align="center">1GBit&#x2F;s</td>
<td align="center">8B10B&#x2F;NRZ</td>
<td align="center">MMF(波长1300nm)<br>SMF(波长1310nm)</td>
<td align="center">550m<br>5km</td>
</tr>
<tr>
<td align="center">1000BASE-ZX</td>
<td align="center">1998年</td>
<td align="center">IEEE 802.3z</td>
<td align="center">1GBit&#x2F;s</td>
<td align="center">8B10B&#x2F;NRZ</td>
<td align="center">SMF(波长1550nm)</td>
<td align="center">70~100km</td>
</tr>
<tr>
<td align="center">1000BASE-CX</td>
<td align="center">1998年</td>
<td align="center">IEEE 802.3z</td>
<td align="center">1GBit&#x2F;s</td>
<td align="center">8B10B&#x2F;NRZ</td>
<td align="center">150Ω平衡屏蔽双绞线</td>
<td align="center">25m</td>
</tr>
<tr>
<td align="center">1000BASE-T</td>
<td align="center">1999年</td>
<td align="center">IEEE 802.3ab</td>
<td align="center">1GBit&#x2F;s</td>
<td align="center">8B1Q4&#x2F;4D-PAM5</td>
<td align="center">双绞线(4对超5类)</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">1000BASE-TX</td>
<td align="center">2001年</td>
<td align="center">TIA&#x2F;EIA-854</td>
<td align="center">1GBit&#x2F;s</td>
<td align="center">8B1Q4&#x2F;4D-PAM5</td>
<td align="center">双绞线(4对6类)</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">1000BASE-BX</td>
<td align="center">2004年</td>
<td align="center">IEEE 802.3ah</td>
<td align="center">1GBit&#x2F;s</td>
<td align="center">8B10B&#x2F;NRZ</td>
<td align="center">SMF(下行1490nm，上行1310nm)</td>
<td align="center">10km</td>
</tr>
</tbody></table>
<h2 id="万兆以太网的主要标准"><a href="#万兆以太网的主要标准" class="headerlink" title="万兆以太网的主要标准"></a>万兆以太网的主要标准</h2><table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">制定时间</th>
<th align="center">IEEE 标准</th>
<th align="center">传输速率</th>
<th align="center">编码</th>
<th align="center">传输介质</th>
<th align="center">最大传输距离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10GBASE-SR</td>
<td align="center">2022年</td>
<td align="center">IEEE 802.3ae</td>
<td align="center">10GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">MMF(LAN PHY) 850nm</td>
<td align="center">300m</td>
</tr>
<tr>
<td align="center">10GBASE-LR</td>
<td align="center">2022年</td>
<td align="center">IEEE 802.3ae</td>
<td align="center">10GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">SMF(LAN PHY) 1310nm</td>
<td align="center">10km</td>
</tr>
<tr>
<td align="center">10GBASE-ER</td>
<td align="center">2022年</td>
<td align="center">IEEE 802.3ae</td>
<td align="center">10GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">SMF(LAN PHY) 1550nm</td>
<td align="center">40km</td>
</tr>
<tr>
<td align="center">10GBASE-SW</td>
<td align="center">2022年</td>
<td align="center">IEEE 802.3ae</td>
<td align="center">10GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B WIS</td>
<td align="center">MMF(WAN PHY)</td>
<td align="center">300m</td>
</tr>
<tr>
<td align="center">10GBASE-LW</td>
<td align="center">2022年</td>
<td align="center">IEEE 802.3ae</td>
<td align="center">10GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B WIS</td>
<td align="center">SMF(WAN PHY)</td>
<td align="center">10km</td>
</tr>
<tr>
<td align="center">10GBASE-EW</td>
<td align="center">2022年</td>
<td align="center">IEEE 802.3ae</td>
<td align="center">10GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B WIS</td>
<td align="center">SMF(WAN PHY)</td>
<td align="center">40km</td>
</tr>
<tr>
<td align="center">10GBASE-T</td>
<td align="center">2022年</td>
<td align="center">IEEE 802.3an</td>
<td align="center">10GBit&#x2F;s</td>
<td align="center">LDPC</td>
<td align="center">UTP&#x2F;STP(6类)</td>
<td align="center">100m</td>
</tr>
</tbody></table>
<p>WIS ，广域网接口子层的简称。LDPC ，低密度奇偶校验码的简称。</p>
<h2 id="40G-x2F-100G-以太网的主要标准"><a href="#40G-x2F-100G-以太网的主要标准" class="headerlink" title="40G&#x2F;100G 以太网的主要标准"></a>40G&#x2F;100G 以太网的主要标准</h2><table>
<thead>
<tr>
<th align="center">条目</th>
<th align="center">制定时间</th>
<th align="center">IEEE 标准</th>
<th align="center">传输速率</th>
<th align="center">编码</th>
<th align="center">传输介质</th>
<th align="center">最大传输距离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">40GBASE-KR4</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">40GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">背板</td>
<td align="center">1m</td>
</tr>
<tr>
<td align="center">40GBASE-CR4</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">40GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">同轴线缆</td>
<td align="center">10m</td>
</tr>
<tr>
<td align="center">40GBASE-SR4</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">40GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">MMF</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">40GBASE-LR4</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">40GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">SMF</td>
<td align="center">10km</td>
</tr>
<tr>
<td align="center">100GBASE-CR10</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">100GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">同轴线缆</td>
<td align="center">10m</td>
</tr>
<tr>
<td align="center">100GBASE-SR10</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">100GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">MMF</td>
<td align="center">100m</td>
</tr>
<tr>
<td align="center">100GBASE-LR4</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">100GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">SMF</td>
<td align="center">10km</td>
</tr>
<tr>
<td align="center">100GBASE-ER4</td>
<td align="center">2010年</td>
<td align="center">IEEE 802.3ba</td>
<td align="center">100GBit&#x2F;s</td>
<td align="center">64B&#x2F;66B</td>
<td align="center">SMF</td>
<td align="center">40km</td>
</tr>
</tbody></table>
<h1 id="以太网标准的数据处理"><a href="#以太网标准的数据处理" class="headerlink" title="以太网标准的数据处理"></a>以太网标准的数据处理</h1><p>以太网采用小端顺序方式传输比特流，也就是说 1 个字节（<code>8bit</code>）的数据，会从最低位开始传送，将每<code>8bit</code>数据中的 0 与 1 顺序颠倒进行传送。FDDI 以及令牌环等网络，则采用大端顺序进行传输数据。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/5.png" class="">

<p>在网络上进行传输的二进制数据使用的字节排列顺序也叫做网络字节序。TCP&#x2F;IP 协议中都使用大端顺序开始传送数据。</p>
<h1 id="碰撞域"><a href="#碰撞域" class="headerlink" title="碰撞域"></a>碰撞域</h1><p>碰撞域又称为冲突域，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</p>
<p>碰撞域越大，发生碰撞的概率越高。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img24.png" class="">

<h1 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h1><p>扩展以太网更常用的方法是在数据链路层进行。早期使用网桥，现在使用以太网交换机。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img25.png" class="">

<h2 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h2><p>以太网交换机实质上就是一个多接口的网桥。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</p>
<p>以太网交换机具有并行性。能同时连通多对接口，使多对主机能同时通信。相互通信的主机都是独占传输媒体，无碰撞地传输数据。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img26.png" class="">

<p>以太网交换机的每个接口是一个碰撞域。</p>
<p>以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。</p>
<p>以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。</p>
<p>以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</p>
<p>以太网交换机的性能远远超过普通的集线器，而且价格并不贵。</p>
<h2 id="以太网交换机的优点"><a href="#以太网交换机的优点" class="headerlink" title="以太网交换机的优点"></a>以太网交换机的优点</h2><ul>
<li>用户独享带宽，增加了总容量。</li>
<li>从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。</li>
<li>以太网交换机一般都具有多种速率的接口，方便了各种不同情况的用户。</li>
</ul>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img6.png" class="">

<h2 id="以太网交换机的自学习功能"><a href="#以太网交换机的自学习功能" class="headerlink" title="以太网交换机的自学习功能"></a>以太网交换机的自学习功能</h2><p>以太网交换机运行自学习算法自动维护交换表。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img7.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img8.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img9.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img10.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img11.png" class="">

<p>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</p>
<h2 id="交换机自学习和转发帧的步骤归纳"><a href="#交换机自学习和转发帧的步骤归纳" class="headerlink" title="交换机自学习和转发帧的步骤归纳"></a>交换机自学习和转发帧的步骤归纳</h2><img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img12.png" class="">

<h2 id="理解以太网交换机的自学习功能"><a href="#理解以太网交换机的自学习功能" class="headerlink" title="理解以太网交换机的自学习功能"></a>理解以太网交换机的自学习功能</h2><img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img13.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img14.png" class="">

<h2 id="交换机使用了生成树协议"><a href="#交换机使用了生成树协议" class="headerlink" title="交换机使用了生成树协议"></a>交换机使用了生成树协议</h2><p>IEEE 802.1D 标准制定了一个生成树协议 STP(<code>Spanning Tree Protocol</code>)。</p>
<p>其要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img15.png" class="">

<h2 id="从总线以太网到星形以太网"><a href="#从总线以太网到星形以太网" class="headerlink" title="从总线以太网到星形以太网"></a>从总线以太网到星形以太网</h2><p>早期，以太网采用无源的总线结构。现在，采用以太网交换机的星形结构成为以太网的首选拓扑。</p>
<p>总线以太网使用 CSMA&#x2F;CD 协议，以半双工方式工作。</p>
<p>以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA&#x2F;CD 协议，以全双工方式工作。但仍然采用以太网的帧结构。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img16.png" class="">

<p>局域网存在的以下几个方面的问题：扩展性、、安全性、可管理性等。</p>
<p>所有计算机都处于同一个碰撞域（或冲突域）中和同一个广播域中。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img17.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img18.png" class="">

<h2 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h2><p>广播域（<code>broadcast domain</code>）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p>
<p>采用以太网交换机的星形以太网，每个接口都处于一个独立的碰撞域（或冲突域）中，但所有计算机都处于同一个广播域中。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img19.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img20.png" class="">

<h1 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h1><p>利用以太网交换机可以很方便地实现虚拟局域网 VLAN(<code>Virtual LAN</code>)。</p>
<p>IEEE 802.1Q 对虚拟局域网 VLAN 的定义：虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</p>
<p>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</p>
<p>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img21.png" class="">

<p>10 台计算机划分为三个虚拟局域网：VLAN1, VLAN2 和 VLAN3。</p>
<p>每个虚拟局域网是一个广播域。VLAN1, VLAN2 和 VLAN3 是三个不同的广播域。</p>
<p>当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到其广播的信息。</p>
<p>B1 发送数据时，VLAN1 和 VLAN3 中的工作站 A1，A2 和 C1 等都不会收到 B1 发出的广播信息。</p>
<p>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息 (即“广播风暴”) 而引起性能恶化。</p>
<p>虚拟局域网（VLAN）技术具有以下主要优点：改善了性能、简化了管理、降低了成本、改善了安全性。</p>
<h2 id="划分虚拟局域网的方法"><a href="#划分虚拟局域网的方法" class="headerlink" title="划分虚拟局域网的方法"></a>划分虚拟局域网的方法</h2><ul>
<li>基于交换机端口的方法：最简单、也是最常用的方法。属于在第一层划分虚拟局域网的方法。缺点：不允许用户移动。</li>
<li>基于计算机网卡的MAC地址的方法：根据用户计算机的MAC地址划分虚拟局域网。属于在第二层划分虚拟局域网的方法。允许用户移动。缺点：需要输入和管理大量的MAC地址。如果用户的MAC地址改变了，则需要管理员重新配置VLAN。</li>
<li>基于协议类型的方法：根据以太网帧的第三个字段“类型”字段确定该类型的协议属于哪一个虚拟局域网。属于在第二层划分虚拟局域网的方法。</li>
<li>基于IP子网地址的方法：根据以太网帧的第三个字段“类型”字段和IP分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网。属于在第三层划分虚拟局域网的方法。</li>
<li>基于高层应用或服务的方法：根据高层应用或服务、或者它们的组合划分虚拟局域网。更加灵活，但更加复杂。</li>
</ul>
<h2 id="虚拟局域网使用的以太网帧格式"><a href="#虚拟局域网使用的以太网帧格式" class="headerlink" title="虚拟局域网使用的以太网帧格式"></a>虚拟局域网使用的以太网帧格式</h2><p>IEEE 批准了 802.3ac 标准，该标准定义了以太网的帧格式的扩展，以支持虚拟局域网。</p>
<p>虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为 VLAN 标记，用来指明该帧属于哪一个虚拟局域网。</p>
<p>插入VLAN标记得出的帧称为 802.1Q 帧或带标记的以太网帧。</p>
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img22.png" class="">
<img src="/2020/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%A5%E5%A4%AA%E7%BD%91/img23.png" class=""> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/18/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/20/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>