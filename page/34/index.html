<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/js/基础/JS Navigator对象、Screen对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/01/09/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20Navigator%E5%AF%B9%E8%B1%A1%E3%80%81Screen%E5%AF%B9%E8%B1%A1/"
    >JS Navigator对象、Screen对象</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/01/09/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20Navigator%E5%AF%B9%E8%B1%A1%E3%80%81Screen%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2019-01-09T13:01:25.000Z" itemprop="datePublished">2019-01-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>window.navigator</code>属性指向一个包含浏览器和系统信息的<code>Navigator</code>对象。脚本通过这个属性了解用户的环境信息。</p>
<h1 id="Navigator-对象的属性"><a href="#Navigator-对象的属性" class="headerlink" title="Navigator 对象的属性"></a>Navigator 对象的属性</h1><h2 id="Navigator-userAgent"><a href="#Navigator-userAgent" class="headerlink" title="Navigator.userAgent"></a>Navigator.userAgent</h2><p><code>navigator.userAgent</code>属性返回浏览器的<code>User Agent</code>字符串，表示浏览器的厂商和版本信息。</p>
<p>下面是 Chrome 浏览器的<code>userAgent</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">userAgent</span></span><br><span class="line"><span class="comment">// &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>userAgent</code>属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器了，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。</p>
<p>不过，通过<code>userAgent</code>可以大致准确地识别手机浏览器，方法就是测试是否包含<code>mobi</code>字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ua = navigator.<span class="property">userAgent</span>.<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="regexp">/mobi/i</span>.<span class="title function_">test</span>(ua)) &#123;</span><br><span class="line">  <span class="comment">// 手机浏览器</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 非手机浏览器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要识别所有移动设备的浏览器，可以测试更多的特征字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mobi|android|touch|mini/i.<span class="title function_">test</span>(ua)</span><br></pre></td></tr></table></figure>
<h2 id="Navigator-plugins"><a href="#Navigator-plugins" class="headerlink" title="Navigator.plugins"></a>Navigator.plugins</h2><p><code>Navigator.plugins</code>属性返回一个类似数组的对象，成员是<code>Plugin</code>实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pluginsLength = navigator.<span class="property">plugins</span>.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pluginsLength; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">filename</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">description</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(navigator.<span class="property">plugins</span>[i].<span class="property">version</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Navigator-platform"><a href="#Navigator-platform" class="headerlink" title="Navigator.platform"></a>Navigator.platform</h2><p><code>Navigator.platform</code>属性返回用户的操作系统信息，比如<code>MacIntel</code>、<code>Win32</code>、<code>Linux x86_64</code>等 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">platform</span> <span class="comment">// &quot;Linux x86_64&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Navigator-onLine"><a href="#Navigator-onLine" class="headerlink" title="Navigator.onLine"></a>Navigator.onLine</h2><p><code>navigator.onLine</code>属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">onLine</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的<code>onLine</code>属性会返回<code>true</code>，所以不能假定只要是<code>true</code>，用户就一定能访问互联网。不过，如果是<code>false</code>，可以断定用户一定离线。</p>
<p>用户变成在线会触发<code>online</code>事件，变成离线会触发<code>offline</code>事件，可以通过<code>window.ononline</code>和<code>window.onoffline</code>指定这两个事件的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;offline&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;offline&#x27;</span>); &#125;);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;online&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;online&#x27;</span>); &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Navigator-language，Navigator-languages"><a href="#Navigator-language，Navigator-languages" class="headerlink" title="Navigator.language，Navigator.languages"></a>Navigator.language，Navigator.languages</h2><p><code>Navigator.language</code>属性返回一个字符串，表示浏览器的首选语言。该属性只读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">language</span> <span class="comment">// &quot;en&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Navigator.languages</code>属性返回一个数组，表示用户可以接受的语言。<code>Navigator.language</code>总是这个数组的第一个成员。HTTP 请求头信息的<code>Accept-Language</code>字段，就来自这个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">languages</span>  <span class="comment">// [&quot;en-US&quot;, &quot;en&quot;, &quot;zh-CN&quot;, &quot;zh&quot;, &quot;zh-TW&quot;]</span></span><br></pre></td></tr></table></figure>
<p>如果这个属性发生变化，就会在<code>window</code>对象上触发<code>languagechange</code>事件。</p>
<h2 id="Navigator-geolocation"><a href="#Navigator-geolocation" class="headerlink" title="Navigator.geolocation"></a>Navigator.geolocation</h2><p><code>Navigator.geolocation</code>属性返回一个<code>Geolocation</code>对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用，否则调用下面方法时会报错。</p>
<p><code>Geolocation</code>对象提供下面三个方法。</p>
<ul>
<li><code>Geolocation.getCurrentPosition()</code>：得到用户的当前位置</li>
<li><code>Geolocation.watchPosition()</code>：监听用户位置变化</li>
<li><code>Geolocation.clearWatch()</code>：取消<code>watchPosition()</code>方法指定的监听函数</li>
</ul>
<p>注意，调用这三个方法时，浏览器会跳出一个对话框，要求用户给予授权。</p>
<h2 id="Navigator-cookieEnabled"><a href="#Navigator-cookieEnabled" class="headerlink" title="Navigator.cookieEnabled"></a>Navigator.cookieEnabled</h2><p><code>Navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">cookieEnabled</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。用户可以设置某个网站不得储存 Cookie，这时<code>cookieEnabled</code>返回的还是<code>true</code>。</p>
<h1 id="Navigator-对象的方法"><a href="#Navigator-对象的方法" class="headerlink" title="Navigator 对象的方法"></a>Navigator 对象的方法</h1><h2 id="Navigator-javaEnabled"><a href="#Navigator-javaEnabled" class="headerlink" title="Navigator.javaEnabled()"></a>Navigator.javaEnabled()</h2><p><code>Navigator.javaEnabled()</code>方法返回一个布尔值，表示浏览器是否能运行 Java Applet 小程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">javaEnabled</span>() <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="Navigator-sendBeacon"><a href="#Navigator-sendBeacon" class="headerlink" title="Navigator.sendBeacon()"></a>Navigator.sendBeacon()</h2><p><code>Navigator.sendBeacon()</code>方法用于向服务器异步发送数据。</p>
<h1 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h1><p>Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。<code>window.screen</code>属性指向这个对象。<br>该对象有下面的属性。</p>
<ul>
<li><code>Screen.height</code>：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li>
<li><code>Screen.width</code>：浏览器窗口所在的屏幕的宽度（单位像素）。</li>
<li><code>Screen.availHeight</code>：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于<code>height</code>减去那些被系统组件的高度。</li>
<li><code>Screen.availWidth</code>：浏览器窗口可用的屏幕宽度（单位像素）。</li>
<li><code>Screen.pixelDepth</code>：整数，表示屏幕的色彩位数，比如<code>24</code>表示屏幕提供24位色彩。</li>
<li><code>Screen.colorDepth</code>：<code>Screen.pixelDepth</code>的别名。严格地说，<code>colorDepth</code>表示应用程序的颜色深度，<code>pixelDepth</code>表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。</li>
<li><code>Screen.orientation</code>：返回一个对象，表示屏幕的方向。该对象的<code>type</code>属性是一个字符串，表示屏幕的具体方向，<code>landscape-primary</code>表示横放，<code>landscape-secondary</code>表示颠倒的横放，<code>portrait-primary</code>表示竖放，<code>portrait-secondary</code>。</li>
</ul>
<p>下面是<code>Screen.orientation</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">orientation</span></span><br><span class="line"><span class="comment">// &#123; angle: 0, type: &quot;landscape-primary&quot;, onchange: null &#125;</span></span><br></pre></td></tr></table></figure>
<p>下面的例子保证屏幕分辨率大于 1024 x 768。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">width</span> &gt;= <span class="number">1024</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">height</span> &gt;= <span class="number">768</span>) &#123;</span><br><span class="line">  <span class="comment">// 分辨率不低于 1024x768</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是根据屏幕的宽度，将用户导向不同网页的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((screen.<span class="property">width</span> &lt;= <span class="number">800</span>) &amp;&amp; (screen.<span class="property">height</span> &lt;= <span class="number">600</span>)) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&#x27;small.html&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">replace</span>(<span class="string">&#x27;wide.html&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS window对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/01/06/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20window%E5%AF%B9%E8%B1%A1/"
    >JS window对象</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/01/06/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20window%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2019-01-06T12:55:28.000Z" itemprop="datePublished">2019-01-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>浏览器里面，<code>window</code>对象（注意，<code>w</code>为小写）指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。</p>
<p><code>window</code>有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把<code>window</code>对象当作顶层对象，所有未声明就赋值的变量都自动变成<code>window</code>对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。</p>
<h1 id="window-对象的属性"><a href="#window-对象的属性" class="headerlink" title="window 对象的属性"></a>window 对象的属性</h1><h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p><code>window.name</code>属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的<code>target</code>属性使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>) <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
<p>该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p>
<p>只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问<code>a.com</code>时，该页面的脚本设置了<code>window.name</code>，接下来在同一个窗口里面载入了<code>b.com</code>，新页面的脚本可以读到上一个网页设置的<code>window.name</code>。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。</p>
<h2 id="window-closed，window-opener"><a href="#window-closed，window-opener" class="headerlink" title="window.closed，window.opener"></a>window.closed，window.opener</h2><p><code>window.closed</code>属性返回一个布尔值，表示窗口是否关闭。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">closed</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码检查当前窗口是否关闭。这种检查意义不大，因为只要能运行代码，当前窗口肯定没有关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((popup !== <span class="literal">null</span>) &amp;&amp; !popup.<span class="property">closed</span>) &#123;</span><br><span class="line">  <span class="comment">// 窗口仍然打开着</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>window.opener</code>属性表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>().<span class="property">opener</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面表达式会打开一个新窗口，然后返回<code>true</code>。</p>
<p>如果两个窗口之间不需要通信，建议将子窗口的<code>opener</code>属性显式设为<code>null</code>，这样可以减少一些安全隐患。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;example.html&#x27;</span>, <span class="string">&#x27;newWindow&#x27;</span>, <span class="string">&#x27;height=400,width=400&#x27;</span>);</span><br><span class="line">newWin.<span class="property">opener</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子窗口的<code>opener</code>属性设为<code>null</code>，两个窗口之间就没办法再联系了。</p>
<p>通过<code>opener</code>属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况，且其中一个窗口由另一个打开。<code>&lt;a&gt;</code>元素添加<code>rel=&quot;noopener&quot;</code>属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://an.evil.site&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener&quot;</span>&gt;</span></span><br><span class="line">恶意网站</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="window-self，window-window"><a href="#window-self，window-window" class="headerlink" title="window.self，window.window"></a>window.self，window.window</h2><p><code>window.self</code>和<code>window.window</code>属性都指向窗口本身。这两个属性只读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">self</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">window</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="window-frames，window-length"><a href="#window-frames，window-length" class="headerlink" title="window.frames，window.length"></a>window.frames，window.length</h2><p><code>window.frames</code>属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括<code>frame</code>元素和<code>iframe</code>元素。<code>window.frames[0]</code>表示页面中第一个框架窗口。</p>
<p>如果<code>iframe</code>元素设置了<code>id</code>或<code>name</code>属性，那么就可以用属性值，引用这个<code>iframe</code>窗口。比如<code>&lt;iframe name=&quot;myIFrame&quot;&gt;</code>可以用<code>frames[&#39;myIFrame&#39;]</code>或者<code>frames.myIFrame</code>来引用。</p>
<p><code>frames</code>属性实际上是<code>window</code>对象的别名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，<code>frames[0]</code>也可以用<code>window[0]</code>表示。但是，从语义上看，<code>frames</code>更清晰，而且考虑到<code>window</code>还是全局对象，因此推荐表示多窗口时，总是使用<code>frames[0]</code>的写法。</p>
<p><code>window.length</code>属性返回当前网页包含的框架总数。如果当前网页不包含<code>frame</code>和<code>iframe</code>元素，那么<code>window.length</code>就返回<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">frames</span>.<span class="property">length</span> === <span class="variable language_">window</span>.<span class="property">length</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>window.frames.length</code>与<code>window.length</code>应该是相等的。</p>
<h2 id="window-frameElement"><a href="#window-frameElement" class="headerlink" title="window.frameElement"></a>window.frameElement</h2><p><code>window.frameElement</code>属性主要用于当前窗口嵌在另一个网页的情况（嵌入<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>或<code>&lt;embed&gt;</code>元素），返回当前窗口所在的那个元素节点。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;iframe src=&quot;about.html&quot;&gt;&lt;/iframe&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的脚本在 about.html 里面</span></span><br><span class="line"><span class="keyword">var</span> frameEl = <span class="variable language_">window</span>.<span class="property">frameElement</span>;</span><br><span class="line"><span class="keyword">if</span> (frameEl) &#123;</span><br><span class="line">  frameEl.<span class="property">src</span> = <span class="string">&#x27;other.html&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>frameEl</code>变量就是<code>&lt;iframe&gt;</code>元素。</p>
<h2 id="window-top，window-parent"><a href="#window-top，window-parent" class="headerlink" title="window.top，window.parent"></a>window.top，window.parent</h2><p><code>window.top</code>属性指向最顶层窗口，主要用于在框架窗口（<code>frame</code>）里面获取顶层窗口。</p>
<p><code>window.parent</code>属性指向父窗口。如果当前窗口没有父窗口，<code>window.parent</code>指向自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">parent</span> !== <span class="variable language_">window</span>.<span class="property">top</span>) &#123;</span><br><span class="line">  <span class="comment">// 表明当前窗口嵌入不止一层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于不包含框架的网页，这两个属性等同于<code>window</code>对象。</p>
<h2 id="window-status"><a href="#window-status" class="headerlink" title="window.status"></a>window.status</h2><p><code>window.status</code>属性用于读写浏览器状态栏的文本。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</p>
<h2 id="window-devicePixelRatio"><a href="#window-devicePixelRatio" class="headerlink" title="window.devicePixelRatio"></a>window.devicePixelRatio</h2><p><code>window.devicePixelRatio</code>属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。也就是说，它表示一个 CSS 像素由多少个物理像素组成。它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。</p>
<h2 id="位置大小属性"><a href="#位置大小属性" class="headerlink" title="位置大小属性"></a>位置大小属性</h2><p>以下属性返回<code>window</code>对象的位置信息和大小信息。</p>
<h4 id="window-screenX，window-screenY"><a href="#window-screenX，window-screenY" class="headerlink" title="window.screenX，window.screenY"></a>window.screenX，window.screenY</h4><p><code>window.screenX</code>和<code>window.screenY</code>属性，返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</p>
<h4 id="window-innerHeight，window-innerWidth"><a href="#window-innerHeight，window-innerWidth" class="headerlink" title="window.innerHeight，window.innerWidth"></a>window.innerHeight，window.innerWidth</h4><p><code>window.innerHeight</code>和<code>window.innerWidth</code>属性，返回网页在当前窗口中可见部分的高度和宽度，即“视口”（<code>viewport</code>）的大小（单位像素）。这两个属性只读。</p>
<p>用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是960像素），只是每个像素占据的屏幕空间变大了，因为可见部分（视口）就变小了。</p>
<p>注意，这两个属性值包括滚动条的高度和宽度。</p>
<h4 id="window-outerHeight，window-outerWidth"><a href="#window-outerHeight，window-outerWidth" class="headerlink" title="window.outerHeight，window.outerWidth"></a>window.outerHeight，window.outerWidth</h4><p><code>window.outerHeight</code>和<code>window.outerWidth</code>属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</p>
<h4 id="window-scrollX，window-scrollY"><a href="#window-scrollX，window-scrollY" class="headerlink" title="window.scrollX，window.scrollY"></a>window.scrollX，window.scrollY</h4><p><code>window.scrollX</code>属性返回页面的水平滚动距离，<code>window.scrollY</code>属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。</p>
<p>注意，这两个属性的返回值不是整数，而是双精度浮点数。如果页面没有滚动，它们的值就是<code>0</code>。</p>
<p>举例来说，如果用户向下拉动了垂直滚动条75像素，那么<code>window.scrollY</code>就是75左右。用户水平向右拉动水平滚动条200像素，<code>window.scrollX</code>就是200左右。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">scrollY</span> &lt; <span class="number">75</span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scroll</span>(<span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果页面向下滚动的距离小于75像素，那么页面向下滚动75像素。</p>
<h4 id="window-pageXOffset，window-pageYOffset"><a href="#window-pageXOffset，window-pageYOffset" class="headerlink" title="window.pageXOffset，window.pageYOffset"></a>window.pageXOffset，window.pageYOffset</h4><p><code>window.pageXOffset</code>属性和<code>window.pageYOffset</code>属性，是<code>window.scrollX</code>和<code>window.scrollY</code>别名。</p>
<h2 id="组件属性"><a href="#组件属性" class="headerlink" title="组件属性"></a>组件属性</h2><p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p>
<ul>
<li><code>window.locationbar</code>：地址栏对象</li>
<li><code>window.menubar</code>：菜单栏对象</li>
<li><code>window.scrollbars</code>：窗口的滚动条对象</li>
<li><code>window.toolbar</code>：工具栏对象</li>
<li><code>window.statusbar</code>：状态栏对象</li>
<li><code>window.personalbar</code>：用户安装的个人工具栏对象</li>
</ul>
<p>这些对象的<code>visible</code>属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">locationbar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">menubar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">scrollbars</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">toolbar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">statusbar</span>.<span class="property">visible</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">personalbar</span>.<span class="property">visible</span></span><br></pre></td></tr></table></figure>
<h2 id="全局对象属性"><a href="#全局对象属性" class="headerlink" title="全局对象属性"></a>全局对象属性</h2><p>全局对象属性指向一些浏览器原生的全局对象。</p>
<ul>
<li><code>window.document</code>：指向<code>document</code>对象。注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。</li>
<li><code>window.location</code>：指向<code>Location</code>对象，用于获取当前窗口的 URL 信息。它等同于<code>document.location</code>属性。</li>
<li><code>window.navigator</code>：指向<code>Navigator</code>对象，用于获取环境信息。</li>
<li><code>window.history</code>：指向<code>History</code>对象，表示浏览器的浏览历史。</li>
<li><code>window.localStorage</code>：指向本地储存的<code>localStorage</code>数据。</li>
<li><code>window.sessionStorage</code>：指向本地储存的<code>sessionStorage</code>数据。</li>
<li><code>window.console</code>：指向<code>console</code>对象，用于操作控制台。</li>
<li><code>window.screen</code>：指向<code>Screen</code>对象，表示屏幕信息。</li>
</ul>
<h2 id="window-isSecureContext"><a href="#window-isSecureContext" class="headerlink" title="window.isSecureContext"></a>window.isSecureContext</h2><p><code>window.isSecureContext</code>属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是<code>true</code>，否则就是<code>false</code>。</p>
<h1 id="window-对象的方法"><a href="#window-对象的方法" class="headerlink" title="window 对象的方法"></a>window 对象的方法</h1><h2 id="window-alert-，window-prompt-，window-confirm"><a href="#window-alert-，window-prompt-，window-confirm" class="headerlink" title="window.alert()，window.prompt()，window.confirm()"></a>window.alert()，window.prompt()，window.confirm()</h2><p><code>window.alert()</code>、<code>window.prompt()</code>、<code>window.confirm()</code>都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p>
<h4 id="window-alert"><a href="#window-alert" class="headerlink" title="window.alert()"></a>window.alert()</h4><p><code>window.alert()</code>方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。<br><code>window.alert()</code>方法的参数只能是字符串，没法使用 CSS 样式，但是可以用<code>\n</code>指定换行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;本条提示\n分成两行&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="window-prompt"><a href="#window-prompt" class="headerlink" title="window.prompt()"></a>window.prompt()</h4><p><code>window.prompt()</code>方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title function_">prompt</span>(<span class="string">&#x27;您的年龄？&#x27;</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码会跳出一个对话框，文字提示为“您的年龄？”，要求用户在对话框中输入自己的年龄（默认显示25）。用户填入的值，会作为返回值存入变量<code>result</code>。</p>
<p><code>window.prompt()</code>的返回值有两种情况，可能是字符串（有可能是空字符串），也有可能是<code>null</code>。具体分成三种情况。</p>
<ol>
<li>用户输入信息，并点击“确定”，则用户输入的信息就是返回值。</li>
<li>用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。</li>
<li>用户点击了“取消”（或者按了 ESC 按钮），则返回值是<code>null</code>。</li>
</ol>
<p><code>window.prompt()</code>方法的第二个参数是可选的，但是最好总是提供第二个参数，作为输入框的默认值。</p>
<h4 id="window-confirm"><a href="#window-confirm" class="headerlink" title="window.confirm()"></a>window.confirm()</h4><p><code>window.confirm()</code>方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title function_">confirm</span>(<span class="string">&#x27;你最近好吗？&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码弹出一个对话框，上面只有一行文字“你最近好吗？”，用户选择点击“确定”或“取消”。</p>
<p><code>confirm</code>方法返回一个布尔值，如果用户点击“确定”，返回<code>true</code>；如果用户点击“取消”，则返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> okay = <span class="title function_">confirm</span>(<span class="string">&#x27;Please confirm this message.&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (okay) &#123;</span><br><span class="line">  <span class="comment">// 用户按下“确定”</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 用户按下“取消”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>confirm</code>的一个用途是，用户离开当前页面时，弹出一个对话框，问用户是否真的要离开。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onunload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;你确定要离开当面页面吗？&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。</p>
<h2 id="window-open-window-close-，window-stop"><a href="#window-open-window-close-，window-stop" class="headerlink" title="window.open(), window.close()，window.stop()"></a>window.open(), window.close()，window.stop()</h2><h4 id="window-open"><a href="#window-open" class="headerlink" title="window.open()"></a>window.open()</h4><p><code>window.open</code>方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;somefile.html&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码会让浏览器弹出一个新建窗口，网址是当前域名下的<code>somefile.html</code>。</p>
<p><code>open</code>方法一共可以接受三个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(url, windowName, [windowFeatures])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是<code>about:blank</code>。</li>
<li><code>windowName</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用<code>_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code>_self</code>表示当前窗口，<code>_top</code>表示顶层窗口，<code>_parent</code>表示上一层窗口。</li>
<li><code>windowFeatures</code>：字符串，内容为逗号分隔的键值对（详见下文），表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(</span><br><span class="line">  <span class="string">&#x27;somepage.html&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;DefinitionsWindows&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码表示，打开的新窗口高度和宽度都为200像素，没有地址栏，但有状态栏和滚动条，允许用户调整大小。</p>
<p>第三个参数可以设定如下属性。</p>
<ul>
<li><code>left</code>：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。</li>
<li><code>top</code>：新窗口距离屏幕最顶部的距离（单位像素）。</li>
<li><code>height</code>：新窗口内容区域的高度（单位像素），不得小于100。</li>
<li><code>width</code>：新窗口内容区域的宽度（单位像素），不得小于100。</li>
<li><code>outerHeight</code>：整个浏览器窗口的高度（单位像素），不得小于100。</li>
<li><code>outerWidth</code>：整个浏览器窗口的宽度（单位像素），不得小于100。</li>
<li><code>menubar</code>：是否显示菜单栏。</li>
<li><code>toolbar</code>：是否显示工具栏。</li>
<li><code>location</code>：是否显示地址栏。</li>
<li><code>personalbar</code>：是否显示用户自己安装的工具栏。</li>
<li><code>status</code>：是否显示状态栏。</li>
<li><code>dependent</code>：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。</li>
<li><code>minimizable</code>：是否有最小化按钮，前提是<code>dialog=yes</code>。</li>
<li><code>noopener</code>：新窗口将与父窗口切断联系，即新窗口的<code>window.opener</code>属性返回<code>null</code>，父窗口的<code>window.open()</code>方法也返回<code>null</code>。</li>
<li><code>resizable</code>：新窗口是否可以调节大小。</li>
<li><code>scrollbars</code>：是否允许新窗口出现滚动条。</li>
<li><code>dialog</code>：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。</li>
<li><code>titlebar</code>：新窗口是否显示标题栏。</li>
<li><code>alwaysRaised</code>：是否显示在所有窗口的顶部。</li>
<li><code>alwaysLowered</code>：是否显示在父窗口的底下。</li>
<li><code>close</code>：新窗口是否显示关闭按钮。</li>
</ul>
<p>对于那些可以打开和关闭的属性，设为<code>yes</code>或<code>1</code>或不设任何值就表示打开，比如<code>status=yes</code>、<code>status=1</code>、<code>status</code>都会得到同样的结果。如果想设为关闭，不用写<code>no</code>，而是直接省略这个属性即可。也就是说，如果在第三个参数中设置了一部分属性，其他没有被设置的<code>yes/no</code>属性都会被设成<code>no</code>，只有<code>titlebar</code>和关闭按钮除外（它们的值默认为<code>yes</code>）。</p>
<p>上面这些属性，属性名与属性值之间用等号连接，属性与属性之间用逗号分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;height=200,width=200,location=no,status=yes,resizable=yes,scrollbars=yes&#x27;</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>open()</code>方法的第二个参数虽然可以指定已经存在的窗口，但是不等于可以任意控制其他窗口。为了防止被不相干的窗口控制，浏览器只有在两个窗口同源，或者目标窗口被当前网页打开的情况下，才允许<code>open</code>方法指向该窗口。</p>
<p><code>window.open</code>方法返回新窗口的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> windowB = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;windowB.html&#x27;</span>, <span class="string">&#x27;WindowB&#x27;</span>);</span><br><span class="line">windowB.<span class="property">window</span>.<span class="property">name</span> <span class="comment">// &quot;WindowB&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，如果新窗口和父窗口不是同源的（即不在同一个域），它们彼此不能获取对方窗口对象的内部属性。<br>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = <span class="variable language_">window</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;已经打开新窗口&#x27;</span>);</span><br><span class="line">w.<span class="property">location</span> = <span class="string">&#x27;http://example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码先打开一个新窗口，然后在该窗口弹出一个对话框，再将网址导向<code>example.com</code>。</p>
<p>由于<code>open</code>这个方法很容易被滥用，许多浏览器默认都不允许脚本自动新建窗口。只允许在用户点击链接或按钮时，脚本做出反应，弹出新窗口。因此，有必要检查一下打开新窗口是否成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="keyword">if</span> (popup === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 新建窗口失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="window-close"><a href="#window-close" class="headerlink" title="window.close()"></a>window.close()</h4><p><code>window.close</code>方法用于关闭当前窗口，一般只用来关闭<code>window.open</code>方法新建的窗口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popup.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure>
<p>该方法只对顶层窗口有效，<code>iframe</code>框架之中的窗口使用该方法无效。</p>
<h4 id="window-stop"><a href="#window-stop" class="headerlink" title="window.stop()"></a>window.stop()</h4><p><code>window.stop()</code>方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">stop</span>()</span><br></pre></td></tr></table></figure>
<h2 id="window-moveTo-，window-moveBy"><a href="#window-moveTo-，window-moveBy" class="headerlink" title="window.moveTo()，window.moveBy()"></a>window.moveTo()，window.moveBy()</h2><p><code>window.moveTo()</code>方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码将窗口移动到屏幕<code>(100, 200)</code>的位置。</p>
<p><code>window.moveBy</code>方法将窗口移动到一个相对位置。它接受两个参数，分布是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveBy</span>(<span class="number">25</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码将窗口向右移动25像素、向下移动50像素。</p>
<p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用<code>window.open</code>方法新建的，并且它所在的 Tab 页是当前窗口里面唯一的。除此以外的情况，使用上面两个方法都是无效的。</p>
<h2 id="window-resizeTo-，window-resizeBy"><a href="#window-resizeTo-，window-resizeBy" class="headerlink" title="window.resizeTo()，window.resizeBy()"></a>window.resizeTo()，window.resizeBy()</h2><p><code>window.resizeTo()</code>方法用于缩放窗口到指定大小。</p>
<p>它接受两个参数，第一个是缩放后的窗口宽度（<code>outerWidth</code>属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code>outerHeight</code>属性）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">resizeTo</span>(</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availWidth</span> / <span class="number">2</span>,</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availHeight</span> / <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面代码将当前窗口缩放到，屏幕可用区域的一半宽度和高度。</p>
<p><code>window.resizeBy()</code>方法用于缩放窗口。它与<code>window.resizeTo()</code>的区别是，它按照相对的量缩放，<code>window.resizeTo()</code>需要给出缩放后的绝对大小。</p>
<p>它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">resizeBy</span>(-<span class="number">200</span>, -<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码将当前窗口的宽度和高度，都缩小200像素。</p>
<h2 id="window-scrollTo-，window-scroll-，window-scrollBy"><a href="#window-scrollTo-，window-scroll-，window-scrollBy" class="headerlink" title="window.scrollTo()，window.scroll()，window.scrollBy()"></a>window.scrollTo()，window.scroll()，window.scrollBy()</h2><p><code>window.scrollTo</code>方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(x-coord, y-coord)</span><br></pre></td></tr></table></figure>
<p>它也可以接受一个配置对象作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(options)</span><br></pre></td></tr></table></figure>
<p>配置对象<code>options</code>有三个属性。</p>
<ul>
<li><code>top</code>：滚动后页面左上角的垂直坐标，即<code>y</code>坐标。</li>
<li><code>left</code>：滚动后页面左上角的水平坐标，即<code>x</code>坐标。</li>
<li><code>behavior</code>：字符串，表示滚动的方式，有三个可能值（<code>smooth</code>、<code>instant</code>、<code>auto</code>），默认值为<code>auto</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>window.scroll()</code>方法是<code>window.scrollTo()</code>方法的别名。</p>
<p><code>window.scrollBy()</code>方法用于将网页滚动指定距离（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码用于将网页向下滚动一屏。</p>
<p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p>
<ul>
<li><code>Element.scrollTop</code></li>
<li><code>Element.scrollLeft</code></li>
<li><code>Element.scrollIntoView()</code></li>
</ul>
<h2 id="window-print"><a href="#window-print" class="headerlink" title="window.print()"></a>window.print()</h2><p><code>window.print</code>方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p>
<p>常见的打印按钮代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;printLink&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非桌面设备（比如手机）可能没有打印功能，这时可以这样判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">print</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 支持打印功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="window-focus-，window-blur"><a href="#window-focus-，window-blur" class="headerlink" title="window.focus()，window.blur()"></a>window.focus()，window.blur()</h2><p><code>window.focus()</code>方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;popup.html&#x27;</span>, <span class="string">&#x27;Popup Window&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((popup !== <span class="literal">null</span>) &amp;&amp; !popup.<span class="property">closed</span>) &#123;</span><br><span class="line">  popup.<span class="title function_">focus</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码先检查<code>popup</code>窗口是否依然存在，确认后激活该窗口。</p>
<p><code>window.blur()</code>方法将焦点从窗口移除。</p>
<p>当前窗口获得焦点时，会触发<code>focus</code>事件；当前窗口失去焦点时，会触发<code>blur</code>事件。</p>
<h2 id="window-getSelection"><a href="#window-getSelection" class="headerlink" title="window.getSelection()"></a>window.getSelection()</h2><p><code>window.getSelection</code>方法返回一个<code>Selection</code>对象，表示用户现在选中的文本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selObj = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>();</span><br></pre></td></tr></table></figure>
<p>使用<code>Selection</code>对象的<code>toString</code>方法可以得到选中的文本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedText = selObj.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>
<h2 id="window-getComputedStyle-，window-matchMedia"><a href="#window-getComputedStyle-，window-matchMedia" class="headerlink" title="window.getComputedStyle()，window.matchMedia()"></a>window.getComputedStyle()，window.matchMedia()</h2><p><code>window.getComputedStyle()</code>方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象。<br><code>window.matchMedia()</code>方法用来检查 CSS 的<code>mediaQuery</code>语句。</p>
<h2 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame()"></a>window.requestAnimationFrame()</h2><p><code>window.requestAnimationFrame()</code>方法跟<code>setTimeout</code>类似，都是推迟某个函数的执行。不同之处在于，<code>setTimeout</code>必须指定推迟的时间，<code>window.requestAnimationFrame()</code>则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code>requestAnimationFrame()</code>会暂停执行。</p>
<p>如果某个函数会改变网页的布局，一般就放在<code>window.requestAnimationFrame()</code>里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p>
<p>该方法接受一个回调函数作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(callback)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>callback</code>是一个回调函数。<code>callback</code>执行时，它的参数就是系统传入的一个高精度时间戳（<code>performance.now()</code>的返回值），单位是毫秒，表示距离网页加载的时间。</p>
<p><code>window.requestAnimationFrame()</code>的返回值是一个整数，这个整数可以传入<code>window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p>
<p>下面是一个<code>window.requestAnimationFrame()</code>执行网页动画的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;animate&#x27;</span>);</span><br><span class="line">element.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;absolute&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> start = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!start) start = timestamp;</span><br><span class="line">  <span class="keyword">var</span> progress = timestamp - start;</span><br><span class="line">  <span class="comment">// 元素不断向左移，最大不超过200像素</span></span><br><span class="line">  element.<span class="property">style</span>.<span class="property">left</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(progress / <span class="number">10</span>, <span class="number">200</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// 如果距离第一次执行不超过 2000 毫秒，</span></span><br><span class="line">  <span class="comment">// 就继续执行动画</span></span><br><span class="line">  <span class="keyword">if</span> (progress &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个网页动画，持续时间是2秒，会让元素向右移动。</p>
<h2 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h2><p><code>window.requestIdleCallback()</code>跟<code>setTimeout</code>类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用<code>window.requestIdleCallback()</code>将其推迟执行，以保证网页性能。</p>
<p>它跟<code>window.requestAnimationFrame()</code>的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；<code>window.requestIdleCallback()</code>可以保证回调函数在系统资源空闲时执行。</p>
<p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空虚，都会执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(callback[, options])</span><br></pre></td></tr></table></figure>
<p><code>callback</code>参数是一个回调函数。该回调函数执行时，系统会传入一个<code>IdleDeadline</code>对象作为参数。<code>IdleDeadline</code>对象有一个<code>didTimeout</code>属性（布尔值，表示是否为超时调用）和一个<code>timeRemaining()</code>方法（返回该空闲时段剩余的毫秒数）。</p>
<p><code>options</code>参数是一个配置对象，目前只有<code>timeout</code>一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p>
<p><code>window.requestIdleCallback()</code>方法返回一个整数。该整数可以传入<code>window.cancelIdleCallback()</code>取消回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(myNonEssentialWork);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNonEssentialWork</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">doWorkIfNeeded</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>requestIdleCallback()</code>用来执行非关键任务<code>myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p>
<p>下面是指定<code>timeout</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">requestIdleCallback</span>(processPendingAnalyticsEvents, &#123; <span class="attr">timeout</span>: <span class="number">2000</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码指定，<code>processPendingAnalyticsEvents</code>必须在未来2秒之内执行。</p>
<p>如果由于超时导致回调函数执行，则<code>deadline.timeRemaining()</code>返回<code>0</code>，<code>deadline.didTimeout</code>返回<code>true</code>。</p>
<p>如果多次执行<code>window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><code>window</code>对象可以接收以下事件。</p>
<h2 id="load-事件和-onload-属性"><a href="#load-事件和-onload-属性" class="headerlink" title="load 事件和 onload 属性"></a>load 事件和 onload 属性</h2><p><code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> elt = elements[i];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码在网页加载完毕后，获取指定元素并进行处理。</p>
<h2 id="error-事件和-onerror-属性"><a href="#error-事件和-onerror-属性" class="headerlink" title="error 事件和 onerror 属性"></a>error 事件和 onerror 属性</h2><p>浏览器脚本发生错误时，会触发<code>window</code>对象的<code>error</code>事件。我们可以通过<code>window.onerror</code>属性对该事件指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, filename, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出错了！--&gt; %s&quot;</span>, error.<span class="property">stack</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于历史原因，<code>window</code>的<code>error</code>事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。</p>
<ul>
<li>出错信息</li>
<li>出错脚本的网址</li>
<li>行号</li>
<li>列号</li>
<li>错误对象</li>
</ul>
<p>老式浏览器只支持前三个参数。</p>
<p>并不是所有的错误，都会触发 JavaScript 的<code>error</code>事件（即让 JavaScript 报错）。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p>
<p>下面是一个例子，如果整个页面未捕获错误超过3个，就显示警告。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">msg, url, line</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (onerror.<span class="property">num</span>++ &gt; onerror.<span class="property">max</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;ERROR: &#x27;</span> + msg + <span class="string">&#x27;\n&#x27;</span> + url + <span class="string">&#x27;:&#x27;</span> + line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">onerror.<span class="property">max</span> = <span class="number">3</span>;</span><br><span class="line">onerror.<span class="property">num</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果脚本网址与网页网址不在同一个域（比如使用了 CDN），浏览器根本不会提供详细的出错信息，只会提示出错，错误类型是“Script error.”，行号为0，其他信息都没有。这是浏览器防止向外部脚本泄漏信息。一个解决方法是在脚本所在的服务器，设置<code>Access-Control-Allow-Origin</code>的 HTTP 头信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>然后，在网页的<code>&lt;script&gt;</code>标签中设置<code>crossorigin</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//example.com/file.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>crossorigin=&quot;anonymous&quot;</code>表示，读取文件不需要身份信息，即不需要 cookie 和 HTTP 认证信息。如果设为<code>crossorigin=&quot;use-credentials&quot;</code>，就表示浏览器会上传 cookie 和 HTTP 认证信息，同时还需要服务器端打开 HTTP 头信息<code>Access-Control-Allow-Credentials</code>。</p>
<h2 id="window-对象的事件监听属性"><a href="#window-对象的事件监听属性" class="headerlink" title="window 对象的事件监听属性"></a>window 对象的事件监听属性</h2><p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code>window</code>对象还具有以下的事件监听函数属性。</p>
<ul>
<li><code>window.onafterprint</code>：<code>afterprint</code>事件的监听函数。</li>
<li><code>window.onbeforeprint</code>：<code>beforeprint</code>事件的监听函数。</li>
<li><code>window.onbeforeunload</code>：<code>beforeunload</code>事件的监听函数。</li>
<li><code>window.onhashchange</code>：<code>hashchange</code>事件的监听函数。</li>
<li><code>window.onlanguagechange</code>: <code>languagechange</code>的监听函数。</li>
<li><code>window.onmessage</code>：<code>message</code>事件的监听函数。</li>
<li><code>window.onmessageerror</code>：<code>MessageError</code>事件的监听函数。</li>
<li><code>window.onoffline</code>：<code>offline</code>事件的监听函数。</li>
<li><code>window.ononline</code>：<code>online</code>事件的监听函数。</li>
<li><code>window.onpagehide</code>：<code>pagehide</code>事件的监听函数。</li>
<li><code>window.onpageshow</code>：<code>pageshow</code>事件的监听函数。</li>
<li><code>window.onpopstate</code>：<code>popstate</code>事件的监听函数。</li>
<li><code>window.onstorage</code>：<code>storage</code>事件的监听函数。</li>
<li><code>window.onunhandledrejection</code>：未处理的<code>Promise</code>对象的<code>reject</code>事件的监听函数。</li>
<li><code>window.onunload</code>：<code>unload</code>事件的监听函数。</li>
</ul>
<h1 id="多窗口操作"><a href="#多窗口操作" class="headerlink" title="多窗口操作"></a>多窗口操作</h1><p>由于网页可以使用<code>iframe</code>元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p>
<h2 id="窗口的引用"><a href="#窗口的引用" class="headerlink" title="窗口的引用"></a>窗口的引用</h2><p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p>
<ul>
<li><code>top</code>：顶层窗口，即最上层的那个窗口</li>
<li><code>parent</code>：父窗口</li>
<li><code>self</code>：当前窗口，即自身</li>
</ul>
<p>下面代码可以判断，当前窗口是否为顶层窗口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">top</span> === <span class="variable language_">window</span>.<span class="property">self</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是顶层窗口</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是子窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码让父窗口的访问历史后退一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">history</span>.<span class="title function_">back</span>();</span><br></pre></td></tr></table></figure>
<p>与这些变量对应，浏览器还提供一些特殊的窗口名，供<code>window.open()</code>方法、<code>&lt;a&gt;</code>标签、<code>&lt;form&gt;</code>标签等引用。</p>
<ul>
<li><code>_top</code>：顶层窗口</li>
<li><code>_parent</code>：父窗口</li>
<li><code>_blank</code>：新窗口</li>
</ul>
<p>下面代码就表示在顶层窗口打开链接。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;somepage.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_top&quot;</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="iframe-元素"><a href="#iframe-元素" class="headerlink" title="iframe 元素"></a>iframe 元素</h2><p>对于<code>iframe</code>嵌入的窗口，<code>document.getElementById</code>方法可以拿到该窗口的 DOM 节点，然后使用<code>contentWindow</code>属性获得<code>iframe</code>节点包含的<code>window</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;theFrame&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> frameWindow = frame.<span class="property">contentWindow</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>frame.contentWindow</code>可以拿到子窗口的<code>window</code>对象。然后，在满足同源限制的情况下，可以读取子窗口内部的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取子窗口的标题</span></span><br><span class="line">frameWindow.<span class="property">title</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;iframe&gt;</code>元素的<code>contentDocument</code>属性，可以拿到子窗口的<code>document</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;theFrame&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> frameDoc = frame.<span class="property">contentDocument</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> frameDoc = frame.<span class="property">contentWindow</span>.<span class="property">document</span>;</span><br></pre></td></tr></table></figure>
<p><code>&lt;iframe&gt;</code>元素遵守同源政策，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用<code>window.postMessage</code>方法。</p>
<p><code>&lt;iframe&gt;</code>窗口内部，使用<code>window.parent</code>引用父窗口。如果当前页面没有父窗口，则<code>window.parent</code>属性返回自身。因此，可以通过<code>window.parent</code>是否等于<code>window.self</code>，判断当前窗口是否为<code>iframe</code>窗口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">parent</span> !== <span class="variable language_">window</span>.<span class="property">self</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前窗口是子窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;iframe&gt;</code>窗口的<code>window</code>对象，有一个<code>frameElement</code>属性，返回<code>&lt;iframe&gt;</code>在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1Element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;f1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> f1Window = f1Element.<span class="property">contentWindow</span>;</span><br><span class="line"></span><br><span class="line">f1Window.<span class="property">frameElement</span> === f1Element <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">frameElement</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="window-frames-属性"><a href="#window-frames-属性" class="headerlink" title="window.frames 属性"></a>window.frames 属性</h2><p><code>window.frames</code>属性返回一个类似数组的对象，成员是所有子窗口的<code>window</code>对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code>frames[0]</code>返回第一个子窗口，<code>frames[1].frames[2]</code>返回第二个子窗口内部的第三个子窗口，<code>parent.frames[1]</code>返回父窗口的第二个子窗口。</p>
<p>注意，<code>window.frames</code>每个成员的值，是框架内的窗口（即框架的<code>window</code>对象），而不是<code>iframe</code>标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用<code>window.frames[0].document</code>的写法。</p>
<p>另外，如果<code>&lt;iframe&gt;</code>元素设置了<code>name</code>或<code>id</code>属性，那么属性值会自动成为全局变量，并且可以通过<code>window.frames</code>属性引用，返回子窗口的<code>window</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;iframe id=&quot;myFrame&quot;&gt;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">myFrame</span> <span class="comment">// [HTMLIFrameElement]</span></span><br><span class="line">frames.<span class="property">myframe</span> === myFrame <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>name</code>属性的值会自动成为子窗口的名称，可以用在<code>window.open</code>方法的第二个参数，或者<code>&lt;a&gt;</code>和<code>&lt;frame&gt;</code>标签的<code>target</code>属性。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS浏览器模型概述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/01/05/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"
    >JS浏览器模型概述</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/01/05/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2019-01-05T12:26:08.000Z" itemprop="datePublished">2019-01-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>JavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。</p>
<h1 id="代码嵌入网页的方法"><a href="#代码嵌入网页的方法" class="headerlink" title="代码嵌入网页的方法"></a>代码嵌入网页的方法</h1><p>网页中嵌入 JavaScript 代码，主要有三种方法。</p>
<ul>
<li><code>&lt;script&gt;</code>元素直接嵌入代码。</li>
<li><code>&lt;script&gt;</code>标签加载外部脚本</li>
<li>事件属性</li>
<li>URL 协议</li>
</ul>
<h2 id="script-元素嵌入代码"><a href="#script-元素嵌入代码" class="headerlink" title="script 元素嵌入代码"></a>script 元素嵌入代码</h2><p><code>&lt;script&gt;</code>元素内部可以直接写 JavaScript 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> x = <span class="number">1</span> + <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;script&gt;</code>标签有一个<code>type</code>属性，用来指定脚本类型。对 JavaScript 脚本来说，<code>type</code>属性可以设为两种值。</p>
<ul>
<li><code>text/javascript</code>：这是默认值，也是历史上一贯设定的值。如果你省略<code>type</code>属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li>
<li><code>application/javascript</code>：对于较新的浏览器，建议设为这个值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于<code>&lt;script&gt;</code>标签默认就是 JavaScript 代码。所以，嵌入 JavaScript 脚本时，<code>type</code>属性可以省略。</p>
<p>如果<code>type</code>属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在<code>&lt;script&gt;</code>标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的<code>type</code>属性即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;mydata&quot;</span> <span class="attr">type</span>=<span class="string">&quot;x-custom-data&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，浏览器不会执行，也不会显示它的内容，因为不认识它的<code>type</code>属性。但是，这个<code>&lt;script&gt;</code>节点依然存在于 DOM 之中，可以使用<code>&lt;script&gt;</code>节点的<code>text</code>属性读出它的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydata&#x27;</span>).<span class="property">text</span></span><br><span class="line"><span class="comment">// console.log(&#x27;Hello World&#x27;);</span></span><br></pre></td></tr></table></figure>
<h2 id="script-元素加载外部脚本"><a href="#script-元素加载外部脚本" class="headerlink" title="script 元素加载外部脚本"></a>script 元素加载外部脚本</h2><p><code>&lt;script&gt;</code>标签也可以指定加载外部的脚本文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果脚本文件使用了非英语字符，还应该注明字符的编码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所加载的脚本必须是纯的 JavaScript 代码，不能有<code>HTML</code>代码和<code>&lt;script&gt;</code>标签。</p>
<p>加载外部脚本和直接添加代码块，这两种方法不能混用。下面代码的<code>console.log</code>语句直接被忽略。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了防止攻击者篡改外部脚本，<code>script</code>标签允许设置一个<code>integrity</code>属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/assets/application.js&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">&quot;sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>script</code>标签有一个<code>integrity</code>属性，指定了外部脚本<code>/assets/application.js</code>的 SHA256 签名。一旦有人改了这个脚本，导致 SHA256 签名不匹配，浏览器就会拒绝加载。</p>
<h2 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h2><p>网页元素的事件属性（比如<code>onclick</code>和<code>onmouseover</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.id)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的事件属性代码只有一个语句。如果有多个语句，使用分号分隔即可。</p>
<h2 id="URL-协议"><a href="#URL-协议" class="headerlink" title="URL 协议"></a>URL 协议</h2><p>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:console.log(&#x27;Hello&#x27;)&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器的地址栏也可以执行<code>javascript:</code>协议。将<code>javascript:console.log(&#39;Hello&#39;)</code>放入地址栏，按回车键也会执行这段代码。</p>
<p>如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都会消失。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript: new Date().toLocaleTimeString();&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，用户点击链接以后，会打开一个新文档，里面有当前时间。</p>
<p>如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: console.log(new Date().toLocaleTimeString())&quot;</span>&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，用户点击链接后，网页不会跳转，只会在控制台显示当前时间。</p>
<p><code>javascript:</code>协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以<code>javascript:</code>网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上<code>void</code>，或者在脚本最后加上<code>void 0</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript: void new Date().toLocaleTimeString();&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript: new Date().toLocaleTimeString();void 0;&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p>
<h1 id="script-元素"><a href="#script-元素" class="headerlink" title="script 元素"></a>script 元素</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成。正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>
</ol>
<p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p>
<p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p>为了避免这种情况，较好的做法是将<code>&lt;script&gt;</code>标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</p>
<p>脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码执行时会报错，因为此时<code>document.body</code>元素还未生成。</p>
<p>一种解决方法是设定<code>DOMContentLoaded</code>事件的回调函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;DOMContentLoaded&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    );</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，指定<code>DOMContentLoaded</code>事件发生后，才开始执行相关代码。<code>DOMContentLoaded</code>事件只有在 DOM 结构生成之后才会触发。</p>
<p>另一种解决方法是，使用<code>&lt;script&gt;</code>标签的<code>onload</code>属性。当<code>&lt;script&gt;</code>标签指定的外部脚本文件下载和解析完成，会触发一个<code>load</code>事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery.min.js&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;console.log(document.body.innerHTML)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他代码  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果有多个<code>script</code>标签，比如下面这样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器会同时并行下载<code>a.js</code>和<code>b.js</code>，但是，执行时会保证先执行<code>a.js</code>，然后再执行<code>b.js</code>，即使后者先下载完成，也是如此。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p>
<p>解析和执行 CSS，也会产生阻塞。Firefox 浏览器会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。</p>
<p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p>
<h2 id="defer-属性"><a href="#defer-属性" class="headerlink" title="defer 属性"></a>defer 属性</h2><p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<code>&lt;script&gt;</code>元素加入<code>defer</code>属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，只有等到 DOM 加载完成后，才会执行<code>a.js</code>和<code>b.js</code>。<br><code>defer</code>属性的运行流程如下。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>defer</code>属性的<code>&lt;script&gt;</code>元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ol>
<p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的<code>script</code>标签，以及动态生成的<code>script</code>标签，<code>defer</code>属性不起作用。另外，使用<code>defer</code>加载的外部脚本不应该使用<code>document.write</code>方法。</p>
<h2 id="async-属性"><a href="#async-属性" class="headerlink" title="async 属性"></a>async 属性</h2><p>解决“阻塞效应”的另一个方法是对<code>&lt;script&gt;</code>元素加入<code>async</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>async</code>属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ol>
<p><code>async</code>属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用<code>async</code>属性的脚本文件里面的代码，不应该使用<code>document.write</code>方法。</p>
<p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>
<h2 id="脚本的动态加载"><a href="#脚本的动态加载" class="headerlink" title="脚本的动态加载"></a>脚本的动态加载</h2><p><code>&lt;script&gt;</code>元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = src;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方法的好处是，动态生成的<code>script</code>标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。</p>
<p>如果想避免这个问题，可以设置<code>async</code>属性为<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a.js&#x27;</span>, <span class="string">&#x27;b.js&#x27;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">src</span> = src;</span><br><span class="line">  script.<span class="property">async</span> = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码不会阻塞页面渲染，而且可以保证<code>b.js</code>在<code>a.js</code>后面执行。不过需要注意的是，在这段代码后面加载的脚本文件，会因此都等待<code>b.js</code>执行完成后再执行。</p>
<p>如果想为动态加载的脚本指定回调函数，可以使用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">src, done</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> js = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  js.<span class="property">src</span> = src;</span><br><span class="line">  js.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  js.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">done</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Failed to load script &#x27;</span> + src));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载使用的协议"><a href="#加载使用的协议" class="headerlink" title="加载使用的协议"></a>加载使用的协议</h2><p>如果不指定协议，浏览器默认采用 HTTP 协议下载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>example.js</code>默认就是采用 HTTP 协议下载，如果要采用 HTTPS 协议下载，必需写明。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h1><p>浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。</p>
<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p>
<p>不同的浏览器有不同的渲染引擎。</p>
<ul>
<li>Firefox：Gecko 引擎</li>
<li>Safari：WebKit 引擎</li>
<li>Chrome：Blink 引擎</li>
<li>IE: Trident 引擎</li>
<li>Edge: EdgeHTML 引擎</li>
</ul>
<p>渲染引擎处理网页，通常分成四个阶段。</p>
<ol>
<li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li>
<li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（<code>render tree</code>）。</li>
<li>布局：计算出渲染树的布局（<code>layout</code>）。</li>
<li>绘制：将渲染树绘制到屏幕。</li>
</ol>
<p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p>
<h2 id="重流和重绘"><a href="#重流和重绘" class="headerlink" title="重流和重绘"></a>重流和重绘</h2><p>渲染树转换为网页布局，称为“布局流”（<code>flow</code>）；布局显示到页面的这个过程，称为“绘制”（<code>paint</code>）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p>
<p>页面生成以后，脚本操作和样式表操作，都会触发“重流”和“重绘”。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code>a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p>
<p>重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p>
<p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p>
<p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘<code>table</code>布局和<code>flex</code>布局，开销都会比较大。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foobar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">foo.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">foo.<span class="property">style</span>.<span class="property">marginTop</span> = <span class="string">&#x27;30px&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码只会导致一次重绘，因为浏览器会累积 DOM 变动，然后一次性执行。</p>
<p>下面是一些优化技巧。</p>
<ul>
<li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li>
<li>缓存 DOM 信息。</li>
<li>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。</li>
<li>使用<code>documentFragment</code>操作 DOM</li>
<li>动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。</li>
<li>只在必要时才显示隐藏元素。</li>
<li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流。</li>
<li>使用虚拟 DOM（virtual DOM）库。</li>
</ul>
<p>下面是一个<code>window.requestAnimationFrame()</code>对比效果的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重绘代价高</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doubleHeight</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentHeight = element.<span class="property">clientHeight</span>;</span><br><span class="line">  element.<span class="property">style</span>.<span class="property">height</span> = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.<span class="title function_">forEach</span>(doubleHeight);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重绘代价低</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doubleHeight</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> currentHeight = element.<span class="property">clientHeight</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    element.<span class="property">style</span>.<span class="property">height</span> = (currentHeight * <span class="number">2</span>) + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.<span class="title function_">forEach</span>(doubleHeight);</span><br></pre></td></tr></table></figure>
<p>上面的第一段代码，每读一次 DOM，就写入新的值，会造成不停的重排和重流。第二段代码把所有的写操作，都累积在一起，从而 DOM 代码变动的代价就最小化了。</p>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p>
<p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p>
<p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（<code>bytecode</code>）的中间代码，以提高运行速度。</p>
<p>早期，浏览器内部对 JavaScript 的处理过程如下：</p>
<ol>
<li>读取代码，进行词法分析（<code>Lexical analysis</code>），将代码分解成词元（<code>token</code>）。</li>
<li>对词元进行语法分析（<code>parsing</code>），将代码整理成“语法树”（<code>syntax tree</code>）。</li>
<li>使用“翻译器”（<code>translator</code>），将代码转为字节码（<code>bytecode</code>）。</li>
<li>使用“字节码解释器”（<code>bytecode interpreter</code>），将字节码转为机器码。</li>
</ol>
<p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p>
<p>字节码不能直接运行，而是运行在一个虚拟机之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（<code>just in time</code>）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些 JavaScript 虚拟机：</p>
<ul>
<li>Chakra(Microsoft Internet Explorer)</li>
<li>Nitro&#x2F;JavaScript Core(Safari)</li>
<li>Carakan (Opera)</li>
<li>SpiderMonkey (Firefox)</li>
<li>V8(Chrome, Chromium)</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS DOM——Mutation Observer API"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/15/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Mutation%20Observer%20API/"
    >JS DOM—Mutation Observer API</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/11/15/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Mutation%20Observer%20API/" class="article-date">
  <time datetime="2018-11-15T06:27:16.000Z" itemprop="datePublished">2018-11-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。</p>
<p>概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。</p>
<p>这样设计是为了应付 DOM 变动频繁的特点。举例来说，如果文档中连续插入1000个<code>&lt;p&gt;</code>元素，就会连续触发1000个插入事件，执行每个事件的回调函数，这很可能造成浏览器的卡顿；而 Mutation Observer 完全不同，只在1000个段落都插入结束后才会触发，而且只触发一次。</p>
<p>Mutation Observer 有以下特点。</p>
<ul>
<li>它等待所有脚本任务完成后，才会运行（即异步触发方式）。</li>
<li>它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM 变动。</li>
<li>它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。</li>
</ul>
<h1 id="MutationObserver-构造函数"><a href="#MutationObserver-构造函数" class="headerlink" title="MutationObserver 构造函数"></a>MutationObserver 构造函数</h1><p>使用时，首先使用<code>MutationObserver</code>构造函数，新建一个观察器实例，同时指定这个实例的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br></pre></td></tr></table></figure>
<p>上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="keyword">function</span> (<span class="params">mutations, observer</span>) &#123;</span><br><span class="line">  mutations.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">mutation</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="MutationObserver-的实例方法"><a href="#MutationObserver-的实例方法" class="headerlink" title="MutationObserver 的实例方法"></a>MutationObserver 的实例方法</h1><h2 id="observe"><a href="#observe" class="headerlink" title="observe()"></a>observe()</h2><p><code>observe</code>方法用来启动监听，它接受两个参数。</p>
<ul>
<li>第一个参数：所要观察的 DOM 节点</li>
<li>第二个参数：一个配置对象，指定所要观察的特定变动</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;article&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  options = &#123;</span><br><span class="line">  <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span>:<span class="literal">true</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(article, options);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>observe</code>方法接受两个参数，第一个是所要观察的DOM元素是<code>article</code>，第二个是所要观察的变动类型（子节点变动和属性变动）。</p>
<p>观察器所能观察的 DOM 变动类型（即上面代码的<code>options</code>对象），有以下几种。</p>
<ul>
<li><strong>childList</strong>：子节点的变动（指新增，删除或者更改）。</li>
<li><strong>attributes</strong>：属性的变动。</li>
<li><strong>characterData</strong>：节点内容或节点文本的变动。</li>
</ul>
<p>想要观察哪一种变动类型，就在<code>option</code>对象中指定它的值为<code>true</code>。需要注意的是，必须同时指定<code>childList</code>、<code>attributes</code>和<code>characterData</code>中的一种或多种，若未均指定将报错。</p>
<p>除了变动类型，<code>options</code>对象还可以设定以下属性：</p>
<ul>
<li><code>subtree</code>：布尔值，表示是否将该观察器应用于该节点的所有后代节点。</li>
<li><code>attributeOldValue</code>：布尔值，表示观察<code>attributes</code>变动时，是否需要记录变动前的属性值。</li>
<li><code>characterDataOldValue</code>：布尔值，表示观察<code>characterData</code>变动时，是否需要记录变动前的值。</li>
<li><code>attributeFilter</code>：数组，表示需要观察的特定属性（比如<code>[&#39;class&#39;,&#39;src&#39;]</code>）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始监听文档根节点（即&lt;html&gt;标签）的变动</span></span><br><span class="line">mutationObserver.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>, &#123;</span><br><span class="line">  <span class="attr">attributes</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">attributeOldValue</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">characterDataOldValue</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对一个节点添加观察器，就像使用<code>addEventListener</code>方法一样，多次添加同一个观察器是无效的，回调函数依然只会触发一次。但是，如果指定不同的<code>options</code>对象，就会被当作两个不同的观察器。</p>
<p>下面的例子是观察新增的子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNodes = [];</span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="keyword">function</span>(<span class="params">mutations</span>) &#123;</span><br><span class="line">  mutations.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">mutation</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mutation.<span class="property">addedNodes</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      insertedNodes.<span class="title function_">push</span>(mutation.<span class="property">addedNodes</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(insertedNodes);</span><br><span class="line">&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>, &#123; <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="disconnect-，takeRecords（）"><a href="#disconnect-，takeRecords（）" class="headerlink" title="disconnect()，takeRecords（）"></a>disconnect()，takeRecords（）</h2><p><code>disconnect</code>方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.<span class="title function_">disconnect</span>();</span><br></pre></td></tr></table></figure>
<p><code>takeRecords</code>方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.<span class="title function_">takeRecords</span>();</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存所有没有被观察器处理的变动</span></span><br><span class="line"><span class="keyword">var</span> changes = mutationObserver.<span class="title function_">takeRecords</span>();</span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">mutationObserver.<span class="title function_">disconnect</span>();</span><br></pre></td></tr></table></figure>
<h1 id="MutationRecord-对象"><a href="#MutationRecord-对象" class="headerlink" title="MutationRecord 对象"></a>MutationRecord 对象</h1><p>DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个<code>MutationRecord</code>实例所组成的数组。</p>
<p><code>MutationRecord</code>对象包含了DOM的相关信息，有如下属性：</p>
<ul>
<li><code>type</code>：观察的变动类型（<code>attributes</code>、<code>characterData</code>或者<code>childList</code>）。</li>
<li><code>target</code>：发生变动的DOM节点。</li>
<li><code>addedNodes</code>：新增的DOM节点。</li>
<li><code>removedNodes</code>：删除的DOM节点。</li>
<li><code>previousSibling</code>：前一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>nextSibling</code>：下一个同级节点，如果没有则返回<code>null</code>。</li>
<li><code>attributeName</code>：发生变动的属性。如果设置了<code>attributeFilter</code>，则只返回预先指定的属性。</li>
<li><code>oldValue</code>：变动前的值。这个属性只对<code>attribute</code>和<code>characterData</code>变动有效，如果发生<code>childList</code>变动，则返回<code>null</code>。</li>
</ul>
<h1 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h1><h2 id="子元素的变动"><a href="#子元素的变动" class="headerlink" title="子元素的变动"></a>子元素的变动</h2><p>下面的例子说明如何读取变动记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="keyword">function</span> (<span class="params">records</span>)&#123;</span><br><span class="line">  records.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">record</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mutation type: &#x27;</span> + record.<span class="property">type</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Mutation target: &#x27;</span> + record.<span class="property">target</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  <span class="string">&#x27;childList&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;subtree&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mo.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, option);</span><br></pre></td></tr></table></figure>
<p>上面代码的观察器，观察<code>&lt;body&gt;</code>的所有下级节点（<code>childList</code>表示观察子节点，<code>subtree</code>表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。</p>
<h2 id="属性的变动"><a href="#属性的变动" class="headerlink" title="属性的变动"></a>属性的变动</h2><p>下面的例子说明如何追踪属性的变动。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="keyword">function</span> (<span class="params">records</span>) &#123;</span><br><span class="line">  records.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">record</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous attribute value: &#x27;</span> + record.<span class="property">oldValue</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mo = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;#my_element&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="string">&#x27;attributes&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;attributeOldValue&#x27;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mo.<span class="title function_">observe</span>(element, options);</span><br></pre></td></tr></table></figure>
<p>上面代码先设定追踪属性变动（<code>&#39;attributes&#39;: true</code>），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。</p>
<h2 id="取代-DOMContentLoaded-事件"><a href="#取代-DOMContentLoaded-事件" class="headerlink" title="取代 DOMContentLoaded 事件"></a>取代 DOMContentLoaded 事件</h2><p>网页加载的时候，DOM 节点的生成会产生变动记录，因此只要观察 DOM 的变动，就能在第一时间触发相关事件，也就没有必要使用<code>DOMContentLoaded</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(callback);</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>, &#123;</span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，监听<code>document.documentElement</code>（即网页的<code>&lt;html&gt;</code>HTML 节点）的子节点的变动，<code>subtree</code>属性指定监听还包括后代节点。因此，任意一个网页元素一旦生成，就能立刻被监听到。</p>
<p>下面的代码，使用<code>MutationObserver</code>对象封装一个监听 DOM 生成的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">win</span>)&#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> listeners = [];</span><br><span class="line">  <span class="keyword">var</span> doc = win.<span class="property">document</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">MutationObserver</span> = win.<span class="property">MutationObserver</span> || win.<span class="property">WebKitMutationObserver</span>;</span><br><span class="line">  <span class="keyword">var</span> observer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">ready</span>(<span class="params">selector, fn</span>)&#123;</span><br><span class="line">    <span class="comment">// 储存选择器和回调函数</span></span><br><span class="line">    listeners.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">selector</span>: selector,</span><br><span class="line">      <span class="attr">fn</span>: fn</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span>(!observer)&#123;</span><br><span class="line">      <span class="comment">// 监听document变化</span></span><br><span class="line">      observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(check);</span><br><span class="line">      observer.<span class="title function_">observe</span>(doc.<span class="property">documentElement</span>, &#123;</span><br><span class="line">        <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">subtree</span>: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查该节点是否已经在DOM中</span></span><br><span class="line">    <span class="title function_">check</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">check</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 检查是否匹配已储存的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> listener = listeners[i];</span><br><span class="line">      <span class="comment">// 检查指定节点是否有匹配</span></span><br><span class="line">      <span class="keyword">var</span> elements = doc.<span class="title function_">querySelectorAll</span>(listener.<span class="property">selector</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; elements.<span class="property">length</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">var</span> element = elements[j];</span><br><span class="line">        <span class="comment">// 确保回调函数只会对该元素调用一次</span></span><br><span class="line">        <span class="keyword">if</span>(!element.<span class="property">ready</span>)&#123;</span><br><span class="line">          element.<span class="property">ready</span> = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 对该节点调用回调函数</span></span><br><span class="line">          listener.<span class="property">fn</span>.<span class="title function_">call</span>(element, element);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对外暴露ready</span></span><br><span class="line">  win.<span class="property">ready</span> = ready;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">ready</span>(<span class="string">&#x27;.foo&#x27;</span>, <span class="keyword">function</span>(<span class="params">element</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS DOM——CSS 操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/14/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94CSS%20%E6%93%8D%E4%BD%9C/"
    >JS DOM—CSS操作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/11/14/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94CSS%20%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2018-11-14T03:51:09.000Z" itemprop="datePublished">2018-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="HTML元素的style属性"><a href="#HTML元素的style属性" class="headerlink" title="HTML元素的style属性"></a>HTML元素的style属性</h1><p>操作 CSS 样式最简单的方法，就是使用网页元素节点的<code>getAttribute</code>方法、<code>setAttribute</code>方法和<code>removeAttribute</code>方法，直接读写或删除网页元素的<code>style</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="title function_">setAttribute</span>(</span><br><span class="line">  <span class="string">&#x27;style&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;background-color:red;&#x27;</span> + <span class="string">&#x27;border:1px solid black;&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的代码相当于下面的 HTML 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color:red; border:1px solid black;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>style</code>不仅可以使用字符串读写，它本身还是一个对象，部署了<code>CSSStyleDeclaration</code>接口，可以直接读写个别属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;18px&#x27;</span>;</span><br><span class="line">e.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;black&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="CSSStyleDeclaration-接口"><a href="#CSSStyleDeclaration-接口" class="headerlink" title="CSSStyleDeclaration 接口"></a>CSSStyleDeclaration 接口</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSSStyleDeclaration 接口用来操作元素的样式。三个地方部署了这个接口。</p>
<ul>
<li>元素节点的<code>style</code>属性（<code>Element.style</code>）</li>
<li><code>CSSStyle</code>实例的<code>style</code>属性</li>
<li><code>window.getComputedStyle()</code>的返回值</li>
</ul>
<p>CSSStyleDeclaration 接口可以直接读写 CSS 的样式属性，不过，连词号需要变成骆驼拼写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divStyle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">style</span>;</span><br><span class="line"></span><br><span class="line">divStyle.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">border</span> = <span class="string">&#x27;1px solid black&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">height</span> = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">divStyle.<span class="property">fontSize</span> = <span class="string">&#x27;10em&#x27;</span>;</span><br><span class="line"></span><br><span class="line">divStyle.<span class="property">backgroundColor</span> <span class="comment">// red</span></span><br><span class="line">divStyle.<span class="property">border</span> <span class="comment">// 1px solid black</span></span><br><span class="line">divStyle.<span class="property">height</span> <span class="comment">// 100px</span></span><br><span class="line">divStyle.<span class="property">width</span> <span class="comment">// 100px</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>style</code>属性的值是一个 CSSStyleDeclaration 实例。这个对象所包含的属性与 CSS 规则一一对应，但是名字需要改写，比如<code>background-color</code>写成<code>backgroundColor</code>。改写的规则是将横杠从 CSS 属性名中去除，然后将横杠后的第一个字母大写。如果 CSS 属性名是 JavaScript 保留字，则规则名之前需要加上字符串<code>css</code>，比如<code>float</code>写成<code>cssFloat</code>。</p>
<p>注意，该对象的属性值都是字符串，设置时必须包括单位，但是不含规则结尾的分号。比如，<code>divStyle.width</code>不能写为<code>100</code>，而要写为<code>100px</code>。</p>
<p>另外，<code>Element.style</code>返回的只是行内样式，并不是该元素的全部样式。通过样式表设置的样式，或者从父元素继承的样式，无法通过这个属性得到。元素的全部样式要通过<code>window.getComputedStyle()</code>得到。</p>
<h2 id="CSSStyleDeclaration-实例属性"><a href="#CSSStyleDeclaration-实例属性" class="headerlink" title="CSSStyleDeclaration 实例属性"></a>CSSStyleDeclaration 实例属性</h2><h4 id="CSSStyleDeclaration-cssText"><a href="#CSSStyleDeclaration-cssText" class="headerlink" title="CSSStyleDeclaration.cssText"></a>CSSStyleDeclaration.cssText</h4><p><code>CSSStyleDeclaration.cssText</code>属性用来读写当前规则的所有样式声明文本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divStyle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">style</span>;</span><br><span class="line"></span><br><span class="line">divStyle.<span class="property">cssText</span> = <span class="string">&#x27;background-color: red;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;border: 1px solid black;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;height: 100px;&#x27;</span></span><br><span class="line">  + <span class="string">&#x27;width: 100px;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>注意，<code>cssText</code>的属性值不用改写 CSS 属性名。</p>
<p>删除一个元素的所有行内样式，最简便的方法就是设置<code>cssText</code>为空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">divStyle.<span class="property">cssText</span> = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="CSSStyleDeclaration-length"><a href="#CSSStyleDeclaration-length" class="headerlink" title="CSSStyleDeclaration.length"></a>CSSStyleDeclaration.length</h4><p><code>CSSStyleDeclaration.length</code>属性返回一个整数值，表示当前规则包含多少条样式声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot;</span></span><br><span class="line"><span class="comment">//   style=&quot;height: 1px;width: 100%;background-color: #CA1;&quot;</span></span><br><span class="line"><span class="comment">// &gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> divStyle = myDiv.<span class="property">style</span>;</span><br><span class="line">divStyle.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h4 id="CSSStyleDeclaration-parentRule"><a href="#CSSStyleDeclaration-parentRule" class="headerlink" title="CSSStyleDeclaration.parentRule"></a>CSSStyleDeclaration.parentRule</h4><p><code>CSSStyleDeclaration.parentRule</code>属性返回当前规则所属的那个样式块（CSSRule 实例）。如果不存在所属的样式块，该属性返回<code>null</code>。</p>
<p>该属性只读，且只在使用 CSSRule 接口时有意义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> declaration = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">rules</span>[<span class="number">0</span>].<span class="property">style</span>;</span><br><span class="line">declaration.<span class="property">parentRule</span> === <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">rules</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="CSSStyleDeclaration-实例方法"><a href="#CSSStyleDeclaration-实例方法" class="headerlink" title="CSSStyleDeclaration 实例方法"></a>CSSStyleDeclaration 实例方法</h2><h4 id="CSSStyleDeclaration-getPropertyPriority"><a href="#CSSStyleDeclaration-getPropertyPriority" class="headerlink" title="CSSStyleDeclaration.getPropertyPriority()"></a>CSSStyleDeclaration.getPropertyPriority()</h4><p><code>CSSStyleDeclaration.getPropertyPriority</code>方法接受 CSS 样式的属性名作为参数，返回一个字符串，表示有没有设置<code>important</code>优先级。如果有就返回<code>important</code>，否则返回空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="property">margin</span> <span class="comment">// &quot;10px&quot;</span></span><br><span class="line">style.<span class="title function_">getPropertyPriority</span>(<span class="string">&#x27;margin&#x27;</span>) <span class="comment">// &quot;important&quot;</span></span><br><span class="line">style.<span class="title function_">getPropertyPriority</span>(<span class="string">&#x27;color&#x27;</span>) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>margin</code>属性有<code>important</code>优先级，<code>color</code>属性没有。</p>
<h4 id="CSSStyleDeclaration-getPropertyValue"><a href="#CSSStyleDeclaration-getPropertyValue" class="headerlink" title="CSSStyleDeclaration.getPropertyValue()"></a>CSSStyleDeclaration.getPropertyValue()</h4><p><code>CSSStyleDeclaration.getPropertyValue</code>方法接受 CSS 样式属性名作为参数，返回一个字符串，表示该属性的属性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;margin: 10px!important; color: red;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="property">margin</span> <span class="comment">// &quot;10px&quot;</span></span><br><span class="line">style.<span class="title function_">getPropertyValue</span>(<span class="string">&quot;margin&quot;</span>) <span class="comment">// &quot;10px&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="CSSStyleDeclaration-item"><a href="#CSSStyleDeclaration-item" class="headerlink" title="CSSStyleDeclaration.item()"></a>CSSStyleDeclaration.item()</h4><p><code>CSSStyleDeclaration.item</code>方法接受一个整数值作为参数，返回该位置的 CSS 属性名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;/&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="title function_">item</span>(<span class="number">0</span>) <span class="comment">// &quot;color&quot;</span></span><br><span class="line">style.<span class="title function_">item</span>(<span class="number">1</span>) <span class="comment">// &quot;background-color&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>0</code>号位置的 CSS 属性名是<code>color</code>，<code>1</code>号位置的 CSS 属性名是<code>background-color</code>。</p>
<p>如果没有提供参数，这个方法会报错。如果参数值超过实际的属性数目，这个方法返回一个空字符值。</p>
<h4 id="CSSStyleDeclaration-removeProperty"><a href="#CSSStyleDeclaration-removeProperty" class="headerlink" title="CSSStyleDeclaration.removeProperty()"></a>CSSStyleDeclaration.removeProperty()</h4><p><code>CSSStyleDeclaration.removeProperty</code>方法接受一个属性名作为参数，在 CSS 规则里面移除这个属性，返回这个属性原来的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   111</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="title function_">removeProperty</span>(<span class="string">&#x27;color&#x27;</span>) <span class="comment">// &#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// HTML 代码变为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;background-color: white;&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，删除<code>color</code>属性以后，字体颜色从红色变成默认颜色。</p>
<h4 id="CSSStyleDeclaration-setProperty"><a href="#CSSStyleDeclaration-setProperty" class="headerlink" title="CSSStyleDeclaration.setProperty()"></a>CSSStyleDeclaration.setProperty()</h4><p><code>CSSStyleDeclaration.setProperty</code>方法用来设置新的 CSS 属性。该方法没有返回值。<br>该方法可以接受三个参数。</p>
<ul>
<li>第一个参数：属性名，该参数是必需的。</li>
<li>第二个参数：属性值，该参数可选。如果省略，则参数值默认为空字符串。</li>
<li>第三个参数：优先级，该参数可选。如果设置，唯一的合法值是<code>important</code>，表示 CSS 规则里面的<code>!important</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;color: red; background-color: white;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   111</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">style</span>;</span><br><span class="line">style.<span class="title function_">setProperty</span>(<span class="string">&#x27;border&#x27;</span>, <span class="string">&#x27;1px solid blue&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码执行后，<code>myDiv</code>元素就会出现蓝色的边框。</p>
<h1 id="CSS-模块的侦测"><a href="#CSS-模块的侦测" class="headerlink" title="CSS 模块的侦测"></a>CSS 模块的侦测</h1><p>CSS 的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对 CSS 模块的支持情况都不一样。有时候，需要知道当前浏览器是否支持某个模块，这就叫做“CSS模块的侦测”。</p>
<p>一个比较普遍适用的方法是，判断元素的<code>style</code>对象的某个属性值是否为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> element.<span class="property">style</span>.<span class="property">animationName</span> === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">typeof</span> element.<span class="property">style</span>.<span class="property">transform</span> === <span class="string">&#x27;string&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果该 CSS 属性确实存在，会返回一个字符串。即使该属性实际上并未设置，也会返回一个空字符串。如果该属性不存在，则会返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;maxWidth&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;maximumWidth&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，这个浏览器支持<code>max-width</code>属性，但是不支持<code>maximum-width</code>属性。</p>
<p>注意，不管 CSS 属性名的写法带不带连词线，<code>style</code>属性上都能反映出该属性是否存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;backgroundColor&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>[<span class="string">&#x27;background-color&#x27;</span>] <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>另外，使用的时候，需要把不同浏览器的 CSS 前缀也考虑进去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">typeof</span> content.<span class="property">style</span>[<span class="string">&#x27;webkitAnimation&#x27;</span>] === <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种侦测方法可以写成一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPropertySupported</span>(<span class="params">property</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (property <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> prefixes = [<span class="string">&#x27;Moz&#x27;</span>, <span class="string">&#x27;Webkit&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;ms&#x27;</span>, <span class="string">&#x27;Khtml&#x27;</span>];</span><br><span class="line">  <span class="keyword">var</span> prefProperty = property.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + property.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prefixes.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((prefixes[i] + prefProperty) <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isPropertySupported</span>(<span class="string">&#x27;background-clip&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="CSS-对象"><a href="#CSS-对象" class="headerlink" title="CSS 对象"></a>CSS 对象</h1><p>浏览器原生提供 CSS 对象，为 JavaScript 操作 CSS 提供一些工具方法。<br>这个对象目前有两个静态方法。</p>
<h2 id="CSS-escape"><a href="#CSS-escape" class="headerlink" title="CSS.escape()"></a>CSS.escape()</h2><p><code>CSS.escape</code>方法用于转义 CSS 选择器里面的特殊字符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo#bar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，该元素的<code>id</code>属性包含一个<code>#</code>号，该字符在 CSS 选择器里面有特殊含义。不能直接写成<code>document.querySelector(&#39;#foo#bar&#39;)</code>，只能写成<code>document.querySelector(&#39;#foo\\#bar&#39;)</code>。这里必须使用双斜杠的原因是，单引号字符串本身会转义一次斜杠。</p>
<p><code>CSS.escape</code>方法就用来转义那些特殊字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#&#x27;</span> + <span class="variable constant_">CSS</span>.<span class="built_in">escape</span>(<span class="string">&#x27;foo#bar&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="CSS-supports"><a href="#CSS-supports" class="headerlink" title="CSS.supports()"></a>CSS.supports()</h2><p><code>CSS.supports</code>方法返回一个布尔值，表示当前环境是否支持某一句 CSS 规则。</p>
<p>它的参数有两种写法，一种是第一个参数是属性名，第二个参数是属性值；另一种是整个参数就是一行完整的 CSS 语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="variable constant_">CSS</span>.<span class="title function_">supports</span>(<span class="string">&#x27;transform-origin&#x27;</span>, <span class="string">&#x27;5px&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="variable constant_">CSS</span>.<span class="title function_">supports</span>(<span class="string">&#x27;display: table-cell&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，第二种写法的参数结尾不能带有分号，否则结果不准确。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">CSS</span>.<span class="title function_">supports</span>(<span class="string">&#x27;display: table-cell;&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h1 id="window-getComputedStyle"><a href="#window-getComputedStyle" class="headerlink" title="window.getComputedStyle()"></a>window.getComputedStyle()</h1><p>行内样式（<code>inline style</code>）具有最高的优先级，改变行内样式，通常会立即反映出来。但是，网页元素最终的样式是综合各种规则计算出来的。因此，如果想得到元素实际的样式，只读取行内样式是不够的，需要得到浏览器最终计算出来的样式规则。</p>
<p><code>window.getComputedStyle</code>方法，就用来返回浏览器计算后得到的最终规则。它接受一个节点对象作为参数，返回一个 CSSStyleDeclaration 实例，包含了指定节点的最终样式信息。所谓“最终样式信息”，指的是各种 CSS 规则叠加后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> styleObj = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(div);</span><br><span class="line">styleObj.<span class="property">backgroundColor</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，得到的背景色就是<code>div</code>元素真正的背景色。</p>
<p>注意，CSSStyleDeclaration 实例是一个活的对象，任何对于样式的修改，会实时反映到这个实例上面。另外，这个实例是只读的。</p>
<p><code>getComputedStyle</code>方法还可以接受第二个参数，表示当前元素的伪元素（比如<code>:before</code>、<code>:after</code>、<code>:first-line</code>、<code>:first-letter</code>等）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(div, <span class="string">&#x27;:before&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>下面的例子是如何获取元素的高度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;elem-container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> styleObj = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(elem, <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">var</span> height = styleObj.<span class="property">height</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> height = styleObj[<span class="string">&#x27;height&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> height = styleObj.<span class="title function_">getPropertyValue</span>(<span class="string">&#x27;height&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码得到的<code>height</code>属性，是浏览器最终渲染出来的高度，比其他方法得到的高度更可靠。由于<code>styleObj</code>是 CSSStyleDeclaration 实例，所以可以使用各种 CSSStyleDeclaration 的实例属性和方法。</p>
<p>有几点需要注意。</p>
<ul>
<li>CSSStyleDeclaration 实例返回的 CSS 值都是绝对单位。比如，长度都是像素单位（返回值包括<code>px</code>后缀），颜色是<code>rgb(#, #, #)</code>或<code>rgba(#, #, #, #)</code>格式。</li>
<li>CSS 规则的简写形式无效。比如，想读取<code>margin</code>属性的值，不能直接读，只能读<code>marginLeft</code>、<code>marginTop</code>等属性；再比如，<code>font</code>属性也是不能直接读的，只能读<code>font-size</code>等单个属性。</li>
<li>如果读取 CSS 原始的属性名，要用方括号运算符，比如<code>styleObj[&#39;z-index&#39;]</code>；如果读取骆驼拼写法的 CSS 属性名，可以直接读取<code>styleObj.zIndex</code>。</li>
<li>该方法返回的 CSSStyleDeclaration 实例的<code>cssText</code>属性无效，返回<code>undefined</code>。</li>
</ul>
<h1 id="CSS-伪元素"><a href="#CSS-伪元素" class="headerlink" title="CSS 伪元素"></a>CSS 伪元素</h1><p>CSS 伪元素是通过 CSS 向 DOM 添加的元素，主要是通过<code>:before</code>和<code>:after</code>选择器生成，然后用<code>content</code>属性指定伪元素的内容。</p>
<p>下面是一段 HTML 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span>Test content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>CSS 添加伪元素<code>:before</code>的写法如下。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#test</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;Before &#x27;</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FF0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点元素的<code>style</code>对象无法读写伪元素的样式，这时就要用到<code>window.getComputedStyle()</code>。JavaScript 获取伪元素，可以使用下面的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>).<span class="property">content</span>;</span><br><span class="line"><span class="keyword">var</span> color = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>).<span class="property">color</span>;</span><br></pre></td></tr></table></figure>
<p>此外，也可以使用 CSSStyleDeclaration 实例的<code>getPropertyValue</code>方法，获取伪元素的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getPropertyValue</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> color = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(test, <span class="string">&#x27;:before&#x27;</span>)</span><br><span class="line">  .<span class="title function_">getPropertyValue</span>(<span class="string">&#x27;color&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="StyleSheet-接口"><a href="#StyleSheet-接口" class="headerlink" title="StyleSheet 接口"></a>StyleSheet 接口</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>StyleSheet</code>接口代表网页的一张样式表，包括<code>&lt;link&gt;</code>元素加载的样式表和<code>&lt;style&gt;</code>元素内嵌的样式表。</p>
<p><code>document</code>对象的<code>styleSheets</code>属性，可以返回当前页面的所有<code>StyleSheet</code>实例（即所有样式表）。它是一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sheets = <span class="variable language_">document</span>.<span class="property">styleSheets</span>;</span><br><span class="line"><span class="keyword">var</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>];</span><br><span class="line">sheet <span class="keyword">instanceof</span> <span class="title class_">StyleSheet</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果是<code>&lt;style&gt;</code>元素嵌入的样式表，还有另一种获取<code>StyleSheet</code>实例的方法，就是这个节点元素的<code>sheet</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;style id=&quot;myStyle&quot;&gt;&lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line">myStyleSheet <span class="keyword">instanceof</span> <span class="title class_">StyleSheet</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>严格地说，<code>StyleSheet</code>接口不仅包括网页样式表，还包括 XML 文档的样式表。所以，它有一个子类<code>CSSStyleSheet</code>表示网页的 CSS 样式表。我们在网页里面拿到的样式表实例，实际上是<code>CSSStyleSheet</code>的实例。这个子接口继承了<code>StyleSheet</code>的所有属性和方法，并且定义了几个自己的属性，下面把这两个接口放在一起介绍。</p>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p><code>StyleSheet</code>实例有以下属性。</p>
<h4 id="StyleSheet-disabled"><a href="#StyleSheet-disabled" class="headerlink" title="StyleSheet.disabled"></a>StyleSheet.disabled</h4><p><code>StyleSheet.disabled</code>返回一个布尔值，表示该样式表是否处于禁用状态。手动设置<code>disabled</code>属性为<code>true</code>，等同于在<code>&lt;link&gt;</code>元素里面，将这张样式表设为<code>alternate stylesheet</code>，即该样式表将不会生效。</p>
<p>注意，<code>disabled</code>属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。</p>
<h4 id="Stylesheet-href"><a href="#Stylesheet-href" class="headerlink" title="Stylesheet.href"></a>Stylesheet.href</h4><p><code>Stylesheet.href</code>返回样式表的网址。对于内嵌样式表，该属性返回<code>null</code>。该属性只读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">href</span></span><br></pre></td></tr></table></figure>
<h4 id="StyleSheet-media"><a href="#StyleSheet-media" class="headerlink" title="StyleSheet.media"></a>StyleSheet.media</h4><p><code>StyleSheet.media</code>属性返回一个类似数组的对象（<code>MediaList</code>实例），成员是表示适用媒介的字符串。表示当前样式表是用于屏幕（<code>screen</code>），还是用于打印或手持设备，或各种媒介都适用（<code>all</code>）。该属性只读，默认值是<code>screen</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">media</span>.<span class="property">mediaText</span> <span class="comment">// &quot;all&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>MediaList</code>实例的<code>appendMedium</code>方法，用于增加媒介；<code>deleteMedium</code>方法用于删除媒介。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">media</span>.<span class="title function_">appendMedium</span>(<span class="string">&#x27;handheld&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">media</span>.<span class="title function_">deleteMedium</span>(<span class="string">&#x27;print&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="StyleSheet-title"><a href="#StyleSheet-title" class="headerlink" title="StyleSheet.title"></a>StyleSheet.title</h4><p><code>StyleSheet.title</code>属性返回样式表的<code>title</code>属性。</p>
<h4 id="StyleSheet-type"><a href="#StyleSheet-type" class="headerlink" title="StyleSheet.type"></a>StyleSheet.type</h4><p><code>StyleSheet.type</code>属性返回样式表的<code>type</code>属性，通常是<code>text/css</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">type</span>  <span class="comment">// &quot;text/css&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="StyleSheet-parentStyleSheet"><a href="#StyleSheet-parentStyleSheet" class="headerlink" title="StyleSheet.parentStyleSheet"></a>StyleSheet.parentStyleSheet</h4><p>CSS 的<code>@import</code>命令允许在样式表中加载其他样式表。<code>StyleSheet.parentStyleSheet</code>属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stylesheet.<span class="property">parentStyleSheet</span>) &#123;</span><br><span class="line">  sheet = stylesheet.<span class="property">parentStyleSheet</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sheet = stylesheet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="StyleSheet-ownerNode"><a href="#StyleSheet-ownerNode" class="headerlink" title="StyleSheet.ownerNode"></a>StyleSheet.ownerNode</h4><p><code>StyleSheet.ownerNode</code>属性返回<code>StyleSheet</code>对象所在的 DOM 节点，通常是<code>&lt;link&gt;</code>或<code>&lt;style&gt;</code>。对于那些由其他样式表引用的样式表，该属性为<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;link rel=&quot;StyleSheet&quot; href=&quot;example.css&quot; type=&quot;text/css&quot; /&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="property">ownerNode</span> <span class="comment">// [object HTMLLinkElement]</span></span><br></pre></td></tr></table></figure>
<h4 id="CSSStyleSheet-cssRules"><a href="#CSSStyleSheet-cssRules" class="headerlink" title="CSSStyleSheet.cssRules"></a>CSSStyleSheet.cssRules</h4><p><code>CSSStyleSheet.cssRules</code>属性指向一个类似数组的对象（<code>CSSRuleList</code>实例），里面每一个成员就是当前样式表的一条 CSS 规则。使用该规则的<code>cssText</code>属性，可以得到 CSS 规则对应的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#styleElement&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"></span><br><span class="line">sheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;body &#123; background-color: red; margin: 20px; &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">sheet.<span class="property">cssRules</span>[<span class="number">1</span>].<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;p &#123; line-height: 1.4em; color: blue; &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>每条 CSS 规则还有一个<code>style</code>属性，指向一个对象，用来读写具体的 CSS 命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssStyleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">cssStyleSheet.<span class="property">cssRules</span>[<span class="number">1</span>].<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;purple&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="CSSStyleSheet-ownerRule"><a href="#CSSStyleSheet-ownerRule" class="headerlink" title="CSSStyleSheet.ownerRule"></a>CSSStyleSheet.ownerRule</h4><p>有些样式表是通过<code>@import</code>规则输入的，它的<code>ownerRule</code>属性会返回一个<code>CSSRule</code>实例，代表那行<code>@import</code>规则。如果当前样式表不是通过<code>@import</code>引入的，<code>ownerRule</code>属性返回<code>null</code>。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h4 id="CSSStyleSheet-insertRule"><a href="#CSSStyleSheet-insertRule" class="headerlink" title="CSSStyleSheet.insertRule()"></a>CSSStyleSheet.insertRule()</h4><p><code>CSSStyleSheet.insertRule</code>方法用于在当前样式表的插入一个新的 CSS 规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sheet = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#styleElement&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line">sheet.<span class="title function_">insertRule</span>(<span class="string">&#x27;#block &#123; color: white &#125;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">sheet.<span class="title function_">insertRule</span>(<span class="string">&#x27;p &#123; color: red &#125;&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>该方法可以接受两个参数，第一个参数是表示 CSS 规则的字符串，这里只能有一条规则，否则会报错。第二个参数是该规则在样式表的插入位置（从0开始），该参数可选，默认为0（即默认插在样式表的头部）。注意，如果插入位置大于现有规则的数目，会报错。</p>
<p>该方法的返回值是新插入规则的位置序号。</p>
<p>注意，浏览器对脚本在样式表里面插入规则有很多限制。所以，这个方法最好放在<code>try...catch</code>里使用。</p>
<h4 id="CSSStyleSheet-deleteRule"><a href="#CSSStyleSheet-deleteRule" class="headerlink" title="CSSStyleSheet.deleteRule()"></a>CSSStyleSheet.deleteRule()</h4><p><code>CSSStyleSheet.deleteRule</code>方法用来在样式表里面移除一条规则，它的参数是该条规则在<code>cssRules</code>对象中的位置。该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>].<span class="title function_">deleteRule</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h1 id="实例：添加样式表"><a href="#实例：添加样式表" class="headerlink" title="实例：添加样式表"></a>实例：添加样式表</h1><p>网页添加样式表有两种方式。一种是添加一张内置样式表，即在文档中添加一个<code>&lt;style&gt;</code>节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">style.<span class="title function_">setAttribute</span>(<span class="string">&#x27;media&#x27;</span>, <span class="string">&#x27;screen&#x27;</span>);</span><br><span class="line">style.<span class="property">innerHTML</span> = <span class="string">&#x27;body&#123;color:red&#125;&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> style = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br><span class="line">  <span class="keyword">return</span> style;</span><br><span class="line">&#125;)();</span><br><span class="line">style.<span class="property">sheet</span>.<span class="title function_">insertRule</span>(<span class="string">&#x27;.foo&#123;color:red;&#125;&#x27;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>另一种是添加外部样式表，即在文档中添加一个<code>&lt;link&gt;</code>节点，然后将<code>href</code>属性指向外部样式表的 URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> linkElm = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>);</span><br><span class="line">linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;reset-min.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(linkElm);</span><br></pre></td></tr></table></figure>
<h1 id="CSSRuleList-接口"><a href="#CSSRuleList-接口" class="headerlink" title="CSSRuleList 接口"></a>CSSRuleList 接口</h1><p>CSSRuleList 接口是一个类似数组的对象，表示一组 CSS 规则，成员都是 CSSRule 实例。</p>
<p>获取 CSSRuleList 实例，一般是通过<code>StyleSheet.cssRules</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   h1 &#123; color: red; &#125;</span></span><br><span class="line"><span class="comment">//   p &#123; color: blue; &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"><span class="keyword">var</span> crl = myStyleSheet.<span class="property">cssRules</span>;</span><br><span class="line">crl <span class="keyword">instanceof</span> <span class="title class_">CSSRuleList</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>CSSRuleList 实例里面，每一条规则（CSSRule 实例）可以通过<code>rules.item(index)</code>或者<code>rules[index]</code>拿到。CSS 规则的条数通过<code>rules.length</code>拿到。还是用上面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crl[<span class="number">0</span>] <span class="keyword">instanceof</span> <span class="title class_">CSSRule</span> <span class="comment">// true</span></span><br><span class="line">crl.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>注意，添加规则和删除规则不能在 CSSRuleList 实例操作，而要在它的父元素 StyleSheet 实例上，通过<code>StyleSheet.insertRule()</code>和<code>StyleSheet.deleteRule()</code>操作。</p>
<h1 id="CSSRule-接口"><a href="#CSSRule-接口" class="headerlink" title="CSSRule 接口"></a>CSSRule 接口</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>一条 CSS 规则包括两个部分：CSS 选择器和样式声明。下面就是一条典型的 CSS 规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myClass</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 通过 CSSRule 接口操作 CSS 规则。一般通过 CSSRuleList 接口（<code>StyleSheet.cssRules</code>）获取 CSSRule 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   .myClass &#123;</span></span><br><span class="line"><span class="comment">//     color: red;</span></span><br><span class="line"><span class="comment">//     background-color: yellow;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"><span class="keyword">var</span> ruleList = myStyleSheet.<span class="property">cssRules</span>;</span><br><span class="line"><span class="keyword">var</span> rule = ruleList[<span class="number">0</span>];</span><br><span class="line">rule <span class="keyword">instanceof</span> <span class="title class_">CSSRule</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="CSSRule-实例的属性"><a href="#CSSRule-实例的属性" class="headerlink" title="CSSRule 实例的属性"></a>CSSRule 实例的属性</h2><h4 id="CSSRule-cssText"><a href="#CSSRule-cssText" class="headerlink" title="CSSRule.cssText"></a>CSSRule.cssText</h4><p><code>CSSRule.cssText</code>属性返回当前规则的文本，还是使用上面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;.myClass &#123; color: red; background-color: yellow; &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果规则是加载（<code>@import</code>）其他样式表，<code>cssText</code>属性返回<code>@import &#39;url&#39;</code>。</p>
<h4 id="CSSRule-parentStyleSheet"><a href="#CSSRule-parentStyleSheet" class="headerlink" title="CSSRule.parentStyleSheet"></a>CSSRule.parentStyleSheet</h4><p><code>CSSRule.parentStyleSheet</code>属性返回当前规则所在的样式表对象（StyleSheet 实例），还是使用上面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rule.<span class="property">parentStyleSheet</span> === myStyleSheet <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="CSSRule-parentRule"><a href="#CSSRule-parentRule" class="headerlink" title="CSSRule.parentRule"></a>CSSRule.parentRule</h4><p><code>CSSRule.parentRule</code>属性返回包含当前规则的父规则，如果不存在父规则（即当前规则是顶层规则），则返回<code>null</code>。</p>
<p>父规则最常见的情况是，当前规则包含在<code>@media</code>规则代码块之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   @supports (display: flex) &#123;</span></span><br><span class="line"><span class="comment">//     @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//       article &#123;</span></span><br><span class="line"><span class="comment">//         display: flex;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> myStyleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line"><span class="keyword">var</span> ruleList = myStyleSheet.<span class="property">cssRules</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule0 = ruleList[<span class="number">0</span>];</span><br><span class="line">rule0.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;@supports (display: flex) &#123;</span></span><br><span class="line"><span class="comment">//    @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//      article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于这条规则内嵌其他规则，</span></span><br><span class="line"><span class="comment">// 所以它有 cssRules 属性，且该属性是 CSSRuleList 实例</span></span><br><span class="line">rule0.<span class="property">cssRules</span> <span class="keyword">instanceof</span> <span class="title class_">CSSRuleList</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule1 = rule0.<span class="property">cssRules</span>[<span class="number">0</span>];</span><br><span class="line">rule1.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;@media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//   article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">// &#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rule2 = rule1.<span class="property">cssRules</span>[<span class="number">0</span>];</span><br><span class="line">rule2.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;article &#123; display: flex; &#125;&quot;</span></span><br><span class="line"></span><br><span class="line">rule1.<span class="property">parentRule</span> === rule0 <span class="comment">// true</span></span><br><span class="line">rule2.<span class="property">parentRule</span> === rule1 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="CSSRule-type"><a href="#CSSRule-type" class="headerlink" title="CSSRule.type"></a>CSSRule.type</h4><p><code>CSSRule.type</code>属性返回一个整数值，表示当前规则的类型。</p>
<p>最常见的类型有以下几种。</p>
<ul>
<li>1：普通样式规则（CSSStyleRule 实例）</li>
<li>3：<code>@import</code>规则</li>
<li>4：<code>@media</code>规则（CSSMediaRule 实例）</li>
<li>5：<code>@font-face</code>规则</li>
</ul>
<h2 id="CSSStyleRule-接口"><a href="#CSSStyleRule-接口" class="headerlink" title="CSSStyleRule 接口"></a>CSSStyleRule 接口</h2><p>如果一条 CSS 规则是普通的样式规则（不含特殊的 CSS 命令），那么除了 CSSRule 接口，它还部署了 CSSStyleRule 接口。</p>
<p>CSSStyleRule 接口有以下两个属性。</p>
<h4 id="CSSStyleRule-selectorText"><a href="#CSSStyleRule-selectorText" class="headerlink" title="CSSStyleRule.selectorText"></a>CSSStyleRule.selectorText</h4><p><code>CSSStyleRule.selectorText</code>属性返回当前规则的选择器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stylesheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>];</span><br><span class="line">stylesheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">selectorText</span> <span class="comment">// &quot;.myClass&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，这个属性是可写的。</p>
<h4 id="CSSStyleRule-style"><a href="#CSSStyleRule-style" class="headerlink" title="CSSStyleRule.style"></a>CSSStyleRule.style</h4><p><code>CSSStyleRule.style</code>属性返回一个对象（CSSStyleDeclaration 实例），代表当前规则的样式声明，也就是选择器后面的大括号里面的部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   p &#123; color: red; &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> styleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">style</span> <span class="keyword">instanceof</span> <span class="title class_">CSSStyleDeclaration</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>CSSStyleDeclaration 实例的<code>cssText</code>属性，可以返回所有样式声明，格式为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">style</span>.<span class="property">cssText</span></span><br><span class="line"><span class="comment">// &quot;color: red;&quot;</span></span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">selectorText</span></span><br><span class="line"><span class="comment">// &quot;p&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="CSSMediaRule-接口"><a href="#CSSMediaRule-接口" class="headerlink" title="CSSMediaRule 接口"></a>CSSMediaRule 接口</h2><p>如果一条 CSS 规则是<code>@media</code>代码块，那么它除了 CSSRule 接口，还部署了 CSSMediaRule 接口。</p>
<p>该接口主要提供<code>media</code>属性和<code>conditionText</code>属性。前者返回代表<code>@media</code>规则的一个对象（MediaList 实例），后者返回<code>@media</code>规则的生效条件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;style id=&quot;myStyle&quot;&gt;</span></span><br><span class="line"><span class="comment">//   @media screen and (min-width: 900px) &#123;</span></span><br><span class="line"><span class="comment">//     article &#123; display: flex; &#125;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &lt;/style&gt;</span></span><br><span class="line"><span class="keyword">var</span> styleSheet = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myStyle&#x27;</span>).<span class="property">sheet</span>;</span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>] <span class="keyword">instanceof</span> <span class="title class_">CSSMediaRule</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">media</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    0: &quot;screen and (min-width: 900px)&quot;,</span></span><br><span class="line"><span class="comment">//    appendMedium: function,</span></span><br><span class="line"><span class="comment">//    deleteMedium: function,</span></span><br><span class="line"><span class="comment">//    item: function,</span></span><br><span class="line"><span class="comment">//    length: 1,</span></span><br><span class="line"><span class="comment">//    mediaText: &quot;screen and (min-width: 900px)&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">styleSheet.<span class="property">cssRules</span>[<span class="number">0</span>].<span class="property">conditionText</span></span><br><span class="line"><span class="comment">// &quot;screen and (min-width: 900px)&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="window-matchMedia"><a href="#window-matchMedia" class="headerlink" title="window.matchMedia()"></a>window.matchMedia()</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>window.matchMedia</code>方法用来将 CSS 的<code>MediaQuery</code>条件语句，转换成一个 MediaQueryList 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mdl = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(min-width: 400px)&#x27;</span>);</span><br><span class="line">mdl <span class="keyword">instanceof</span> <span class="title class_">MediaQueryList</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注意，如果参数不是有效的<code>MediaQuery</code>条件语句，<code>window.matchMedia</code>不会报错，依然返回一个 MediaQueryList 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;bad string&#x27;</span>) <span class="keyword">instanceof</span> <span class="title class_">MediaQueryList</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="MediaQueryList-接口的实例属性"><a href="#MediaQueryList-接口的实例属性" class="headerlink" title="MediaQueryList 接口的实例属性"></a>MediaQueryList 接口的实例属性</h2><p>MediaQueryList 实例有三个属性。</p>
<h4 id="MediaQueryList-media"><a href="#MediaQueryList-media" class="headerlink" title="MediaQueryList.media"></a>MediaQueryList.media</h4><p><code>MediaQueryList.media</code>属性返回一个字符串，表示对应的 MediaQuery 条件语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(min-width: 400px)&#x27;</span>);</span><br><span class="line">mql.<span class="property">media</span> <span class="comment">// &quot;(min-width: 400px)&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="MediaQueryList-matches"><a href="#MediaQueryList-matches" class="headerlink" title="MediaQueryList.matches"></a>MediaQueryList.matches</h4><p><code>MediaQueryList.matches</code>属性返回一个布尔值，表示当前页面是否符合指定的 MediaQuery 条件语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(min-width: 400px)&#x27;</span>).<span class="property">matches</span>) &#123;</span><br><span class="line">  <span class="comment">/* 当前视口不小于 400 像素 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 当前视口小于 400 像素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子根据<code>mediaQuery</code>是否匹配当前环境，加载相应的 CSS 样式表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&quot;(max-width: 700px)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.<span class="property">matches</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> linkElm = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">  linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;rel&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>);</span><br><span class="line">  linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/css&#x27;</span>);</span><br><span class="line">  linkElm.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;small.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(linkElm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MediaQueryList-onchange"><a href="#MediaQueryList-onchange" class="headerlink" title="MediaQueryList.onchange"></a>MediaQueryList.onchange</h4><p>如果 MediaQuery 条件语句的适配环境发生变化，会触发<code>change</code>事件。<code>MediaQueryList.onchange</code>属性用来指定<code>change</code>事件的监听函数。该函数的参数是<code>change</code>事件对象（MediaQueryListEvent 实例），该对象与 MediaQueryList 实例类似，也有<code>media</code>和<code>matches</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mql.<span class="property">onchange</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">matches</span>) &#123;</span><br><span class="line">    <span class="comment">/* 视口不超过 600 像素 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 视口超过 600 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>change</code>事件发生后，存在两种可能。一种是显示宽度从700像素以上变为以下，另一种是从700像素以下变为以上，所以在监听函数内部要判断一下当前是哪一种情况。</p>
<h2 id="MediaQueryList-接口的实例方法"><a href="#MediaQueryList-接口的实例方法" class="headerlink" title="MediaQueryList 接口的实例方法"></a>MediaQueryList 接口的实例方法</h2><p>MediaQueryList 实例有两个方法<code>MediaQueryList.addListener()</code>和<code>MediaQueryList.removeListener()</code>，用来为<code>change</code>事件添加或撤销监听函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mql = <span class="variable language_">window</span>.<span class="title function_">matchMedia</span>(<span class="string">&#x27;(max-width: 600px)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定监听函数</span></span><br><span class="line">mql.<span class="title function_">addListener</span>(mqCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 撤销监听函数</span></span><br><span class="line">mql.<span class="title function_">removeListener</span>(mqCallback);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mqCallback</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">matches</span>) &#123;</span><br><span class="line">    <span class="comment">/* 视口不超过 600 像素 */</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 视口超过 600 像素 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS DOM——Text节点和DocumentFragment节点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/13/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment%E8%8A%82%E7%82%B9/"
    >JS DOM—Text节点和DocumentFragment节点</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/11/13/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Text%E8%8A%82%E7%82%B9%E5%92%8CDocumentFragment%E8%8A%82%E7%82%B9/" class="article-date">
  <time datetime="2018-11-13T03:22:14.000Z" itemprop="datePublished">2018-11-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Text-节点的概念"><a href="#Text-节点的概念" class="headerlink" title="Text 节点的概念"></a>Text 节点的概念</h1><p>文本节点（<code>Text</code>）代表元素节点（<code>Element</code>）和属性节点（<code>Attribute</code>）的文本内容。如果一个节点只包含一段文本，那么它就有一个文本子节点，代表该节点的文本内容。</p>
<p>通常我们使用父节点的<code>firstChild</code>、<code>nextSibling</code>等属性获取文本节点，或者使用<code>Document</code>节点的<code>createTextNode</code>方法创造一个文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创造文本节点</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">appendChild</span>(textNode);</span><br></pre></td></tr></table></figure>
<p>浏览器原生提供一个<code>Text</code>构造函数。它返回一个文本节点实例。它的参数就是该文本节点的文本内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空字符串</span></span><br><span class="line"><span class="keyword">var</span> text1 = <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line"><span class="comment">// 非空字符串</span></span><br><span class="line"><span class="keyword">var</span> text2 = <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;This is a text node&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，由于空格也是一个字符，所以哪怕只有一个空格，也会形成文本节点。比如，<code>&lt;p&gt; &lt;/p&gt;</code>包含一个空格，它的子节点就是一个文本节点。</p>
<p>文本节点除了继承<code>Node</code>接口，还继承了<code>CharacterData</code>接口。以下的属性和方法大部分来自<code>CharacterData</code>接口。</p>
<h1 id="Text-节点的属性"><a href="#Text-节点的属性" class="headerlink" title="Text 节点的属性"></a>Text 节点的属性</h1><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p><code>data</code>属性等同于<code>nodeValue</code>属性，用来设置或读取文本节点的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文本内容</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="property">data</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="property">nodeValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文本内容</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="property">data</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="wholeText"><a href="#wholeText" class="headerlink" title="wholeText"></a>wholeText</h2><p><code>wholeText</code>属性将当前文本节点与毗邻的文本节点，作为一个整体返回。大多数情况下，<code>wholeText</code>属性的返回值，与<code>data</code>属性和<code>textContent</code>属性相同。但是，某些特殊情况会有差异。</p>
<p>举例来说，HTML 代码如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para&quot;</span>&gt;</span>A <span class="tag">&lt;<span class="name">em</span>&gt;</span>B<span class="tag">&lt;/<span class="name">em</span>&gt;</span> C<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时，文本节点的<code>wholeText</code>属性和<code>data</code>属性，返回值相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para&#x27;</span>);</span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">wholeText</span> <span class="comment">// &quot;A &quot;</span></span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">data</span> <span class="comment">// &quot;A &quot;</span></span><br></pre></td></tr></table></figure>
<p>但是，一旦移除<code>&lt;em&gt;</code>节点，<code>wholeText</code>属性与<code>data</code>属性就会有差异，因为这时其实<code>&lt;p&gt;</code>节点下面包含了两个毗邻的文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">removeChild</span>(para.<span class="property">childNodes</span>[<span class="number">1</span>]);</span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">wholeText</span> <span class="comment">// &quot;A C&quot;</span></span><br><span class="line">el.<span class="property">firstChild</span>.<span class="property">data</span> <span class="comment">// &quot;A &quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p><code>length</code>属性返回当前文本节点的文本长度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&#x27;Hello&#x27;</span>)).<span class="property">length</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="nextElementSibling，previousElementSibling"><a href="#nextElementSibling，previousElementSibling" class="headerlink" title="nextElementSibling，previousElementSibling"></a>nextElementSibling，previousElementSibling</h2><p><code>nextElementSibling</code>属性返回紧跟在当前文本节点后面的那个同级元素节点。如果取不到元素节点，则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> tn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">firstChild</span>;</span><br><span class="line">tn.<span class="property">nextElementSibling</span></span><br><span class="line"><span class="comment">// &lt;em&gt;World&lt;/em&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>previousElementSibling</code>属性返回当前文本节点前面最近的同级元素节点。如果取不到元素节点，则返回<code>null：</code>。</p>
<h1 id="Text-节点的方法"><a href="#Text-节点的方法" class="headerlink" title="Text 节点的方法"></a>Text 节点的方法</h1><h2 id="appendData-，deleteData-，insertData-，replaceData-，subStringData"><a href="#appendData-，deleteData-，insertData-，replaceData-，subStringData" class="headerlink" title="appendData()，deleteData()，insertData()，replaceData()，subStringData()"></a>appendData()，deleteData()，insertData()，replaceData()，subStringData()</h2><p>以下5个方法都是编辑<code>Text</code>节点文本内容的方法。</p>
<ul>
<li><code>appendData()</code>：在<code>Text</code>节点尾部追加字符串。</li>
<li><code>deleteData()</code>：删除<code>Text</code>节点内部的子字符串，第一个参数为子字符串开始位置，第二个参数为子字符串长度。</li>
<li><code>insertData()</code>：在<code>Text</code>节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。</li>
<li><code>replaceData()</code>：用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。</li>
<li><code>subStringData()</code>：用于获取子字符串，第一个参数为子字符串在<code>Text</code>节点中的开始位置，第二个参数为子字符串长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello World&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> pElementText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line">pElementText.<span class="title function_">appendData</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello World!</span></span><br><span class="line">pElementText.<span class="title function_">deleteData</span>(<span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello W</span></span><br><span class="line">pElementText.<span class="title function_">insertData</span>(<span class="number">7</span>, <span class="string">&#x27;Hello &#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello WHello</span></span><br><span class="line">pElementText.<span class="title function_">replaceData</span>(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&#x27;World&#x27;</span>);</span><br><span class="line"><span class="comment">// 页面显示 Hello WWorld</span></span><br><span class="line">pElementText.<span class="title function_">substringData</span>(<span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 页面显示不变，返回&quot;World &quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove</code>方法用于移除当前<code>Text</code>节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello World&lt;/p&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>).<span class="property">firstChild</span>.<span class="title function_">remove</span>()</span><br><span class="line"><span class="comment">// 现在 HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;p&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="splitText"><a href="#splitText" class="headerlink" title="splitText()"></a>splitText()</h2><p><code>splitText</code>方法将<code>Text</code>节点一分为二，变成两个毗邻的<code>Text</code>节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。</p>
<p>分割后，该方法返回分割位置后方的字符串，而原<code>Text</code>节点变成只包含分割位置前方的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html 代码为 &lt;p id=&quot;p&quot;&gt;foobar&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> textnode = p.<span class="property">firstChild</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newText = textnode.<span class="title function_">splitText</span>(<span class="number">3</span>);</span><br><span class="line">newText <span class="comment">// &quot;bar&quot;</span></span><br><span class="line">textnode <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<p>父元素节点的<code>normalize</code>方法可以将毗邻的两个<code>Text</code>节点合并。</p>
<p>接上面的例子，文本节点的<code>splitText</code>方法将一个<code>Text</code>节点分割成两个，父元素的<code>normalize</code>方法可以实现逆操作，将它们合并。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="property">childNodes</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将毗邻的两个 Text 节点合并</span></span><br><span class="line">p.<span class="title function_">normalize</span>();</span><br><span class="line">p.<span class="property">childNodes</span>.<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>#DocumentFragment 节点<br><code>DocumentFragment</code>节点代表一个文档的片段，本身就是一个完整的 DOM 树形结构。它没有父节点，<code>parentNode</code>返回<code>null</code>，但是可以插入任意数量的子节点。它不属于当前文档，操作<code>DocumentFragment</code>节点，要比直接操作 DOM 树快得多。</p>
<p>它一般用于构建一个 DOM 结构，然后插入当前文档。<code>document.createDocumentFragment</code>方法，以及浏览器原生的<code>DocumentFragment</code>构造函数，可以创建一个空的<code>DocumentFragment</code>节点。然后再使用其他 DOM 方法，向其添加子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docFrag = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> docFrag = <span class="keyword">new</span> <span class="title class_">DocumentFragment</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">li.<span class="property">textContent</span> = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">docFrag.<span class="title function_">appendChild</span>(li);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>).<span class="title function_">appendChild</span>(docFrag);</span><br></pre></td></tr></table></figure>
<p>上面代码创建了一个<code>DocumentFragment</code>节点，然后将一个<code>li</code>节点添加在它里面，最后将<code>DocumentFragment</code>节点移动到原文档。</p>
<p>注意，<code>DocumentFragment</code>节点本身不能被插入当前文档。当它作为<code>appendChild()</code>、<code>insertBefore()</code>、<code>replaceChild()</code>等方法的参数时，是它的所有子节点插入当前文档，而不是它自身。一旦<code>DocumentFragment</code>节点被添加进当前文档，它自身就变成了空节点（<code>textContent</code>属性为空字符串），可以被再次使用。如果想要保存<code>DocumentFragment</code>节点的内容，可以使用<code>cloneNode</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span></span><br><span class="line">  .<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">  .<span class="title function_">appendChild</span>(docFrag.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>上面这样添加<code>DocumentFragment</code>节点进入当前文档，不会清空<code>DocumentFragment</code>节点。</p>
<p>下面是一个例子，使用<code>DocumentFragment</code>反转一个指定节点的所有子节点的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">while</span>(n.<span class="property">lastChild</span>) f.<span class="title function_">appendChild</span>(n.<span class="property">lastChild</span>);</span><br><span class="line">  n.<span class="title function_">appendChild</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DocumentFragment</code>节点对象没有自己的属性和方法，全部继承自<code>Node</code>节点和<code>ParentNode</code>接口。也就是说，<code>DocumentFragment</code>节点比<code>Node</code>节点多出以下四个属性。</p>
<ul>
<li><code>children</code>：返回一个动态的<code>HTMLCollection</code>集合对象，包括当前<code>DocumentFragment</code>对象的所有子元素节点。</li>
<li><code>firstElementChild</code>：返回当前<code>DocumentFragment</code>对象的第一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>lastElementChild</code>：返回当前<code>DocumentFragment</code>对象的最后一个子元素节点，如果没有则返回<code>null</code>。</li>
<li><code>childElementCount</code>：返回当前<code>DocumentFragment</code>对象的所有子元素数量。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS DOM——属性的操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/13/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C/"
    >JS DOM—属性的操作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/11/13/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94%E5%B1%9E%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2018-11-13T03:22:14.000Z" itemprop="datePublished">2018-11-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（<code>attribute</code>）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com&quot;</span>&gt;</span></span><br><span class="line">  链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>元素包括两个属性：<code>id</code>属性和<code>href</code>属性。</p>
<p>属性本身是一个对象（<code>Attr</code>对象），但是实际上，这个对象极少使用。一般都是通过元素节点对象（<code>HTMlElement</code>对象）来操作属性。</p>
<h1 id="Element-attributes-属性"><a href="#Element-attributes-属性" class="headerlink" title="Element.attributes 属性"></a>Element.attributes 属性</h1><p>元素对象有一个<code>attributes</code>属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。其他类型的节点对象，虽然也有<code>attributes</code>属性，但返回的都是<code>null</code>，因此可以把这个属性视为元素对象独有的。</p>
<p>单个属性可以通过序号引用，也可以通过属性名引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;body bgcolor=&quot;yellow&quot; onload=&quot;&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">attributes</span>[<span class="number">0</span>]</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">attributes</span>.<span class="property">bgcolor</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">attributes</span>[<span class="string">&#x27;ONLOAD&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>注意，上面代码的三种方法，返回的都是属性节点对象，而不是属性值。</p>
<p>属性节点对象有<code>name</code>和<code>value</code>属性，对应该属性的属性名和属性值，等同于<code>nodeName</code>属性和<code>nodeValue</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;mydiv&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">name</span> <span class="comment">// &quot;id&quot;</span></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">nodeName</span> <span class="comment">// &quot;id&quot;</span></span><br><span class="line"></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">value</span> <span class="comment">// &quot;mydiv&quot;</span></span><br><span class="line">n.<span class="property">attributes</span>[<span class="number">0</span>].<span class="property">nodeValue</span> <span class="comment">// &quot;mydiv&quot;</span></span><br></pre></td></tr></table></figure>
<p>下面代码可以遍历一个元素节点的所有属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> para = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (para.<span class="title function_">hasAttributes</span>()) &#123;</span><br><span class="line">  <span class="keyword">var</span> attrs = para.<span class="property">attributes</span>;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = attrs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    output += attrs[i].<span class="property">name</span> + <span class="string">&#x27;-&gt;&#x27;</span> + attrs[i].<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result.<span class="property">textContent</span> = output;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result.<span class="property">textContent</span> = <span class="string">&#x27;No attributes to show&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="元素的标准属性"><a href="#元素的标准属性" class="headerlink" title="元素的标准属性"></a>元素的标准属性</h1><p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">a.<span class="property">id</span> <span class="comment">// &quot;test&quot;</span></span><br><span class="line">a.<span class="property">href</span> <span class="comment">// &quot;http://www.example.com/&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>元素标签的属性<code>id</code>和<code>href</code>，自动成为节点对象的属性。</p>
<p>这些属性都是可写的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myImage&#x27;</span>);</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;http://www.example.com/image.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面的写法，会立刻替换掉<code>img</code>对象的<code>src</code>属性，即会显示另外一张图片。</p>
<p>这种修改属性的方法，常常用于添加表单的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>];</span><br><span class="line">f.<span class="property">action</span> = <span class="string">&#x27;submit.php&#x27;</span>;</span><br><span class="line">f.<span class="property">method</span> = <span class="string">&#x27;POST&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码为表单添加提交网址和提交方法。</p>
<p>注意，这种用法虽然可以读写属性，但是无法删除属性，<code>delete</code>运算符在这里不会生效。</p>
<p>HTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转换规则是，转为 JavaScript 属性名时，一律采用小写。如果属性名包括多个单词，则采用骆驼拼写法，即从第二个单词开始，每个单词的首字母采用大写，比如<code>onClick</code>。</p>
<p>有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名。主要是以下两个。</p>
<ul>
<li><code>for</code>属性改为<code>htmlFor</code></li>
<li><code>class</code>属性改为<code>className</code></li>
</ul>
<p>另外，HTML 属性值一般都是字符串，但是 JavaScript 属性会自动转换类型。比如，将字符串<code>true</code>转为布尔值，将<code>onClick</code>的值转为一个函数，将<code>style</code>属性的值转为一个<code>CSSStyleDeclaration</code>对象。因此，可以对这些属性赋予各种类型的值。</p>
<h1 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="headerlink" title="属性操作的标准方法"></a>属性操作的标准方法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>元素节点提供六个方法，用来操作属性。</p>
<ul>
<li><code>getAttribute()</code></li>
<li><code>getAttributeNames()</code></li>
<li><code>setAttribute()</code></li>
<li><code>hasAttribute()</code></li>
<li><code>hasAttributes()</code></li>
<li><code>removeAttribute()</code></li>
</ul>
<p>这有几点注意。<br>（1）适用性<br>这六个方法对所有属性（包括用户自定义的属性）都适用。<br>（2）返回值<br><code>getAttribute()</code>只返回字符串，不会返回其他类型的值。<br>（3）属性名<br>这些方法只接受属性的标准名称，不用改写保留字，比如<code>for</code>和<code>class</code>都可以直接使用。另外，这些方法对于属性名是大小写不敏感的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>];</span><br><span class="line">image.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;myImage&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>setAttribute</code>方法直接使用<code>class</code>作为属性名，不用写成<code>className</code>。</p>
<h2 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h2><p><code>Element.getAttribute</code>方法返回当前元素节点的指定属性。如果指定属性不存在，则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; align=&quot;left&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">div.<span class="title function_">getAttribute</span>(<span class="string">&#x27;align&#x27;</span>) <span class="comment">// &quot;left&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Element-getAttributeNames"><a href="#Element-getAttributeNames" class="headerlink" title="Element.getAttributeNames()"></a>Element.getAttributeNames()</h2><p><code>Element.getAttributeNames()</code>返回一个数组，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。使用<code>Element.attributes</code>属性，也可以拿到同样的结果，唯一的区别是它返回的是类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mydiv.<span class="title function_">getAttributeNames</span>().<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = mydiv.<span class="title function_">getAttribute</span>(key);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码用于遍历某个节点的所有属性。</p>
<h2 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h2><p><code>Element.setAttribute</code>方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;button&gt;Hello World&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">b.<span class="title function_">setAttribute</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line">b.<span class="title function_">setAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>button</code>元素的<code>name</code>属性被设成<code>myButton</code>，<code>disabled</code>属性被设成<code>true</code>。</p>
<p>这里有两个地方需要注意，首先，属性值总是字符串，其他类型的值会自动转成字符串，比如布尔值<code>true</code>就会变成字符串<code>true</code>；其次，上例的<code>disable</code>属性是一个布尔属性，对于<code>&lt;button&gt;</code>元素来说，这个属性不需要属性值，只要设置了就总是会生效，因此<code>setAttribute</code>方法里面可以将<code>disabled</code>属性设成任意值。</p>
<h2 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h2><p><code>Element.hasAttribute</code>方法返回一个布尔值，表示当前元素节点是否包含指定属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;align&#x27;</span>)) &#123;</span><br><span class="line">  d.<span class="title function_">setAttribute</span>(<span class="string">&#x27;align&#x27;</span>, <span class="string">&#x27;center&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Element-hasAttributes"><a href="#Element-hasAttributes" class="headerlink" title="Element.hasAttributes()"></a>Element.hasAttributes()</h2><p><code>Element.hasAttributes</code>方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回<code>false</code>，否则返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">foo.<span class="title function_">hasAttributes</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h2><p><code>Element.removeAttribute</code>方法移除指定属性。该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; align=&quot;left&quot; width=&quot;200px&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="title function_">removeAttribute</span>(<span class="string">&#x27;align&#x27;</span>);</span><br><span class="line"><span class="comment">// 现在的HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div1&quot; width=&quot;200px&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="dataset-属性"><a href="#dataset-属性" class="headerlink" title="dataset 属性"></a>dataset 属性</h1><p>有时，需要在HTML元素上附加数据，供 JavaScript 脚本使用。一种解决方法是自定义属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mydiv&quot;</span> <span class="attr">foo</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码为<code>div</code>元素自定义了<code>foo</code>属性，然后可以用<code>getAttribute()</code>和<code>setAttribute()</code>读写这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">n.<span class="title function_">getAttribute</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// bar</span></span><br><span class="line">n.<span class="title function_">setAttribute</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这种方法虽然可以达到目的，但是会使得 HTML 元素的属性不符合标准，导致网页代码通不过校验。</p>
<p>更好的解决方法是，使用标准提供的<code>data-*</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mydiv&quot;</span> <span class="attr">data-foo</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，使用元素节点对象的<code>dataset</code>属性，它指向一个对象，可以用来操作 HTML 元素标签的<code>data-*</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">n.<span class="property">dataset</span>.<span class="property">foo</span> <span class="comment">// bar</span></span><br><span class="line">n.<span class="property">dataset</span>.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>dataset.foo</code>读写<code>data-foo</code>属性。</p>
<p>删除一个<code>data-*</code>属性，可以直接使用<code>delete</code>命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">dataset</span>.<span class="property">foo</span>;</span><br></pre></td></tr></table></figure>
<p>除了<code>dataset</code>属性，也可以用<code>getAttribute(&#39;data-foo&#39;)</code>、<code>removeAttribute(&#39;data-foo&#39;)</code>、<code>setAttribute(&#39;data-foo&#39;)</code>、<code>hasAttribute(&#39;data-foo&#39;)</code>等方法操作<code>data-*</code>属性。</p>
<p>注意，<code>data-</code>后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名不应该使用<code>A</code>到<code>Z</code>的大写字母，比如不能有<code>data-helloWorld</code>这样的属性名，而要写成<code>data-hello-world</code>。</p>
<p>转成<code>dataset</code>的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，<code>dataset</code>的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，<code>dataset.helloWorld</code>会转成<code>data-hello-world</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS DOM——Element节点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/11/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Element%E8%8A%82%E7%82%B9/"
    >JS DOM—Element节点</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/11/11/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Element%E8%8A%82%E7%82%B9/" class="article-date">
  <time datetime="2018-11-11T09:15:41.000Z" itemprop="datePublished">2018-11-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>Element</code>节点对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个<code>Element</code>节点对象（以下简称元素节点）。</p>
<p>元素节点的<code>nodeType</code>属性都是<code>1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.<span class="property">nodeName</span> <span class="comment">// &quot;P&quot;</span></span><br><span class="line">p.<span class="property">nodeType</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>Element</code>对象继承了<code>Node</code>接口，因此<code>Node</code>的属性和方法在<code>Element</code>对象都存在。此外，不同的 HTML 元素对应的元素节点是不一样的，浏览器使用不同的构造函数，生成不同的元素节点，比如<code>&lt;a&gt;</code>元素的节点对象由<code>HTMLAnchorElement</code>构造函数生成，<code>&lt;button&gt;</code>元素的节点对象由<code>HTMLButtonElement</code>构造函数生成。因此，元素节点不是一种对象，而是一组对象，这些对象除了继承<code>Element</code>的属性和方法，还有各自构造函数的属性和方法。</p>
<h1 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h1><h2 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="headerlink" title="元素特性的相关属性"></a>元素特性的相关属性</h2><h4 id="Element-id"><a href="#Element-id" class="headerlink" title="Element.id"></a>Element.id</h4><p><code>Element.id</code>属性返回指定元素的<code>id</code>属性，该属性可读写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;p id=&quot;foo&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.<span class="property">id</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>id</code>属性的值是大小写敏感，即浏览器能正确识别<code>&lt;p id=&quot;foo&quot;&gt;</code>和<code>&lt;p id=&quot;FOO&quot;&gt;</code>这两个元素的<code>id</code>属性，但是最好不要这样命名。</p>
<h4 id="Element-tagName"><a href="#Element-tagName" class="headerlink" title="Element.tagName"></a>Element.tagName</h4><p><code>Element.tagName</code>属性返回指定元素的大写标签名，与<code>nodeName</code>属性的值相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;span id=&quot;myspan&quot;&gt;Hello&lt;/span&gt;</span></span><br><span class="line"><span class="keyword">var</span> span = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myspan&#x27;</span>);</span><br><span class="line">span.<span class="property">id</span> <span class="comment">// &quot;myspan&quot;</span></span><br><span class="line">span.<span class="property">tagName</span> <span class="comment">// &quot;SPAN&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Element-dir"><a href="#Element-dir" class="headerlink" title="Element.dir"></a>Element.dir</h4><p><code>Element.dir</code>属性用于读写当前元素的文字方向，可能是从左到右（<code>&quot;ltr&quot;</code>），也可能是从右到左（<code>&quot;rtl&quot;</code>）。</p>
<h4 id="Element-accessKey"><a href="#Element-accessKey" class="headerlink" title="Element.accessKey"></a>Element.accessKey</h4><p><code>Element.accessKey</code>属性用于读写分配给当前元素的快捷键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;button accesskey=&quot;h&quot; id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">accessKey</span> <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>btn</code>元素的快捷键是<code>h</code>，按下<code>Alt + h</code>就能将焦点转移到它上面。</p>
<h4 id="Element-draggable"><a href="#Element-draggable" class="headerlink" title="Element.draggable"></a>Element.draggable</h4><p><code>Element.draggable</code>属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</p>
<h4 id="Element-lang"><a href="#Element-lang" class="headerlink" title="Element.lang"></a>Element.lang</h4><p><code>Element.lang</code>属性返回当前元素的语言设置。该属性可读写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">lang</span> <span class="comment">// &quot;en&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Element-tabIndex"><a href="#Element-tabIndex" class="headerlink" title="Element.tabIndex"></a>Element.tabIndex</h4><p><code>Element.tabIndex</code>属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</p>
<p><code>tabIndex</code>属性值如果是负值（通常是<code>-1</code>），则 Tab 键不会遍历到该元素。如果是正整数，则按照顺序，从小到大遍历。如果两个元素的<code>tabIndex</code>属性的正整数值相同，则按照出现的顺序遍历。遍历完所有<code>tabIndex</code>为正整数的元素以后，再遍历所有<code>tabIndex</code>等于<code>0</code>、或者属性值是非法值、或者没有<code>tabIndex</code>属性的元素，顺序为它们在网页中出现的顺序。</p>
<h4 id="Element-title"><a href="#Element-title" class="headerlink" title="Element.title"></a>Element.title</h4><p><code>Element.title</code>属性用来读写当前元素的 HTML 属性<code>title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p>
<h2 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="headerlink" title="元素状态的相关属性"></a>元素状态的相关属性</h2><h4 id="Element-hidden"><a href="#Element-hidden" class="headerlink" title="Element.hidden"></a>Element.hidden</h4><p><code>Element.hidden</code>属性返回一个布尔值，表示当前元素的<code>hidden</code>属性，用来控制当前元素是否可见。该属性可读写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mydiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  mydiv.<span class="property">hidden</span> = !mydiv.<span class="property">hidden</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，<code>Element.hidden</code>并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p>
<p>CSS 的设置高于<code>Element.hidden</code>。如果 CSS 指定了该元素不可见（<code>display: none</code>）或可见（<code>display: hidden</code>），那么<code>Element.hidden</code>并不能改变该元素实际的可见性。换言之，这个属性只在 CSS 没有明确设定当前元素的可见性时才有效。</p>
<h4 id="Element-contentEditable，Element-isContentEditable"><a href="#Element-contentEditable，Element-isContentEditable" class="headerlink" title="Element.contentEditable，Element.isContentEditable"></a>Element.contentEditable，Element.isContentEditable</h4><p>HTML 元素可以设置<code>contentEditable</code>属性，使得元素的内容可以编辑。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;div&gt;</code>元素有<code>contenteditable</code>属性，因此用户可以在网页上编辑这个区块的内容。</p>
<p><code>Element.contentEditable</code>属性返回一个字符串，表示是否设置了<code>contenteditable</code>属性，有三种可能的值。该属性可写。</p>
<ul>
<li><code>&quot;true&quot;</code>：元素内容可编辑</li>
<li><code>&quot;false&quot;</code>：元素内容不可编辑</li>
<li><code>&quot;inherit&quot;</code>：元素是否可编辑，继承了父元素的设置</li>
</ul>
<p><code>Element.isContentEditable</code>属性返回一个布尔值，同样表示是否设置了<code>contenteditable</code>属性。该属性只读。</p>
<h2 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h2><p><code>Element.attributes</code>属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> attrs = p.<span class="property">attributes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = attrs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(attrs[i].<span class="property">name</span> + <span class="string">&#x27;-&gt;&#x27;</span> + attrs[i].<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历<code>p</code>元素的所有属性。</p>
<h2 id="Element-className，Element-classList"><a href="#Element-className，Element-classList" class="headerlink" title="Element.className，Element.classList"></a>Element.className，Element.classList</h2><p><code>className</code>属性用来读写当前元素节点的<code>class</code>属性。它的值是一个字符串，每个<code>class</code>之间用空格分割。</p>
<p><code>classList</code>属性返回一个类似数组的对象，当前元素节点的每个<code>class</code>就是这个对象的一个成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码 &lt;div class=&quot;one two three&quot; id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="property">className</span> <span class="comment">// &quot;one two three&quot;</span></span><br><span class="line"></span><br><span class="line">div.<span class="property">classList</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   0: &quot;one&quot;</span></span><br><span class="line"><span class="comment">//   1: &quot;two&quot;</span></span><br><span class="line"><span class="comment">//   2: &quot;three&quot;</span></span><br><span class="line"><span class="comment">//   length: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>className</code>属性返回一个空格分隔的字符串，而<code>classList</code>属性指向一个类似数组的对象，该对象的<code>length</code>属性（只读）返回当前元素的<code>class</code>数量。<br><code>classList</code>对象有下列方法。</p>
<ul>
<li><code>add()</code>：增加一个 class。</li>
<li><code>remove()</code>：移除一个 class。</li>
<li><code>contains()</code>：检查当前元素是否包含某个 class。</li>
<li><code>toggle()</code>：将某个 class 移入或移出当前元素。</li>
<li><code>item()</code>：返回指定索引位置的 class。</li>
<li><code>toString()</code>：将 class 的列表转为字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;myCssClass&#x27;</span>);</span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;myCssClass&#x27;</span>);</span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;myCssClass&#x27;</span>); <span class="comment">// 如果 myCssClass 不存在就加入，否则移除</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;myCssClass&#x27;</span>); <span class="comment">// 返回 true 或者 false</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">item</span>(<span class="number">0</span>); <span class="comment">// 返回第一个 Class</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>
<p>下面比较一下，<code>className</code>和<code>classList</code>在添加和删除某个 class 时的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加class</span></span><br><span class="line">foo.<span class="property">className</span> += <span class="string">&#x27;bold&#x27;</span>;</span><br><span class="line">foo.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除class</span></span><br><span class="line">foo.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line">foo.<span class="property">className</span> = foo.<span class="property">className</span>.<span class="title function_">replace</span>(<span class="regexp">/^bold$/</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>toggle</code>方法可以接受一个布尔值，作为第二个参数。如果为<code>true</code>，则添加该属性；如果为<code>false</code>，则去除该属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;abc&#x27;</span>, boolValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">if</span> (boolValue) &#123;</span><br><span class="line">  el.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  el.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Element-dataset"><a href="#Element-dataset" class="headerlink" title="Element.dataset"></a>Element.dataset</h2><p>网页元素可以自定义<code>data-</code>属性，用来添加数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-timestamp</span>=<span class="string">&quot;1522907809292&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;div&gt;</code>元素有一个自定义的<code>data-timestamp</code>属性，用来为该元素添加一个时间戳。</p>
<p><code>Element.dataset</code>属性返回一个对象，可以从这个对象读写<code>data-</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;article</span></span><br><span class="line"><span class="comment">//   id=&quot;foo&quot;</span></span><br><span class="line"><span class="comment">//   data-columns=&quot;3&quot;</span></span><br><span class="line"><span class="comment">//   data-index-number=&quot;12314&quot;</span></span><br><span class="line"><span class="comment">//   data-parent=&quot;cars&quot;&gt;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// &lt;/article&gt;</span></span><br><span class="line"><span class="keyword">var</span> article = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">article.<span class="property">dataset</span>.<span class="property">columns</span> <span class="comment">// &quot;3&quot;</span></span><br><span class="line">article.<span class="property">dataset</span>.<span class="property">indexNumber</span> <span class="comment">// &quot;12314&quot;</span></span><br><span class="line">article.<span class="property">dataset</span>.<span class="property">parent</span> <span class="comment">// &quot;cars&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>dataset</code>上面的各个属性返回都是字符串。</p>
<p>HTML 代码中，<code>data-</code>属性的属性名，只能包含英文字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>）。它们转成 JavaScript 对应的<code>dataset</code>属性名，规则如下。</p>
<ul>
<li>开头的<code>data-</code>会省略。</li>
<li>如果连词线后面跟了一个英文字母，那么连词线会取消，该字母变成大写。</li>
<li>其他字符不变。</li>
</ul>
<p>因此，<code>data-abc-def</code>对应<code>dataset.abcDef</code>，<code>data-abc-1</code>对应<code>dataset[&quot;abc-1&quot;]</code>。</p>
<p>除了使用<code>dataset</code>读写<code>data-</code>属性，也可以使用<code>Element.getAttribute()</code>和<code>Element.setAttribute()</code>，通过完整的属性名读写这些属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mydiv.<span class="property">dataset</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">mydiv.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-foo&#x27;</span>) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Element-innerHTML"><a href="#Element-innerHTML" class="headerlink" title="Element.innerHTML"></a>Element.innerHTML</h2><p><code>Element.innerHTML</code>属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括<code>&lt;HTML&gt;</code>和<code>&lt;body&gt;</code>元素。</p>
<p>如果将<code>innerHTML</code>属性设为空，等于删除所有它包含的所有节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码等于将<code>el</code>节点变成了一个空节点，<code>el</code>原来包含的节点被全部删除。</p>
<p>注意，读取属性值的时候，如果文本节点包含<code>&amp;</code>、小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>），<code>innerHTML</code>属性会将它们转为实体形式<code>&amp;amp;</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code>。如果想得到原文，建议使用<code>element.textContent</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码如下 &lt;p id=&quot;para&quot;&gt; 5 &gt; 3 &lt;/p&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para&#x27;</span>).<span class="property">innerHTML</span></span><br><span class="line"><span class="comment">// 5 &amp;gt; 3</span></span><br></pre></td></tr></table></figure>
<p>写入的时候，如果插入的文本包含 HTML 标签，会被解析成为节点对象插入 DOM。注意，如果文本之中含有<code>&lt;script&gt;</code>标签，虽然可以生成<code>script</code>节点，但是插入的代码不会执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;&lt;script&gt;alert(&#x27;haha&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">el.<span class="property">innerHTML</span> = name;</span><br></pre></td></tr></table></figure>
<p>上面代码将脚本插入内容，脚本并不会执行。但是，<code>innerHTML</code>还是有安全风险的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;&lt;img src=x onerror=alert(1)&gt;&quot;</span>;</span><br><span class="line">el.<span class="property">innerHTML</span> = name;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>alert</code>方法是会执行的。因此为了安全考虑，如果插入的是文本，最好用<code>textContent</code>属性代替<code>innerHTML</code>。</p>
<h2 id="Element-outerHTML"><a href="#Element-outerHTML" class="headerlink" title="Element.outerHTML"></a>Element.outerHTML</h2><p><code>Element.outerHTML</code>属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">d.<span class="property">outerHTML</span></span><br><span class="line"><span class="comment">// &#x27;&lt;div id=&quot;d&quot;&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>outerHTML</code>属性是可读写的，对它进行赋值，等于替换掉当前元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;container&quot;&gt;&lt;div id=&quot;d&quot;&gt;Hello&lt;/div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">container.<span class="property">firstChild</span>.<span class="property">nodeName</span> <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line">d.<span class="property">nodeName</span> <span class="comment">// &quot;DIV&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="property">outerHTML</span> = <span class="string">&#x27;&lt;p&gt;Hello&lt;/p&gt;&#x27;</span>;</span><br><span class="line">container.<span class="property">firstChild</span>.<span class="property">nodeName</span> <span class="comment">// &quot;P&quot;</span></span><br><span class="line">d.<span class="property">nodeName</span> <span class="comment">// &quot;DIV&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>d</code>代表子节点，它的<code>outerHTML</code>属性重新赋值以后，内层的<code>div</code>元素就不存在了，被<code>p</code>元素替换了。但是，变量<code>d</code>依然指向原来的<code>div</code>元素，这表示被替换的<code>DIV</code>元素还存在于内存中。</p>
<p>注意，如果一个节点没有父节点，设置<code>outerHTML</code>属性会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">outerHTML</span> = <span class="string">&#x27;&lt;p&gt;test&lt;/p&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// DOMException: This element has no parent node.</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>div</code>元素没有父节点，设置<code>outerHTML</code>属性会报错。</p>
<h2 id="Element-clientHeight，Element-clientWidth"><a href="#Element-clientHeight，Element-clientWidth" class="headerlink" title="Element.clientHeight，Element.clientWidth"></a>Element.clientHeight，Element.clientWidth</h2><p><code>Element.clientHeight</code>属性返回一个整数值，表示元素节点的 CSS 高度（单位像素），只对块级元素生效，对于行内元素返回<code>0</code>。如果块级元素没有设置 CSS 高度，则返回实际高度。</p>
<p>除了元素本身的高度，它还包括<code>padding</code>部分，但是不包括<code>border</code>、<code>margin</code>。如果有水平滚动条，还要减去水平滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p>
<p><code>Element.clientWidth</code>属性返回元素节点的 CSS 宽度，同样只对块级元素有效，也是只包括元素本身的宽度和<code>padding</code>，如果有垂直滚动条，还要减去垂直滚动条的宽度。</p>
<p><code>document.documentElement</code>的<code>clientHeight</code>属性，返回当前视口的高度（即浏览器窗口的高度），等同于<code>window.innerHeight</code>属性减去水平滚动条的高度（如果有的话）。<code>document.body</code>的高度则是网页的实际高度。一般来说，<code>document.body.clientHeight</code>大于<code>document.documentElement.clientHeight</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视口高度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line"><span class="comment">// 网页总高度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span></span><br></pre></td></tr></table></figure>
<h2 id="Element-clientLeft，Element-clientTop"><a href="#Element-clientLeft，Element-clientTop" class="headerlink" title="Element.clientLeft，Element.clientTop"></a>Element.clientLeft，Element.clientTop</h2><p><code>Element.clientLeft</code>属性等于元素节点左边框（<code>left border</code>）的宽度（单位像素），不包括左侧的<code>padding</code>和<code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回<code>0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</p>
<p><code>Element.clientTop</code>属性等于网页元素顶部边框的宽度（单位像素），其他特点都与<code>clientLeft</code>相同。</p>
<h2 id="Element-scrollHeight，Element-scrollWidth"><a href="#Element-scrollHeight，Element-scrollWidth" class="headerlink" title="Element.scrollHeight，Element.scrollWidth"></a>Element.scrollHeight，Element.scrollWidth</h2><p><code>Element.scrollHeight</code>属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括<code>padding</code>，但是不包括<code>border</code>、<code>margin</code>以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code>或<code>::after</code>）的高度。</p>
<p><code>Element.scrollWidth</code>属性表示当前元素的总宽度（单位像素），其他地方都与<code>scrollHeight</code>属性类似。这两个属性只读。</p>
<p>整张网页的总高度可以从<code>document.documentElement</code>或<code>document.body</code>上读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回网页的总高度</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollHeight</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span></span><br></pre></td></tr></table></figure>
<p>注意，如果元素节点的内容出现溢出，即使溢出的内容是隐藏的，<code>scrollHeight</code>属性仍然返回元素的总高度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div id=&quot;myDiv&quot; style=&quot;height: 200px; overflow: hidden;&quot;&gt;...&lt;div&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>).<span class="property">scrollHeight</span> <span class="comment">// 356</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，即使<code>myDiv</code>元素的 CSS 高度只有200像素，且溢出部分不可见，但是<code>scrollHeight</code>仍然会返回该元素的原始高度。</p>
<h2 id="Element-scrollLeft，Element-scrollTop"><a href="#Element-scrollLeft，Element-scrollTop" class="headerlink" title="Element.scrollLeft，Element.scrollTop"></a>Element.scrollLeft，Element.scrollTop</h2><p><code>Element.scrollLeft</code>属性表示当前元素的水平滚动条向右侧滚动的像素数量，<code>Element.scrollTop</code>属性表示当前元素的垂直滚动条向下滚动的像素数量。对于那些没有滚动条的网页元素，这两个属性总是等于0。</p>
<p>如果要查看整张网页的水平的和垂直的滚动距离，要从<code>document.documentElement</code>元素上读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollLeft</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span></span><br></pre></td></tr></table></figure>
<p>这两个属性都可读写，设置该属性的值，会导致浏览器将当前元素自动滚动到相应的位置。</p>
<h2 id="Element-offsetParent"><a href="#Element-offsetParent" class="headerlink" title="Element.offsetParent"></a>Element.offsetParent</h2><p><code>Element.offsetParent</code>属性返回最靠近当前元素的、并且 CSS 的<code>position</code>属性不等于<code>static</code>的上层元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性就是<code>div</code>元素。</p>
<p>该属性主要用于确定子元素位置偏移的计算基准，<code>Element.offsetTop</code>和<code>Element.offsetLeft</code>就是<code>offsetParent</code>元素计算的。</p>
<p>如果该元素是不可见的（<code>display</code>属性为<code>none</code>），或者位置是固定的（<code>position</code>属性为<code>fixed</code>），则<code>offsetParent</code>属性返回<code>null</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>span</code>元素的<code>offsetParent</code>属性是<code>null</code>。</p>
<p>如果某个元素的所有上层节点的<code>position</code>属性都是<code>static</code>，则<code>Element.offsetParent</code>属性指向<code>&lt;body&gt;</code>元素。</p>
<h2 id="Element-offsetHeight，Element-offsetWidth"><a href="#Element-offsetHeight，Element-offsetWidth" class="headerlink" title="Element.offsetHeight，Element.offsetWidth"></a>Element.offsetHeight，Element.offsetWidth</h2><p><code>Element.offsetHeight</code>属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、<code>padding</code>和<code>border</code>，以及水平滚动条的高度（如果存在滚动条）。</p>
<p><code>Element.offsetWidth</code>属性表示元素的 CSS 水平宽度（单位像素），其他都与<code>Element.offsetHeight</code>一致。</p>
<p>这两个属性都是只读属性，只比<code>Element.clientHeight</code>和<code>Element.clientWidth</code>多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如<code>display: none;</code>），则返回<code>0</code>。</p>
<h2 id="Element-offsetLeft，Element-offsetTop"><a href="#Element-offsetLeft，Element-offsetTop" class="headerlink" title="Element.offsetLeft，Element.offsetTop"></a>Element.offsetLeft，Element.offsetTop</h2><p><code>Element.offsetLeft</code>返回当前元素左上角相对于<code>Element.offsetParent</code>节点的水平位移，<code>Element.offsetTop</code>返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。</p>
<p>下面的代码可以算出元素左上角相对于整张网页的坐标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElementPosition</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (e !== <span class="literal">null</span>)  &#123;</span><br><span class="line">    x += e.<span class="property">offsetLeft</span>;</span><br><span class="line">    y += e.<span class="property">offsetTop</span>;</span><br><span class="line">    e = e.<span class="property">offsetParent</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Element-style"><a href="#Element-style" class="headerlink" title="Element.style"></a>Element.style</h2><p>每个元素节点都有<code>style</code>用来读写该元素的行内样式信息。</p>
<h2 id="Element-children，Element-childElementCount"><a href="#Element-children，Element-childElementCount" class="headerlink" title="Element.children，Element.childElementCount"></a>Element.children，Element.childElementCount</h2><p><code>Element.children</code>属性返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括当前元素节点的所有子元素。如果当前元素没有子元素，则返回的对象包含零个成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (para.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> children = para.<span class="property">children</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历了<code>para</code>元素的所有子元素。</p>
<p>这个属性与<code>Node.childNodes</code>属性的区别是，它只包括元素类型的子节点，不包括其他类型的子节点。</p>
<p><code>Element.childElementCount</code>属性返回当前元素节点包含的子元素节点的个数，与<code>Element.children.length</code>的值相同。</p>
<h2 id="Element-firstElementChild，Element-lastElementChild"><a href="#Element-firstElementChild，Element-lastElementChild" class="headerlink" title="Element.firstElementChild，Element.lastElementChild"></a>Element.firstElementChild，Element.lastElementChild</h2><p><code>Element.firstElementChild</code>属性返回当前元素的第一个元素子节点，<code>Element.lastElementChild</code>返回最后一个元素子节点。</p>
<p>如果没有元素子节点，这两个属性返回<code>null</code>。</p>
<h2 id="Element-nextElementSibling，Element-previousElementSibling"><a href="#Element-nextElementSibling，Element-previousElementSibling" class="headerlink" title="Element.nextElementSibling，Element.previousElementSibling"></a>Element.nextElementSibling，Element.previousElementSibling</h2><p><code>Element.nextElementSibling</code>属性返回当前元素节点的后一个同级元素节点，如果没有则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-01&quot;&gt;Here is div-01&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div-01&#x27;</span>);</span><br><span class="line">el.<span class="property">nextElementSibling</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;div-02&quot;&gt;Here is div-02&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>Element.previousElementSibling</code>属性返回当前元素节点的前一个同级元素节点，如果没有则返回<code>null</code>。</p>
<h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><h2 id="属性相关方法"><a href="#属性相关方法" class="headerlink" title="属性相关方法"></a>属性相关方法</h2><p>元素节点提供六个方法，用来操作属性。</p>
<ul>
<li><code>getAttribute()</code>：读取某个属性的值</li>
<li><code>getAttributeNames()</code>：返回当前元素的所有属性名</li>
<li><code>setAttribute()</code>：写入属性值</li>
<li><code>hasAttribute()</code>：某个属性是否存在</li>
<li><code>hasAttributes()</code>：当前元素是否有属性</li>
<li><code>removeAttribute()</code>：删除属性</li>
</ul>
<h2 id="Element-querySelector"><a href="#Element-querySelector" class="headerlink" title="Element.querySelector()"></a>Element.querySelector()</h2><p><code>Element.querySelector</code>方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el = content.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码返回<code>content</code>节点的第一个<code>p</code>元素。</p>
<p><code>Element.querySelector</code>方法可以接受任何复杂的 CSS 选择器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;style[type=&#x27;text/css&#x27;], style:not([type])&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，这个方法无法选中伪元素。</p>
<p>它可以接受多个选择器，它们之间使用逗号分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">querySelector</span>(<span class="string">&#x27;div, p&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码返回<code>element</code>的第一个<code>div</code>或<code>p</code>子元素。</p>
<p>需要注意的是，浏览器执行<code>querySelector</code>方法时，是先在全局范围内搜索给定的 CSS 选择器，然后过滤出哪些属于当前元素的子元素。因此，会有一些违反直觉的结果，下面是一段 HTML 代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>World<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，像下面这样查询的话，实际上返回的是第一个<code>p</code>元素，而不是第二个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;outer&#x27;</span>);</span><br><span class="line">outer.<span class="title function_">querySelector</span>(<span class="string">&#x27;div p&#x27;</span>)</span><br><span class="line"><span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Element-querySelectorAll"><a href="#Element-querySelectorAll" class="headerlink" title="Element.querySelectorAll()"></a>Element.querySelectorAll()</h2><p><code>Element.querySelectorAll</code>方法接受 CSS 选择器作为参数，返回一个<code>NodeList</code>实例，包含所有匹配的子元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#test&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> matches = el.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>该方法的执行机制与<code>querySelector</code>方法相同，也是先在全局范围内查找，再过滤出当前元素的子元素。因此，选择器实际上针对整个文档的。</p>
<p>它也可以接受多个 CSS 选择器，它们之间使用逗号分隔。如果选择器里面有伪元素的选择器，则总是返回一个空的<code>NodeList</code>实例。</p>
<h2 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h2><p><code>Element.getElementsByClassName</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;red test&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该方法的参数大小写敏感。</p>
<p>由于<code>HTMLCollection</code>实例是一个活的集合，<code>document</code>对象的任何变化会立刻反应到实例，下面的代码不会生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;example&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> matches = element.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; matches.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  matches[i].<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  matches.<span class="title function_">item</span>(i).<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行后，HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;example&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p class=&quot;foo bar&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>matches</code>集合的第一个成员，一旦被拿掉 class 里面的<code>foo</code>，就会立刻从<code>matches</code>里面消失，导致出现上面的结果。</p>
<h2 id="Element-getElementsByTagName"><a href="#Element-getElementsByTagName" class="headerlink" title="Element.getElementsByTagName()"></a>Element.getElementsByTagName()</h2><p><code>Element.getElementsByTagName</code>方法返回一个<code>HTMLCollection</code>实例，成员是当前节点的所有匹配指定标签名的子元素节点。该方法与<code>document.getElementsByClassName</code>方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;forecast-table&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> cells = table.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;td&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该方法的参数是大小写不敏感的。</p>
<h2 id="Element-closest"><a href="#Element-closest" class="headerlink" title="Element.closest()"></a>Element.closest()</h2><p><code>Element.closest</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;article&gt;</span></span><br><span class="line"><span class="comment">//   &lt;div id=&quot;div-01&quot;&gt;Here is div-01</span></span><br><span class="line"><span class="comment">//     &lt;div id=&quot;div-02&quot;&gt;Here is div-02</span></span><br><span class="line"><span class="comment">//       &lt;div id=&quot;div-03&quot;&gt;Here is div-03&lt;/div&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;/article&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div03 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div-03&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// div-03 最近的祖先节点</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;#div-02&quot;</span>) <span class="comment">// div-02</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;div div&quot;</span>) <span class="comment">// div-03</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;article &gt; div&quot;</span>) <span class="comment">//div-01</span></span><br><span class="line">div03.<span class="title function_">closest</span>(<span class="string">&quot;:not(div)&quot;</span>) <span class="comment">// article</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>closest</code>方法将当前节点也考虑在内，所以第二个<code>closest</code>方法返回<code>div-03</code>。</p>
<h2 id="Element-matches"><a href="#Element-matches" class="headerlink" title="Element.matches()"></a>Element.matches()</h2><p><code>Element.matches</code>方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (el.<span class="title function_">matches</span>(<span class="string">&#x27;.someClass&#x27;</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Match!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件相关方法"><a href="#事件相关方法" class="headerlink" title="事件相关方法"></a>事件相关方法</h2><p>以下三个方法与<code>Element</code>节点的事件相关。这些方法都继承自<code>EventTarget</code>接口。</p>
<ul>
<li><code>Element.addEventListener()</code>：添加事件的回调函数</li>
<li><code>Element.removeEventListener()</code>：移除事件监听函数</li>
<li><code>Element.dispatchEvent()</code>：触发事件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line">element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line">element.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>
<h2 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="Element.scrollIntoView()"></a>Element.scrollIntoView()</h2><p><code>Element.scrollIntoView</code>方法滚动当前元素，进入浏览器的可见区域，类似于设置<code>window.location.hash</code>的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="title function_">scrollIntoView</span>(); <span class="comment">// 等同于el.scrollIntoView(true)</span></span><br><span class="line">el.<span class="title function_">scrollIntoView</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>该方法可以接受一个布尔值作为参数。如果为<code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为<code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为<code>true</code>。</p>
<h2 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h2><p><code>Element.getBoundingClientRect</code>方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = obj.<span class="title function_">getBoundingClientRect</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>getBoundingClientRect</code>方法返回的<code>rect</code>对象，具有以下属性（全部为只读）。</p>
<ul>
<li><code>x</code>：元素左上角相对于视口的横坐标</li>
<li><code>y</code>：元素左上角相对于视口的纵坐标</li>
<li><code>height</code>：元素高度</li>
<li><code>width</code>：元素宽度</li>
<li><code>left</code>：元素左上角相对于视口的横坐标，与<code>x</code>属性相等</li>
<li><code>right</code>：元素右边界相对于视口的横坐标（等于<code>x + width</code>）</li>
<li><code>top</code>：元素顶部相对于视口的纵坐标，与<code>y</code>属性相等</li>
<li><code>bottom</code>：元素底部相对于视口的纵坐标（等于<code>y + height</code>）</li>
</ul>
<p>由于元素相对于视口（viewport）的位置，会随着页面滚动变化，因此表示位置的四个属性值，都不是固定不变的。如果想得到绝对位置，可以将<code>left</code>属性加上<code>window.scrollX</code>，<code>top</code>属性加上<code>window.scrollY</code>。</p>
<p>注意，<code>getBoundingClientRect</code>方法的所有属性，都把边框（<code>border</code>属性）算作元素的一部分。也就是说，都是从边框外缘的各个点来计算。因此，<code>width</code>和<code>height</code>包括了元素本身 + <code>padding</code> + <code>border</code>。</p>
<p>另外，上面的这些属性，都是继承自原型的属性，<code>Object.keys</code>会返回一个空数组，这一点也需要注意。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(rect) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>rect</code>对象没有自身属性，而<code>Object.keys</code>方法只返回对象自身的属性，所以返回了一个空数组。</p>
<h2 id="Element-getClientRects"><a href="#Element-getClientRects" class="headerlink" title="Element.getClientRects()"></a>Element.getClientRects()</h2><p><code>Element.getClientRects</code>方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的<code>Rect</code>用的是复数）。每个矩形都有<code>bottom</code>、<code>height</code>、<code>left</code>、<code>right</code>、<code>top</code>和<code>width</code>六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。</p>
<p>对于盒状元素（比如<code>&lt;div&gt;</code>和<code>&lt;p&gt;</code>），该方法返回的对象中只有该元素一个成员。对于行内元素（比如<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;em&gt;</code>），该方法返回的对象有多少个成员，取决于该元素在页面上占据多少行。这是它和<code>Element.getBoundingClientRect()</code>方法的主要区别，后者对于行内元素总是返回一个矩形。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;inline&quot;</span>&gt;</span>Hello World Hello World Hello World<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码是一个行内元素<code>&lt;span&gt;</code>，如果它在页面上占据三行，<code>getClientRects</code>方法返回的对象就有三个成员，如果它在页面上占据一行，<code>getClientRects</code>方法返回的对象就只有一个成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;inline&#x27;</span>);</span><br><span class="line">el.<span class="title function_">getClientRects</span>().<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">left</span> <span class="comment">// 8</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">right</span> <span class="comment">// 113.908203125</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">bottom</span> <span class="comment">// 31.200000762939453</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">height</span> <span class="comment">// 23.200000762939453</span></span><br><span class="line">el.<span class="title function_">getClientRects</span>()[<span class="number">0</span>].<span class="property">width</span> <span class="comment">// 105.908203125</span></span><br></pre></td></tr></table></figure>
<p>这个方法主要用于判断行内元素是否换行，以及行内元素的每一行的位置偏移。</p>
<p>注意，如果行内元素包括换行符，那么该方法会把换行符考虑在内。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;inline&quot;</span>&gt;</span></span><br><span class="line">  Hello World</span><br><span class="line">  Hello World</span><br><span class="line">  Hello World</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;span&gt;</code>节点内部有三个换行符，即使 HTML 语言忽略换行符，将它们显示为一行，<code>getClientRects()</code>方法依然会返回三个成员。如果行宽设置得特别窄，上面的<code>&lt;span&gt;</code>元素显示为6行，那么就会返回六个成员。</p>
<h2 id="Element-insertAdjacentElement"><a href="#Element-insertAdjacentElement" class="headerlink" title="Element.insertAdjacentElement()"></a>Element.insertAdjacentElement()</h2><p><code>Element.insertAdjacentElement</code>方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">insertAdjacentElement</span>(position, element);</span><br></pre></td></tr></table></figure>
<p><code>Element.insertAdjacentElement</code>方法一共可以接受两个参数，第一个参数是一个字符串，表示插入的位置，第二个参数是将要插入的节点。第一个参数只可以取如下的值。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后</li>
</ul>
<p>注意，<code>beforebegin</code>和<code>afterend</code>这两个值，只在当前节点有父节点时才会生效。如果当前节点是由脚本创建的，没有父节点，那么插入会失败。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">p1.<span class="title function_">insertAdjacentElement</span>(<span class="string">&#x27;afterend&#x27;</span>, p2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p1</code>没有父节点，所以插入<code>p2</code>到它后面就失败了。</p>
<p>如果插入的节点是一个文档里现有的节点，它会从原有位置删除，放置到新的位置。</p>
<h2 id="Element-insertAdjacentHTML-，Element-insertAdjacentText"><a href="#Element-insertAdjacentHTML-，Element-insertAdjacentText" class="headerlink" title="Element.insertAdjacentHTML()，Element.insertAdjacentText()"></a>Element.insertAdjacentHTML()，Element.insertAdjacentText()</h2><p><code>Element.insertAdjacentHTML</code>方法用于将一个 HTML 字符串，解析生成 DOM 结构，插入相对于当前节点的指定位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(position, text);</span><br></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个是一个表示指定位置的字符串，第二个是待解析的 HTML 字符串。第一个参数只能设置下面四个值之一。</p>
<ul>
<li><code>beforebegin</code>：当前元素之前</li>
<li><code>afterbegin</code>：当前元素内部的第一个子节点前面</li>
<li><code>beforeend</code>：当前元素内部的最后一个子节点后面</li>
<li><code>afterend</code>：当前元素之后</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">d1.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行后的 HTML 代码：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>该方法只是在现有的 DOM 结构里面插入节点，这使得它的执行速度比<code>innerHTML</code>方法快得多。</p>
<p>注意，该方法不会转义 HTML 字符串，这导致它不能用来插入用户输入的内容，否则会有安全风险。</p>
<p><code>Element.insertAdjacentText</code>方法在相对于当前节点的指定位置，插入一个文本节点，用法与<code>Element.insertAdjacentHTML</code>方法完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码：&lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">d1.<span class="title function_">insertAdjacentText</span>(<span class="string">&#x27;afterend&#x27;</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line"><span class="comment">// 执行后的 HTML 代码：</span></span><br><span class="line"><span class="comment">// &lt;div id=&quot;one&quot;&gt;one&lt;/div&gt;two</span></span><br></pre></td></tr></table></figure>
<h2 id="Element-remove"><a href="#Element-remove" class="headerlink" title="Element.remove()"></a>Element.remove()</h2><p><code>Element.remove</code>方法继承自<code>ChildNode</code>接口，用于将当前元素节点从它的父节点移除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span><br><span class="line">el.<span class="title function_">remove</span>();</span><br></pre></td></tr></table></figure>
<p>上面代码将<code>el</code>节点从 DOM 树里面移除。</p>
<h2 id="Element-focus-，Element-blur"><a href="#Element-focus-，Element-blur" class="headerlink" title="Element.focus()，Element.blur()"></a>Element.focus()，Element.blur()</h2><p><code>Element.focus</code>方法用于将当前页面的焦点，转移到指定元素上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-span&#x27;</span>).<span class="title function_">focus</span>();</span><br></pre></td></tr></table></figure>
<p>该方法可以接受一个对象作为参数。参数对象的<code>preventScroll</code>属性是一个布尔值，指定是否将当前元素停留在原始位置，而不是滚动到可见区域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFocus</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">focus</span>(&#123;<span class="attr">preventScroll</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码会让<code>btn</code>元素获得焦点，并滚动到可见区域。</p>
<p>最后，从<code>document.activeElement</code>属性可以得到当前获得焦点的元素。</p>
<p><code>Element.blur</code>方法用于将焦点从当前元素移除。</p>
<h2 id="Element-click"><a href="#Element-click" class="headerlink" title="Element.click()"></a>Element.click()</h2><p><code>Element.click</code>方法用于在当前元素上模拟一次鼠标点击，相当于触发了<code>click</code>事件。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS错误处理机制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/08/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"
    >JS错误处理机制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/11/08/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2018-11-08T12:10:11.000Z" itemprop="datePublished">2018-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h1><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">err.<span class="property">message</span> <span class="comment">// &quot;出错了&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。</p>
<p>JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>
<ul>
<li><code>message</code>：错误提示信息</li>
<li><code>name</code>：错误名称（非标准属性）</li>
<li><code>stack</code>：错误的堆栈（非标准属性）</li>
</ul>
<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error.<span class="property">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + error.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>stack</code>属性用来查看错误发生时的堆栈。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throwit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">catchit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">throwit</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">stack</span>); <span class="comment">// print stack trace</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">catchit</span>()</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//    at throwit (~/examples/throwcatch.js:9:11)</span></span><br><span class="line"><span class="comment">//    at catchit (~/examples/throwcatch.js:3:9)</span></span><br><span class="line"><span class="comment">//    at repl:1:5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>
<h1 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h1><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>
<h2 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h2><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">var</span> 1a;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected string</span></span><br></pre></td></tr></table></figure>
<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>
<h2 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h2><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个不存在的变量</span></span><br><span class="line">unknownVariable</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: unknownVariable is not defined</span></span><br></pre></td></tr></table></figure>
<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号左侧不是变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>() = <span class="number">1</span></span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure>
<p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误。</p>
<h2 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h2><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组长度不得为负数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>
<h2 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h2><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: number is not a func</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="title function_">unknownMethod</span>()</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj.unknownMethod is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>
<h2 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h2><p>URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&#x27;%2&#x27;</span>)</span><br><span class="line"><span class="comment">// URIError: URI malformed</span></span><br></pre></td></tr></table></figure>
<h2 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h2><p>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;出错了，变量超出有效范围！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;出错了，变量类型无效！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">err1.<span class="property">message</span> <span class="comment">// &quot;出错了！&quot;</span></span><br><span class="line">err2.<span class="property">message</span> <span class="comment">// &quot;出错了，变量超出有效范围！&quot;</span></span><br><span class="line">err3.<span class="property">message</span> <span class="comment">// &quot;出错了，变量类型无效！&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h1><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserError</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">UserError</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line"><span class="title class_">UserError</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">UserError</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">UserError</span>(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h1><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果变量<code>x</code>小于等于0，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。</p>
<p><code>throw</code>也可以抛出自定义错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">UserError</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserError</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>
<p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出一个字符串</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Error！&#x27;</span>;</span><br><span class="line"><span class="comment">// Uncaught Error！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个数值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// Uncaught 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个布尔值</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Uncaught true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出一个对象</span></span><br><span class="line"><span class="keyword">throw</span> &#123;</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Error!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Uncaught &#123;toString: ƒ&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>
<h1 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h1><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">stack</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: 出错了!</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:3:9</span></span><br><span class="line"><span class="comment">//   ...</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。</p>
<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数f执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。</p>
<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;出错了&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 111</span></span><br><span class="line"><span class="comment">// 222</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。</p>
<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> n;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught 100</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。</p>
<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.<span class="title function_">bar</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">EvalError</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">RangeError</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>
<h1 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h1><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cleansUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了……&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此行不会执行&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;完成清理工作&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cleansUp</span>()</span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Uncaught Error: 出错了……</span></span><br><span class="line"><span class="comment">//    at cleansUp (&lt;anonymous&gt;:3:11)</span></span><br><span class="line"><span class="comment">//    at &lt;anonymous&gt;:10:1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">idle</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;result&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;FINALLY&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">idle</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// FINALLY</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。</p>
<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countUp</span>()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">count</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。</p>
<p>下面是<code>finally</code>代码块用法的典型场景。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">openFile</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">writeFile</span>(<span class="title class_">Data</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="title function_">handleError</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="title function_">closeFile</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用<code>finally</code>代码块关闭文件。</p>
<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;bug&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这句原本会延迟到 finally 代码块结束再执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这句会覆盖掉前面那句 return</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 不会运行</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>); <span class="comment">// 不会运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。</p>
<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;出错了！&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉到内部错误&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// 这句原本会等到finally结束再执行</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// 此处不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caught outer &quot;bogus&quot;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。</p>
<p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    consle.<span class="title function_">log</span>(<span class="string">&#x27;Hello world!&#x27;</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finally&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Will I run?&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finally</span></span><br><span class="line"><span class="comment">// consle is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS DOM——Document节点"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/08/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Document%E8%8A%82%E7%82%B9/"
    >JS DOM—Document节点</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/11/08/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20DOM%E2%80%94%E2%80%94Document%E8%8A%82%E7%82%B9/" class="article-date">
  <time datetime="2018-11-08T07:46:54.000Z" itemprop="datePublished">2018-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>document</code>节点对象代表整个文档，每张网页都有自己的<code>document</code>对象。<code>window.document</code>属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p>
<p><code>document</code>对象有不同的办法可以获取。</p>
<ul>
<li>正常的网页，直接使用<code>document</code>或<code>window.document</code>。</li>
<li><code>iframe</code>框架里面的网页，使用<code>iframe</code>节点的<code>contentDocument</code>属性。</li>
<li>Ajax 操作返回的文档，使用<code>XMLHttpRequest</code>对象的<code>responseXML</code>属性。</li>
<li>内部节点的<code>ownerDocument</code>属性。</li>
</ul>
<p><code>document</code>对象继承了<code>EventTarget</code>接口、<code>Node</code>接口、<code>ParentNode</code>接口。这意味着，这些接口的方法都可以在<code>document</code>对象上调用。除此之外，<code>document</code>对象还有很多自己的属性和方法。</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="快捷方式属性"><a href="#快捷方式属性" class="headerlink" title="快捷方式属性"></a>快捷方式属性</h2><p>以下属性是指向文档内部的某个节点的快捷方式。</p>
<h4 id="document-defaultView"><a href="#document-defaultView" class="headerlink" title="document.defaultView"></a>document.defaultView</h4><p><code>document.defaultView</code>属性返回<code>document</code>对象所属的<code>window</code>对象。如果当前文档不属于<code>window</code>对象，该属性返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">defaultView</span> === <span class="variable language_">window</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="document-doctype"><a href="#document-doctype" class="headerlink" title="document.doctype"></a>document.doctype</h4><p>对于 HTML 文档来说，<code>document</code>对象一般有两个子节点。第一个子节点是<code>document.doctype</code>，指向<code>&lt;DOCTYPE&gt;</code>节点，即文档类型（<code>Document Type Declaration</code>，简写DTD）节点。HTML 的文档类型节点，一般写成<code>&lt;!DOCTYPE html&gt;</code>。如果网页没有声明 DTD，该属性返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doctype = <span class="variable language_">document</span>.<span class="property">doctype</span>;</span><br><span class="line">doctype <span class="comment">// &quot;&lt;!DOCTYPE html&gt;&quot;</span></span><br><span class="line">doctype.<span class="property">name</span> <span class="comment">// &quot;html&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>document.firstChild</code>通常就返回这个节点。</p>
<h4 id="document-documentElement"><a href="#document-documentElement" class="headerlink" title="document.documentElement"></a>document.documentElement</h4><p><code>document.documentElement</code>属性返回当前文档的根元素节点。它通常是<code>document</code>节点的第二个子节点，紧跟在<code>document.doctype</code>节点后面。HTML网页的该属性，一般是<code>&lt;html&gt;</code>节点。</p>
<h4 id="document-body，document-head"><a href="#document-body，document-head" class="headerlink" title="document.body，document.head"></a>document.body，document.head</h4><p><code>document.body</code>属性指向<code>&lt;body&gt;</code>节点，<code>document.head</code>属性指向<code>&lt;head&gt;</code>节点。</p>
<p>这两个属性总是存在的，如果网页源码里面省略了<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</p>
<h4 id="document-scrollingElement"><a href="#document-scrollingElement" class="headerlink" title="document.scrollingElement"></a>document.scrollingElement</h4><p><code>document.scrollingElement</code>属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。</p>
<p>标准模式下，这个属性返回的文档的根元素<code>document.documentElement</code>（即<code>&lt;html&gt;</code>）。兼容模式下，返回的是<code>&lt;body&gt;</code>元素，如果该元素不存在，返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面滚动到浏览器顶部</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">scrollingElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="document-activeElement"><a href="#document-activeElement" class="headerlink" title="document.activeElement"></a>document.activeElement</h4><p><code>document.activeElement</code>属性返回获得当前焦点（<code>focus</code>）的 DOM 元素。通常，这个属性返回的是<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等表单元素，如果当前没有焦点元素，返回<code>&lt;body&gt;</code>元素或<code>null</code>。</p>
<h4 id="document-fullscreenElement"><a href="#document-fullscreenElement" class="headerlink" title="document.fullscreenElement"></a>document.fullscreenElement</h4><p><code>document.fullscreenElement</code>属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">fullscreenElement</span>.<span class="property">nodeName</span> == <span class="string">&#x27;VIDEO&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;全屏播放视频&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>document.fullscreenElement</code>可以知道<code>&lt;video&gt;</code>元素有没有处在全屏状态，从而判断用户行为。</p>
<h2 id="节点集合属性"><a href="#节点集合属性" class="headerlink" title="节点集合属性"></a>节点集合属性</h2><p>以下属性返回一个<code>HTMLCollection</code>实例，表示文档内部特定元素的集合。这些集合都是动态的，原节点有任何变化，立刻会反映在集合中。</p>
<h4 id="document-links"><a href="#document-links" class="headerlink" title="document.links"></a>document.links</h4><p><code>document.links</code>属性返回当前文档所有设定了<code>href</code>属性的<code>&lt;a&gt;</code>及<code>&lt;area&gt;</code>节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印文档所有的链接</span></span><br><span class="line"><span class="keyword">var</span> links = <span class="variable language_">document</span>.<span class="property">links</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(links[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="document-forms"><a href="#document-forms" class="headerlink" title="document.forms"></a>document.forms</h4><p><code>document.forms</code>属性返回所有<code>&lt;form&gt;</code>表单节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectForm = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码获取文档第一个表单。<br>除了使用位置序号，<code>id</code>属性和<code>name</code>属性也可以用来引用表单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;form name=&quot;foo&quot; id=&quot;bar&quot;&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>] === <span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">foo</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">bar</span> === <span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">foo</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="document-images"><a href="#document-images" class="headerlink" title="document.images"></a>document.images</h4><p><code>document.images</code>属性返回页面所有<code>&lt;img&gt;</code>图片节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imglist = <span class="variable language_">document</span>.<span class="property">images</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; imglist.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (imglist[i].<span class="property">src</span> === <span class="string">&#x27;banner.gif&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在所有<code>img</code>标签中，寻找某张图片。</p>
<h4 id="document-embeds，document-plugins"><a href="#document-embeds，document-plugins" class="headerlink" title="document.embeds，document.plugins"></a>document.embeds，document.plugins</h4><p><code>document.embeds</code>属性和<code>document.plugins</code>属性，都返回所有<code>&lt;embed&gt;</code>节点。</p>
<h4 id="document-scripts"><a href="#document-scripts" class="headerlink" title="document.scripts"></a>document.scripts</h4><p><code>document.scripts</code>属性返回所有<code>&lt;script&gt;</code>节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scripts = <span class="variable language_">document</span>.<span class="property">scripts</span>;</span><br><span class="line"><span class="keyword">if</span> (scripts.<span class="property">length</span> !== <span class="number">0</span> ) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前网页有脚本&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="document-styleSheets"><a href="#document-styleSheets" class="headerlink" title="document.styleSheets"></a>document.styleSheets</h4><p><code>document.styleSheets</code>属性返回文档内嵌或引入的样式表集合。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>除了<code>document.styleSheets</code>，以上的集合属性返回的都是<code>HTMLCollection</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">links</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">embeds</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">scripts</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>HTMLCollection</code>实例是类似数组的对象，所以这些属性都有<code>length</code>属性，都可以使用方括号运算符引用成员。如果成员有<code>id</code>或<code>name</code>属性，还可以用这两个属性的值，在<code>HTMLCollection</code>实例上引用到这个成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;form name=&quot;myForm&quot;&gt;</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">myForm</span> === <span class="variable language_">document</span>.<span class="property">forms</span>.<span class="property">myForm</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="文档静态信息属性"><a href="#文档静态信息属性" class="headerlink" title="文档静态信息属性"></a>文档静态信息属性</h2><p>以下属性返回文档信息。</p>
<h4 id="document-documentURI，document-URL"><a href="#document-documentURI，document-URL" class="headerlink" title="document.documentURI，document.URL"></a>document.documentURI，document.URL</h4><p><code>document.documentURI</code>属性和<code>document.URL</code>属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code>documentURI</code>继承自<code>Document</code>接口，可用于所有文档；<code>URL</code>继承自<code>HTMLDocument</code>接口，只能用于 HTML 文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">URL</span> <span class="comment">// http://www.example.com/about</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentURI</span> === <span class="variable language_">document</span>.<span class="property">URL</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果文档的锚点（<code>#anchor</code>）变化，这两个属性都会跟着变化。</p>
<h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p><code>document.domain</code>属性返回当前文档的域名，不包含协议和端口。比如，网页的网址是<code>http://www.example.com:80/hello.html</code>，那么<code>document.domain</code>属性就等于<code>www.example.com</code>。如果无法获取域名，该属性返回<code>null</code>。</p>
<p><code>document.domain</code>基本上是一个只读属性，只有一种情况除外。次级域名的网页，可以把<code>document.domain</code>设为对应的上级域名。比如，当前域名是<code>a.sub.example.com</code>，则<code>document.domain</code>属性可以设置为<code>sub.example.com</code>，也可以设为<code>example.com</code>。修改后，<code>document.domain</code>相同的两个网页，可以读取对方的资源，比如设置的Cookie。</p>
<p>另外，设置<code>document.domain</code>会导致端口被改成<code>null</code>。因此，如果通过设置<code>document.domain</code>来进行通信，双方网页都必须设置这个值，才能保证端口相同。</p>
<h4 id="document-location"><a href="#document-location" class="headerlink" title="document.location"></a>document.location</h4><p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>
<h4 id="document-lastModified"><a href="#document-lastModified" class="headerlink" title="document.lastModified"></a>document.lastModified</h4><p><code>document.lastModified</code>属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">lastModified</span> <span class="comment">// &quot;03/07/2018 11:18:27&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>document.lastModified</code>属性的值是字符串，所以不能直接用来比较。<code>Date.parse</code>方法将其转为<code>Date</code>实例，才能比较两个网页。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastVisitedDate = <span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&#x27;01/01/2018&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="variable language_">document</span>.<span class="property">lastModified</span>) &gt; lastVisitedDate) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网页已经变更&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果页面上有 JavaScript 生成的内容，<code>document.lastModified</code>属性返回的总是当前时间。</p>
<h4 id="document-title"><a href="#document-title" class="headerlink" title="document.title"></a>document.title</h4><p><code>document.title</code>属性返回当前文档的标题。默认情况下，返回<code>&lt;title&gt;</code>节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;新标题&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> <span class="comment">// &quot;新标题&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="document-characterSet"><a href="#document-characterSet" class="headerlink" title="document.characterSet"></a>document.characterSet</h4><p><code>document.characterSet</code>属性返回当前文档的编码，比如<code>UTF-8</code>、<code>ISO-8859-1</code>等等。</p>
<h4 id="document-referrer"><a href="#document-referrer" class="headerlink" title="document.referrer"></a>document.referrer</h4><p><code>document.referrer</code>属性返回一个字符串，表示当前文档的访问者来自哪里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">referrer</span> <span class="comment">// &quot;https://example.com/path&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果无法获取来源，或者用户直接键入网址而不是从其他网页点击进入，<code>document.referrer</code>返回一个空字符串。</p>
<p><code>document.referrer</code>的值，总是与 HTTP 头信息的<code>Referer</code>字段保持一致。但是，<code>document.referrer</code>的拼写有两个<code>r</code>，而头信息的<code>Referer</code>字段只有一个<code>r</code>。</p>
<h4 id="document-dir"><a href="#document-dir" class="headerlink" title="document.dir"></a>document.dir</h4><p><code>document.dir</code>返回一个字符串，表示文字方向。它只有两个可能的值：<code>rtl</code>表示文字从右到左，阿拉伯文是这种方式；<code>ltr</code>表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</p>
<h4 id="document-compatMode"><a href="#document-compatMode" class="headerlink" title="document.compatMode"></a>document.compatMode</h4><p><code>compatMode</code>属性返回浏览器处理文档的模式，可能的值为<code>BackCompat</code>（向后兼容模式）和<code>CSS1Compat</code>（严格模式）。</p>
<p>一般来说，如果网页代码的第一行设置了明确的<code>DOCTYPE</code>（比如<code>&lt;!doctype html&gt;</code>），<code>document.compatMode</code>的值都为<code>CSS1Compat</code>。</p>
<h2 id="文档状态属性"><a href="#文档状态属性" class="headerlink" title="文档状态属性"></a>文档状态属性</h2><h4 id="document-hidden"><a href="#document-hidden" class="headerlink" title="document.hidden"></a>document.hidden</h4><p><code>document.hidden</code>属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得<code>document.hidden</code>返回<code>true</code>。</p>
<p>这个属性是 Page Visibility API 引入的，一般都是配合这个 API 使用。</p>
<h4 id="document-visibilityState"><a href="#document-visibilityState" class="headerlink" title="document.visibilityState"></a>document.visibilityState</h4><p><code>document.visibilityState</code>返回文档的可见状态。<br>它的值有四种可能。</p>
<ul>
<li><code>visible</code>：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</li>
<li><code>hidden</code>：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</li>
<li><code>prerender</code>：页面处于正在渲染状态，对于用户来说，该页面不可见。</li>
<li><code>unloaded</code>：页面从内存里面卸载了。</li>
</ul>
<p>这个属性可以用在页面加载时，防止加载某些资源；或者页面不可见时，停掉一些页面功能。</p>
<h4 id="document-readyState"><a href="#document-readyState" class="headerlink" title="document.readyState"></a>document.readyState</h4><p><code>document.readyState</code>属性返回当前文档的状态，共有三种可能的值。</p>
<ul>
<li><code>loading</code>：加载 HTML 代码阶段（尚未完成解析）</li>
<li><code>interactive</code>：加载外部资源阶段</li>
<li><code>complete</code>：加载完成</li>
</ul>
<p>这个属性变化的过程如下。</p>
<ol>
<li>浏览器开始解析 HTML 文档，<code>document.readyState</code>属性等于<code>loading</code>。</li>
<li>浏览器遇到 HTML 文档中的<code>&lt;script&gt;</code>元素，并且没有<code>async</code>或<code>defer</code>属性，就暂停解析，开始执行脚本，这时<code>document.readyState</code>属性还是等于<code>loading</code>。</li>
<li>HTML 文档解析完成，<code>document.readyState</code>属性变成<code>interactive</code>。</li>
<li>浏览器等待图片、样式表、字体文件等外部资源加载完成，一旦全部加载完成，<code>document.readyState</code>属性变成<code>complete</code>。</li>
</ol>
<p>下面的代码用来检查网页是否加载成功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本检查</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> === <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询检查</span></span><br><span class="line"><span class="keyword">var</span> interval = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> === <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>另外，每次状态变化都会触发一个<code>readystatechange</code>事件。</p>
<h2 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h2><p><code>document.cookie</code>属性用来操作浏览器 Cookie。</p>
<h2 id="document-designMode"><a href="#document-designMode" class="headerlink" title="document.designMode"></a>document.designMode</h2><p><code>document.designMode</code>属性控制当前文档是否可编辑。该属性只有两个值<code>on</code>和<code>off</code>，默认值为<code>off</code>。一旦设为<code>on</code>，用户就可以编辑整个文档的内容。</p>
<p>下面代码打开<code>iframe</code>元素内部文档的<code>designMode</code>属性，就能将其变为一个所见即所得的编辑器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;iframe id=&quot;editor&quot; src=&quot;about:blank&quot;&gt;&lt;/iframe&gt;</span></span><br><span class="line"><span class="keyword">var</span> editor = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;editor&#x27;</span>);</span><br><span class="line">editor.<span class="property">contentDocument</span>.<span class="property">designMode</span> = <span class="string">&#x27;on&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="document-implementation"><a href="#document-implementation" class="headerlink" title="document.implementation"></a>document.implementation</h2><p><code>document.implementation</code>属性返回一个<code>DOMImplementation</code>对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。</p>
<ul>
<li><code>DOMImplementation.createDocument()</code>：创建一个 XML 文档。</li>
<li><code>DOMImplementation.createHTMLDocument()</code>：创建一个 HTML 文档。</li>
<li><code>DOMImplementation.createDocumentType()</code>：创建一个 DocumentType 对象。</li>
</ul>
<p>下面是创建 HTML 文档的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">createHTMLDocument</span>(<span class="string">&#x27;Title&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = doc.<span class="title function_">createElement</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">doc.<span class="property">body</span>.<span class="title function_">appendChild</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">replaceChild</span>(</span><br><span class="line">  doc.<span class="property">documentElement</span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一步生成一个新的 HTML 文档<code>doc</code>，然后用它的根元素<code>document.documentElement</code>替换掉<code>document.documentElement</code>。这会使得当前文档的内容全部消失，变成<code>hello world</code>。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="document-open-，document-close"><a href="#document-open-，document-close" class="headerlink" title="document.open()，document.close()"></a>document.open()，document.close()</h2><p><code>document.open</code>方法清除当前文档所有内容，使得文档处于可写状态，供<code>document.write</code>方法写入内容。</p>
<p><code>document.close</code>方法用来关闭<code>document.open()</code>打开的文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>
<h2 id="document-write-，document-writeln"><a href="#document-write-，document-writeln" class="headerlink" title="document.write()，document.writeln()"></a>document.write()，document.writeln()</h2><p><code>document.write</code>方法用于向当前文档写入内容。</p>
<p>在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行<code>document.close()</code>），<code>document.write</code>写入的内容就会追加在已有内容的后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面显示“helloworld”</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">open</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>
<p>注意，<code>document.write</code>会当作 HTML 代码解析，不会转义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;hello world&lt;/p&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.write</code>会将<code>&lt;p&gt;</code>当作 HTML 标签解释。</p>
<p>如果页面已经解析完成（<code>DOMContentLoaded</code>事件发生之后），再调用<code>write</code>方法，它会先调用<code>open</code>方法，擦除当前文档所有内容，然后再写入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">open</span>();</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;p&gt;Hello World!&lt;/p&gt;&#x27;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果在页面渲染过程中调用<code>write</code>方法，并不会自动调用<code>open</code>方法。（可以理解成，<code>open</code>方法已调用，但<code>close</code>方法还未调用。）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;world&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器打开上面网页，将会显示<code>hello world</code>。</p>
<p><code>document.write</code>是 JavaScript 语言标准化之前就存在的方法，现在完全有更符合标准的方法向文档写入内容（比如对<code>innerHTML</code>属性赋值）。所以，除了某些特殊情况，应该尽量避免使用<code>document.write</code>这个方法。</p>
<p><code>document.writeln</code>方法与<code>write</code>方法完全一致，除了会在输出内容的尾部添加换行符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">writeln</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">writeln</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>writeln</code>方法添加的是 ASCII 码的换行符，渲染成 HTML 网页时不起作用，即在网页上显示不出换行。网页上的换行，必须显式写入<code>&lt;br&gt;</code>。</p>
<h2 id="document-querySelector-，document-querySelectorAll"><a href="#document-querySelector-，document-querySelectorAll" class="headerlink" title="document.querySelector()，document.querySelectorAll()"></a>document.querySelector()，document.querySelectorAll()</h2><p><code>document.querySelector</code>方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.myclass&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el2 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myParent &gt; [ng-click]&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>document.querySelectorAll</code>方法与<code>querySelector</code>用法类似，区别是返回一个<code>NodeList</code>对象，包含所有匹配给定选择器的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.myclass&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这两个方法的参数，可以是逗号分隔的多个 CSS 选择器，返回匹配其中一个选择器的元素节点，这与 CSS 选择器的规则是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matches = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div.note, div.alert&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码返回<code>class</code>属性是<code>note</code>或<code>alert</code>的<code>div</code>元素。</p>
<p>这两个方法都支持复杂的 CSS 选择器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选中 data-foo-bar 属性等于 someval 的元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;[data-foo-bar=&quot;someval&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中 myForm 表单中所有不通过验证的元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;#myForm :invalid&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中div元素，那些 class 含 ignore 的除外</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;DIV:not(.ignore)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时选中 div，a，script 三类元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;DIV, A, SCRIPT&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>但是，它们不支持 CSS 伪元素的选择器（比如<code>:first-line</code>和<code>:first-letter</code>）和伪类的选择器（比如<code>:link</code>和<code>:visited</code>），即无法选中伪元素和伪类。</p>
<p>如果<code>querySelectorAll</code>方法的参数是字符串<code>*</code>，则会返回文档中的所有元素节点。另外，<code>querySelectorAll</code>的返回结果不是动态集合，不会实时反映元素节点的变化。</p>
<p>最后，这两个方法除了定义在<code>document</code>对象上，还定义在元素节点上，即在元素节点上也可以调用。</p>
<h2 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName()"></a>document.getElementsByTagName()</h2><p><code>document.getElementsByTagName</code>方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（<code>HTMLCollection</code>实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">paras <span class="keyword">instanceof</span> <span class="title class_">HTMLCollection</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码返回当前文档的所有<code>p</code>元素节点。</p>
<p>HTML 标签名是大小写不敏感的，因此<code>getElementsByTagName</code>方法也是大小写不敏感的。另外，返回结果中，各个成员的顺序就是它们在文档中出现的顺序。</p>
<p>如果传入<code>*</code>，就可以返回文档中所有 HTML 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allElements = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，元素节点本身也定义了<code>getElementsByTagName</code>方法，返回该元素的后代元素中符合条件的元素。也就是说，这个方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstPara = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;p&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> spans = firstPara.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;span&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码选中第一个<code>p</code>元素内部的所有<code>span</code>元素。</p>
<h2 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName()"></a>document.getElementsByClassName()</h2><p><code>document.getElementsByClassName</code>方法返回一个类似数组的对象（<code>HTMLCollection</code>实例），包括了所有<code>class</code>名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(names);</span><br></pre></td></tr></table></figure>
<p>由于<code>class</code>是保留字，所以 JavaScript 一律使用<code>className</code>表示 CSS 的<code>class</code>。</p>
<p>参数可以是多个<code>class</code>，它们之间使用空格分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;foo bar&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码返回同时具有<code>foo</code>和<code>bar</code>两个<code>class</code>的元素，<code>foo</code>和<code>bar</code>的顺序不重要。</p>
<p>注意，正常模式下，CSS 的<code>class</code>是大小写敏感的。（<code>quirks mode</code>下，大小写不敏感。）</p>
<p>与<code>getElementsByTagName</code>方法一样，<code>getElementsByClassName</code>方法不仅可以在<code>document</code>对象上调用，也可以在任何元素节点上调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非document对象上调用</span></span><br><span class="line"><span class="keyword">var</span> elements = rootElement.<span class="title function_">getElementsByClassName</span>(names);</span><br></pre></td></tr></table></figure>
<h2 id="document-getElementsByName"><a href="#document-getElementsByName" class="headerlink" title="document.getElementsByName()"></a>document.getElementsByName()</h2><p><code>document.getElementsByName</code>方法用于选择拥有<code>name</code>属性的 HTML 元素（比如<code>&lt;form&gt;</code>、<code>&lt;radio&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;embed&gt;</code>和<code>&lt;object&gt;</code>等），返回一个类似数组的的对象（<code>NodeList</code>实例），因为<code>name</code>属性相同的元素可能不止一个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单为 &lt;form name=&quot;x&quot;&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="keyword">var</span> forms = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">forms[<span class="number">0</span>].<span class="property">tagName</span> <span class="comment">// &quot;FORM&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById()"></a>document.getElementById()</h2><p><code>document.getElementById</code>方法返回匹配指定<code>id</code>属性的元素节点。如果没有发现匹配的节点，则返回<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;para1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>注意，该方法的参数是大小写敏感的。比如，如果某个节点的<code>id</code>属性是<code>main</code>，那么<code>document.getElementById(&#39;Main&#39;)</code>将返回<code>null</code>。</p>
<p><code>document.getElementById</code>方法与<code>document.querySelector</code>方法都能获取元素节点，不同之处是<code>document.querySelector</code>方法的参数使用 CSS 选择器语法，<code>document.getElementById</code>方法的参数是元素的<code>id</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myElement&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#myElement&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，两个方法都能选中<code>id</code>为<code>myElement</code>的元素，但是<code>document.getElementById()</code>比<code>document.querySelector()</code>效率高得多。</p>
<p>另外，这个方法只能在<code>document</code>对象上使用，不能在其他元素节点上使用。</p>
<h2 id="document-elementFromPoint-，document-elementsFromPoint"><a href="#document-elementFromPoint-，document-elementsFromPoint" class="headerlink" title="document.elementFromPoint()，document.elementsFromPoint()"></a>document.elementFromPoint()，document.elementsFromPoint()</h2><p><code>document.elementFromPoint</code>方法返回位于页面指定位置最上层的元素节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">elementFromPoint</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码选中在<code>(50, 50)</code>这个坐标位置的最上层的那个 HTML 元素。</p>
<p><code>elementFromPoint</code>方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回<code>null</code>。</p>
<p><code>document.elementsFromPoint()</code>返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="variable language_">document</span>.<span class="title function_">elementsFromPoint</span>(x, y);</span><br></pre></td></tr></table></figure>
<h2 id="document-caretPositionFromPoint"><a href="#document-caretPositionFromPoint" class="headerlink" title="document.caretPositionFromPoint()"></a>document.caretPositionFromPoint()</h2><p><code>document.caretPositionFromPoint()</code>返回一个<code>CaretPosition</code>对象，包含了指定坐标点在节点对象内部的位置信息。<code>CaretPosition</code>对象就是光标插入点的概念，用于确定光标点在文本对象内部的具体位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> range = <span class="variable language_">document</span>.<span class="title function_">caretPositionFromPoint</span>(clientX, clientY);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>range</code>是指定坐标点的<code>CaretPosition</code>对象。该对象有两个属性。</p>
<ul>
<li><code>CaretPosition.offsetNode</code>：该位置的节点对象</li>
<li><code>CaretPosition.offset</code>：该位置在<code>offsetNode</code>对象内部，与起始位置相距的字符数。</li>
</ul>
<h2 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h2><p><code>document.createElement</code>方法用来生成元素节点，并返回该节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>createElement</code>方法的参数为元素的标签名，即元素节点的<code>tagName</code>属性，对于 HTML 网页大小写不敏感，即参数为<code>div</code>或<code>DIV</code>返回的是同一种节点。如果参数里面包含尖括号（即<code>&lt;</code>和<code>&gt;</code>）会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;&lt;div&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// DOMException: The tag name provided (&#x27;&lt;div&gt;&#x27;) is not a valid name</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>document.createElement</code>的参数可以是自定义的标签名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h2><p><code>document.createTextNode</code>方法用来生成文本节点（<code>Text</code>实例），并返回该节点。它的参数是文本节点的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newContent = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">newDiv.<span class="title function_">appendChild</span>(newContent);</span><br></pre></td></tr></table></figure>
<p>上面代码新建一个<code>div</code>节点和一个文本节点，然后将文本节点插入<code>div</code>节点。</p>
<p>这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;&lt;span&gt;Foo &amp; bar&lt;/span&gt;&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="property">innerHTML</span>)</span><br><span class="line"><span class="comment">// &amp;lt;span&amp;gt;Foo &amp;amp; bar&amp;lt;/span&amp;gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>createTextNode</code>方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。</p>
<p>需要注意的是，该方法不对单引号和双引号转义，所以不能用来对 HTML 属性赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">escapeHtml</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  div.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(str));</span><br><span class="line">  <span class="keyword">return</span> div.<span class="property">innerHTML</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userWebsite = <span class="string">&#x27;&quot; onmouseover=&quot;alert(\&#x27;derp\&#x27;)&quot; &quot;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> profileLink = <span class="string">&#x27;&lt;a href=&quot;&#x27;</span> + escapeHtml(userWebsite) + <span class="string">&#x27;&quot;&gt;Bob&lt;/a&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line">div.<span class="property">innerHTML</span> = profileLink;</span><br><span class="line"><span class="comment">// &lt;a href=&quot;&quot; onmouseover=&quot;alert(&#x27;derp&#x27;)&quot; &quot;&quot;&gt;Bob&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>createTextNode</code>方法不转义双引号，导致<code>onmouseover</code>方法被注入了代码。</p>
<h2 id="document-createAttribute"><a href="#document-createAttribute" class="headerlink" title="document.createAttribute()"></a>document.createAttribute()</h2><p><code>document.createAttribute</code>方法生成一个新的属性节点（<code>Attr</code>实例），并返回它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attribute = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(name);</span><br></pre></td></tr></table></figure>
<p><code>document.createAttribute</code>方法的参数<code>name</code>，是属性的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&#x27;my_attrib&#x27;</span>);</span><br><span class="line">a.<span class="property">value</span> = <span class="string">&#x27;newVal&#x27;</span>;</span><br><span class="line"></span><br><span class="line">node.<span class="title function_">setAttributeNode</span>(a);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">node.<span class="title function_">setAttribute</span>(<span class="string">&#x27;my_attrib&#x27;</span>, <span class="string">&#x27;newVal&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码为<code>div1</code>节点，插入一个值为<code>newVal</code>的<code>my_attrib</code>属性。</p>
<h2 id="document-createComment"><a href="#document-createComment" class="headerlink" title="document.createComment()"></a>document.createComment()</h2><p><code>document.createComment</code>方法生成一个新的注释节点，并返回该节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CommentNode</span> = <span class="variable language_">document</span>.<span class="title function_">createComment</span>(data);</span><br></pre></td></tr></table></figure>
<p><code>document.createComment</code>方法的参数是一个字符串，会成为注释节点的内容。</p>
<h2 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h2><p><code>document.createDocumentFragment</code>方法生成一个空的文档片段对象（<code>DocumentFragment</code>实例）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docFragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br></pre></td></tr></table></figure>
<p><code>DocumentFragment</code>是一个存在于内存的 DOM 片段，不属于当前文档，常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。这样做的好处在于，因为<code>DocumentFragment</code>不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docfrag = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">  li.<span class="property">textContent</span> = e;</span><br><span class="line">  docfrag.<span class="title function_">appendChild</span>(li);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element  = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">element.<span class="title function_">appendChild</span>(docfrag);</span><br></pre></td></tr></table></figure>
<p>上面代码中，文档片断<code>docfrag</code>包含四个<code>&lt;li&gt;</code>节点，这些子节点被一次性插入了当前文档。</p>
<h2 id="document-createEvent"><a href="#document-createEvent" class="headerlink" title="document.createEvent()"></a>document.createEvent()</h2><p><code>document.createEvent</code>方法生成一个事件对象（<code>Event</code>实例），该对象可以被<code>element.dispatchEvent</code>方法使用，触发指定事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(type);</span><br></pre></td></tr></table></figure>
<p><code>document.createEvent</code>方法的参数是事件类型，比如<code>UIEvents</code>、<code>MouseEvents</code>、<code>MutationEvents</code>、<code>HTMLEvents</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">event.<span class="title function_">initEvent</span>(<span class="string">&#x27;build&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;build&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">type</span>); <span class="comment">// &quot;build&quot;</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>
<p>上面代码新建了一个名为<code>build</code>的事件实例，然后触发该事件。</p>
<h2 id="document-addEventListener-，document-removeEventListener-，document-dispatchEvent"><a href="#document-addEventListener-，document-removeEventListener-，document-dispatchEvent" class="headerlink" title="document.addEventListener()，document.removeEventListener()，document.dispatchEvent()"></a>document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h2><p>这三个方法用于处理<code>document</code>节点的事件。它们都继承自<code>EventTarget</code>接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件监听函数</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件监听函数</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>
<h2 id="document-hasFocus"><a href="#document-hasFocus" class="headerlink" title="document.hasFocus()"></a>document.hasFocus()</h2><p><code>document.hasFocus</code>方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> focused = <span class="variable language_">document</span>.<span class="title function_">hasFocus</span>();</span><br></pre></td></tr></table></figure>
<p>注意，有焦点的文档必定被激活，反之不成立，激活的文档未必有焦点。比如，用户点击按钮，从当前窗口跳出一个新窗口，该新窗口就是激活的，但是不拥有焦点。</p>
<h2 id="document-adoptNode-，document-importNode"><a href="#document-adoptNode-，document-importNode" class="headerlink" title="document.adoptNode()，document.importNode()"></a>document.adoptNode()，document.importNode()</h2><p><code>document.adoptNode</code>方法将某个节点及其子节点，从原来所在的文档或<code>DocumentFragment</code>里面移除，归属当前<code>document</code>对象，返回插入后的新节点。插入的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">adoptNode</span>(externalNode);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">appendChild</span>(node);</span><br></pre></td></tr></table></figure>
<p>注意，<code>document.adoptNode</code>方法只是改变了节点的归属，并没有将这个节点插入新的文档树。所以，还要再用<code>appendChild</code>方法或<code>insertBefore</code>方法，将新节点插入当前文档树。</p>
<p><code>document.importNode</code>方法则是从原来所在的文档或<code>DocumentFragment</code>里面，拷贝某个节点及其子节点，让它们归属当前<code>document</code>对象。拷贝的节点对象的<code>ownerDocument</code>属性，会变成当前的<code>document</code>对象，而<code>parentNode</code>属性是<code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.importNode(externalNode, deep);</span><br></pre></td></tr></table></figure>
<p><code>document.importNode</code>方法的第一个参数是外部节点，第二个参数是一个布尔值，表示对外部节点是深拷贝还是浅拷贝，默认是浅拷贝（<code>false</code>）。虽然第二个参数是可选的，但是建议总是保留这个参数，并设为<code>true</code>。</p>
<p>注意，<code>document.importNode</code>方法只是拷贝外部节点，这时该节点的父节点是<code>null</code>。下一步还必须将这个节点插入当前文档树。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;iframe&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> oldNode = iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myNode&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> newNode = <span class="variable language_">document</span>.importNode(oldNode, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>).<span class="title function_">appendChild</span>(newNode);</span><br></pre></td></tr></table></figure>
<p>上面代码从<code>iframe</code>窗口，拷贝一个指定节点<code>myNode</code>，插入当前文档。</p>
<h2 id="document-createNodeIterator"><a href="#document-createNodeIterator" class="headerlink" title="document.createNodeIterator()"></a>document.createNodeIterator()</h2><p><code>document.createNodeIterator</code>方法返回一个子节点遍历器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>,</span><br><span class="line">  <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码返回<code>&lt;body&gt;</code>元素子节点的遍历器。</p>
<p><code>document.createNodeIterator</code>方法第一个参数为所要遍历的根节点，第二个参数为所要遍历的节点类型，这里指定为元素节点（<code>NodeFilter.SHOW_ELEMENT</code>）。几种主要的节点类型写法如下。</p>
<ul>
<li>所有节点：<code>NodeFilter.SHOW_ALL</code></li>
<li>元素节点：<code>NodeFilter.SHOW_ELEMENT</code></li>
<li>文本节点：<code>NodeFilter.SHOW_TEXT</code></li>
<li>评论节点：<code>NodeFilter.SHOW_COMMENT</code></li>
</ul>
<p><code>document.createNodeIterator</code>方法返回一个“遍历器”对象（<code>NodeFilter</code>实例）。该实例的<code>nextNode()</code>方法和<code>previousNode()</code>方法，可以用来遍历所有子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(<span class="variable language_">document</span>.<span class="property">body</span>);</span><br><span class="line"><span class="keyword">var</span> pars = [];</span><br><span class="line"><span class="keyword">var</span> currentNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (currentNode = nodeIterator.<span class="title function_">nextNode</span>()) &#123;</span><br><span class="line">  pars.<span class="title function_">push</span>(currentNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，使用遍历器的<code>nextNode</code>方法，将根节点的所有子节点，依次读入一个数组。<code>nextNode</code>方法先返回遍历器的内部指针所在的节点，然后会将指针移向下一个节点。所有成员遍历完成后，返回<code>null</code>。<code>previousNode</code>方法则是先将指针移向上一个节点，然后返回该节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeIterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>,</span><br><span class="line">  <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentNode = nodeIterator.<span class="title function_">nextNode</span>();</span><br><span class="line"><span class="keyword">var</span> previousNode = nodeIterator.<span class="title function_">previousNode</span>();</span><br><span class="line"></span><br><span class="line">currentNode === previousNode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>currentNode</code>和<code>previousNode</code>都指向同一个的节点。</p>
<p>注意，遍历器返回的第一个节点，总是根节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pars[<span class="number">0</span>] === <span class="variable language_">document</span>.<span class="property">body</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="document-createTreeWalker"><a href="#document-createTreeWalker" class="headerlink" title="document.createTreeWalker()"></a>document.createTreeWalker()</h2><p><code>document.createTreeWalker</code>方法返回一个 DOM 的子树遍历器。它与<code>document.createNodeIterator</code>方法基本是类似的，区别在于它返回的是<code>TreeWalker</code>实例，后者返回的是<code>NodeIterator</code>实例。另外，它的第一个节点不是根节点。</p>
<p><code>document.createTreeWalker</code>方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与<code>document.createNodeIterator</code>方法的第二个参数相同）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> treeWalker = <span class="variable language_">document</span>.<span class="title function_">createTreeWalker</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>,</span><br><span class="line">  <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodeList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(treeWalker.<span class="title function_">nextNode</span>()) &#123;</span><br><span class="line">  nodeList.<span class="title function_">push</span>(treeWalker.<span class="property">currentNode</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历<code>&lt;body&gt;</code>节点下属的所有元素节点，将它们插入<code>nodeList</code>数组。</p>
<h2 id="document-execCommand-，document-queryCommandSupported-，document-queryCommandEnabled"><a href="#document-execCommand-，document-queryCommandSupported-，document-queryCommandEnabled" class="headerlink" title="document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()"></a>document.execCommand()，document.queryCommandSupported()，document.queryCommandEnabled()</h2><p>如果<code>document.designMode</code>属性设为<code>on</code>，那么整个文档用户可编辑；如果元素的<code>contenteditable</code>属性设为<code>true</code>，那么该元素可编辑。这两种情况下，可以使用<code>document.execCommand()</code>方法，改变内容的样式，比如<code>document.execCommand(&#39;bold&#39;)</code>会使得字体加粗。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">execCommand</span>(command, showDefaultUI, input)</span><br></pre></td></tr></table></figure>
<p>该方法接受三个参数。</p>
<ul>
<li><code>command</code>：字符串，表示所要实施的样式。</li>
<li><code>showDefaultUI</code>：布尔值，表示是否要使用默认的用户界面，建议总是设为<code>false</code>。</li>
<li><code>input</code>：字符串，表示该样式的辅助内容，比如生成超级链接时，这个参数就是所要链接的网址。如果第二个参数设为<code>true</code>，那么浏览器会弹出提示框，要求用户在提示框输入该参数。但是，不是所有浏览器都支持这样做，为了兼容性，还是需要自己部署获取这个参数的方式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="variable language_">window</span>.<span class="title function_">prompt</span>(<span class="string">&#x27;请输入网址&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (url) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;createlink&#x27;</span>, <span class="literal">false</span>, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，先提示用户输入所要链接的网址，然后手动生成超级链接。注意，第二个参数是<code>false</code>，表示此时不需要自动弹出提示框。</p>
<p><code>document.execCommand()</code>的返回值是一个布尔值。如果为<code>false</code>，表示这个方法无法生效。</p>
<p>这个方法大部分情况下，只对选中的内容生效。如果有多个内容可编辑区域，那么只对当前焦点所在的元素生效。</p>
<p><code>document.execCommand()</code>方法可以执行的样式改变有很多种，下面是其中的一些：<code>bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo</code>。这些值都可以用作第一个参数，它们的含义不难从字面上看出来。</p>
<p><code>document.queryCommandEnabled()</code>方法返回一个布尔值，表示浏览器是否允许使用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">queryCommandEnabled</span>(<span class="string">&#x27;SelectAll&#x27;</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>document.queryCommandSupported()</code>方法返回一个布尔值，表示当前是否可用某种样式改变。比如，加粗只有存在文本选中时才可用，如果没有选中文本，就不可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">queryCommandSupported</span>(<span class="string">&#x27;SelectAll&#x27;</span>)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>document.queryCommandEnabled()</code>方法返回一个布尔值。</p>
<h2 id="document-getSelection"><a href="#document-getSelection" class="headerlink" title="document.getSelection()"></a>document.getSelection()</h2><p>这个方法指向<code>window.getSelection()</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/33/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="page-number" href="/page/33/">33</a><span class="page-number current">34</span><a class="page-number" href="/page/35/">35</a><a class="page-number" href="/page/36/">36</a><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/35/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>