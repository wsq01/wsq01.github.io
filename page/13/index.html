<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-网络是怎样连接的/网络是怎样连接的1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/"
    >网络是怎样连接的——浏览器生成消息</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/" class="article-date">
  <time datetime="2021-12-01T03:31:41.000Z" itemprop="datePublished">2021-12-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="生成-HTTP-请求消息"><a href="#生成-HTTP-请求消息" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h1><h2 id="浏览器先要解析-URL"><a href="#浏览器先要解析-URL" class="headerlink" title="浏览器先要解析 URL"></a>浏览器先要解析 URL</h2><p>浏览器要做的第一步工作就是对 URL 进行解析，从而生成发送给 Web 服务器的请求消息。URL 的格式会随着协议的不同而不同。以访问 Web 服务器的情况为例。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/1.png" class="">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/2.png" class="">

<p>图中的 URL 表示要访问<code>www.lab.glasscom.com</code>这个 Web 服务器上路径名为<code>/dir/file1.html</code>的文件，也就是位于<code>/dir/</code>目录下的<code>file1.html</code>这个文件。</p>
<h2 id="省略文件名的情况"><a href="#省略文件名的情况" class="headerlink" title="省略文件名的情况"></a>省略文件名的情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.lab.glasscom.com/dir/</span><br></pre></td></tr></table></figure>
<p>以<code>/</code>结尾代表<code>/dir/</code>后面本来应该有的文件名被省略了。根据 URL 的规则，文件名可以像前面这样省略。</p>
<p>我们会在服务器上事先设置好文件名省略时要访问的默认文件名。这个设置根据服务器不同而不同，大多数情况下是<code>index.html</code>。因此，省略文件名时，服务器就会访问<code>/dir/index.html</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.lab.glasscom.com/</span><br></pre></td></tr></table></figure>
<p>这个 URL 表示访问一个名叫<code>/</code>的目录。而且，由于省略了文件名，所以结果就是访问<code>/index.html</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.lab.glasscom.com/whatisthis</span><br></pre></td></tr></table></figure>
<p>一般来说，这种情况会按照下面的惯例进行处理：如果 Web 服务器上存在名为<code>whatisthis</code>的文件，则将<code>whatisthis</code>作为文件名来处理；如果存在名为<code>whatisthis</code>的目录，则将<code>whatisthis</code>作为目录名来处理。</p>
<h2 id="HTTP-的基本思路"><a href="#HTTP-的基本思路" class="headerlink" title="HTTP 的基本思路"></a>HTTP 的基本思路</h2><p>解析完 URL 之后，我们就知道应该要访问的目标在哪里了。接下来，浏览器会使用 HTTP 协议来访问 Web 服务器。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/3.png" class="">

<p>HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤。</p>
<p>首先，客户端会向服务器发送请求消息。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。其中相当于“对什么”的部分称为 URI。一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如<code>/dir1/file1.html</code>等。不过，URI 不仅限于此，也可以直接使用<code>http:</code>开头的 URL 来作为 URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为 URI。</p>
<p>相当于接下来“进行怎样的操作”的部分称为方法。方法表示需要让 Web 服务器完成怎样的工作，方法主要包括<code>GET POST DELETE PUT</code>等。</p>
<p>除了URI和请求方法之外，HTTP 消息中还有一些用来表示附加信息的头字段。客户端向 Web 服务器发送数据时，会先发送头字段，然后再发送数据。不过，头字段属于可有可无的附加信息。</p>
<p>收到请求消息之后，Web 服务器会对其中的内容进行解析，通过 URI 和方法来判断“对什么”“进行怎样的操作”，并根据这些要求来完成自己的工作，然后将结果存放在响应消息中。在响应消息的开头有一个状态码，它用来表示操作的执行结果是成功还是发生了错误。状态码后面就是头字段和网页数据。响应消息会被发送回客户端，客户端收到之后，浏览器会从消息中读出所需的数据并显示在屏幕上。到这里，HTTP 的整个工作就完成了。</p>
<h2 id="生成-HTTP-请求消息-1"><a href="#生成-HTTP-请求消息-1" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h2><p>对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。HTTP 消息在格式上是有严格规定的，因此浏览器会按照规定的格式来生成请求消息。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/4.png" class="" title="HTTP 消息的格式">

<p>首先，请求消息的第一行称为请求行。第一个值是方法，写好方法之后，加一个空格，然后写 URI。URI 部分一般是文件和程序的路径名。第一行的末尾需要写上 HTTP 的版本号，这是为了表示该消息是基于哪个版本的 HTTP 规格编写的。</p>
<p>第二行开始为消息头。尽管通过第一行我们就可以大致理解请求的内容，但有些情况下还需要一些额外的详细信息，而消息头的功能就是用来存放这些信息。消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等。这些项目表示的都是非常细节的信息。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/5.png" class="">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/6.png" class="">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/7.png" class="">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/8.png" class="">

<p>消息头中的内容随着浏览器类型、版本号、设置等的不同而不同，大多数情况下消息头的长度为几行到十几行不等。</p>
<p>写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。不过，在使用 GET 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。消息体结束之后，整个消息也就结束了。当使用 POST 方法时，需要将表单中填写的信息写在消息体中。到此为止，请求消息的生成操作就全部完成了。</p>
<h2 id="发送请求后会收到响应"><a href="#发送请求后会收到响应" class="headerlink" title="发送请求后会收到响应"></a>发送请求后会收到响应</h2><p>请求消息发送出去之后，Web 服务器会返回响应消息。响应消息的格式以及基本思路和请求消息是相同的，差别只在第一行上。在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。状态码和响应短语表示的内容一致，但它们的用途不同。状态码是一个数字，它主要用来向程序告知执行的结果；相对地，响应短语则是一段文字，用来向人们告知执行的结果。</p>
<p>返回响应消息之后，浏览器会将数据提取出来并显示在屏幕上，我们就能够看到网页的样子了。如果网页的内容只有文字，那么到这里就全部处理完毕了，但如果网页中还包括图片等资源，则还有下文。</p>
<p>当网页中包含图片时，会在网页中的相应位置嵌入表示图片文件的标签的控制信息。浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后再次访问 Web 服务器，按照标签中指定的文件名向 Web 服务器请求获取相应的图片并显示在预留的空间中。这个步骤和获取网页文件时一样，只要在 URI 部分写上图片的文件名并生成和发送请求消息就可以了。</p>
<p>由于每条请求消息中只能写 1 个 URI，所以每次只能获取 1 个文件，如果需要获取多个文件，必须对每个文件单独发送 1 条请求。比如 1 个网页中包含 3 张图片，那么获取网页加上获取图片，一共需要向 Web 服务器发送 4 条请求。</p>
<p>判断所需的文件，然后获取这些文件并显示在屏幕上，这一系列工作的整体指挥是浏览器的任务之一，而 Web 服务器却毫不知情。Web 服务器完全不关心这 4 条请求获取的文件到底是 1 个网页上的还是不同网页上的，它的任务就是对每一条单独的请求返回 1 条响应而已。</p>
<p>到这里，浏览器与 Web 服务器进行交互的整个过程就结束了。作为参考，下图展示了浏览器与 Web 服务器之间交互消息的一个实例。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/9.png" class="" title="HTTP 消息示例">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/10.png" class="" title="HTTP 消息示例">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/11.png" class="" title="HTTP 消息示例">

<h1 id="向-DNS-服务器查询-Web-服务器的-IP-地址"><a href="#向-DNS-服务器查询-Web-服务器的-IP-地址" class="headerlink" title="向 DNS 服务器查询 Web 服务器的 IP 地址"></a>向 DNS 服务器查询 Web 服务器的 IP 地址</h1><h2 id="IP-地址的基本知识"><a href="#IP-地址的基本知识" class="headerlink" title="IP 地址的基本知识"></a>IP 地址的基本知识</h2><p>生成 HTTP 消息之后，接下来我们需要委托操作系统将消息发送给 Web 服务器。尽管浏览器能够解析网址并生成 HTTP 消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。在进行这一操作时，我们还有一个工作需要完成，那就是查询网址中服务器域名对应的 IP 地址。在委托操作系统发送消息时，必须要提供的不是通信对象的域名，而是它的 IP 地址。因此，在生成 HTTP 消息之后，下一步就是根据域名查询 IP 地址。</p>
<p>互联网和公司内部的局域网都是基于 TCP&#x2F;IP 的思路来设计的。TCP&#x2F;IP 就是由一些小的子网，通过路由器连接起来组成一个大的网络。这里的子网可以理解为用集线器连接起来的几台计算机，我们将它看作一个单位，称为子网。将子网通过路由器连接起来，就形成了一个网络。</p>
<p>在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“×× 号 ×× 室”。其中“号”对应的号码是分配给整个子网的，而“室”对应的号码是分配给子网中的计算机的，这就是网络中的地址。“号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址的整体称为 IP 地址。</p>
<p>通过 IP 地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上。接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器，即消息再次经过子网内的集线器被转发到下一个路由器。前面的过程不断重复，最终消息就被传送到目的地。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/12.png" class="" title="IP 的基本思路">

<p>实际的 IP 地址是一串 32 比特的数字，按照 8 比特（1 字节）为一组分成 4 组，分别用十进制表示然后再用圆点隔开。IP 地址的规则中，网络号和主机号连起来总共是 32 比特，但这两部分的具体结构是不固定的。在组建网络时，用户可以自行决定它们之间的分配关系，因此，我们还需要另外的附加信息来表示 IP 地址的内部结构。</p>
<p>这一附加信息称为子网掩码。子网掩码是一串与 IP 地址长度相同的 32 比特数字，其左边一半都是 1，右边一半都是0。其中，子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/13.png" class="" title="IP 地址的表示方法">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/14.png" class="" title="IP 地址的结构">

<p>顺带一提，主机号部分全部为 0 代表整个子网而不是子网中的某台设备。此外，主机号部分全部为 1 代表向子网上所有设备发送包，即广播。</p>
<h2 id="域名和-IP-地址并用的理由"><a href="#域名和-IP-地址并用的理由" class="headerlink" title="域名和 IP 地址并用的理由"></a>域名和 IP 地址并用的理由</h2><p>TCP&#x2F;IP 网络是通过 IP 地址来确定通信对象的，因此不知道 IP 地址就无法将消息发送给对方。因此，在委托操作系统发送消息时，必须要先查询好对方的 IP 地址。</p>
<p>实际上，如果用 IP 地址来代替服务器名称也是能够正常工作的。然而，要记住一串由数字组成的 IP 地址也非常困难。因此，相比 IP 地址来说，网址中还是使用服务器名称比较好。</p>
<p>互联网中存在无数的路由器，它们之间相互配合，根据 IP 地址来判断应该把数据传送到什么地方。IP 地址的长度为 32 比特，也就是 4 字节，相对地，域名最短也要几十个字节，最长甚至可以达到 255 字节。换句话说，使用 IP 地址只需要处理 4 字节的数字，而域名则需要处理几十个到 255 个字节的字符，这增加了路由器的负担，传送数据也会花费更长的时间。路由器的速度是有极限的，而互联网内部流动的数据量已然让路由器疲于应付了，因此我们不应该再采用效率更低的设计。</p>
<p>随着技术的发展，路由器的性能也会不断提升，但与此同时，数据量也在以更快的速度增长，在可预见的未来，这样的趋势应该不会发生变化。出于这样的原因，使用名称本身来确定通信对象并不是一个聪明的设计。</p>
<p>于是，现在我们使用的方案是让人来使用名称，让路由器来使用 IP 地址。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询 IP 地址，或者通过 IP 地址来查询名称，这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是 DNS。</p>
<h2 id="Socket-库提供查询-IP-地址的功能"><a href="#Socket-库提供查询-IP-地址的功能" class="headerlink" title="Socket 库提供查询 IP 地址的功能"></a>Socket 库提供查询 IP 地址的功能</h2><p>向 DNS 服务器发出查询，也就是向 DNS 服务器发送查询消息，并接收服务器返回的响应消息。换句话说，对于 DNS 服务器，我们的计算机上一定有相应的 DNS 客户端，而相当于 DNS 客户端的部分称为 DNS 解析器，或者简称解析器。通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析这一操作的就叫解析器（<code>resolver</code>）了。</p>
<p>解析器实际上是一段程序，它包含在操作系统的 Socket 库中。Socket 库中包含很多用于发送和接收数据的程序组件。这些程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。</p>
<h2 id="通过解析器向-DNS-服务器发出查询"><a href="#通过解析器向-DNS-服务器发出查询" class="headerlink" title="通过解析器向 DNS 服务器发出查询"></a>通过解析器向 DNS 服务器发出查询</h2><p>Socket 库中的程序都是标准组件，只要从应用程序中进行调用就可以了。具体来说，在编写浏览器等应用程序的时候，只要像下面这样写上解析器的程序名称<code>gethostbyname</code>以及 Web 服务器的域名<code>www.lab.glasscom.com</code>就完成了对解析器的调用。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/15.png" class="" title="解析器的调用方法">

<p>调用解析器后，解析器会向 DNS 服务器发送查询消息，然后 DNS 服务器会返回响应消息。响应消息中包含查询到的 IP 地址，解析器会取出 IP 地址，并将其写入浏览器指定的内存地址中。只要运行<code>gethostbyname(www.lab.glasscom.com)</code>，就可以完成前面所有这些工作，我们也就完成了 IP 地址的查询。接下来，浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了。</p>
<h2 id="解析器的内部原理"><a href="#解析器的内部原理" class="headerlink" title="解析器的内部原理"></a>解析器的内部原理</h2><img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/16.png" class="" title="调用解析器时计算机内部的工作流程">

<p>网络应用程序（浏览器）调用解析器时，程序的控制流程就会转移到解析器的内部。</p>
<p>一般来说，应用程序编写的操作内容是从上往下按顺序执行的，当到达需要调用解析器的部分时，对应的那一行程序就会被执行，应用程序本身的工作就会暂停。然后，Socket 库中的解析器开始运行，完成应用程序委托的操作。像这样，由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行，这就是“控制流程转移”。</p>
<p>当控制流程转移到解析器后，解析器会生成要发送给 DNS 服务器的查询消息。这个过程与浏览器生成要发送给 Web 服务器的 HTTP 请求消息的过程类似，解析器会根据 DNS 的规格，生成一条表示“请告诉我<code>www.lab.glasscom.com</code>的 IP 地址”的数据，并将它发送给 DNS 服务器。</p>
<p>发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈来执行。这是因为解析器本身不具备使用网络收发数据的功能。解析器调用协议栈后，控制流程会再次转移，协议栈会执行发送消息的操作，然后通过网卡将消息发送给 DNS 服务器。</p>
<p>当 DNS 服务器收到查询消息后，它会根据消息中的查询内容进行查询。如果要访问的 Web 服务器已经在 DNS 服务器上注册，那么这条记录就能够被找到，然后其 IP 地址会被写入响应消息并返回给客户端。接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器，然后解析器读取出消息取出 IP 地址，并将 IP 地址传递给应用程序。实际上，解析器会将取出的 IP 地址写入应用程序指定的内存地址中，在实际的程序代码中应该写的是代表这一内存地址的名称。</p>
<p>到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器）。现在应用程序已经能够从内存中取出 IP 地址了，所以说 IP 地址是用这种方式传递给应用程序的。</p>
<p>计算机的内部结构就是这样一层一层的。也就是说，很多程序组成不同的层次，彼此之间分工协作。当接到上层委派的操作时，本层的程序并不会完成所有的工作，而是会完成一部分工作，再将剩下的部分委派到下层来完成。</p>
<p>顺带一提，向 DNS 服务器发送消息时，我们当然也需要知道 DNS 服务器的 IP 地址。只不过这个 IP 地址是作为 TCP&#x2F;IP 的一个设置项目事先设置好的，不需要再去查询了。</p>
<h1 id="全世界-DNS-服务器的大接力"><a href="#全世界-DNS-服务器的大接力" class="headerlink" title="全世界 DNS 服务器的大接力"></a>全世界 DNS 服务器的大接力</h1><p>上面介绍了解析器与 DNS 服务器之间的交互过程，下面来了解一下 DNS 服务器的工作。</p>
<h2 id="DNS-服务器的基本工作"><a href="#DNS-服务器的基本工作" class="headerlink" title="DNS 服务器的基本工作"></a>DNS 服务器的基本工作</h2><p>DNS 服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。</p>
<p>其中，来自客户端的查询消息包含以下 3 种信息。 </p>
<ol>
<li>域名：服务器、邮件服务器（邮件地址中<code>@</code>后面的部分）的名称</li>
<li><code>Class</code>：在最早设计 DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而<code>Class</code>就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此<code>Class</code>的值永远是代表互联网的<code>IN</code></li>
<li>记录类型：表示域名对应何种类型的记录。例如，当类型为 A 时，表示域名对应的是 IP 地址；当类型为 MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同</li>
</ol>
<p>DNS 服务器上事先保存有前面这 3 种信息对应的记录数据。DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/17.png" class="" title="DNS 服务器的基本工作">

<p>例如，如果要查询<code>www.lab.glasscom.com</code>这个域名对应的 IP 地址，客户端会向 DNS 服务器发送包含以下信息的查询消息。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">域名 = www.lab.glasscom.com</span><br><span class="line">Class = IN</span><br><span class="line">记录类型 = A</span><br></pre></td></tr></table></figure>
<p>然后，DNS 服务器会从已有的记录中查找域名、<code>Class</code>和记录类型全部匹配的记录。假如 DNS 服务器中的记录如上图，那么第一行记录与查询消息中的 3 个项目完全一致。于是，DNS 服务器会将记录中的<code>192.0.2.226</code>这个值返回给客户端。然而，Web 服务器的域名有很多都是像<code>www.lab.glasscom.com</code>这样以<code>www</code>开头的，但这并不是一定之规，只是因为最早设计 Web 的时候，很多 Web 服务器都采用了<code>www</code>这样的命名，后来就形成了一个惯例而已。因此，只要是作为 A 记录在 DNS 服务器上注册的，都可以作为 Web 服务器的域名。</p>
<p>在查询 IP 地址时我们使用 A 这个记录类型，而查询邮件服务器时则要使用 MX 类型。这是因为在 DNS 服务器上，IP 地址是保存在 A 记录中的，而邮件服务器则是保存在 MX 记录中的。例如，对于一个邮件地址<code>tone@glasscom.com</code>，当需要知道这个地址对应的邮件服务器时，我们需要提供<code>@</code>后面的那一串名称。查询消息的内容如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">域名 = glasscom.com</span><br><span class="line">Class = IN</span><br><span class="line">记录类型 = MX</span><br></pre></td></tr></table></figure>
<p>DNS 服务器会返回 10 和<code>mail.glasscom.com</code>这两条信息。当记录类型为 MX 时，DNS 服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级。此外，MX 记录的返回消息还包括邮件服务器<code>mail.glasscom.com</code>的 IP 地址。上表的第三行就是<code>mail.glasscom.com</code>的 IP 地址，因此只要用<code>mail.glasscom.com</code>的域名就可以找到这条记录。在这个例子中，我们得到的 IP 地址是<code>192.0.2.227</code>。</p>
<p>综上所述，DNS 服务器的基本工作就是根据需要查询的域名和记录类型查找相关的记录，并向客户端返回响应消息。</p>
<p>除了 A 和 MX 这两个记录类型，还有很多其他的类型。例如根据 IP 地址反查域名的 PTR 类型，查询域名相关别名的 CNAME 类型，查询 DNS 服务器 IP 地址的 NS 类型，以及查询域名属性信息的 SOA 类型等。尽管 DNS 服务器的工作原理很简单，不过是根据查询消息中的域名和记录类型来进行查找并返回响应的信息而已，但通过组合使用不同的记录类型，就可以处理各种各样的信息。</p>
<p>此外，虽然图中展示的是表格形式，但实际上这些信息是保存在配置文件中的，表格中的一行信息被称为一条资源记录。</p>
<h2 id="域名的层次结构"><a href="#域名的层次结构" class="headerlink" title="域名的层次结构"></a>域名的层次结构</h2><p>我们假设要查询的信息已经保存在 DNS 服务器内部的记录中了。如果是在像公司内部网络这样 Web 和邮件服务器数量有限的环境中，所有的信息都可以保存在一台 DNS 服务器中。然而，互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台 DNS 服务器中是不可能的，因此一定会出现在 DNS 服务器中找不到要查询的信息的情况。</p>
<p>DNS 服务器是将信息分布保存在多台 DNS 服务器中，这些 DNS 服务器相互接力配合，从而查找出要查询的信息。不过，这个机制有点复杂，因此我们先来看一看信息是如何在 DNS 服务器上注册并保存的。</p>
<p>首先，DNS 服务器中的所有信息都是按照域名以分层次的结构来保存的。DNS 中的域名都是用句点来分隔的，比如<code>www.lab.glasscom.com</code>，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高。其中，相当于一个层级的部分称为域。因此，<code>com</code>域的下一层是<code>glasscom</code>域，再下一层是<code>lab</code>域，再下面才是<code>www</code>这个名字。</p>
<p>这种具有层次结构的域名信息会注册到 DNS 服务器中，而每个域都是作为一个整体来处理的。换句话说就是，一个域的信息是作为一个整体存放在 DNS 服务器中的，不能将一个域拆开来存放在多台 DNS 服务器中。</p>
<p>不过，DNS 服务器和域之间的关系也并不总是一对一的，一台 DNS 服务器中也可以存放多个域的信息。为了避免把事情搞得太复杂，这里先假设一台 DNS 服务器中只存放一个域的信息。于是，DNS 服务器也具有了像域名一样的层次结构，每个域的信息都存放在相应层级的 DNS 服务器中。例如，这里有一个公司的域，那么就相应地有一台 DNS 服务器，其中存放了公司中所有 Web 服务器和邮件服务器的信息。</p>
<p>对于公司域来说，例如现在需要为每一个事业集团配备一台 DNS 服务器，分别管理各事业集团自己的信息，但我们之前也说过一个域是不可分割的，这该怎么办呢？没关系，我们可以在域的下面创建下级域 B，然后再将它们分别分配给各个事业集团。比如，假设公司的域为<code>example.co.jp</code>， 我们可以在这个域的下面创建两个子域， 即<code>sub1.example.co.jp</code>和<code>sub2.example.co.jp</code>，然后就可以将这两个下级域分配给不同的事业集团来使用。如果公司下级的组织不是事业部而是子公司，对于域来说也是没有区别的。因为域并不代表“事业集团”这一特定组织，无论是子公司还是什么别的组织名称，都可以分配相应的域。实际上，互联网中的域也是一样，通过创建下级的域来分配给不同的国家、公司和组织使用。通过实际的域名可能更容易理解，比如<code>www.nikkeibp.co.jp</code>这个域名，最上层的<code>jp</code>代表分配给日本这个国家的域；下一层的<code>co</code>是日本国内进行分类的域，代表公司；再下层的<code>nikkeibp</code>就是分配给某个公司的域；最下层的<code>www</code>就是服务器的名称。</p>
<h2 id="寻找相应的-DNS-服务器并获取-IP-地址"><a href="#寻找相应的-DNS-服务器并获取-IP-地址" class="headerlink" title="寻找相应的 DNS 服务器并获取 IP 地址"></a>寻找相应的 DNS 服务器并获取 IP 地址</h2><p>下面再来看一看如何找到 DNS 服务器中存放的信息。这里的关键在于如何找到我们要访问的 Web 服务器的信息归哪一台 DNS 服务器管。</p>
<p>互联网中有数万台 DNS 服务器，肯定不能一台一台挨个去找。我们可以采用下面的办法。首先，将负责管理下级域的 DNS 服务器的 IP 地址注册到它们的上级 DNS 服务器中，然后上级 DNS 服务器的 IP 地址再注册到更上一级的 DNS 服务器中，以此类推。也就是说，负责管理<code>lab.glasscom.com</code>这个域的 DNS 服务器的 IP 地址需要注册到<code>glasscom.com</code>域的 DNS 服务器中，而<code>glasscom.com</code>域的 DNS 服务器的 IP 地址又需要注册到<code>com</code>域的 DNS 服务器中。这样，我们就可以通过上级 DNS 服务器查询出下级 DNS 服务器的 IP 地址，也就可以向下级 DNS 服务器发送查询请求了。</p>
<p>似乎<code>com、jp</code>这些域（称为顶级域）就是最顶层了，它们各自负责保存下级 DNS 服务器的信息，但实际上并非如此。<code>com</code>和<code>jp</code>的上面还有一级域，称为根域。根域不像<code>com、jp</code>那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像<code>www.lab.glasscom.com.</code>这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。不过，一般都不写最后那个句点，因此根域的存在往往被忽略，但根域毕竟是真实存在的，根域的 DNS 服务器中保管着<code>com、jp</code>等的 DNS 服务器的信息。由于上级 DNS 服务器保管着所有下级DNS 服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的 DNS 服务器。</p>
<p>除此之外还需要完成另一项工作，那就是将根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。分配给根域 DNS 服务器的 IP 地址在全世界仅有 13 个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的 DNS 服务器中也并不是一件难事。实际上，根域 DNS 服务器的相关信息已经包含在 DNS 服务器程序的配置文件中了，因此只要安装了 DNS 服务器程序，这些信息也就被自动配置好了。</p>
<p>到这里所有的准备工作就都完成了。当我们配置一台 DNS 服务器时，必须要配置好上面这些信息，这样 DNS 服务器就能够从上万台 DNS 服务器中找到目标服务器。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/18.png" class="" title="找到目标 DNS 服务器">

<p>如图所示，客户端首先会访问最近的一台 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址），假设我们要查询<code>www.lab.glasscom.com</code>这台 Web 服务器的相关信息。由于最近的 DNS 服务器中没有存放<code>www.lab.glasscom.com</code>这一域名对应的信息，所以我们需要从顶层开始向下查找。最近的 DNS 服务器中保存了根域 DNS 服务器的信息，因此它会将来自客户端的查询消息转发给根域 DNS 服务器。根域服务器中也没有<code>www.lab.glasscom.com</code>这个域名，但根据域名结构可以判断这个域名属于<code>com</code>域，因此根域 DNS 服务器会返回它所管理的<code>com</code>域中的 DNS 服务器的 IP 地址，意思是“虽然我不知道你要查的那个域名的地址，但你可以去<code>com</code>域问问看”。接下来，最近的 DNS 服务器又会向<code>com</code>域的 DNS 服务器发送查询消息。<code>com</code>域中也没有<code>www.lab.glasscom.com</code>这个域名的信息，和刚才一样，<code>com</code>域服务器会返回它下面的<code>glasscom.com</code>域的 DNS 服务器的 IP 地址。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标 DNS 服务器，只要向目标 DNS 服务器发送查询消息，就能够得到我们需要的答案，也就是<code>www.lab.glasscom.com</code>的 IP 地址了。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/19.png" class="" title="DNS 服务器之间的查询操作">

<p>收到客户端的查询消息之后，DNS 服务器会按照前面的方法来查询 IP地址，并返回给客户端。这样，客户端就知道了 Web 服务器的 IP 地址，也就能够对其进行访问了。</p>
<h2 id="通过缓存加快-DNS-服务器的响应"><a href="#通过缓存加快-DNS-服务器的响应" class="headerlink" title="通过缓存加快 DNS 服务器的响应"></a>通过缓存加快 DNS 服务器的响应</h2><p>在真实的互联网中，一台 DNS 服务器可以管理多个域的信息，因此并不是像上面这样每个域都有一台自己的 DNS 服务器。现实中上级域和下级域有可能共享同一台 DNS 服务器。在这种情况下，访问上级 DNS 服务器时就可以向下跳过一级 DNS 服务器，直接返回再下一级 DNS 服务器的相关信息。</p>
<p>此外，有时候并不需要从最上级的根域开始查找，因为 DNS 服务器有一个缓存功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。并且，当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。这样，当下次查询这个不存在的域名时，也可以快速响应。</p>
<p>这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。因此，DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。而且，在对查询进行响应时，DNS 服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的 DNS 服务器。</p>
<h1 id="委托协议栈发送消息"><a href="#委托协议栈发送消息" class="headerlink" title="委托协议栈发送消息"></a>委托协议栈发送消息</h1><h2 id="数据收发操作概览"><a href="#数据收发操作概览" class="headerlink" title="数据收发操作概览"></a>数据收发操作概览</h2><p>知道了 IP 地址之后，就可以委托操作系统内部的协议栈向这个目标 IP地址，也就是我们要访问的 Web 服务器发送消息了。要发送给 Web 服务器的 HTTP 消息是一种数字信息，因此也可以说是委托协议栈来发送数字信息。收发数字信息这一操作不仅限于浏览器，对于各种使用网络的应用程序来说都是共通的。因此，这一操作的过程也不仅适用于Web，而是适用于任何网络应用程序。</p>
<p>和向 DNS 服务器查询 IP 地址的操作一样，这里也需要使用 Socket 库中的程序组件。不过，查询 IP 地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件。发送数据是一系列操作相结合来实现的，如果不能理解这个操作的全貌，就无法理解其中每个操作的意义。</p>
<p>使用 Socket 库来收发数据的操作过程如下图。简单来说，收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。数据可以从任何一端被送入管道，数据的流动是双向的。不过，这并不是说现实中真的有这么一条管道，只是为了便于理解数据收发操作的全貌。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/20.png" class="" title="数据通过类似管道的结构来流动">

<p>收发数据的整体思路就是这样，但还有一点也非常重要。光从图上来看，这条管道好像一开始就有，实际上并不是这样，在进行收发数据操作之前，双方需要先建立起这条管道才行。建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。我们需要先创建套接字，然后再将套接字连接起来形成管道。实际的过程是下面这样的。</p>
<p>首先，服务器一方先创建套接字，然后等待客户端向该套接字连接管道。当服务器进入等待状态时，客户端就可以连接管道了。具体来说，客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。当双方的套接字连接起来之后，通信准备就完成了。接下来，只要将数据送入套接字就可以收发数据了。</p>
<p>当数据全部发送完毕之后，连接的管道将会被断开。管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。到此为止，通信操作就结束了。</p>
<p>综上所述，收发数据的操作分为若干个阶段，可以大致总结为以下 4 个。</p>
<ol>
<li>创建套接字（创建套接字阶段）</li>
<li>将管道连接到服务器端的套接字上（连接阶段）</li>
<li>收发数据（通信阶段）</li>
<li>断开管道并删除套接字（断开阶段）</li>
</ol>
<p>在每个阶段，Socket 库中的程序组件都会被调用来执行相关的数据收发操作。前面这 4 个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。此外，这些委托的操作都是通过调用 Socket 库中的程序组件来执行的，但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈。因此，我们无法形象地展示这些程序组件到底完成了怎样的工作，与其勉强强调 Socket 库的存在，还不如将 Socket 库和协议栈看成一个整体更让人更容易理解。不过，不要忘记 Socket 库这一桥梁的存在。</p>
<h2 id="创建套接字阶段"><a href="#创建套接字阶段" class="headerlink" title="创建套接字阶段"></a>创建套接字阶段</h2><p>下面我们就来探索一下应用程序（浏览器）委托收发数据的过程。这个过程的关键点就是调用 Socket 库中的特定程序组件。访问 DNS 服务器时我们调用的是一个叫作<code>gethostbyname</code>的程序组件（也就是解析器），而这一次则需要按照一定的顺序调用若干个程序组件，其过程如图所示。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%841/21.png" class="" title="客户端和服务器之间收发数据操作的情形">

<p>首先是套接字创建阶段。客户端创建套接字，只要调用 Socket 库中的<code>socket</code>程序组件就可以了。和调用解析器一样，调用<code>socket</code>之后，控制流程会转移到<code>socket</code>内部并执行创建套接字的操作，完成之后控制流程又会被移交回应用程序。只不过，<code>socket</code>的内部操作并不像解析器那样简单。现在大家只要知道调用<code>socket</code>后套接字就创建好了就可以了。</p>
<p>套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中。描述符是用来识别不同的套接字的，大家可以作如下理解。</p>
<p>实际上计算机中会同时进行多个数据的通信操作，比如可以打开两个浏览器窗口，同时访问两台 Web 服务器。这时，有两个数据收发操作在同时进行，也就需要创建两个不同的套接字。这个例子说明，同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。我们可以将描述符理解成给某个套接字分配的编号。当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了。</p>
<h2 id="连接阶段：把管道接上去"><a href="#连接阶段：把管道接上去" class="headerlink" title="连接阶段：把管道接上去"></a>连接阶段：把管道接上去</h2><p>接下来，我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用 Socket 库中的名为<code>connect</code>的程序组件来完成这一操作。调用<code>connect</code>时，需要指定描述符、服务器 IP 地址和端口号这 3 个参数。</p>
<p>第 1 个参数，即描述符，就是在创建套接字的时候由协议栈返回的那个描述符。<code>connect</code>会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。</p>
<p>第 2 个参数，即服务器 IP 地址，就是通过 DNS 服务器查询得到的我们要访问的服务器的 IP 地址。在进行数据收发操作时，双方必须知道对方的 IP 地址并告知协议栈。这个参数就是那个 IP 地址了。</p>
<p>第 3 个参数，即端口号。IP 地址是为了区分网络中的各个计算机而分配的数值。因此，只要知道了 IP 地址，我们就可以识别出网络上的某台计算机。但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭 IP 地址是无法做到这一点的。我们打电话的时候，也需要通过“请帮我找一下某某某”这样的方式来找到具体的某个联系人，而端口号就是这样一种方式。当同时指定 IP 地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。</p>
<p>也许有人会说：“能不能用前面创建套接字时提到的那个描述符来识别套接字呢？”这种方法其实是行不通的，因为描述符是和委托创建套接字的应用程序进行交互时使用的，并不是用来告诉网络连接的另一方的，因此另一方并不知道这个描述符。同样地，客户端也无法知道服务器上的描述符。因此，客户端也无法通过服务器端的描述符去确定位于服务器上的某一个套接字。所以，我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。</p>
<p>既然需要通过端口号来确定连接对象的套接字，那么到底应该使用几号端口呢？服务器上所使用的端口号是根据应用的种类事先规定好的。比如 Web 是 80 号端口，电子邮件是 25 号端口。只要指定了事先规定好的端口号，就可以连接到相应的服务器程序的套接字。也就是说，浏览器访问 Web 服务器时使用 80 号端口，这是已经规定好的。</p>
<p>既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字号码才行吧，这个问题是怎么解决的呢？首先，客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。</p>
<p>总而言之，就是当调用<code>connect</code>时，协议栈就会执行连接操作。当连接成功后，协议栈会将对方的 IP 地址和端口号等信息保存在套接字中，这样我们就可以开始收发数据了。</p>
<h2 id="通信阶段：传递消息"><a href="#通信阶段：传递消息" class="headerlink" title="通信阶段：传递消息"></a>通信阶段：传递消息</h2><p>当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。当然，应用程序无法直接控制套接字，因此还是要通过 Socket 库委托协议栈来完成这个操作。这个操作需要使用<code>write</code>这个程序组件，具体过程如下。</p>
<p>首先，应用程序需要在内存中准备好要发送的数据。根据用户输入的网址生成的 HTTP 请求消息就是我们要发送的数据。接下来，当调用<code>write</code>时，需要指定描述符和发送数据，然后协议栈就会将数据发送到服务器。由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。</p>
<p>接着，发送数据会通过网络到达我们要访问的服务器。</p>
<p>接下来，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息。当消息返回后，需要执行的是接收消息的操作。接收消息的操作是通过 Socket 库中的<code>read</code>程序组件委托协议栈来完成的。调用<code>read</code>时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。于是，当服务器返回响应消息时，<code>read</code>就会负责将接收到的响应消息存放到接收缓冲区中。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。</p>
<h2 id="断开阶段：收发数据结束"><a href="#断开阶段：收发数据结束" class="headerlink" title="断开阶段：收发数据结束"></a>断开阶段：收发数据结束</h2><p>当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用 Socket 库的<code>close</code>程序组件进入断开阶段。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。</p>
<p>断开的过程如下。Web 使用的 HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作，因此 Web 服务器会首先调用<code>close</code>来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用<code>read</code>执行接收数据操作时，<code>read</code>会告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用<code>close</code>进入断开阶段。</p>
<p>这就是 HTTP 的工作过程。HTTP 协议将 HTML 文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在 HTTP 版本 1.1 中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-网络是怎样连接的/网络是怎样连接的2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/"
    >网络是怎样连接的——电信号传输TCP/IP数据</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/" class="article-date">
  <time datetime="2021-12-01T03:31:41.000Z" itemprop="datePublished">2021-12-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h1><h2 id="协议栈的内部结构"><a href="#协议栈的内部结构" class="headerlink" title="协议栈的内部结构"></a>协议栈的内部结构</h2><p>协议栈的内部如图所示，分为几个部分，分别承担不同的功能。图中的上下关系是有一定规则的，上面的部分会向下面的部分委派工作，下面的部分接受委派的工作并实际执行。当然，这一上下关系只是一个总体的规则，其中也有一部分上下关系不明确，或者上下关系相反的情况。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/1.png" class="">

<p>图中最上面的部分是网络应用程序，也就是浏览器、电子邮件客户端、Web 服务器、电子邮件服务器等程序，它们会将收发数据等工作委派给下层的部分来完成。当然，除了浏览器之外，其他应用程序在网络上收发数据的操作也都是类似上面这样的，也就是说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。</p>
<p>应用程序的下面是 Socket 库，其中包括解析器，解析器用来向 DNS 服务器发出查询。再下面就是操作系统内部了，其中包括协议栈。协议栈的上半部分有两块，分别是负责用 TCP 协议收发数据的部分和负责用 UDP 协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。</p>
<p>下面一半是用 IP 协议控制网络包收发操作的部分。在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由 IP 来负责的。此外，IP 中还包括 ICMP 协议和 ARP 协议。ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</p>
<p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。</p>
<h2 id="套接字的实体就是通信控制信息"><a href="#套接字的实体就是通信控制信息" class="headerlink" title="套接字的实体就是通信控制信息"></a>套接字的实体就是通信控制信息</h2><p>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的 IP 地址、端口号、通信操作的进行状态等。本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。</p>
<p>协议栈在执行操作时需要参阅这些控制信息。例如，在发送数据时，需要看一看套接字中的通信对象 IP 地址和端口号，以便向指定的 IP 地址和端口发送数据。在发送数据之后，协议栈需要等待对方返回收到数据的响应信息，但数据也可能在中途丢失，永远也等不到对方的响应。在这样的情况下，我们不能一直等下去，需要在等待一定时间之后重新发送丢失的数据，这就需要协议栈能够知道执行发送数据操作后过了多长时间。为此，套接字中必须要记录是否已经收到响应，以及发送数据后经过了多长时间，才能根据这些信息按照需要执行重发操作。</p>
<p>上面说的只是其中一个例子。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。</p>
<p>在 Windows 中可以用<code>netstat</code>命令显示套接字内容。除了图上的内容之外，套接字中还记录了其他很多种控制信息。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/2.png" class="">

<p>图中每一行相当于一个套接字，当创建套接字时，就会在这里增加一行新的控制信息，赋予“即将开始通信”的状态，并进行通信的准备工作，如分配用于临时存放收发数据的缓冲区空间。</p>
<p>比如第 8 行，它表示 PID 为 4 的程序正在使用 IP 地址为<code>10.10.1.16</code>的网卡与 IP 地址为<code>10.10.1.18</code>的对象进行通信。此外我们还可以看出，本机使用 1031 端口，对方使用 139 端口，而 139 端口是 Windows 文件服务器使用的端口，因此我们就能够看出这个套接字是连接到一台文件服务器的。我们再来看第 1 行，这一行表示 PID 为 984 的程序正在 135 端口等待另一方的连接，其中本地 IP 地址和远程 IP 地址都是 0.0.0.0，这表示通信还没开始，IP 地址不确定。</p>
<h2 id="调用-socket-时的操作"><a href="#调用-socket-时的操作" class="headerlink" title="调用 socket 时的操作"></a>调用 socket 时的操作</h2><p>看过套接字的具体样子之后，接下来看一看当浏览器调用<code>socket、connect</code>等 Socket 库中的程序组件时，协议栈内部是如何工作的。</p>
<p>首先，我们再来看一下浏览器通过 Socket 库向协议栈发出委托的一系列操作。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/3.png" class="">

<p>浏览器委托协议栈使用 TCP 协议来收发数据。</p>
<p>首先是创建套接字的阶段。应用程序调用<code>socket</code>申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。</p>
<p>在这个过程中，协议栈首先会分配用于存放一个套接字所需的内存空间。用于记录套接字控制信息的内存空间并不是一开始就存在的，因此我们先要开辟出这样一块空间来，这相当于为控制信息准备一个容器。但光一个容器并没有什么用，还需要往里面存入控制信息。套接字刚刚创建时，数据收发操作还没有开始，因此需要在套接字的内存空间中写入表示这一初始状态的控制信息。到这里，创建套接字的操作就完成了。</p>
<p>接下来，需要将表示这个套接字的描述符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌。</p>
<p>收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。</p>
<h1 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h1><h2 id="连接是什么意思"><a href="#连接是什么意思" class="headerlink" title="连接是什么意思"></a>连接是什么意思</h2><p>创建套接字之后，应用程序（浏览器）就会调用<code>connect</code>，随后协议栈会将本地的套接字与服务器的套接字进行连接。话说，以太网的网线都是一直连接的状态，我们并不需要来回插拔网线，那么这里的“连接”到底是什么意思呢？连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作，我们先来说一说“连接”到底代表什么意思。</p>
<p>网线是一直连接着的，随时都有信号从中流过，如果通信过程只是将数据转换为电信号，那么这一操作随时都可以进行。不过，在这个时间点，也就是套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。浏览器可以根据网址来查询服务器的 IP 地址，而且根据规则也知道应该使用 80 号端口，但只有浏览器知道这些必要的信息是不够的，因为在调用<code>socket</code>创建套接字时，这些信息并没有传递给协议栈。因此，我们需要把服务器的 IP 地址和端口号等信息告知协议栈，这是连接操作的目的之一。</p>
<p>服务器上也会创建套接字，但服务器上的协议栈和客户端一样，只创建套接字是不知道应该和谁进行通信的。而且，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没法开始通信。于是，我们需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的 IP 地址是<code>xxx.xxx.xxx.xxx</code>，端口号是<code>yyyy</code>。”可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。</p>
<p>连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作，像上面提到的客户端将 IP 地址和端口号告知服务器这样的过程就属于交换控制信息的一个具体的例子。所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP 地址和端口号就是典型的例子。除此之外还有其他一些控制信息。连接操作中所交换的控制信息是根据通信规则来确定的，只要根据规则执行连接操作，双方就可以得到必要的信息从而完成数据收发的准备。此外，当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。上面这些就是“连接”这个词代表的具体含义。</p>
<h2 id="负责保存控制信息的头部"><a href="#负责保存控制信息的头部" class="headerlink" title="负责保存控制信息的头部"></a>负责保存控制信息的头部</h2><p>控制信息其实可以大体上分为两类。</p>
<p>第一类是客户端和服务器相互联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要，这些内容在 TCP 协议的规格中进行了定义。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/4.png" class="">

<p>表中的这些字段就是 TCP 规格中定义的控制信息。这些字段是固定的，在连接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息。具体来说，这些信息会被添加在客户端与服务器之间传递的网络包的开头。在连接阶段，由于数据收发还没有开始，网络包中没有实际的数据，只有控制信息。这些控制信息位于网络包的开头，因此被称为头部。此外，以太网和 IP 协议也有自己的控制信息，这些信息也叫头部，为了避免各种不同的头部发生混淆，我们一般会记作 TCP 头部、以太网头部、IP 头部。客户端和服务器在通信中会将必要的信息记录在头部并相互确认。</p>
<p>头部的信息非常重要，头部是用来记录和交换控制信息的，理解了头部各字段的含义，就等于理解了整个通信的过程。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/5.png" class="">

<p>控制信息还有另外一类，那就是保存在套接字中，用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。我们可以说，套接字的控制信息和协议栈的程序本身其实是一体的，因此，“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同，但这并没有什么问题。因为协议栈中的控制信息通信对方是看不见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够得以成立。</p>
<p>例如，Windows 和 Linux 操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些控制信息，但可以用命令来显示一些重要的套接字控制信息，这些信息无论何种操作系统的协议栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。</p>
<p>通信操作中使用的控制信息分为两类：</p>
<ul>
<li>头部中记录的信息</li>
<li>套接字（协议栈中的内存空间）中记录的信息</li>
</ul>
<h2 id="连接操作的实际过程"><a href="#连接操作的实际过程" class="headerlink" title="连接操作的实际过程"></a>连接操作的实际过程</h2><p>我们已经了解了连接操作的含义，下面来看一下具体的操作过程。这个过程是从应用程序调用 Socket 库的<code>connect</code>开始的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect（&lt; 描述符 &gt;, &lt; 服务器 IP 地址和端口号 &gt;, …）</span><br></pre></td></tr></table></figure>
<p>上面的调用提供了服务器的 IP 地址和端口号，这些信息会传递给协议栈中的 TCP 模块。然后，TCP 模块会与该 IP 地址对应的对象，也就是与服务器的 TCP 模块交换控制信息，这一交互过程包括下面几个步骤。</p>
<p>首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。头部包含很多字段，这里要关注的重点是发送方和接收方的端口号。到这里，客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。然后，我们将头部中的控制位的 SYN 比特设置为 1，大家可以认为它表示连接。此外还需要设置适当的序号和窗口大小。</p>
<blockquote>
<p>连接操作的第一步是在 TCP 模块处创建表示连接控制信息的头部。</p>
</blockquote>
<p>当 TCP 头部创建好之后，接下来 TCP 模块会将信息传递给 IP 模块并委托它进行发送。IP 模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的 IP 模块会将接收到的数据传递给 TCP 模块，服务器的 TCP 模块根据 TCP 头部中的信息找到端口号对应的套接字，也就是说，从处于等待连接状态的套接字中找到与 TCP 头部中记录的端口号相同的套接字就可以了。</p>
<p>当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的 TCP 模块会返回响应，这个过程和客户端一样，需要在 TCP 头部中设置发送方和接收方端口号以及 SYN 比特。此外，在返回响应时还需要将 ACK 控制位设为 1，这表示已经接收到相应的网络包。网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置 ACK 比特就是用来进行这一确认的。接下来，服务器 TCP 模块会将 TCP 头部传递给 IP 模块，并委托 IP 模块向客户端返回响应。</p>
<p>然后，网络包就会返回到客户端，通过 IP 模块到达 TCP 模块，并通过 TCP 头部的信息确认连接服务器的操作是否成功。如果 SYN 为 1 则表示连接成功，这时会向套接字中写入服务器的 IP 地址、端口号等信息，同时还会将状态改为连接完毕。到这里，客户端的操作就已经完成，但其实还剩下最后一个步骤。刚才服务器返回响应时将 ACK 比特设置为 1，相应地，客户端也需要将 ACK 比特设置为 1 并发回服务器，告诉服务器刚才的响应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。</p>
<p>现在，套接字就已经进入随时可以收发数据的状态了，大家可以认为这时有一根管子把两个套接字连接了起来。当然，实际上并不存在这么一根管子，不过这样想比较容易理解。这根管子，我们称之为连接。只要数据传输过程在持续，也就是在调用<code>close</code>断开之前，连接是一直存在的。建立连接之后，协议栈的连接操作就结束了，也就是说<code>connect</code>已经执行完毕，控制流程被交回到应用程序。</p>
<h1 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h1><h2 id="将-HTTP-请求消息交给协议栈"><a href="#将-HTTP-请求消息交给协议栈" class="headerlink" title="将 HTTP 请求消息交给协议栈"></a>将 HTTP 请求消息交给协议栈</h2><p>当控制流程从<code>connect</code>回到应用程序之后，接下来就进入数据收发阶段了。数据收发操作是从应用程序调用<code>write</code>将要发送的数据交给协议栈开始的，协议栈收到数据后执行发送操作，这一操作包含如下要点。</p>
<p>首先，协议栈并不关心应用程序传来的数据是什么内容。应用程序在调用<code>write</code>时会指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。</p>
<p>其次，协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。这样做是有道理的。应用程序交给协议栈发送的数据长度是由应用程序本身来决定的，不同的应用程序在实现上有所不同，有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据。总之，一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。</p>
<p>第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作 MTU 的参数来进行判断。MTU 表示一个网络包的最大长度，在以太网中一般是 1500 字节。MTU 是包含头部的总长度，因此需要从 MTU 减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作 MSS。当从应用程序收到的数据长度超过或者接近 MSS 时再发送出去，就可以避免发送大量小包的问题了。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/6.png" class="">

<p>另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近 MSS 时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到 MSS，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。</p>
<p>判断要素就是这两个，但它们其实是互相矛盾的。如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。</p>
<p>正如前面所说，如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。</p>
<h2 id="对较大的数据进行拆分"><a href="#对较大的数据进行拆分" class="headerlink" title="对较大的数据进行拆分"></a>对较大的数据进行拆分</h2><p>HTTP 请求消息一般不会很长，一个网络包就能装得下，但如果其中要提交表单数据，长度就可能超过一个网络包所能容纳的数据量。</p>
<p>这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，这时我们当然不需要继续等待后面的数据了。发送缓冲区中的数据会被以 MSS 长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。</p>
<p>根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上 TCP 头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号，然后交给 IP 模块来执行发送数据的操作。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/7.png" class="">

<h2 id="使用-ACK-号确认网络包已收到"><a href="#使用-ACK-号确认网络包已收到" class="headerlink" title="使用 ACK 号确认网络包已收到"></a>使用 ACK 号确认网络包已收到</h2><p>到这里，网络包已经装好数据并发往服务器了，但数据发送操作还没有结束。TCP 具备确认对方是否成功收到网络包，以及当对方没收到时进行重发的功能，因此在发送网络包之后，接下来还需要进行确认操作。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/8.png" class="">

<p>首先，TCP 模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在 TCP 头部中，“序号”字段就是派在这个用场上的。然后，发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。</p>
<p>通过这些信息，接收方还能够检查收到的网络包有没有遗漏。例如，假设上次接收到第 1460 字节，那么接下来如果收到序号为 1461 的包，说明中间没有遗漏；但如果收到的包序号为 2921，那就说明中间有包遗漏了。像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方。简单来说，发送方说的是“现在发送的是从第 ×× 字节开始的部分，一共有 ×× 字节哦！”而接收方则回复说， “到第 ×× 字节之前的数据我已经都收到了哦！”这个返回 ACK 号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。</p>
<p>然而，上图的例子和实际情况还是有些出入的。在实际的通信中，序号并不是从 1 开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从 1 开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。</p>
<p>在刚才的连接过程中，有一个将 SYN 控制位设为 1 并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将 SYN 设为 1 的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。</p>
<p>通过序号和 ACK 号来进行数据确认还不够，因为我们刚刚只考虑了单向的数据传输，但 TCP 数据收发是双向的，在客户端向服务器发送数据的同时，服务器也会向客户端发送数据，因此必须要想办法应对这样的情况。这其实也不难，上图中展示的客户端向服务器发送数据的情形，我们只要增加一种左右相反的情形就可以了。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/9.png" class="">

<p>首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算 ACK 号并返回给客户端；相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算 ACK 号并返回给服务器。此外，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。</p>
<p>明白原理之后我们来看一下实际的工作过程。</p>
<ul>
<li>首先，客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器。</li>
<li>接下来，服务器会通过这个初始值计算出 ACK 号并返回给客户端。</li>
<li>初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回 ACK 号作为确认。同时，服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值，并将这个值发送给客户端。</li>
<li>接下来像刚才一样，客户端也需要根据服务器发来的初始值计算出 ACK 号并返回给服务器。</li>
<li>到这里，序号和 ACK 号都已经准备完成了，接下来就可以进入数据收发阶段了。数据收发操作本身是可以双向同时进行的，但 Web 中是先由客户端向服务器发送请求，序号也会跟随数据一起发送。</li>
<li>然后，服务器收到数据后再返回 ACK 号。</li>
<li>从服务器向客户端发送数据的过程则正好相反。</li>
</ul>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/10.png" class="">

<p>TCP 采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的 ACK 号，那么就重新发送这些包。</p>
<p>这一机制非常强大。通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。</p>
<p>因此，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。应用程序也是一样，因为采用 TCP 传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。不过，如果发生网络中断、服务器宕机等问题，那么无论 TCP 怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此 TCP 会在尝试几次重传无效之后强制结束通信，并向应用程序报错。</p>
<h2 id="根据网络包平均往返时间调整-ACK-号等待时间"><a href="#根据网络包平均往返时间调整-ACK-号等待时间" class="headerlink" title="根据网络包平均往返时间调整 ACK 号等待时间"></a>根据网络包平均往返时间调整 ACK 号等待时间</h2><p>实际上网络的错误检测和补偿机制非常复杂。下面来说几个关键的点，首先是返回 ACK 号的等待时间（这个等待时间叫超时时间）。</p>
<p>当网络传输繁忙时就会发生拥塞，ACK 号的返回会变慢，这时我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的 ACK 号才姗姗来迟的情况。这样的重传是多余的，看上去只是多发一个包而已，但它造成的后果却没那么简单。因为 ACK 号的返回变慢大多是由于网络拥塞引起的，因此如果此时再出现很多多余的重传，对于本来就很拥塞的网络来说无疑是雪上加霜。如果等待时间过长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。</p>
<p>等待时间需要设为一个合适的值，不能太长也不能太短，但这谈何容易。根据服务器物理距离的远近，ACK 号的返回时间也会产生很大的波动，而且我们还必须考虑到拥塞带来的影响。例如，在公司里的局域网环境下，几毫秒就可以返回 ACK 号，但在互联网环境中，当遇到拥塞时需要几百毫秒才能返回 ACK 号也并不稀奇。</p>
<p>正因为波动如此之大，所以将等待时间设置为一个固定值并不是一个好办法。因此，TCP 采用了动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。具体来说，TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地，如果 ACK 号马上就能返回，则相应缩短等待时间。</p>
<h2 id="使用窗口有效管理-ACK-号"><a href="#使用窗口有效管理-ACK-号" class="headerlink" title="使用窗口有效管理 ACK 号"></a>使用窗口有效管理 ACK 号</h2><img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/11.png" class="">

<p>如图（a）所示，每发送一个包就等待一个 ACK 号的方式是最简单也最容易理解的，但在等待 ACK 号的这段时间中，如果什么都不做那实在太浪费了。为了减少这样的浪费，TCP 采用图（b）这样的滑动窗口方式来管理数据发送和 ACK 号的操作。所谓滑动窗口，就是在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。这样一来，等待 ACK 号的这段时间就被有效利用起来了。</p>
<p>虽然这样做能够减少等待 ACK 号时的时间浪费，但有一些问题需要注意。在一来一回方式中，接收方完成接收操作后返回 ACK 号，然后发送方收到 ACK 号之后才继续发送下一个包，因此不会出现发送的包太多接收方处理不过来的情况。但如果不等返回 ACK 号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。</p>
<p>下面来具体解释一下。当接收方的 TCP 收到包后，会先将数据存放到接收缓冲区中。然后，接收方需要计算 ACK 号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。我们可以通过下面的方法来避免这种情况的发生。首先，接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/12.png" class="">

<p>在这张图中，接收方将数据暂存到接收缓冲区中并执行接收操作。当接收操作完成后，接收缓冲区中的空间会被释放出来，也就可以接收更多的数据了，这时接收方会通过 TCP 头部中的窗口字段将自己能接收的数据量告知发送方。这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了。</p>
<p>此外，单从图上看，大家可能会以为接收方在等待接收缓冲区被填满之前似乎什么都没做，实际上并不是这样。这张图是为了讲解方便，故意体现一种接收方来不及处理收到的包，导致缓冲区被填满的情况。实际上，接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。</p>
<p>还有，图中只显示了从右往左发送数据的操作，实际上和序号、ACK 号一样，发送操作也是双向进行的。</p>
<h2 id="ACK-与窗口的合并"><a href="#ACK-与窗口的合并" class="headerlink" title="ACK 与窗口的合并"></a>ACK 与窗口的合并</h2><p>要提高收发数据的效率，还需要考虑另一个问题，那就是返回 ACK 号和更新窗口的时机。如果假定这两个参数是相互独立的，分别用两个单独的包来发送，结果会如何呢？</p>
<p>首先，什么时候需要更新窗口大小呢？当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。因此，更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。</p>
<p>那么 ACK 号又是什么情况呢？当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回 ACK 号，因此我们可以认为收到数据之后马上就应该进行这一操作。</p>
<p>如果将前面两个因素结合起来看，首先，发送方的数据到达接收方，在接收操作完成之后就需要向发送方返回 ACK 号，而再经过一段时间，当数据传递给应用程序之后才需要更新窗口大小。但如果根据这样的设计来实现，每收到一个包，就需要向发送方分别发送 ACK 号和窗口更新这两个单独的包。这样一来，接收方发给发送方的包就太多了，导致网络效率下降。</p>
<p>因此，接收方在发送 ACK 号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。举个例子，在等待发送 ACK 号的时候正好需要更新窗口，这时就可以把 ACK 号和窗口更新放在一个包里发送，从而减少包的数量。当需要连续发送多个 ACK 号时，也可以减少包的数量，这是因为 ACK 号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，因此当需要连续发送 ACK 号时，只要发送最后一个 ACK 号就可以了，中间的可以全部省略。当需要连续发送多个窗口更新时也可以减少包的数量，因为连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加。这种情况和 ACK 号一样，可以省略中间过程，只要发送最终的结果就可以了。</p>
<h2 id="接收-HTTP-响应消息"><a href="#接收-HTTP-响应消息" class="headerlink" title="接收 HTTP 响应消息"></a>接收 HTTP 响应消息</h2><p>到这里，我们已经讲解完协议栈接到浏览器的委托后发送 HTTP 请求消息的一系列操作过程了。</p>
<p>不过，浏览器的工作并非到此为止。发送 HTTP 请求消息后，接下来还需要等待 Web 服务器返回响应消息。对于响应消息，浏览器需要进行接收操作，这一操作也需要协议栈的参与。</p>
<p>首先，浏览器在委托协议栈发送请求消息之后，会调用<code>read</code>程序来获取响应消息。然后，控制流程会通过<code>read</code>转移到协议栈，然后协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下。首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作。</p>
<p>协议栈接收数据的具体操作过程总结：首先，协议栈会检查收到的数据块和 TCP 头部的内容，判断是否有数据丢失，如果没有问题则返回 ACK 号。然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。具体来说，协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。</p>
<h1 id="从服务器断开并删除套接字"><a href="#从服务器断开并删除套接字" class="headerlink" title="从服务器断开并删除套接字"></a>从服务器断开并删除套接字</h1><h2 id="数据发送完毕后断开连接"><a href="#数据发送完毕后断开连接" class="headerlink" title="数据发送完毕后断开连接"></a>数据发送完毕后断开连接</h2><p>毫无疑问，收发数据结束的时间点应该是应用程序判断所有数据都已经发送完毕的时候。这时，数据发送完毕的一方会发起断开过程，但不同的应用程序会选择不同的断开时机。以 Web 为例，浏览器向 Web 服务器发送请求消息，Web 服务器再返回响应消息，这时收发数据的过程就全部结束了，服务器一方会发起断开过程。当然，可能也有一些程序是客户端发送完数据就结束了，不用等服务器响应，这时客户端会先发起断开过程。这一判断是应用程序作出的，协议栈在设计上允许任何一方先发起断开过程。</p>
<p>无论哪种情况，完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/13.png" class="">

<p>首先，服务器一方的应用程序会调用 Socket 库的<code>close</code>程序。然后，服务器的协议栈会生成包含断开信息的 TCP 头部，具体来说就是将控制位中的 FIN 比特设为 1。接下来，协议栈会委托 IP 模块向客户端发送数据。同时，服务器的套接字中也会记录下断开操作的相关信息。</p>
<p>接下来轮到客户端了。当收到服务器发来的 FIN 为 1 的 TCP 头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。然后，为了告知服务器已收到 FIN 为 1 的包，客户端会向服务器返回一个 ACK 号。这些操作完成后，协议栈就可以等待应用程序来取数据了。</p>
<p>过了一会儿，应用程序就会调用<code>read</code>来读取数据。这时，协议栈不会向应用程序传递数据，而是会告知应用程序（浏览器）来自服务器的数据已经全部收到了。根据规则，服务器返回请求之后，Web 通信操作就全部结束了，因此只要收到服务器返回的所有数据，客户端的操作也就随之结束了。因此，客户端应用程序会调用<code>close</code>来结束数据收发操作，这时客户端的协议栈也会和服务器一样，生成一个 FIN 比特为 1 的 TCP 包，然后委托 IP 模块发送给服务器。一段时间之后，服务器就会返回 ACK 号。到这里，客户端和服务器的通信就全部结束了。</p>
<h2 id="删除套接字"><a href="#删除套接字" class="headerlink" title="删除套接字"></a>删除套接字</h2><p>和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。</p>
<p>等待这段时间是为了防止误操作，引发误操作的原因有很多，这里无法全部列举，下面来举一个最容易理解的例子。假设客户端先发起断开，则断开的操作顺序如下。</p>
<ol>
<li>客户端发送 FIN</li>
<li>服务器返回 ACK 号</li>
<li>服务器发送 FIN</li>
<li>客户端返回 ACK 号</li>
</ol>
<p>如果最后客户端返回的 ACK 号丢失了，这时，服务器没有接收到 ACK 号，可能会重发一次 FIN。如果这时客户端的套接字已经删除了，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。这时，如果别的应用程序要创建套接字，新套接字碰巧又被分配了同一个端口号，而服务器重发的 FIN 正好到达，本来这个 FIN 是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作。</p>
<p>至于具体等待多长时间，这和包重传的操作方式有关。网络包丢失之后会进行重传，这个操作通常要持续几分钟。如果重传了几分钟之后依然无效，则停止重传。在这段时间内，网络中可能存在重传的包，也就有可能发生前面讲到的这种误操作，因此需要等待到重传完全结束。协议中对于这个等待时间没有明确的规定，一般来说会等待几分钟之后再删除套接字。</p>
<h2 id="数据收发操作小结"><a href="#数据收发操作小结" class="headerlink" title="数据收发操作小结"></a>数据收发操作小结</h2><p>到这里，用 TCP 协议收发应用程序数据的操作就全部结束了。</p>
<p>数据收发操作的第一步是创建套接字。一般来说，服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态。客户端则一般是在用户触发特定动作，需要访问服务器的时候创建套接字。在这个阶段，还没有开始传输网络包。</p>
<p>创建套接字之后，客户端会向服务器发起连接操作。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/14.png" class="">

<p>首先，客户端会生成一个 SYN 为 1 的 TCP 包并发送给服务器。这个 TCP 包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小。当这个包到达服务器之后，服务器会返回一个 SYN 为 1 的 TCP 包。和①一样，这个包的头部中也包含了序号和窗口大小，此外还包含表示确认已收到包 ① 的 ACK 号。当这个包到达客户端时，客户端会向服务器返回一个包含表示确认的 ACK 号的 TCP 包。到这里，连接操作就完成了，双方进入数据收发阶段。</p>
<p>数据收发阶段的操作根据应用程序的不同而有一些差异，以 Web 为例，首先客户端会向服务器发送请求消息。TCP 会将请求消息切分成一定大小的块，并在每一块前面加上 TCP 头部，然后发送给服务器。</p>
<p>TCP 头部中包含序号，它表示当前发送的是第几个字节的数据。当服务器收到数据时，会向客户端返回 ACK 号。在最初的阶段，服务器只是不断接收数据，随着数据收发的进行，数据不断传递给应用程序，接收缓冲区就会被逐步释放。这时，服务器需要将新的窗口大小告知客户端。当服务器收到客户端的请求消息后，会向客户端返回响应消息，这个过程和刚才的过程正好相反。</p>
<p>服务器的响应消息发送完毕之后，数据收发操作就结束了，这时就会开始执行断开操作。以 Web 为例，服务器会先发起断开过程。在这个过程中，服务器先发送一个 FIN 为 1 的 TCP 包，然后客户端返回一个表示确认收到的 ACK 号。接下来，双方还会交换一组方向相反的 FIN 为 1 的 TCP 包和包含 ACK 号的 TCP 包。最后，在等待一段时间后，套接字会被删除。</p>
<h1 id="IP-与以太网的包收发操作"><a href="#IP-与以太网的包收发操作" class="headerlink" title="IP 与以太网的包收发操作"></a>IP 与以太网的包收发操作</h1><h2 id="包的基本知识"><a href="#包的基本知识" class="headerlink" title="包的基本知识"></a>包的基本知识</h2><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成包发送给通信对象。下面就来讨论一下 IP 模块是如何将包发送给对方的。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/15.png" class="">

<p>首先，包是由头部和数据两部分构成的。头部包含目的地址等控制信息，头部后面就是委托方要发送给对方的数据。一个包发往目的地的过程如图所示。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/16.png" class="">

<p>首先，发送方的网络设备会负责创建包，创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。接下来，包会被发往最近的网络转发设备。当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。</p>
<p>接下来，包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的方式被发往下一个转发设备。就这样，经过多个转发设备的接力之后，包最终就会到达接收方的网络设备。当然，发送方向接收方发送一个包，接收方可能也会向发送方返回一个包，此时的发送方到了接下来的某个时刻就会变成接收方。因此，我们不需要把发送方和接收方明确区分开来，在这里我们把发送方和接收方统称为终端节点。</p>
<p>上面这些基本知识，对于各种通信方式都是适用的，当然也适用于 TCP&#x2F;IP 网络。不过，TCP&#x2F;IP 包的结构是在这个基本结构的基础上扩展出来的，因此更加复杂。路由器和集线器两种不同的转发设备，它们在传输网络包时有着各自的分工。</p>
<ol>
<li>路由器根据目标地址判断下一个路由器的位置</li>
<li>集线器在子网中将网络包传输到下一个路由</li>
</ol>
<p>实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP 规则传输包的设备，因此我们也可以作如下理解。</p>
<ol>
<li>IP 协议根据目标地址判断下一个 IP 转发设备的位置</li>
<li>子网中的以太网协议将包传输到下一个转发设备</li>
</ol>
<p>具体来说，TCP&#x2F;IP 包包含如下两个头部。</p>
<ol>
<li>MAC 头部（用于以太网协议）</li>
<li>IP 头部（用于 IP 协议）</li>
</ol>
<p>这两个头部分别具有不同的作用。首先，发送方将包的目的地，也就是要访问的服务器的 IP 地址写入 IP 头部中。这样一来，我们就知道这个包应该发往哪里，IP 协议就可以根据这一地址查找包的传输方向，从而找到下一个路由器的位置，也就是图中的路由器 R1。接下来，IP 协议会委托以太网协议将包传输过去。这时，IP 协议会查找下一个路由器的以太网地址（MAC 地址），并将这个地址写入 MAC 头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。</p>
<p>网络包在传输过程中会经过集线器，集线器是根据以太网协议工作的设备。为了判断包接下来应该向什么地方传输，集线器里有一张表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向。这张图中只有一个集线器，当存在多个集线器时，网络包会按顺序逐一通过这些集线器进行传输。</p>
<p>接下来，包会到达下一个路由器。路由器中有一张 IP 协议的表，可根据这张表以及 IP 头部中记录的目的地信息查出接下来应该发往哪个路由器。为了将包发到下一个路由器，我们还需要查出下一个路由器的 MAC 地址，并记录到 MAC 头部中，可以理解为改写了 MAC 头部。这样，网络包就又被发往下一个节点了。</p>
<p>再往后的过程图上就没有画出来了。网络包会通过路由器到达下一个路由器 R2。这个过程不断重复，最终网络包就会被送到目的地，当目的地设备成功接收之后，网络包的传输过程就结束了。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/17.png" class="">

<p>前面介绍的就是在 TCP&#x2F;IP 网络中，一个网络包从出发到到达目的地的全过程。IP 和以太网的分工中，其中以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH 等，它们都可以替代以太网的角色帮助 IP 协议来传输网络包。因此，将 IP 和负责传输的网络分开，可以更好地根据需要使用各种通信技术。像互联网这样庞大复杂的网络，在架构上需要保证灵活性，这就是设计这种分工方式的原因。</p>
<h2 id="包收发操作概览"><a href="#包收发操作概览" class="headerlink" title="包收发操作概览"></a>包收发操作概览</h2><p>了解了整体流程之后，下面来看一看在协议栈中 IP 模块是如何完成包收发操作的。尽管我们说 IP 模块负责将包发给对方，但实际上将包从发送方传输到接收方的工作是由集线器、路由器等网络设备来完成的，因此 IP 模块仅仅是整个包传输过程的入口而已。即便如此，IP 模块还是有很多工作需要完成。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/18.png" class="">

<p>包收发操作的起点是 TCP 模块委托 IP 模块发送包的操作。这个委托的过程就是 TCP 模块在数据块的前面加上 TCP 头部，然后整个传递给 IP 模块，这部分就是网络包的内容。与此同时，TCP 模块还需要指定通信对象的 IP 地址，也就是需要写清楚“将什么内容发给谁”。</p>
<p>收到委托后，IP 模块会将包的内容当作一整块数据，在前面加上包含控制信息的头部。IP 模块会添加 IP 头部和 MAC 头部这两种头部。IP 头部中包含 IP 协议规定的、根据 IP 地址将包发往目的地所需的控制信息；MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息。总之，加上这两个头部之后，一个包就封装好了，这些就是 IP 模块负责的工作。</p>
<p>接下来，封装好的包会被交给网络硬件，例如以太网、无线局域网等。网络硬件可能是插在计算机主板上的板卡，也可能是笔记本电脑上的 PCMCIA 卡，或者是计算机主板上集成的芯片，不同形态的硬件名字也不一样，统称为网卡。传递给网卡的网络包是由一连串 0 和 1 组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去，然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方。</p>
<p>包送达对方之后，对方会作出响应。返回的包也会通过转发设备发送回来，然后我们需要接收这个包。接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来，然后由网卡将其转换为数字信息并传递给 IP 模块。接下来，IP 模块会将 MAC 头部和 IP 头部后面的内容，也就是 TCP 头部加上数据块，传递给 TCP 模块。</p>
<p>接下来的操作就是TCP 模块负责的部分了。</p>
<p>在这个过程中，有几个关键的点。TCP 模块在收发数据时会分为好几个阶段，并为各个阶段设计了实现相应功能的网络包，但 IP 的包收发操作都是相同的，并不会因包本身而有所区别。因为 IP 模块会将 TCP 头部和数据块看作一整块二进制数据，在执行收发操作时并不关心其中的内容，也不关心这个包是包含 TCP 头部和数据两者都有呢，还是只有 TCP 头部而没有数据。当然，IP 模块也不关心 TCP 的操作阶段，对于包的乱序和丢失也一概不知。总之，IP 的职责就是将委托的东西打包送到对方手里，或者是将对方送来的包接收下来，仅此而已。</p>
<p>无论要收发的包是控制包还是数据包，IP 对各种类型的包的收发操作都是相同的。</p>
<h2 id="生成包含接收方-IP-地址的-IP-头部"><a href="#生成包含接收方-IP-地址的-IP-头部" class="headerlink" title="生成包含接收方 IP 地址的 IP 头部"></a>生成包含接收方 IP 地址的 IP 头部</h2><p>下面来看一看 IP 模块的具体工作过程。IP 模块接受 TCP 模块的委托负责包的收发工作，它会生成 IP 头部并附加在 TCP 头部前面。IP 头部包含的内容如表。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/19.png" class="">

<p>其中最重要的内容就是 IP 地址，它表示这个包应该发到哪里去。这个地址是由 TCP 模块告知的，而 TCP 又是在执行连接操作时从应用程序那里获得这个地址的，因此这个地址的最初来源就是应用程序。IP 不会自行判断包的目的地，而是将包发往应用程序指定的接收方，即便应用程序指定了错误的 IP 地址，IP 模块也只能照做。当然，这样做肯定会出错，但这个责任应该由应用程序来承担。</p>
<p>IP 头部中还需要填写发送方的 IP 地址，大家可以认为是发送方计算机的 IP 地址，实际上“计算机的 IP 地址”这种说法并不准确。一般的客户端计算机上只有一块网卡，因此也就只有一个 IP 地址，这种情况下我们可以认为这个 IP 地址就是计算机的 IP 地址，但如果计算机上有多个网卡，情况就没那么简单了。IP 地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块网卡都会有自己的 IP 地址。很多服务器上都会安装多块网卡，这时一台计算机就有多个 IP 地址，在填写发送方 IP 地址时就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器，因此只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的 IP 地址。</p>
<blockquote>
<p>发送方 IP 地址需要判断发送所使用的网卡，并填写该网卡的 IP地址。</p>
</blockquote>
<p>那么，我们应该如何判断应该把包交给哪块网卡呢？其实和图中路由器使用 IP 表判断下一个路由器位置的操作是一样的。因为协议栈的 IP 模块与路由器中负责包收发的部分都是根据 IP 协议规则来进行包收发操作的，所以它们也都用相同的方法来判断把包发送给谁。</p>
<p>这个“IP 表”叫作路由表。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/20.png" class="">

<p>如图所示，我们可以通过<code>route print</code>命令来显示路由表。首先，我们对套接字中记录的目的地 IP 地址与路由表左侧的<code>Network Destination</code>栏进行比较，找到对应的一行。例如，TCP 模块告知的目标 IP 地址为<code>192.168.1.21</code>，那么就对应图中的第 6 行，因为它和<code>192.168.1</code>的部分相匹配。如果目标 IP 地址为<code>10.10.1.166，那么就和 10.10.1</code>的部分相匹配，所以对应第 3 行。以此类推，我们需要找到与 IP 地址左边部分相匹配的条目，找到相应的条目之后，接下来看从右边数第 2 列和第 3 列的内容。右起第 2 列，也就是<code>Interface</code>列，表示网卡等网络接口，这些网络接口可以将包发送给通信对象。此外，右起第 3 列，即<code>Gateway</code>列表示下一个路由器的 IP 地址，将包发给这个 IP 地址，该地址对应的路由器 A 就会将包转发到目标地址 B。路由表的第 1 行中，目标地址和子网掩码 A 都是 0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行。</p>
<p>这样一来，我们就可以判断出应该使用哪块网卡来发送包了，然后就可以在 IP 头部的发送方 IP 地址中填上这块网卡对应的 IP 地址。</p>
<p>接下来还需要填写协议号，它表示包的内容是来自哪个模块的。例如，如果是 TCP 模块委托的内容，则设置为 06（十六进制），如果是 UDP 模块委托的内容，则设置为 17（十六进制），这些值都是按照规则来设置的。在现在我们使用的浏览器中，HTTP 请求消息都是通过 TCP 来传输的，因此这里就会填写表示 TCP 的 06（十六进制）。</p>
<p>其他字段内也需要填写相应的值，但对大局没什么影响。</p>
<h2 id="生成以太网用的-MAC-头部"><a href="#生成以太网用的-MAC-头部" class="headerlink" title="生成以太网用的 MAC 头部"></a>生成以太网用的 MAC 头部</h2><p>生成了 IP 头部之后，接下来 IP 模块还需要在 IP 头部的前面加上 MAC 头部。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/21.png" class="">

<p>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，TCP&#x2F;IP 的这个思路是行不通的。以太网在判断网络包目的地时和 TCP&#x2F;IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的。</p>
<p>IP 模块在生成 IP 头部之后，会在它前面再加上 MAC 头部。MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p>
<p>MAC 头部的开头是接收方和发送方的 MAC 地址，大家可以认为它们和 IP 头部中的接收方和发送方 IP 地址的功能差不多，只不过 IP 地址的长度为 32 比特，而 MAC地址为 48 比特。此外，IP 地址是类似多少弄多少号这种现实中地址的层次化的结构，而 MAC 地址中的 48 比特可以看作是一个整体。尽管有上述差异，但从表示接收方和发送方的意义上来说，MAC 地址和 IP 地址是没有区别的，因此可以暂且先把它们当成是一回事。第 3 个以太类型字段和 IP 头部中的协议号类似。在 IP 中，协议号表示 IP 头部后面的包内容的类型；而在以太网中，我们可以认为以太网类型后面就是以太网包的内容，而以太类型就表示后面内容的类型。以太网包的内容可以是 IP、ARP 等协议的包，它们都有对应的值，这也是根据规则来确定的。</p>
<p>在生成 MAC 头部时，只要设置表中的 3 个字段就可以了。首先是“以太类型”，这里填写表示 IP 协议的值 0800（十六进制）。接下来是发送方 MAC 地址，这里填写网卡本身的 MAC 地址。MAC 地址是在网卡生产时写入 ROM 里的，只要将这个值读取出来写入 MAC 头部就可以了。设置发送方 IP 地址时，我们已经判断出了从哪块网卡发送这个包，那么现在只要将这块网卡对应的 MAC 地址填进去就好了。</p>
<p>前面这些还比较简单，而接收方 MAC 地址就有点复杂了。只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。然而，在这个时间点上，我们还没有把包发送出去，所以先得搞清楚应该把包发给谁，这个只要查一下路由表就知道了。在路由表中找到相匹配的条目，然后把包发给<code>Gateway</code>列中的 IP 地址就可以了。</p>
<p>既然已经知道了包应该发给谁，那么只要将对方的 MAC 地址填上去就好了，但到这里为止根本没有出现对方的 MAC 地址，也就是说我们现在根本不知道对方的 MAC 地址是什么。因此，我们还需要执行根据 IP 地址查询 MAC 地址的操作。IP 模块根据路由表<code>Gateway</code>栏的内容判断应该把包发送给谁。</p>
<h2 id="通过-ARP-查询目标路由器的-MAC-地址"><a href="#通过-ARP-查询目标路由器的-MAC-地址" class="headerlink" title="通过 ARP 查询目标路由器的 MAC 地址"></a>通过 ARP 查询目标路由器的 MAC 地址</h2><p>这里我们需要使用 ARP。在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP 就是利用广播对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。”然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 ××××。”</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/22.png" class="">

<p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC头部就完成了。</p>
<p>不过，如果每次发送包都要这样查询一次，网络中就会增加很多 ARP 包，因此我们会将查询结果放到一块叫作 ARP 缓存的内存空间中留着以后用。也就是说，在发送包时，先查询一下 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址，而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 查询。显 示 ARP 缓存的方法和 MAC 地址的写法如图。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/23.png" class="">
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/24.png" class="">

<p>有了 ARP 缓存，我们可以减少 ARP 包的数量，但如果总是使用 ARP 缓存中保存的地址也会产生问题。例如当 IP 地址发生变化时，ARP 缓存的内容就会和现实发生差异。为了防止这种问题的发生，ARP 缓存中的值在经过一段时间后会被删除，一般这个时间在几分钟左右。这个删除的操作非常简单粗暴，不管 ARP 缓存中的内容是否有效，只要经过几分钟就全部删掉，这样就不会出问题了。当地址从 ARP 缓存中删除后，只要重新执行一次 ARP 查询就可以再次获得地址了。</p>
<p>上面这个策略能够在几分钟后消除缓存和现实的差异，但 IP 地址刚刚发生改变的时候，ARP 缓存中依然会保留老的地址，这时就会发生通信的异常。</p>
<p>将 MAC 头部加在 IP 头部的前面，整个包就完成了。到这里为止，整个打包的工作是由 IP 模块负责的。有人认为，MAC 头部是以太网需要的内容，并不属于 IP 的职责范围，但从现实来看，让 IP 负责整个打包工作是有利的。</p>
<p>如果在交给网卡之前，IP 模块能够完成整个打包工作，那么网卡只要将打好的包发送出去就可以了。对于除 IP 以外的其他类型的包也是一样，如果在交给网卡之前完成打包，那么对于网卡来说，发送的操作和发送 IP 包是完全相同的。这样一来，同一块网卡就可以支持各种类型的包。至于接收操作，如果接收的包可以原封不动直接交给 IP 模块来处理，网卡就只要负责接收就可以了。这样一来，一块网卡也就能支持各种类型的包了。与其机械地设计模块和设备之间的分工，导致网卡只能支持 IP 包，不如将分工设计得现实一些，让网卡能够灵活支持各种类型的包。</p>
<h2 id="以太网的基本知识"><a href="#以太网的基本知识" class="headerlink" title="以太网的基本知识"></a>以太网的基本知识</h2><p>完成 IP 模块的工作之后，下面就该轮到网卡了。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/25.png" class="">

<p>以太网是一种为多台计算机能够彼此自由和廉价地相互通信而设计的通信技术，它的原型如图（a）所示。从图上不难看出，这种网络的本质其实就是一根网线。图上还有一种叫作收发器的小设备，它的功能只是将不同网线之间的信号连接起来而已。因此，当一台计算机发送信号时，信号就会通过网线流过整个网络，最终到达所有的设备。这种网络中任何一台设备发送的信号所有设备都能接收到。不过，我们无法判断一个信号到底是发给谁的，因此需要在信号的开头加上接收者的信息，也就是地址。这样一来就能够判断信号的接收者了，与接收者地址匹配的设备就接收这个包，其他的设备则丢弃这个包，这样我们的包就送到指定的目的地了。为了控制这一操作，我们就需要使用 MAC 头部。通过 MAC 头部中的接收方 MAC 地址，就能够知道包是发给谁的；而通过发送方 MAC 地址，就能够知道包是谁发出的；此外，通过以太类型就可以判断包里面装了什么类型的内容。以太网其实就这么简单。</p>
<p>这个原型后来变成了图（b）中的结构。这个结构是将主干网线替换成了一个中继式集线器，将收发器网线替换成了双绞线。不过，虽然网络的结构有所变化，但信号会发送给所有设备这一基本性质并没有改变。</p>
<p>后来，图（c）这样的使用交换式集线器的结构普及开来，现在我们说的以太网指的都是这样的结构。这个结构看上去和（b）很像，但其实里面有一个重要的变化，即信号会发送给所有设备这一性质变了，现在信号只会流到根据 MAC 地址指定的设备，而不会到达其他设备了。当然，根据 MAC 地址来传输包这一点并没有变，因此 MAC 头部的设计也得以保留。</p>
<p>尽管以太网经历了数次变迁，但其基本的 3 个性质至今仍未改变，即将包发送到 MAC 头部的接收方 MAC 地址代表的目的地，用发送方 MAC地址识别发送方，用以太类型识别包的内容。因此，大家可以认为具备这 3 个性质的网络就是以太网。</p>
<p>以太网中的各种设备也是基于以太网规格来工作的，因此下面的内容不仅适用于客户端计算机，同样也适用于服务器、路由器等各种设备。</p>
<p>此外，以太网和 IP 一样，并不关心网络包的实际内容，因此以太网的收发操作也和 TCP 的工作阶段无关，都是共通的。</p>
<h2 id="将-IP-包转换成电或光信号发送出去"><a href="#将-IP-包转换成电或光信号发送出去" class="headerlink" title="将 IP 包转换成电或光信号发送出去"></a>将 IP 包转换成电或光信号发送出去</h2><p>下面来看看以太网的包收发操作。IP 生成的网络包只是存放在内存中的一串数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电或光信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
<p>负责执行这一操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。驱动程序不只有网卡才有，键盘、鼠标、显卡、声卡等各种硬件设备都有。当然，不同厂商和型号的网卡在结构上有所不同，因此网卡驱动程序也是厂商开发的专用程序。</p>
<p>网卡的内部结构如图，这是一张网卡主要构成要素的概念图，并不代表硬件的实际结构，但依然可以看清大体的思路。记住这一内部结构之后，我们再来介绍包收发的操作过程，现在，我们先来讲讲网卡的初始化过程。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/26.png" class="">

<p>网卡并不是通上电之后就可以马上开始工作的，而是和其他硬件一样，都需要进行初始化。也就是说，打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态。这些操作包括硬件错误检查、初始设置等步骤，这些步骤对于很多其他硬件也是共通的，但也有一些操作是以太网特有的，那就是在控制以太网收发操作的 MACA 模块中设置 MAC 地址。</p>
<p>网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的，将这个值读出之后就可以对 MAC 模块进行设置，MAC 模块就知道自己对应的 MAC 地址了。也有一些特殊的方法，比如从命令或者配置文件中读取 MAC 地址并分配给 MAC 模块。这种情况下，网卡会忽略 ROM 中的 MAC 地址。有人认为在网卡通电之后，ROM 中的 MAC 地址就自动生效了，其实不然，真正生效的是网卡驱动进行初始化时在 MAC 模块中设置的那个 MAC 地址。在操作系统启动并完成这些初始化操作之后，网卡就可以等待来自 IP 的委托了。</p>
<p>网卡中保存的 MAC 地址会由网卡驱动程序读取并分配给 MAC 模块。</p>
<h2 id="给网络包再加-3-个控制数据"><a href="#给网络包再加-3-个控制数据" class="headerlink" title="给网络包再加 3 个控制数据"></a>给网络包再加 3 个控制数据</h2><p>下面来看一看网卡是如何将包转换成电信号并发送到网线中的。</p>
<p>网卡驱动从 IP 模块获取包之后，会将其复制到网卡内的缓冲区中，然后向 MAC 模块发送发送包的命令。接下来就轮到 MAC 模块进行工作了。</p>
<p>首先，MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/27.png" class="">

<p>报头是一串像 10101010…这样 1 和 0 交替出现的比特序列，长度为 56 比特，它的作用是确定包的读取时机。当这些 1010 的比特序列被转换成电信号后，会形成如图这样的波形。接收方在收到信号时，遇到这样的波形就可以判断读取数据的时机。我们得先了解如何通过电信号来读取数据。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/28.png" class="">

<p>用电信号来表达数字信息时，我们需要让 0 和 1 两种比特分别对应特定的电压和电流，例如图（a）这样的电信号就可以表达数字信息。通过电信号来读取数据的过程就是将这种对应关系颠倒过来。也就是说，通过测量信号中的电压和电流变化，还原出 0 和 1 两种比特的值。然而，实际的信号并不像图所示的那样有分隔每个比特的辅助线，因此在测量电压和电流时必须先判断出每个比特的界限在哪里。但是，像图 （a）右边这种 1 和 0 连续出现的信号，由于电压和电流没有变化，我们就没办法判断出其中每个比特到底应该从哪里去切分。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/29.png" class="">

<p>要解决这个问题，最简单的方法就是在数据信号之外再发送一组用来区分比特间隔的时钟信号。如图（b）所示，当时钟信号从下往上变化时读取电压和电流的值，然后和 0 或 1 进行对应就可以了。但是这种方法存在问题。当距离较远，网线较长时，两条线路的长度会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。</p>
<p>要解决这个问题，可以采用将数据信号和时钟信号叠加在一起的方法。</p>
<p>这样的信号如图（c）所示，发送方将这样的信号发给接收方。由于时钟信号是像图（b）这样按固定频率进行变化的，只要能够找到这个变化的周期，就可以从接收到的信号（c）中提取出时钟信号（b），进而通过接收信号（c）和时钟信号（b）计算出数据信号（a），这和发送方将数据信号和时钟信号进行叠加的过程正好相反。然后，只要根据时钟信号（b）的变化周期，我们就可以从数据信号（a）中读取相应的电压和电流值，并将其还原为 0 或 1 的比特了。</p>
<p>这里的重点在于如何判断时钟信号的变化周期。时钟信号是以 10 Mbit&#x2F;s 或者 100 Mbit&#x2F;s 这种固定频率进行变化的，就像我们乘坐自动扶梯一样，只要对信号进行一段时间的观察，就可以找到其变化的周期。因此，我们不能一开始就发送包的数据，而是要在前面加上一段用来测量时钟信号的特殊信号，这就是报头的作用。</p>
<p>以太网根据速率和网线类型的不同分为多种派生方式，每种方式的信号形态也有差异，并不都是像本例中讲的这样，单纯通过电压和电流来表达 0 和 1 的。因此，101010…这样的报头数字信息在转换成电信号后，其波形也不一定都是图中的那个样子，而是根据方式的不同而不同。但是，报头的作用和基本思路是一致的。</p>
<p>报头后面的起始帧分界符在图中也已经画出来了，它的末尾比特排列有少许变化。接收方以这一变化作为标记，从这里开始提取网络包数据。也就是说，起始帧分界符是一个用来表示包起始位置的标记。</p>
<p>末尾的 FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串 32 比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。具体的计算公式在此省略，它和磁盘等设备中使用的 CRCA 错误校验码是同一种东西，当原始数据中某一个比特发生变化时，计算出来的结果就会发生变化。在包传输过程中，如果受到噪声的干扰而导致其中的数据发生了变化，那么接收方计算出的 FCS 和发送方计算出的 FCS 就会不同，这样我们就可以判断出数据有没有错误。</p>
<h2 id="向集线器发送网络包"><a href="#向集线器发送网络包" class="headerlink" title="向集线器发送网络包"></a>向集线器发送网络包</h2><p>加上报头、起始帧分界符和 FCS 之后，我们就可以将包通过网线发送出去了。发送信号的操作分为两种，一种是使用集线器的半双工模式，另一种是使用交换机的全双工模式。</p>
<p>在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信号。如果有，则需要等待该信号传输完毕，因为如果在有信号时再发送一组信号，两组信号就会发生碰撞。当之前的信号传输完毕，或者本来就没有信号在传输的情况下，我们就可以开始发送信号了。首先，MAC 模块从报头开始将数字信息按每个比特转换成电信号，然后由 PHY，或者叫 MAU 的信号收发模块发送出去。在这里，将数字信息转换为电信号的速率就是网络的传输速率，例如每秒将 10 Mbit 的数字信息转换为电信号发送出去，则速率就是 10 Mbit&#x2F;s。</p>
<p>接下来，PHY（MAU）模块会将信号转换为可在网线上传输的格式，并通过网线发送出去。以太网规格中对不同的网线类型和速率以及其对应的信号格式进行了规定，但 MAC 模块并不关心这些区别，而是将可转换为任意格式的通用信号发送给 PHY（MAU）模块，然后 PHY（MAU）模块再将其转换为可在网线上传输的格式。大家可以认为 PHY（MAU）模块的功能就是对 MAC 模块产生的信号进行格式转换。当然，以太网还有很多不同的派生方式，网线传输的信号格式也有各种变化。下图就是这样一个例子，总之，网线中实际传输的信号就是这个样子的。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/30.png" class="">

<p>PHY（MAU）的职责并不是仅仅是将 MAC 模块传递过来的信号通过网线发送出去，它还需要监控接收线路中有没有信号进来。在开始发送信号之前，需要先确认没有其他信号进来，这时才能开始发送。如果在信号开始发送到结束发送的这段时间内一直没有其他信号进来，发送操作就成功完成了。以太网不会确认发送的信号对方有没有收到。根据以太网的规格，两台设备之间的网线不能超过 100 米，在这个距离内极少会发生错误，万一发生错误，协议栈的 TCP 也会负责搞定，因此在发送信号时没有必要检查错误。</p>
<p>在发送信号的过程中，接收线路不应该有信号进来，但情况并不总是尽如人意，有很小的可能性出现多台设备同时进行发送操作的情况。如果有其他设备同时发送信号，这些信号就会通过接收线路传进来。</p>
<p>在使用集线器的半双工模式中，一旦发生这种情况，两组信号就会相互叠加，无法彼此区分出来，这就是所谓的信号碰撞。这种情况下，继续发送信号是没有意义的，因此发送操作会终止。为了通知其他设备当前线路已发生碰撞，还会发送一段时间的阻塞信号，然后所有的发送操作会全部停止。</p>
<p>等待一段时间之后，网络中的设备会尝试重新发送信号。但如果所有设备的等待时间都相同，那肯定还会发生碰撞，因此必须让等待的时间相互错开。具体来说，等待时间是根据 MAC 地址生成一个随机数计算出来的。</p>
<p>当网络拥塞时，发生碰撞的可能性就会提高，重试发送的时候可能又会和另外一台设备的发送操作冲突，这时会将等待时间延长一倍，然后再次重试。以此类推，每次发生碰撞就将等待时间延长一倍，最多重试 10 次，如果还是不行就报告通信错误。</p>
<p>在全双工模式中，发送和接收可以同时进行，不会发生碰撞。因此，全双工模式中不需要像半双工模式这样考虑这么多复杂的问题，即便接收线路中有信号进来，也可以直接发送信号。</p>
<h2 id="接收返回包"><a href="#接收返回包" class="headerlink" title="接收返回包"></a>接收返回包</h2><p>网卡将包转换为电信号并发送出去的过程到这里就结束了，既然讲到了以太网的工作方式，那我们不妨继续看看接收网络包时的操作过程。</p>
<p>在使用集线器的半双工模式以太网中，一台设备发送的信号会到达连接在集线器上的所有设备。这意味着无论是不是发给自己的信号都会通过接收线路传进来，因此接收操作的第一步就是不管三七二十一把这些信号全都收进来再说。</p>
<p>信号的开头是报头，通过报头的波形同步时钟，然后遇到起始帧分界符时开始将后面的信号转换成数字信息。这个操作和发送时是相反的，即 PHY（MAU）模块先开始工作， 然后再轮到 MAC 模块。 首先，PHY（MAU）模块会将信号转换成通用格式并发送给 MAC 模块，MAC 模块再从头开始将信号转换为数字信息，并存放到缓冲区中。当到达信号的末尾时，还需要检查 FCS。具体来说，就是将从包开头到结尾的所有比特套用到公式中计算出 FCS，然后和包末尾的 FCS 进行对比，正常情况下两者应该是一致的，如果中途受到噪声干扰而导致波形发生紊乱，则两者的值会产生差异，这时这个包就会被当作错误包而被丢弃。</p>
<p>如果 FCS 校验没有问题，接下来就要看一下 MAC 头部中接收方 MAC 地址与网卡在初始化时分配给自己的 MAC 地址是否一致，以判断这个包是不是发给自己的。我们没必要去接收发给别人的包，因此如果不是自己的包就直接丢弃，如果接收方 MAC 地址和自己 MAC 地址一致，则将包放入缓冲区中。到这里，MAC 模块的工作就完成了，接下来网卡会通知计算机收到了一个包。</p>
<p>通知计算机的操作会使用一个叫作中断的机制。在网卡执行接收包的操作的过程中，计算机并不是一直监控着网卡的活动，而是去继续执行其他的任务。因此，如果网卡不通知计算机，计算机是不知道包已经收到了这件事的。网卡驱动也是在计算机中运行的一个程序，因此它也不知道包到达的状态。在这种情况下，我们需要一种机制能够打断计算机正在执行的任务，让计算机注意到网卡中发生的事情，这种机制就是中断。</p>
<p>具体来说，中断的工作过程是这样的。首先，网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到 CPU。当产生中断信号时，CPU 会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序。然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。</p>
<p>中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，在中断处理程序中则将硬件的中断号和相应的驱动程序绑定。例如，假设网卡的中断号为 11，则在中断处理程序中将中断号 11 和相应的网卡驱动绑定起来，当网卡发起中断时，就会自动调用网卡驱动了。现在的硬件设备都遵循即插即用规范自动设置中断号，我们没必要去关心中断号了，在以前需要手动设置中断号的年代，经常发生因为设置了错误的中断号而导致网卡无法正常工作的问题。</p>
<p>网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过 MAC 头部中的以太类型字段判断协议的类型。现在我们在大多数情况下都是使用 TCP&#x2F;IP 协议，但除了 TCP&#x2F;IP 之外还有很多其他类型的协议，例如 NetWare 中使用的 IPX&#x2F;SPX，以及 Mac 电脑中使用的 AppleTalk 等协议。这些协议都被分配了不同的以太类型，如 0080（十六进制）代表IP 协议，网卡驱动就会把这样的包交给 TCP&#x2F;IP 协议栈；如果是 809B 则表示 AppleTalk 协议，就把包交给 AppleTalk 协议栈，以此类推。</p>
<p>大家可能会认为向 Web 服务器发送包之后，后面收到的一定是 Web 服务器返回的包，其实并非如此。计算机中同时运行了很多程序，也会同时进行很多通信操作，因此收到的包也有可能是其他应用程序的。不过，即便如此也没问题，网卡不会关心包里的内容，只要按照以太类型将包交给对应的协议栈就可以了。接下来，协议栈会判断这个包应该交给哪个应用程序，并进行相应的处理。</p>
<h2 id="将服务器的响应包从-IP-传递给-TCP"><a href="#将服务器的响应包从-IP-传递给-TCP" class="headerlink" title="将服务器的响应包从 IP 传递给 TCP"></a>将服务器的响应包从 IP 传递给 TCP</h2><p>下面我们假设 Web 服务器返回了一个网络包，那么协议栈会进行哪些处理呢？服务器返回的包的以太类型应该是 0800，因此网卡驱动会将其交给 TCP&#x2F;IP 协议栈来进行处理。接下来就轮到 IP 模块先开始工作了，第一步是检查 IP 头部，确认格式是否正确。如果格式没有问题，下一步就是查看接收方 IP 地址。如果接收网络包的设备是一台 Windows 客户端计算机，那么服务器返回的包的接收方 IP 地址应该与客户端网卡的地址一致，检查确认之后我们就可以接收这个包了。</p>
<p>如果接收方 IP 地址不是自己的地址，那一定是发生了什么错误。客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包。当发生这样的错误时，IP 模块会通过 ICMP 消息将错误告知发送方。</p>
<p>ICMP 规定了各种类型的消息，如表所示。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/32.png" class="">

<p>当我们遇到这个错误时，IP 模块会通过表中的 Destination unreachable 消息通知对方。从这张表的内容中我们可以看到在包的接收和转发过程中能够遇到的各种错误，因此希望大家看一看这张表。</p>
<p>如果接收方 IP 地址正确，则这个包会被接收下来，这时还需要完成另一项工作。IP 协议有一个叫作分片的功能。简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包。如果接收到的包是经过分片的，那么 IP 模块会将它们还原成原始的包。分片的包会在 IP 头部的标志字段中进行标记，当收到分片的包时，IP 模块会将其暂存在内部的内存空间中，然后等待 IP 头部中具有相同 ID 的包全部到达，这是因为同一个包的所有分片都具有相同的 ID。此外，IP 头部还有一个分片偏移量（fragment offset）字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组。</p>
<p>到这里，IP 模块的工作就结束了，接下来包会被交给 TCP 模块。TCP 模块会根据 IP 头部中的接收方和发送方 IP 地址，以及 TCP 头部中的接收方和发送方端口号来查找对应的套接字。找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。</p>
<h1 id="UDP-协议的收发操作"><a href="#UDP-协议的收发操作" class="headerlink" title="UDP 协议的收发操作"></a>UDP 协议的收发操作</h1><h2 id="不需要重发的数据用-UDP-发送更高效"><a href="#不需要重发的数据用-UDP-发送更高效" class="headerlink" title="不需要重发的数据用 UDP 发送更高效"></a>不需要重发的数据用 UDP 发送更高效</h2><p>通过套接字收发数据的整个过程到这里已经告一段落了。接下来，网络包会从计算机出来跑向集线器。</p>
<p>大多数的应用程序都使用 TCP 协议来收发数据，但当然也有例外。有些应用程序不使用 TCP 协议，而是使用 UDP 协议来收发数据。向 DNS 服务器查询 IP 地址的时候我们用的也是 UDP 协议。</p>
<p>其实 TCP 中就包含了 UDP 的一些要点。TCP 的工作方式十分复杂，如果我们能够理解 TCP 为什么要设计得如此复杂，也就能够理解 UDP 了。那么，为什么要设计得如此复杂呢？因为我们需要将数据高效且可靠地发送给对方。为了实现可靠性，我们就需要确认对方是否收到了我们发送的数据，如果没有还需要再发一遍。</p>
<p>要实现上面的要求，最简单的方法是数据全部发送完毕之后让接收方返回一个接收确认。这样一来，如果没收到直接全部重新发送一遍就好了，根本不用像 TCP 一样要管理发送和确认的进度。但是，如果漏掉了一个包就要全部重发一遍，怎么看都很低效。为了实现高效的传输，我们要避免重发已经送达的包，而是只重发那些出错的或者未送达的包。TCP 之所以复杂，就是因为要实现这一点。</p>
<p>不过，在某种情况下，即便没有 TCP 这样复杂的机制，我们也能够高效地重发数据，这种情况就是数据很短，用一个包就能装得下。如果只有一个包，就不用考虑哪个包未送达了，因为全部重发也只不过是重发一个包而已，这种情况下我们就不需要 TCP 这样复杂的机制了。而且，如果不使用 TCP，也不需要发送那些用来建立和断开连接的控制包了。此外，我们发送了数据，对方一般都会给出回复，只要将回复的数据当作接收确认就行了，也不需要专门的接收确认包了。</p>
<h2 id="控制用的短数据"><a href="#控制用的短数据" class="headerlink" title="控制用的短数据"></a>控制用的短数据</h2><p>这种情况就适合使用 UDP。像 DNS 查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种场景中就可以用 UDP 来代替 TCP。UDP 没有 TCP 的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上 UDP 头部，然后交给 IP 进行发送就可以了。接收也很简单，只要根据 IP 头部中的接收方和发送方 IP 地址，以及 UDP 头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。除此之外，UDP 协议没有其他功能了，遇到错误或者丢包也一概不管。因为 UDP 只负责单纯地发送包而已，并不像 TCP 一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误。但这样并不会引发什么问题，因此出错时就收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据。这样的操作本身并不复杂，也并不会增加应用程序的负担。</p>
<img src="/2021/12/01/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%842/31.png" class="">

<h2 id="音频和视频数据"><a href="#音频和视频数据" class="headerlink" title="音频和视频数据"></a>音频和视频数据</h2><p>还有另一个场景会使用 UDP，就是发送音频和视频数据的时候。音频和视频数据必须在规定的时间内送达，一旦送达晚了，就会错过播放时机，导致声音和图像卡顿。如果像 TCP 一样通过接收确认响应来检查错误并重发，重发的过程需要消耗一定的时间，因此重发的数据很可能已经错过了播放的时机。一旦错过播放时机，重发数据也是没有用的，因为声音和图像已经卡顿了，这是无法挽回的。当然，我们可以用高速线路让重发的数据能够在规定的时间内送达，但这样一来可能要增加几倍的带宽才行。</p>
<p>此外，音频和视频数据中缺少了某些包并不会产生严重的问题，只是会产生一些失真或者卡顿而已，一般都是可以接受的。</p>
<p>在这些无需重发数据，或者是重发了也没什么意义的情况下，使用 UDP 发送数据的效率会更高。</p>
<p>我们探索了在收发数据时，操作系统中的协议栈是如何工作的，以及网卡是如何将包转换成电信号通过网线发送出去的。到这里，我们的网络包已经沿着网线流出了客户端计算机。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-others/HTTPS证书申请的主要步骤"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/"
    >HTTPS证书申请的主要步骤</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/" class="article-date">
  <time datetime="2021-10-22T06:32:16.000Z" itemprop="datePublished">2021-10-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h1><p>SSL 证书，简称安全套接层，是由 Netscape 开发来保护 Web 服务器和 Web 浏览器之间的网上交易。SSL 证书可以帮助保护在线用户的银行信息，登录账号密码，电子邮件，以及相关重要的机密信息，在信息传输过程中对其进行高强度加密，防止黑客篡改以及截取信息。</p>
<p>SSL 证书由受信任的数字证书颁发机构（CA），在验证服务器身份后颁发，CA 是值得信赖的第三方机构，它对申请证书用户进行认证。CA 机构会对申请 SSL 证书的域名，主机名和服务器名以及申请者的身份、机构进行审核。以确保 SSL 证书顺利安装到网站合法 Web 服务器。便于用户通过网络浏览器进行在线传输数据保护。CA 机构根据所选择的 SSL 证书类型，对申请者经过不同级别的验证。</p>
<p>成功安装 SSL 证书后，网站的<code>https：//</code>网址成立， 意味着 Web 服务器与 Web 浏览器建立安全连接。然后浏览器告知访问者，该网站已采用 SSL 加密。</p>
<h1 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h1><p>要申请 HTTPS 证书，首先你要了解到底你的网站应该申请哪一种 HTTPS 证书。一般 HTTPS 证书分以下几种：</p>
<table>
<thead>
<tr>
<th align="center">证书类型</th>
<th align="center">适用网站类型</th>
<th align="center">公信等级</th>
<th align="center">认证强度</th>
<th align="center">安全性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DV域名型</td>
<td align="center">个人网站</td>
<td align="center">一般</td>
<td align="center">CA机构审核个人网站真实性、不验证企业真实性</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">OV企业型</td>
<td align="center">政府组织、企业、教育机构等</td>
<td align="center">高</td>
<td align="center">CA机构审核组织及企业真实性</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">EV企业增强型</td>
<td align="center">大型企业、金融机构等</td>
<td align="center">最高</td>
<td align="center">严格认证</td>
<td align="center">最高（地址栏绿色）</td>
</tr>
</tbody></table>
<p>根据你的网站实际情况，选择好合适的证书类型是你申请HTTPS证书的第一步，也是很重要的一步。</p>
<h2 id="浏览器展示效果"><a href="#浏览器展示效果" class="headerlink" title="浏览器展示效果"></a>浏览器展示效果</h2><p>SSL 数字证书主要分为 DV SSL、OV SSL、EV SSL 三种类型。不同类型的 SSL 证书部署到网站所在的服务器上后，该网站在浏览器地址栏会展示以下不同的效果。</p>
<p>DV SSL、OV SSL 数字证书部署在服务器上后，浏览器访问网站时，展示以下效果：</p>
<img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/1.png" class="">

<p>EV SSL数字证书部署在服务器上后，浏览器访问网站时，展示以下效果：</p>
<img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/2.png" class="">

<h1 id="证书品牌"><a href="#证书品牌" class="headerlink" title="证书品牌"></a>证书品牌</h1><table>
<thead>
<tr>
<th align="center">证书品牌</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DigiCert</td>
<td align="center">DigiCert（原Symantec）是全球第一大数字证书颁发机构、全球最值得信赖的SSL证书品牌，所有证书都采用业界领先的加密技术，为不同的网站和服务器提供安全解决方案。<br>DigiCert品牌证书具有安全、稳定、兼容性好等优势。</td>
</tr>
<tr>
<td align="center">GeoTrust</td>
<td align="center">GeoTrust是全球第二大数字证书颁发机构，也是身份认证和信任认证领域的领导者，采用各种先进的技术使任何大小的机构和公司都能安全、低成本地部署SSL数字证书和实现各种身份认证。<br>该品牌是DigiCert旗下的子品牌。</td>
</tr>
<tr>
<td align="center">GlobalSign</td>
<td align="center">GlobalSign是全球最早的数字证书认证机构之一，一直致力于网络安全认证及数字证书服务，是一个备受信赖的CA和SSL数字证书提供商。<br>GlobalSign品牌证书具有签发速度快、验证速度快等优势。天猫、淘宝等大型电商网站采用了GlobalSign品牌证书。</td>
</tr>
<tr>
<td align="center">CFCA（国产）</td>
<td align="center">中国金融认证中心（CFCA）通过了国际WebTrust认证，遵循全球统一鉴证标准，是国际CA浏览器联盟的组织成员。<br>CFCA支持以下服务：<br>提供全球信任证书，由中国权威数字证书认证机构自主研发，纯国产证书。<br>提供7*24小时金融级的安全保障服务，具有完善的风险承保计划。<br>提供中文版全球信任体系电子认证业务规则（CPS），便于用户理解双方权利和义务。<br>CFCA品牌证书符合政府机构合规要求，使用了国密算法。</td>
</tr>
<tr>
<td align="center">vTrus（国产）</td>
<td align="center">vTrus是一个国产证书品牌，满足企业采购国产品牌SSL证书的需求。vTrus品牌证书的兼容性较好。</td>
</tr>
<tr>
<td align="center">WoSign（国产）</td>
<td align="center">WoSign是一个国产证书品牌，满足企业采购国产品牌SSL证书的需求。WoSign品牌证书的性价比较高。</td>
</tr>
</tbody></table>
<h1 id="HTTPS证书申请的主要步骤"><a href="#HTTPS证书申请的主要步骤" class="headerlink" title="HTTPS证书申请的主要步骤"></a>HTTPS证书申请的主要步骤</h1><table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">任务</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">购买一个SSL证书实例。</td>
<td align="center">根据你的网站实际情况，选择好合适的证书类型</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">使用已购买的SSL证书实例，向CA中心提交证书申请。</td>
<td align="center">CA中心是颁发SSL证书的机构，您可以通过已购买的SSL证书实例向CA中心提交证书申请。只有当CA中心审核通过申请后，才会签发SSL证书。</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">将已签发的SSL证书安装到Web服务器。</td>
<td align="center">SSL证书只有正确安装到Web服务器，才能实现客户端与服务器间的HTTPS通信。</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">在证书即将过期时，为证书续费并使用新签发的证书替换旧证书。</td>
<td align="center">cA中心签发的SSL证书默认有1年有效期。证书过期后将不被浏览器信任，影响客户端通过HTTPS协议访问。<br>可以在证书到期前的30个自然日内，为证书手动续费，或者提前开启证书托管服务，由SSL证书服务自动续费证书。<br>证书续费表示重新购买并申请一张与旧证书规格相同的SSL证书。在证书续费后，还必须将续费签发的新证书重新安装到Web服务器，替换即将过期的旧证书。</td>
</tr>
</tbody></table>
<h1 id="OV-证书申请信息"><a href="#OV-证书申请信息" class="headerlink" title="OV 证书申请信息"></a>OV 证书申请信息</h1><img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/8.png" class="">
<img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/9.png" class="">
<h1 id="阿里云申请-SSL证书示例"><a href="#阿里云申请-SSL证书示例" class="headerlink" title="阿里云申请 SSL证书示例"></a>阿里云申请 SSL证书示例</h1><h2 id="购买SSL证书"><a href="#购买SSL证书" class="headerlink" title="购买SSL证书"></a>购买SSL证书</h2><ol>
<li>访问<a target="_blank" rel="noopener" href="https://common-buy.aliyun.com/?spm=a2c4g.11186623.0.0.379e787bBHgLHT&commodityCode=cas_dv_public_cn&request=%7B%22product%22:%22cert_product%22,%22domain%22:%22all%22,%22productCode%22:%22symantec-dv-1-starter%22%7D">云盾证书服务购买页</a>，并登录您的阿里云账号。</li>
<li>按照页面提示，完成以下购买配置。<img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/3.png" class=""></li>
<li>单击立即购买。</li>
<li>确认订单并完成支付。</li>
</ol>
<p>完成购买后，可以在SSL证书控制台的SSL证书页面，通过订单管理查询已购买的SSL证书订单实例。</p>
<img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/4.png" class="">
<h2 id="提交证书申请"><a href="#提交证书申请" class="headerlink" title="提交证书申请"></a>提交证书申请</h2><p>购买SSL证书订单实例后，必须通过SSL证书服务向CA中心提交证书申请。只有当CA中心审核通过请后，才会签发证书，然后才可以将已签发的证书安装到Web服务器，实现网站HTTPS。</p>
<p>操作步骤：</p>
<ol>
<li>登录SSL证书控制台。</li>
<li>在左侧导航栏，单击SSL证书。</li>
<li>在证书管理页签，定位到待申请区域，单击证书申请。</li>
<li>在证书申请面板，完成以下配置并单击确定，创建一个证书申请。<br>证书申请（不开启快捷签发）：<img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/5.png" class="">
证书申请（开启快捷签发）：<img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/6.png" class=""></li>
</ol>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">证书类型</td>
<td align="center">根据证书要绑定的域名类型，选择对应的证书类型。可选项：<br>单域名：表示要申请的证书用于绑定1个具体域名（例如，只绑定<code>www.yourdomain.com</code>）。<br>多域名：表示要申请的证书用于绑定1~5个具体域名（例如，同时绑定<code>yourdomain.com、www.yourdomain.com、abc.yourdomain.com</code>等）。<br>通配符：表示要申请的证书用于绑定1个通配符域名（例如，绑定<code>*.yourdomain.com</code>）。<br></td>
</tr>
<tr>
<td align="center">证书规格</td>
<td align="center">从下拉列表选择要申请的证书品牌及类型。<br> 下拉列表展示了您当前拥有的不同规格证书资源的个数（即可申请证书的张数）。只有当您已经购买了对应规格的证书资源，才可以在此处进行选择。<br> 如果您要申请的证书规格不在下拉列表（或者下拉列表为空），您必须先购买对应规格的证书资源。</td>
</tr>
<tr>
<td align="center">域名名称</td>
<td align="center">填写证书用于保护的域名。<br> 如果证书类型选择了单域名、通配符，则此处可以填写1个单域名、1个通配符域名。<br> 如果证书类型选择了多域名，则此处可以填写1~5个单域名。多个单域名间使用半角逗号（,）分隔。</td>
</tr>
<tr>
<td align="center">年限</td>
<td align="center">选择您需要的证书服务年限。</td>
</tr>
<tr>
<td align="center">快捷签发</td>
<td align="center">选择是否开启快捷签发功能：<br> 不开启快捷签发：无需在该步骤填写证书申请信息。<br> 创建证书申请后，您将获得一个证书实例（对应要申请的证书）。后续您可以单击证书实例后的证书申请，填写证书申请信息。<br> 开启快捷签发：需要在该步骤填写证书申请信息。<br> 申请不同类型证书需要填写的申请信息不同。</td>
</tr>
</tbody></table>
<p>创建证书申请后，您将获得一个证书实例（对应要申请的证书），您可以在证书列表中查看新增的证书实例（如果证书实例没有出现，请刷新页面）。此时，证书实例对应证书的状态为待申请，您还需要将证书申请提交到CA中心审核。只有当CA中心审核通过您的证书申请后，才会为您签发证书。</p>
<ol start="5">
<li>提交证书申请到CA中心审核。</li>
</ol>
<ul>
<li>定位待申请状态的证书实例，单击操作列下的证书申请。</li>
<li>在证书申请面板，确认证书申请信息，并提交审核。</li>
</ul>
<h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><img src="/2021/10/22/others/HTTPS%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4/7.png" class="">
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/Spring Boot整合MyBatis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/18/java/SpringBoot/Spring%20Boot%E6%95%B4%E5%90%88MyBatis/"
    >Spring Boot 整合MyBatis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/18/java/SpringBoot/Spring%20Boot%E6%95%B4%E5%90%88MyBatis/" class="article-date">
  <time datetime="2021-09-18T09:09:34.000Z" itemprop="datePublished">2021-09-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Boot/">Spring Boot</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>MyBatis 是一个半自动化的 ORM 框架，所谓半自动化是指 MyBatis 只支持将数据库查出的数据映射到 POJO 实体类上，而实体到数据库的映射则需要我们自己编写 SQL 语句实现，相较于 Hibernate 这种完全自动化的框架，Mybatis 更加灵活，我们可以根据自身的需求编写 sql 语句来实现复杂的数据库操作。</p>
<p>MyBatis 开发了一套基于 Spring Boot 模式的<code>starter</code>：<code>mybatis-spring-boot-starter</code>。</p>
<h1 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h1><p>Spring Boot 整合 MyBatis 的第一步，就是在项目的<code>pom.xml</code>中引入<code>mybatis-spring-boot-starter</code>的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 mybatis-spring-boot-starter 的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="配置-MyBatis"><a href="#配置-MyBatis" class="headerlink" title="配置 MyBatis"></a>配置 MyBatis</h1><p>在 Spring Boot 的配置文件（<code>application.properties/yml</code>）中对 MyBatis 进行配置，例如指定<code>mapper.xml</code>的位置、实体类的位置、是否开启驼峰命名法等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">###################################### MyBatis 配置######################################</span><br><span class="line">mybatis:</span><br><span class="line">  # 指定 mapper.xml 的位置</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br><span class="line">  #扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span><br><span class="line">  type-aliases-package: net.biancheng.www.bean</span><br><span class="line">  configuration:</span><br><span class="line">    #默认开启驼峰命名法，可以不用设置该属性</span><br><span class="line">    map-underscore-to-camel-case: true  </span><br></pre></td></tr></table></figure>
<p>注意：使用 MyBatis 时，必须配置数据源信息，例如数据库 URL、数据库用户型、数据库密码和数据库驱动等。</p>
<h1 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h1><p>在指定的数据库内创建一个<code>user</code>表，并插入一些数据，如下表。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">user_id</th>
<th align="center">user_name</th>
<th align="center">password</th>
<th align="center">email</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">001</td>
<td align="center">admin</td>
<td align="center">admin</td>
<td align="center"><a href="mailto:&#49;&#x32;&#51;&#52;&#53;&#54;&#55;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;">&#49;&#x32;&#51;&#52;&#53;&#54;&#55;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">002</td>
<td align="center">user</td>
<td align="center">123456</td>
<td align="center"><a href="mailto:&#57;&#x38;&#x37;&#x36;&#53;&#52;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;">&#57;&#x38;&#x37;&#x36;&#53;&#52;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">003</td>
<td align="center">bianchengbang</td>
<td align="center">qwertyuiop</td>
<td align="center"><a href="mailto:&#98;&#x69;&#97;&#x6e;&#99;&#104;&#x65;&#x6e;&#103;&#98;&#x61;&#110;&#x67;&#x40;&#x73;&#105;&#x6e;&#x61;&#x2e;&#99;&#111;&#109;">&#98;&#x69;&#97;&#x6e;&#99;&#104;&#x65;&#x6e;&#103;&#98;&#x61;&#110;&#x67;&#x40;&#x73;&#105;&#x6e;&#x61;&#x2e;&#99;&#111;&#109;</a></td>
</tr>
</tbody></table>
<p>根据数据库<code>user</code>表，创建相应的实体类<code>User</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String userId;</span><br><span class="line">  <span class="keyword">private</span> String userName;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getUserId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserId</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userId = userId == <span class="literal">null</span> ? <span class="literal">null</span> : userId.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.userName = userName == <span class="literal">null</span> ? <span class="literal">null</span> : userName.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> password;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.password = password == <span class="literal">null</span> ? <span class="literal">null</span> : password.trim();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> email;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.email = email == <span class="literal">null</span> ? <span class="literal">null</span> : email.trim();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建-Mapper-接口"><a href="#创建-Mapper-接口" class="headerlink" title="创建 Mapper 接口"></a>创建 Mapper 接口</h1><p>在<code>net.biancheng.www.mapper</code>中创建一个<code>UserMapper</code>接口，并在该类上使用<code>@Mapper</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.mapper;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">  <span class="comment">//通过用户名密码查询用户数据</span></span><br><span class="line">  User <span class="title function_">getByUserNameAndPassword</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>mapper</code>接口较多时，可以在 Spring Boot 主启动类上使用<code>@MapperScan</code>注解扫描指定包下的<code>mapper</code>接口，而不再需要在每个<code>mapper</code>接口上都标注<code>@Mapper</code>注解。</p>
<h1 id="创建-Mapper-映射文件"><a href="#创建-Mapper-映射文件" class="headerlink" title="创建 Mapper 映射文件"></a>创建 Mapper 映射文件</h1><p>在配置文件<code>application.properties/yml</code>通过<code>mybatis.mapper-locations</code>指定的位置中创建<code>UserMapper.xml</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;net.biancheng.www.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">    id, user_id, user_name, password, email</span><br><span class="line">  <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--根据用户名密码查询用户信息--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--application.yml 中通过 type-aliases-package 指定了实体类的为了，因此--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getByUserNameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from user</span><br><span class="line">    where user_name = #&#123;userName,jdbcType=VARCHAR&#125;</span><br><span class="line">      and password = #&#123;password,jdbcType=VARCHAR&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>Mapper</code>进行开发时，需要遵循以下规则：</p>
<ul>
<li><code>mapper</code>映射文件中<code>namespace</code>必须与对应的<code>mapper</code>接口的完全限定名一致。</li>
<li><code>mapper</code>映射文件中<code>statement</code>的<code>id</code>必须与<code>mapper</code>接口中的方法的方法名一致</li>
<li><code>mapper</code>映射文件中<code>statement</code>的<code>parameterType</code>指定的类型必须与<code>mapper</code>接口中方法的参数类型一致。</li>
<li><code>mapper</code>映射文件中<code>statement</code>的<code>resultType</code>指定的类型必须与<code>mapper</code>接口中方法的返回值类型一致。</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h2><ol>
<li>创建一个名为<code>UserService</code>的接口。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.service;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.User;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getByUserNameAndPassword</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建<code>UserService</code>接口的实现类，并使用<code>@Service</code>注解将其以组件的形式添加到容器中。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.service.impl;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.User;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  UserMapper userMapper;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getByUserNameAndPassword</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userMapper.getByUserNameAndPassword(user);</span><br><span class="line">    <span class="keyword">return</span> loginUser;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改<code>LoginController</code>中的<code>doLogin()</code>方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.controller;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.User;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  UserService userService;</span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">doLogin</span><span class="params">(User user, Map&lt;String, Object&gt; map, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//从数据库中查询用户信息</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">loginUser</span> <span class="operator">=</span> userService.getByUserNameAndPassword(user);</span><br><span class="line">    <span class="keyword">if</span> (loginUser != <span class="literal">null</span>) &#123;</span><br><span class="line">      session.setAttribute(<span class="string">&quot;loginUser&quot;</span>, loginUser);</span><br><span class="line">      log.info(<span class="string">&quot;登陆成功，用户名：&quot;</span> + loginUser.getUserName());</span><br><span class="line">      <span class="comment">//防止重复提交使用重定向</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;redirect:/main.html&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">      log.error(<span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动 Spring Boot，浏览器地址栏输入<code>“http://localhost:8080/”</code>，访问 AdminEx 系统的登陆页面，分别输入用户名“user”和密码“123456”。</li>
</ol>
<h1 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h1><p>我们知道<code>mapper</code>映射文件其实就是一个 XML 配置文件，它存在 XML 配置文件的通病，即编写繁琐，容易出错。即使是一个十分简单项目，涉及的 SQL 语句也都十分简单，我们仍然需要花费一定的时间在<code>mapper</code>映射文件的配置上。</p>
<p>为了解决这个问题，MyBatis 针对实际实际业务中使用最多的“增删改查”操作，分别提供了以下注解来替换<code>mapper</code>映射文件，简化配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Select</span><br><span class="line">@Insert</span><br><span class="line">@Update</span><br><span class="line">@Delete</span><br></pre></td></tr></table></figure>
<p>通过以上注解，基本可以满足我们对数据库的增删改查操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.mapper;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">  <span class="meta">@Select(&quot;select * from user where user_name = #&#123;userName,jdbcType=VARCHAR&#125; and password = #&#123;password,jdbcType=VARCHAR&#125;&quot;)</span></span><br><span class="line">  List&lt;User&gt; <span class="title function_">getByUserNameAndPassword</span><span class="params">(User user)</span>;</span><br><span class="line">  <span class="meta">@Delete(&quot;delete from user where id = #&#123;id,jdbcType=INTEGER&#125;&quot;)</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Integer id)</span>;</span><br><span class="line">  <span class="meta">@Insert(&quot;insert into user ( user_id, user_name, password, email)&quot; +</span></span><br><span class="line"><span class="meta">      &quot;values ( #&#123;userId,jdbcType=VARCHAR&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)&quot;)</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line">  <span class="meta">@Update(&quot; update user&quot; +</span></span><br><span class="line"><span class="meta">      &quot;    set user_id = #&#123;userId,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">      &quot;      user_name = #&#123;userName,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">      &quot;      password = #&#123;password,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">      &quot;      email = #&#123;email,jdbcType=VARCHAR&#125;\n&quot; +</span></span><br><span class="line"><span class="meta">      &quot;    where id = #&#123;id,jdbcType=INTEGER&#125;&quot;)</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mapper</code>接口中的任何一个方法，都只能使用一种配置方式，即注解和<code>mapper</code>映射文件二选一，但不同方法之间，这两种方式则可以混合使用，例如方法 1 使用注解方式，方法 2 使用<code>mapper</code>映射文件方式。</p>
<p>我们可以根据 SQL 的复杂程度，选择不同的方式来提高开发效率。</p>
<ul>
<li>如果没有复杂的连接查询，我们可以使用注解的方式来简化配置；</li>
<li>如果涉及的 sql 较为复杂时，则使用 XML （<code>mapper</code>映射文件）的方式更好一些。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/Spring Boot配置绑定"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/15/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/"
    >SpringBoot 配置绑定</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/15/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/" class="article-date">
  <time datetime="2021-09-15T03:56:01.000Z" itemprop="datePublished">2021-09-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Boot/">Spring Boot</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>所谓“配置绑定”就是把配置文件中的值与<code>JavaBean</code>中对应的属性进行绑定。通常，我们会把一些配置信息（例如，数据库配置）放在配置文件中，然后通过 Java 代码去读取该配置文件，并且把配置文件中指定的配置封装到<code>JavaBean</code>（实体类） 中。</p>
<p>SpringBoot 提供了以下 2 种方式进行配置绑定：</p>
<ul>
<li>使用<code>@ConfigurationProperties</code>注解</li>
<li>使用<code>@Value</code>注解</li>
</ul>
<h1 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h1><p><code>@ConfigurationProperties</code>注解可以将全局配置文件中的配置数据绑定到<code>JavaBean</code>中。</p>
<ol>
<li>全局配置文件<code>appilcation.yml</code>中添加以下自定义属性。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">  lastName: 张三</span><br><span class="line">  age: 18</span><br><span class="line">  boss: false</span><br><span class="line">  birth: 1990/12/12</span><br><span class="line">  maps: &#123; k1: v1,k2: 12 &#125;</span><br><span class="line">  lists:</span><br><span class="line">    ‐ lisi</span><br><span class="line">    ‐ zhaoliu</span><br><span class="line">  dog:</span><br><span class="line">    name: 迪迪</span><br><span class="line">    age: 5</span><br></pre></td></tr></table></figure></li>
<li>在<code>net.biancheng.www.bean</code>中创建一个名为<code>Person</code>的实体类，并将配置文件中的属性映射到这个实体类上。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ConfigurationProperties</span>：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment">* prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 只有这个组件是容器中的组件，才能使用容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="keyword">private</span> Boolean boss;</span><br><span class="line">  <span class="keyword">private</span> Date birth;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">  <span class="keyword">private</span> Dog dog;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lastName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">getBoss</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> boss;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBoss</span><span class="params">(Boolean boss)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.boss = boss;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Date <span class="title function_">getBirth</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> birth;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirth</span><span class="params">(Date birth)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.birth = birth;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getMaps</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maps;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaps</span><span class="params">(Map&lt;String, Object&gt; maps)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.maps = maps;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">getLists</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLists</span><span class="params">(List&lt;Object&gt; lists)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lists = lists;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Dog <span class="title function_">getDog</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dog;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDog</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dog = dog;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String lastName, Integer age, Boolean boss, Date birth, Map&lt;String, Object&gt; maps, List&lt;Object&gt; lists, Dog dog)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.boss = boss;</span><br><span class="line">    <span class="built_in">this</span>.birth = birth;</span><br><span class="line">    <span class="built_in">this</span>.maps = maps;</span><br><span class="line">    <span class="built_in">this</span>.lists = lists;</span><br><span class="line">    <span class="built_in">this</span>.dog = dog;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">				<span class="string">&quot;, boss=&quot;</span> + boss +</span><br><span class="line">				<span class="string">&quot;, birth=&quot;</span> + birth +</span><br><span class="line">				<span class="string">&quot;, maps=&quot;</span> + maps +</span><br><span class="line">				<span class="string">&quot;, lists=&quot;</span> + lists +</span><br><span class="line">				<span class="string">&quot;, dog=&quot;</span> + dog +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意：</li>
</ol>
<ul>
<li>只有在容器中的组件，才会拥有 SpringBoot 提供的强大功能。如果我们想要使用<code>@ConfigurationProperties</code>注解进行配置绑定，那么首先就要保证该<code>JavaBean</code>对象在 IoC 容器中，所以需要用到<code>@Component</code>注解来添加组件到容器中。</li>
<li><code>JavaBean</code>上使用了注解<code>@ConfigurationProperties(prefix = &quot;person&quot;)</code>，它表示将这个<code>JavaBean</code>中的所有属性与配置文件中以<code>person</code>为前缀的配置进行绑定。</li>
</ul>
<ol start="3">
<li>在<code>net.biancheng.www.bean</code>中，创建一个名为<code>Dog</code>的<code>JavaBean</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改<code>HelloController</code>的代码，在浏览器中展示配置文件中各个属性值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.controller;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.bean.Person;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Person person;</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Person <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> person;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启项目，使用浏览器访问<code>http://localhost:8081/hello</code>。<img src="/2021/09/15/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/1.png" class="" title="Spring Boot 读取自定义配置"></li>
</ol>
<h1 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h1><p>当我们只需要读取配置文件中的某一个配置时，可以通过<code>@Value</code>注解获取。</p>
<ol>
<li>修改实体类<code>Person</code>中的代码，使用<code>@Value</code>注解进行配置绑定。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;person.lastName&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;person.boss&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Boolean boss;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;person.birth&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Date birth;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">	<span class="keyword">private</span> Dog dog;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// getter和setter</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启项目，使用浏览器访问<code>http://localhost:8081/hello</code>。<img src="/2021/09/15/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/2.png" class="" title="Spring Boot @Value 注解读取配置文件属性值"></li>
</ol>
<h1 id="Value-与-ConfigurationProperties-对比"><a href="#Value-与-ConfigurationProperties-对比" class="headerlink" title="@Value 与 @ConfigurationProperties 对比"></a>@Value 与 @ConfigurationProperties 对比</h1><p><code>@Value</code>和<code>@ConfigurationProperties</code>注解都能读取配置文件中的属性值并绑定到<code>JavaBean</code>中，但两者存在以下不同。</p>
<ol>
<li>使用位置不同</li>
</ol>
<ul>
<li><code>@ConfigurationProperties</code>：标注在<code>JavaBean</code>的类名上；</li>
<li><code>@Value</code>：标注在<code>JavaBean</code>的属性上。</li>
</ul>
<ol start="2">
<li>功能不同</li>
</ol>
<ul>
<li><code>@ConfigurationProperties</code>：用于批量绑定配置文件中的配置；</li>
<li><code>@Value</code>：只能一个一个的指定需要绑定的配置。</li>
</ul>
<ol start="3">
<li>松散绑定支持不同</li>
</ol>
<ul>
<li><code>@ConfigurationProperties</code>：支持松散绑定（松散语法），例如实体类<code>Person</code>中有一个属性为<code>firstName</code>，那么配置文件中的属性名支持以下写法： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.firstName</span><br><span class="line">person.first-name</span><br><span class="line">person.first_name</span><br><span class="line">PERSON_FIRST_NAME</span><br></pre></td></tr></table></figure></li>
<li><code>@Vaule</code>：不支持松散绑定。</li>
</ul>
<ol start="4">
<li>SpEL 支持不同</li>
</ol>
<ul>
<li><code>@ConfigurationProperties</code>：不支持 SpEL 表达式;</li>
<li><code>@Value</code>：支持 SpEL 表达式。</li>
</ul>
<ol start="5">
<li>复杂类型封装</li>
</ol>
<ul>
<li><code>@ConfigurationProperties</code>：支持所有类型数据的封装，例如<code>Map、List、Set</code>、以及对象等；</li>
<li><code>@Value</code>：只支持基本数据类型的封装，例如字符串、布尔值、整数等类型。</li>
</ul>
<ol start="6">
<li>应用场景不同<br><code>@Value</code>和<code>@ConfigurationProperties</code>两个注解之间，并没有明显的优劣之分，它们只是适合的应用场景不同而已。</li>
</ol>
<ul>
<li>若只是获取配置文件中的某项值，则推荐使用<code>@Value</code>注解；</li>
<li>若专门编写了一个 JavaBean 来和配置文件进行映射，则建议使用 @ConfigurationProperties 注解。</li>
</ul>
<p>我们在选用时，根据实际应用场景选择合适的注解能达到事半功倍的效果。</p>
<h1 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h1><p>如果将所有的配置都集中到<code>application.properties</code>或<code>application.yml</code>中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 Spring Boot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的<code>JavaBean</code>上使用<code>@PropertySource</code>注解指向该配置文件。</p>
<ol>
<li>以<code>helloworld</code>为例，将与<code>person</code>相关的自定义配置移动到<code>src/main/resources</code>下的<code>person.properties</code>中。<br><code>person.properties</code>的配置如下。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">person.last-name=李四</span><br><span class="line">person.age=12</span><br><span class="line">person.birth=2000/12/15</span><br><span class="line">person.boss=false</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=14</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=dog</span><br><span class="line">person.dog.age=2</span><br></pre></td></tr></table></figure></li>
<li>在<code>Person</code>使用<code>@PropertySource</code>注解指向<code>person.properties</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:person.properties&quot;)</span><span class="comment">//指向对应的配置文件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="keyword">private</span> Boolean boss;</span><br><span class="line">	<span class="keyword">private</span> Date birth;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; maps;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">	<span class="keyword">private</span> Dog dog;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// getter和setter</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启项目，使用浏览器访问<code>http://localhost:8081/hello</code>。<img src="/2021/09/15/java/SpringBoot/Spring%20Boot%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A/3.png" class="" title="Spring Boot 将 person.properties 的属性注入"></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/SpringBoot数据库配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/"
    >SpringBoot 数据库配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2021-09-12T08:56:01.000Z" itemprop="datePublished">2021-09-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Boot/">Spring Boot</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JDBC访问数据库"><a href="#JDBC访问数据库" class="headerlink" title="JDBC访问数据库"></a>JDBC访问数据库</h1><p>对于数据访问层，无论是 SQL 还是 NOSQL，Spring Boot 都默认采用整合 Spring Data 的方式进行统一处理，通过大量自动配置，来简化对数据访问层的操作，我们只需要进行简单的设置即可实现对数据库层的访问。</p>
<h2 id="导入-JDBC-场景启动器"><a href="#导入-JDBC-场景启动器" class="headerlink" title="导入 JDBC 场景启动器"></a>导入 JDBC 场景启动器</h2><p>Spring Boot 将日常企业应用研发中的各种场景都抽取出来，做成一个个的场景启动器（<code>Starter</code>），场景启动器中整合了该场景下各种可能用到的依赖，让用户摆脱了处理各种依赖和配置的困扰。</p>
<p>想要在 Spring Boot 中使用 JDBC 进行数据访问，第一步就是要在<code>pom.xml</code>中导入 JDBC 场景启动器：<code>spring-boot-starter-data-jdbc</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入JDBC的场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查看<code>spring-boot-starter-data-jdbc</code>的依赖树，可以看到，该场景启动器默认引入了一个数据源：<code>HikariCP</code>。</p>
<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/1.png" class="" title="JDBC 默认数据源">

<h2 id="导入数据库驱动"><a href="#导入数据库驱动" class="headerlink" title="导入数据库驱动"></a>导入数据库驱动</h2><p>JDBC 的场景启动器中并没有导入数据库驱动，我们需要根据自身的需求引入所需的数据库驱动。例如，访问 MySQL 数据库时，需要导入 MySQL 的数据库驱动：<code>mysql-connector-java</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入数据库驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot 默认为数据库驱动程序做了版本仲裁，所以我们在导入数据库驱动时，可以不再声明版本。需要注意的是，数据库驱动的版本必须与数据库的版本相对应。</p>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>在导入了 JDBC 场景启动器和数据库驱动后，接下来我们就可以在配置文件（<code>application.properties/yml</code>）中配置数据源了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#数据源连接信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Spring Boot 提供了一个名为<code>JdbcTemplate</code>的轻量级数据访问工具，它是对 JDBC 的封装。Spring Boot 对<code>JdbcTemplate</code>提供了默认自动配置，我们可以直接使用<code>@Autowired</code>或构造函数将它注入到<code>bean</code>中使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootJdbcApplicationTests</span> &#123;</span><br><span class="line">  <span class="comment">//数据源组件</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DataSource dataSource;</span><br><span class="line">  <span class="comment">//用于访问数据库的组件</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  JdbcTemplate jdbcTemplate;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;默认数据源为：&quot;</span> + dataSource.getClass());</span><br><span class="line">    System.out.println(<span class="string">&quot;数据库连接实例：&quot;</span> + dataSource.getConnection());</span><br><span class="line">    <span class="comment">//访问数据库</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT count(*) from `user`&quot;</span>, Integer.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user 表中共有&quot;</span> + i + <span class="string">&quot;条数据。&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认数据源为：class com.zaxxer.hikari.HikariDataSource</span><br><span class="line">数据库连接实例：HikariProxyConnection@659763564 wrapping com.mysql.cj.jdbc.ConnectionImpl@59edb4f5</span><br><span class="line">user 表中共有1条数据。</span><br></pre></td></tr></table></figure>
<p>通过以上运行结果可以看出，Spring Boot 默认使用<code>HikariCP</code>作为其数据源，对数据库的访问。</p>
<h1 id="数据源配置原理"><a href="#数据源配置原理" class="headerlink" title="数据源配置原理"></a>数据源配置原理</h1><p>在数据库访问过程中，“数据源”不仅可以对与数据库访问相关的各种参数进行封装和统一管理，还可以管理数据库连接池，提高数据库连接性能。</p>
<p>在市面上有很多优秀的开源数据源，例如 DBCP、C3P0、Druid、HikariCP 等等。在 Spring Boot 2.x 中，采用目前性能最佳的 HikariCP 作为其默认数据源。</p>
<h2 id="DataSourceAutoConfiguration"><a href="#DataSourceAutoConfiguration" class="headerlink" title="DataSourceAutoConfiguration"></a>DataSourceAutoConfiguration</h2><p>Spring Boot 中几乎所有的默认配置都是通过配置类<code>XxxAutoConfiguration</code>进行配置的，Spring Boot 数据源也不例外，它的自动配置类是：<code>DataSourceAutoConfiguration</code>。</p>
<p><code>DataSourceAutoConfiguration</code>中共包括以下 5 个内部静态类：</p>
<ul>
<li><code>EmbeddedDatabaseCondition</code></li>
<li><code>PooledDataSourceAvailableCondition</code></li>
<li><code>PooledDataSourceCondition</code></li>
<li><code>PooledDataSourceConfiguration</code>（池化数据源自动配置类）</li>
<li><code>EmbeddedDatabaseConfiguration</code>（内嵌数据源自动配置类）</li>
</ul>
<p>其中，<code>PooledDataSourceConfiguration</code>和<code>EmbeddedDatabaseConfiguration</code>为使用了<code>@Configuration</code>注解的自动配置类，其余 3 个为限制条件类。</p>
<h3 id="EmbeddedDatabaseConfiguration"><a href="#EmbeddedDatabaseConfiguration" class="headerlink" title="EmbeddedDatabaseConfiguration"></a>EmbeddedDatabaseConfiguration</h3><p><code>EmbeddedDatabaseConfiguration</code>是内嵌数据源的自动配置类，该类中并没有任何的方法实现，它的主要功能都是通过<code>@Import</code>注解引入<code>EmbeddedDataSourceConfiguration</code>类来实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123;EmbeddedDataSourceConfiguration.class&#125;)</span><br></pre></td></tr></table></figure>
<p><code>EmbeddedDataSourceConfiguration</code>向容器中添加了一个 Spring Boot 内嵌的数据源，该数据源支持 HSQL，H2 和 DERBY 三种数据库，其部分代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;DataSourceProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmbeddedDataSourceConfiguration</span> <span class="keyword">implements</span> <span class="title class_">BeanClassLoaderAware</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">EmbeddedDataSourceConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.classLoader = classLoader;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向容器中添加 Spring Boot 内嵌的数据源</span></span><br><span class="line">  <span class="meta">@Bean(</span></span><br><span class="line"><span class="meta">    destroyMethod = &quot;shutdown&quot;</span></span><br><span class="line"><span class="meta">  )</span></span><br><span class="line">  <span class="keyword">public</span> EmbeddedDatabase <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()).setType(EmbeddedDatabaseConnection.get(<span class="built_in">this</span>.classLoader).getType()).setName(properties.determineDatabaseName()).build();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的分析，我们知道自动配置类<code>EmbeddedDatabaseConfiguration</code>的作用是向容器中添加一个内嵌的数据源（<code>DataSource</code>），但这是有条件限制的。</p>
<p>在<code>EmbeddedDatabaseConfiguration</code>类上还使用一个<code>@Conditional</code>注解，该注解使用了<code>DataSourceAutoConfiguration</code>的内部限制条件类<code>EmbeddedDatabaseCondition</code>来进行条件判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Conditional(&#123;DataSourceAutoConfiguration.EmbeddedDatabaseCondition.class&#125;)</span><br></pre></td></tr></table></figure>
<p><code>EmbeddedDatabaseCondition</code>主要用来检测容器中是否已经存在池化数据源（<code>PooledDataSource</code>）。若容器中存在池化数据源时，则<code>EmbeddedDatabaseConfiguration</code>不能被实例化。只有当容器中不存在池化数据源时，<code>EmbeddedDatabaseConfiguration</code>才能被实例化，才能向容器中添加内嵌数据源（<code>EmbeddedDataSource</code>）。</p>
<h3 id="PooledDataSourceConfiguration"><a href="#PooledDataSourceConfiguration" class="headerlink" title="PooledDataSourceConfiguration"></a>PooledDataSourceConfiguration</h3><p><code>PooledDataSourceConfiguration</code>是池化数据源的自动配置类，该类上使用了一个<code>@Conditional</code>注解，该注解使用了<code>DataSourceAutoConfiguration</code>的内部限制条件类<code>PooledDataSourceCondition</code>来进行条件判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Conditional(&#123;DataSourceAutoConfiguration.PooledDataSourceCondition.class&#125;)</span><br></pre></td></tr></table></figure>
<p><code>PooledDataSourceCondition</code>与<code>EmbeddedDatabaseCondition</code>一样，也是用来检测容器中是否已经存在池化数据源的，但不同的是，<code>PooledDataSourceConfiguration</code>是只有当容器中存在池化数据源时，才可以被实例化，才可以向容器中添加池化数据源。</p>
<p>与<code>EmbeddedDatabaseConfiguration</code>一样，<code>PooledDataSourceConfiguration</code>类中也没有任何的方法实现，它的所有功能都是通过<code>@Import</code>注解引入其他的类实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Import(&#123;Hikari.class, Tomcat.class, Dbcp2.class, OracleUcp.class, Generic.class, DataSourceJmxConfiguration.class&#125;)</span><br></pre></td></tr></table></figure>
<p><code>PooledDataSourceConfiguration</code>通过<code>@Import</code>注解引入了 Hikari、Tomcat、Dbcp2、OracleUcp 和 Generic 五个数据源配置类，它们都是<code>DataSourceConfiguration</code>的内部类，且它们的功能类似，都是向容器中添加指定的数据源。</p>
<p>下面我们以<code>Hikari</code>为例进行分析，<code>Hikari</code>的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;HikariDataSource.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;DataSource.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">  name = &#123;&quot;spring.datasource.type&quot;&#125;,</span></span><br><span class="line"><span class="meta">  havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,</span></span><br><span class="line"><span class="meta">  matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Hikari</span> &#123;</span><br><span class="line">  Hikari() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.datasource.hikari&quot;</span></span><br><span class="line"><span class="meta">  )</span></span><br><span class="line">  HikariDataSource <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">    <span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">      dataSource.setPoolName(properties.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Hikari</code>类中，主要使用以下注解：</p>
<ul>
<li><code>@Configuration</code>：表示当前类是一个配置类；</li>
<li><code>@ConditionalOnMissingBean(&#123;DataSource.class&#125;)</code>：表示容器中没有用户自定义的数据源时，该配置类才会被实例化；</li>
<li><code>@ConditionalOnClass(&#123;HikariDataSource.class&#125;)</code>：表示必须在类路径中存在<code>HikariDataSource</code>类时，<code>Hikari</code>才会实例化。而<code>HikariDataSource</code>类是由<code>spring- boot-starter-jdbc</code>默认将其引入的，因此只要我们在<code>pom.xml</code>中引入了该<code>starter</code>，<code>Hikari</code>就会被实例化（这也是 Spring Boot 2.x 默认使用 HikariCP 作为其数据源的原因）。；</li>
<li><code>@ConditionalOnProperty( name = &#123;&quot;spring.datasource.type&quot;&#125;,havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,matchIfMissing = true)</code>： 表示当 Spring Boot 配置文件中，配置了 <code>spring.datasource.type = com.zaxxer.hikari.HikariDataSource</code>（明确指定使用<code>Hikari</code>数据源）或者不配置<code>spring.datasource.type</code>（即默认情况）时，<code>Hikari</code>才会被实例化。</li>
</ul>
<p><code>Hikari</code>类通过<code>@Bean</code>注解向容器中添加了<code>HikariDataSource</code>组件，该组件的实例对象是通过调用<code>DataSourceConfiguration</code>的<code>createDataSource()</code>方法得到的，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(</span></span><br><span class="line"><span class="meta">  prefix = &quot;spring.datasource.hikari&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">HikariDataSource <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">  <span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (HikariDataSource)DataSourceConfiguration.createDataSource(properties, HikariDataSource.class);</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">    dataSource.setPoolName(properties.getName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>createDataSource()</code>方法中，调用<code>DataSourceProperties</code>的<code>initializeDataSourceBuilder()</code>来初始化<code>DataSourceBuilder</code>，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">createDataSource</span><span class="params">(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> properties.initializeDataSourceBuilder().type(type).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initializeDataSourceBuilder()</code>方法通过调用<code>DataSourceBuilder</code>的<code>create()</code>方法创建<code>DataSourceBuilder</code>对象，并根据 Spring Boot 的配置文件（<code>application.properties/yml</code>）中的配置，依次设置数据源类型、驱动类名、连接<code>url</code>、用户名和密码等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DataSourceBuilder&lt;?&gt; initializeDataSourceBuilder() &#123;</span><br><span class="line">  <span class="keyword">return</span> DataSourceBuilder.create(<span class="built_in">this</span>.getClassLoader()).type(<span class="built_in">this</span>.getType()).</span><br><span class="line">      driverClassName(<span class="built_in">this</span>.determineDriverClassName()).url(<span class="built_in">this</span>.determineUrl()).username(<span class="built_in">this</span>.determineUsername()).password(<span class="built_in">this</span>.determinePassword());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到<code>spring.datasource.type</code>默认是可以不用配置的，因此在<code>createDataSource()</code>方法在获取到回传回来的<code>DataSourceBuilder</code>对象后，还需要将其<code>type</code>属性再次设置为<code>HikariDataSource</code>，并调用<code>DataSourceBuilder</code>的<code>build()</code>方法，完成<code>HikariDataSource</code>的初始化。</p>
<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/2.png" class="" title="初始化 HikariDataSource">

<p><code>dataSource()</code>方法获得数据源对象，并设置了连接池的名字（<code>name</code>），注入到容器中。</p>
<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/3.png" class="" title="设置连接池 name">

<p>自此，我们就完成了对 Spring Boot 数据源自动配置原理的分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对 Spring Boot 数据源自动配置原理的分析可知：</p>
<ul>
<li>在用户没有配置数据源的情况，若容器中存在<code>HikariDataSource</code>类，则 Spring Boot 就会自动实例化<code>Hikari</code>，并将其作为其数据源。</li>
<li>Spring Boot 的 JDBC 场景启动器（<code>spring-boot-starter-data-jdbc</code>）通过<code>spring- boot-starter-jdbc</code>默认引入了 HikariCP 数据源（包含<code>HikariDataSource</code>类），因此 Spring Boot 默认使用 HikariCP 作为其数据源。</li>
</ul>
<h1 id="整合Druid数据源"><a href="#整合Druid数据源" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h1><p>Spring Boot 2.x 默认使用 HikariCP 作为数据源，我们只要在项目中导入了 Spring Boot 的 JDBC 场景启动器，便可以使用 HikariCP 数据源获取数据库连接，对数据库进行增删改查等操作。</p>
<p>HikariCP 是目前市面上性能最好的数据源产品，但在实际的开发过程中，企业往往更青睐于另一款数据源产品：Druid，它是目前国内使用范围最广的数据源产品。</p>
<p>Druid 是阿里巴巴推出的一款开源的高性能数据源产品，Druid 支持所有 JDBC 兼容的数据库，包括 Oracle、MySQL、SQL Server 和 H2 等等。Druid 不仅结合了 C3P0、DBCP 和 PROXOOL 等数据源产品的优点，同时还加入了强大的监控功能。通过 Druid 的监控功能，可以实时观察数据库连接池和 SQL 的运行情况，帮助用户及时排查出系统中存在的问题。</p>
<p>Druid 不是 Spring Boot 内部提供的技术，它属于第三方技术，我们可以通过以下两种方式进行整合：</p>
<ul>
<li>自定义整合 Druid </li>
<li>通过<code>starter</code>整合 Druid</li>
</ul>
<h2 id="自定义整合-Druid"><a href="#自定义整合-Druid" class="headerlink" title="自定义整合 Druid"></a>自定义整合 Druid</h2><p>自定义整合 Druid 是指：根据 Druid 官方文档和自身的需求，通过手动创建 Druid 数据源的方式，将 Druid 整合到 Spring Boot 中。</p>
<h3 id="1-引入-Druid-依赖"><a href="#1-引入-Druid-依赖" class="headerlink" title="1. 引入 Druid 依赖"></a>1. 引入 Druid 依赖</h3><p>在项目的<code>pom.xml</code>中引入 Druid 的依赖，即可将 Druid 导入到项目中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入 JDBC 场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入数据库驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--采用自定义方式整合 druid 数据源--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义整合需要编写一个与之相关的配置类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-创建数据源"><a href="#2-创建数据源" class="headerlink" title="2. 创建数据源"></a>2. 创建数据源</h3><p>Spring Boot 使用 HikariCP 作为其默认数据源，但其中有一个十分重要的条件，如下图。</p>
<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/4.png" class="" title="Hikari 数据源生效条件">

<p><code>@ConditionalOnMissingBean(DataSource.class)</code>的含义是：当容器中没有<code>DataSource</code>（数据源类）时，Spring Boot 才会使用 HikariCP 作为其默认数据源。 也就是说，若我们向容器中添加 Druid 数据源类（<code>DruidDataSource</code>，继承自<code>DataSource</code>）的对象时，Spring Boot 就会使用 Druid 作为其数据源，而不再使用 HikariCP。</p>
<p>例如，在<code>net.biancheng.www.config</code>包中，创建一个名为<code>MyDataSourceConfig</code>的配置类，并将 Druid 数据源对象添加到容器中，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.config;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当向容器中添加了 Druid 数据源</span></span><br><span class="line"><span class="comment">   * 使用 <span class="doctag">@ConfigurationProperties</span> 将配置文件中 spring.datasource 开头的配置与数据源中的属性进行绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="comment">//我们一般不建议将数据源属性硬编码到代码中，而应该在配置文件中进行配置（@ConfigurationProperties 绑定）</span></span><br><span class="line"><span class="comment">//        druidDataSource.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc&quot;);</span></span><br><span class="line"><span class="comment">//        druidDataSource.setUsername(&quot;root&quot;);</span></span><br><span class="line"><span class="comment">//        druidDataSource.setPassword(&quot;root&quot;);</span></span><br><span class="line"><span class="comment">//        druidDataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置文件<code>application.yml</code>中添加以下数据源配置，它们会与 Druid 数据源中的属性进行绑定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#数据源连接信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：配置类创建 Druid 数据源对象时，应该尽量避免将数据源信息（例如 url、username 和 password 等）硬编码到代码中，而应该通过 @ConfigurationProperties(“spring.datasource”) 注解，将 Druid 数据源对象的属性与配置文件中的以“spring.datasource”开头的配置进行绑定。</p>
</blockquote>
<p>至此，我们就已经将数据源从 HikariCP 切换到了 Druid 了。</p>
<p>接下来，我们可以使用 Spring Boot 提供的默认测试类<code>SpringBootAdminexApplicationTests</code>进行简单的测试，来验证数据源类型是否为 Druid 以及是否能正常获取数据库连接、访问数据库，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringBootAdminexApplicationTests</span> &#123;</span><br><span class="line">  <span class="comment">//数据源组件</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DataSource dataSource;</span><br><span class="line">  <span class="comment">//用于访问数据库的组件</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  JdbcTemplate jdbcTemplate;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;默认数据源为：&quot;</span> + dataSource.getClass());</span><br><span class="line">    System.out.println(<span class="string">&quot;数据库连接实例：&quot;</span> + dataSource.getConnection());</span><br><span class="line">    <span class="comment">//访问数据库</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT count(*) from `user`&quot;</span>, Integer.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user 表中共有&quot;</span> + i + <span class="string">&quot;条数据。&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试程序，结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认数据源为：class com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">数据库连接实例：com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@46e190ed</span><br><span class="line">user 表中共有2条数据。</span><br></pre></td></tr></table></figure>
<p>根据以上运行结果可以看出，数据源已经成功地切换到了 Druid 数据源，且通过它也可以正常的获取数据库连接，访问数据库。</p>
<h3 id="3-开启-Druid-内置监控页面"><a href="#3-开启-Druid-内置监控页面" class="headerlink" title="3. 开启 Druid 内置监控页面"></a>3. 开启 Druid 内置监控页面</h3><p>Druid 内置提供了一个名为<code>StatViewServlet</code>的<code>Servlet</code>，这个<code>Servlet</code>可以开启 Druid 的内置监控页面功能， 展示 Druid 的统计信息，它的主要用途如下：</p>
<ul>
<li>提供监控信息展示的 html 页面</li>
<li>提供监控信息的 JSON API</li>
</ul>
<p><code>StatViewServlet</code>是一个标准的<code>javax.servlet.http.HttpServlet</code>，想要开启 Druid 的内置监控页面，需要将该 Servlet 配置在 Web 应用中的<code>WEB-INF/web.xml</code>中，<code>web.xml</code>中配置如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/druid/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们知道，Spring Boot 项目中是没有<code>WEB-INF/web.xml</code>的，因此我们可以在配置类中，通过<code>ServletRegistrationBean</code>将<code>StatViewServlet</code>注册到容器中，来开启 Druid 的内置监控页面。</p>
<ol>
<li>在 MyDataSourceConfig 配置类中添加以下代码，将 StatViewServlet 注入到容器中，开启 Druid 内置监控页面功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 开启 Druid 数据源内置监控页面</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ServletRegistrationBean <span class="title function_">statViewServlet</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">StatViewServlet</span> <span class="variable">statViewServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatViewServlet</span>();</span><br><span class="line">  <span class="comment">//向容器中注入 StatViewServlet，并将其路径映射设置为 /druid/*</span></span><br><span class="line">  <span class="type">ServletRegistrationBean</span> <span class="variable">servletRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(statViewServlet, <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">  <span class="comment">//配置监控页面访问的账号和密码（选配）</span></span><br><span class="line">  servletRegistrationBean.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">  servletRegistrationBean.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> servletRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>启动 Spring Boot，浏览器访问<code>http://localhost:8080/druid</code>，即可访问 Druid 的内置监控页面的登陆页。</li>
<li>在登陆页输入框内，分别输入我们自定义的用户名和密码，点击<code>Sign in</code>按钮访问监控页面。</li>
</ol>
<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/5.png" class="" title="Druid 内置监控页面首页">

<h3 id="4-开启-SQL-监控"><a href="#4-开启-SQL-监控" class="headerlink" title="4. 开启 SQL 监控"></a>4. 开启 SQL 监控</h3><p>Druid 内置提供了一个<code>StatFilter</code>，通过它可以开启 Druid 的 SQL 监控功能，对 SQL 进行监控。</p>
<p><code>StatFilter</code>的别名是<code>stat</code>，这个别名的映射配置信息保存在<code>druid-xxx.jar!/META-INF/druid-filter.properties</code>中。在 Spring 中配置该别名（<code>stat</code>）开启 Druid SQL 监控的方式，配置如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">... ...</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;stat&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据以上配置我们可以看出，只要在<code>dataSource</code>的<code>Bean</code>中添加一个取值为<code>stat</code>的<code>filters</code>属性，就能开启 Druid SQL 监控，因此我们只要将该配置转换为在配置类中进行即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">  <span class="comment">//设置 filters 属性值为 stat，开启 SQL 监控</span></span><br><span class="line">  druidDataSource.setFilters(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> druidDataSource; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>为了验证 Druid SQL 监控是否开启，我们需要在<code>IndexController</code>中添加一个能够查询数据库的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line">  <span class="comment">//自动装配 jdbcTemplate</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  JdbcTemplate jdbcTemplate;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 访问&quot;/testSql&quot;,访问数据库</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/testSql&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">testSql</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;SELECT count(*) from `user`&quot;</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> jdbcTemplate.queryForObject(SQL, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> integer.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启 Spring Boot，浏览器访问<code>http://localhost:8080/testSql</code>。</li>
<li>访问 Druid 的内置监控页面，切换到 SQL 监控模块，可以看到 Druid SQL 监控已经开启，如下图。<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/6.png" class="" title="Druid SQL 监控"></li>
</ol>
<h3 id="5-开启防火墙"><a href="#5-开启防火墙" class="headerlink" title="5. 开启防火墙"></a>5. 开启防火墙</h3><p>Druid 内置提供了一个<code>WallFilter</code>，使用它可以开启防火墙功能，防御 SQL 注入攻击。</p>
<p><code>WallFilter</code>的别名是<code>wall</code>，这个别名映射配置信息保存在<code>druid-xxx.jar!/META-INF/druid-filter.properties</code>中。在 Spring 中使用该别名（<code>wall</code>）开启防火墙的方式，配置如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">... ...</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wall&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>WallFilter</code>可以结合其他<code>Filter</code>一起使用，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filters&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wall,stat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据以上配置我们可以看出，只要在<code>dataSource</code>的<code>Bean</code>中添加一个取值为<code>wall</code>的<code>filters</code>属性，就能开启 Druid 的防火墙功能，因此我们只需要在配置类中为<code>dataSource</code>的<code>filters</code>属性再添加一个<code>wall</code>即可（多个属性值之间使用逗号“，”隔开）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">  <span class="comment">//同时开启 sql 监控(stat) 和防火墙(wall)，中间用逗号隔开。</span></span><br><span class="line">  <span class="comment">//开启防火墙能够防御 SQL 注入攻击</span></span><br><span class="line">  druidDataSource.setFilters(<span class="string">&quot;stat,wall&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> druidDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>重启 Spring Boot，浏览器访问<code>http://localhost:8080/testSql</code>。</li>
<li>访问 Druid 的内置监控页面，切换到 SQL 防火墙，可以看到 Druid 防火墙已经开启，如下图。<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/7.png" class="" title="Druid 防火墙"></li>
</ol>
<h3 id="6-开启-Web-JDBC-关联监控"><a href="#6-开启-Web-JDBC-关联监控" class="headerlink" title="6. 开启 Web-JDBC 关联监控"></a>6. 开启 Web-JDBC 关联监控</h3><p>Druid 还内置提供了一个名为<code>WebStatFilter</code>的过滤器，它可以用来监控与采集<code>web-jdbc</code>关联监控的数据。</p>
<p>想要开启 Druid 的 Web-JDBC 关联监控，只需要将<code>WebStatFilter</code>配置在 Web 应用中的<code>WEB-INF/web.xml</code>中即可，<code>web.xml</code>配置如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.alibaba.druid.support.http.WebStatFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>exclusions<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot 项目中是没有<code>WEB-INF/web.xml</code>的，但是我们可以在配置类中，通过<code>FilterRegistrationBean</code>将<code>WebStatFilter</code>注入到容器中，来开启 Druid 的 Web-JDBC 关联监控。</p>
<p>配置类中示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 向容器中添加 WebStatFilter</span></span><br><span class="line"><span class="comment">* 开启内置监控中的 Web-jdbc 关联监控的数据</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FilterRegistrationBean <span class="title function_">druidWebStatFilter</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">WebStatFilter</span> <span class="variable">webStatFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebStatFilter</span>();</span><br><span class="line">  <span class="type">FilterRegistrationBean</span> <span class="variable">filterRegistrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>(webStatFilter);</span><br><span class="line">  <span class="comment">// 监控所有的访问</span></span><br><span class="line">  filterRegistrationBean.setUrlPatterns(Arrays.asList(<span class="string">&quot;/*&quot;</span>));</span><br><span class="line">  <span class="comment">// 监控访问不包括以下路径</span></span><br><span class="line">  filterRegistrationBean.addInitParameter(<span class="string">&quot;exclusions&quot;</span>, <span class="string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>重启 Spring Boot，浏览器访问<code>http://localhost:8080/testSql</code>。</li>
<li>浏览器访问 AdminEx 系统的任意页面，然后再访问 Druid 的内置监控页面，切换到 Web 应用模块，可以看到 Druid 的 Web 监控已经开启，如下图。<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/8.png" class="" title="Druid Web 应用模块">
与此同时，<code>URI</code>监控和<code>Session</code>监控也都被开启，如下图。<img src="/2021/09/12/java/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE/9.png" class="" title="Druid URI 监控"></li>
</ol>
<h2 id="通过-starter-整合-Druid"><a href="#通过-starter-整合-Druid" class="headerlink" title="通过 starter 整合 Druid"></a>通过 starter 整合 Druid</h2><p>Druid 可以说是国内使用最广泛的数据源连接池产品，但到目前为止 Spring Boot 官方只对 Hikari、Tomcat、Dbcp2 和 OracleUcp 等 4 种数据源产品提供了自动配置支持，对于其他的数据源连接池产品（包括 Druid），则并没有提供自动配置支持。这就导致用户只能通过自定义的方式（第一种整合方式）整合 Druid，非常繁琐。</p>
<p>为了解决这一问题，阿里官方提供了<code>Druid Spring Boot Starter</code>，它可以帮助我们在 Spring Boot 项目中，轻松地整合 Druid 的数据库连接池和监控功能。</p>
<p>使用<code>Druid Spring Boot Starter</code>将 Druid 与 Spring Boot 整合，步骤如下。</p>
<ol>
<li>引入<code>Druid Spring Boot Starter</code>依赖<br>在 Spring Boot 项目的 pom.xml 中添加以下依赖，引入 Druid Spring Boot Starter。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加 druid 的 starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置属性<br><code>Druid Spring Boot Starter</code>已经将 Druid 数据源中的所有模块都进行默认配置，我们也可以通过 Spring Boot 配置文件（<code>application.properties/yml</code>）来修改 Druid 各个模块的配置，否则将使用默认配置。</li>
</ol>
<p>在 Spring Boot 配置文件中配置以下内容：</p>
<ul>
<li>JDBC 通用配置</li>
<li>Druid 数据源连接池配置</li>
<li>Druid 监控配置</li>
<li>Druid 内置<code>Filter</code>配置</li>
</ul>
<p>这些配置内容既可以在<code>application.properties</code>中进行配置，也可以在<code>application.yml</code>中配置，当配置内容较多时，推荐使用<code>application.yml</code>。</p>
<h3 id="JDBC-通用配置"><a href="#JDBC-通用配置" class="headerlink" title="JDBC 通用配置"></a>JDBC 通用配置</h3><p>我们可以在 Spring Boot 的配置文件中对 JDBC 进行通用配置，例如，数据库用户名、数据库密码、数据库 URL 以及 数据库驱动等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ################################################## JDBC 通用配置  ##########################################</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root                                                                   #数据库登陆用户名</span><br><span class="line">    password: root                                                                   #数据库登陆密码</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc                              #数据库url</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver                                      #数据库驱动</span><br></pre></td></tr></table></figure>
<h3 id="Druid-数据源连接池配置"><a href="#Druid-数据源连接池配置" class="headerlink" title="Druid 数据源连接池配置"></a>Druid 数据源连接池配置</h3><p>我们还可以在 Spring Boot 的配置文件中对 Druid 数据源连接池进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  ################################################## Druid连接池的配置 ##########################################</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      initial-size: 5                                                                 #初始化连接大小</span><br><span class="line">      min-idle: 5                                                                     #最小连接池数量</span><br><span class="line">      max-active: 20                                                                  #最大连接池数量</span><br><span class="line">      max-wait: 60000                                                                 #获取连接时最大等待时间，单位毫秒</span><br><span class="line">      time-between-eviction-runs-millis: 60000                                        #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">      min-evictable-idle-time-millis: 300000                                          #配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">      validation-query: SELECT 1 FROM DUAL                                            #测试连接</span><br><span class="line">      test-while-idle: true                                                           #申请连接的时候检测，建议配置为true，不影响性能，并且保证安全性</span><br><span class="line">      test-on-borrow: false                                                           #获取连接时执行检测，建议关闭，影响性能</span><br><span class="line">      test-on-return: false                                                           #归还连接时执行检测，建议关闭，影响性能</span><br><span class="line">      pool-prepared-statements: false                                                 #是否开启PSCache，PSCache对支持游标的数据库性能提升巨大，oracle建议开启，mysql下建议关闭</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20                             #开启poolPreparedStatements后生效</span><br><span class="line">      filters: stat,wall                                                              #配置扩展插件，常用的插件有=&gt;stat:监控统计  wall:防御sql注入</span><br><span class="line">      connection-properties: &#x27;druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000&#x27; #通过connectProperties属性来打开mergeSql功能;慢SQL记录</span><br></pre></td></tr></table></figure>
<h3 id="Druid-监控配置"><a href="#Druid-监控配置" class="headerlink" title="Druid 监控配置"></a>Druid 监控配置</h3><p>我们还可以在 Spring Boot 的配置文件中对 Druid 内置监控页面、Web-JDBC 关联监控和 Spring 监控等功能进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  ###################################################### Druid 监控配置信息  ##########################################</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      # StatViewServlet配置，说明请参考Druid Wiki，配置_StatViewServlet配置</span><br><span class="line">      stat-view-servlet:</span><br><span class="line">        enabled: true                                                                 #是否开启内置监控页面，默认值为 false</span><br><span class="line">        url-pattern: &#x27;/druid/*&#x27;                                                       #StatViewServlet 的映射路径，即内置监控页面的访问地址</span><br><span class="line">        reset-enable: true                                                            #是否启用重置按钮</span><br><span class="line">        login-username: admin                                                         #内置监控页面的登录页用户名 username</span><br><span class="line">        login-password: admin                                                         #内置监控页面的登录页密码 password</span><br><span class="line">      # WebStatFilter配置，说明请参考Druid Wiki，配置_配置WebStatFilter</span><br><span class="line">      web-stat-filter:</span><br><span class="line">        enabled: true                                                                 #是否开启内置监控中的 Web-jdbc 关联监控的数据</span><br><span class="line">        url-pattern: &#x27;/*&#x27;                                                             #匹配路径</span><br><span class="line">        exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;                     #排除路径</span><br><span class="line">        session-stat-enable: true                                                     #是否监控session</span><br><span class="line">      # Spring监控配置，说明请参考Druid Github Wiki，配置_Druid和Spring关联监控配置</span><br><span class="line">      aop-patterns: net.biancheng.www.*                                               #Spring监控AOP切入点，如x.y.z.abc.*,配置多个英文逗号分隔</span><br></pre></td></tr></table></figure>
<h3 id="Druid-内置-Filter-配置"><a href="#Druid-内置-Filter-配置" class="headerlink" title="Druid 内置 Filter 配置"></a>Druid 内置 Filter 配置</h3><p><code>Druid Spring Boot Starter</code>对以下 Druid 内置<code>Filter</code>，都提供了默认配置：</p>
<ul>
<li><code>StatFilter</code></li>
<li><code>WallFilter</code></li>
<li><code>ConfigFilter</code></li>
<li><code>EncodingConvertFilter</code></li>
<li><code>Slf4jLogFilter</code></li>
<li><code>Log4jFilter</code></li>
<li><code>Log4j2Filter</code></li>
<li><code>CommonsLogFilter</code></li>
</ul>
<p>我们可以通过<code>spring.datasource.druid.filters=stat,wall ...</code>的方式来启用相应的内置<code>Filter</code>，不过这些<code>Filter</code>使用的都是默认配置。如果默认配置不能满足我们的需求，我们还可以在配置文件使用<code>spring.datasource.druid.filter.*</code>对这些<code>Filter</code>进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#  ####################################################### Druid 监控配置信息  ##########################################</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">     # 对配置已开启的 filters 即 stat(sql 监控)  wall（防火墙）</span><br><span class="line">      filter:</span><br><span class="line">        #配置StatFilter (SQL监控配置)</span><br><span class="line">        stat:</span><br><span class="line">          enabled: true                                                               #开启 SQL 监控</span><br><span class="line">          slow-sql-millis: 1000                                                       #慢查询</span><br><span class="line">          log-slow-sql: true                                                          #记录慢查询 SQL</span><br><span class="line">        #配置WallFilter (防火墙配置)</span><br><span class="line">        wall:</span><br><span class="line">          enabled: true                                                               #开启防火墙</span><br><span class="line">          config:</span><br><span class="line">            update-allow: true                                                        #允许更新操作</span><br><span class="line">            drop-table-allow: false                                                   #禁止删表操作</span><br><span class="line">            insert-allow:  true                                                       #允许插入操作</span><br><span class="line">            delete-allow: true                                                        #删除数据操作</span><br></pre></td></tr></table></figure>
<p>在配置 Druid 内置<code>Filter</code>时，需要先将对应<code>Filter</code>的<code>enabled</code>设置为<code>true</code>，否则内置<code>Filter</code>的配置不会生效。</p>
<p>以上所有内容都只是示例配置，<code>Druid Spring Boot Starter</code>并不是只支持以上属性，它支持<code>DruidDataSource</code>内所有具有<code>setter</code>方法的属性。</p>
<p>至此，我们就完成了使用<code>Druid Spring Boot Starter</code>整合 Druid 的全部过程。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>无论是自定义整合还是通过<code>Druid Spring Boot Starter</code>整合，都能实现 Spring Boot 整合 Druid 数据源的目的，它们都各有利弊。</p>
<ul>
<li>自定义整合 Druid 数据源能够更加清晰地了解 Druid 的各种功能及其实现方式，但整合过程繁琐。</li>
<li>通过<code>Druid Spring Boot Starter</code>整合 Druid 数据源，则更加方便快捷，大大简化了整合过程，但无法清晰地了解 Druid 的功能内部的实现方式和原理。</li>
</ul>
<p>推荐使用<code>Druid Spring Boot Starter</code>进行整合，毕竟这种整合方式大大简化了整个整合的过程。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/SpringBoot异常处理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/11/java/SpringBoot/SpringBoot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"
    >SpringBoot异常处理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/11/java/SpringBoot/SpringBoot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2021-09-11T07:21:16.000Z" itemprop="datePublished">2021-09-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Boot/">Spring Boot</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="默认异常处理"><a href="#默认异常处理" class="headerlink" title="默认异常处理"></a>默认异常处理</h1><h2 id="默认异常处理机制"><a href="#默认异常处理机制" class="headerlink" title="默认异常处理机制"></a>默认异常处理机制</h2><p>Spring Boot 提供了一套默认的异常处理机制，一旦程序中出现了异常，Spring Boot 会自动识别客户端的类型（浏览器客户端或机器客户端），并根据客户端的不同，以不同的形式展示异常信息。</p>
<ol>
<li>对于浏览器客户端而言，Spring Boot 会响应一个错误视图，以 HTML 格式呈现错误信息；<img src="/2021/09/11/java/SpringBoot/SpringBoot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1.png" class="" title="Spring Boot 默认错误白页"></li>
<li>对于机器客户端而言，Spring Boot 将生成 JSON 响应，来展示异常消息。<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-07-12T07:05:29.885+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">404</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Not Found&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;No message available&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/main.html&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="异常处理自动配置原理"><a href="#异常处理自动配置原理" class="headerlink" title="异常处理自动配置原理"></a>异常处理自动配置原理</h2><p>Spring Boot 通过配置类<code>ErrorMvcAutoConfiguration</code>对异常处理提供了自动配置，该配置类向容器中注入了以下 4 个组件。</p>
<ul>
<li><code>ErrorPageCustomizer</code>：该组件会在在系统发生异常后，默认将请求转发到<code>/error</code>上。</li>
<li><code>BasicErrorController</code>：处理默认的<code>/error</code>请求。</li>
<li><code>DefaultErrorViewResolver</code>：默认的错误视图解析器，将异常信息解析到相应的错误视图上。</li>
<li><code>DefaultErrorAttributes</code>：用于页面上共享异常信息。</li>
</ul>
<h2 id="ErrorPageCustomizer"><a href="#ErrorPageCustomizer" class="headerlink" title="ErrorPageCustomizer"></a>ErrorPageCustomizer</h2><p><code>ErrorMvcAutoConfiguration</code>向容器中注入了一个名为<code>ErrorPageCustomizer</code>的组件，它主要用于定制错误页面的响应规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageCustomizer <span class="title function_">errorPageCustomizer</span><span class="params">(DispatcherServletPath dispatcherServletPath)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorPageCustomizer</span>(<span class="built_in">this</span>.serverProperties, dispatcherServletPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ErrorPageCustomizer</code>通过<code>registerErrorPages()</code>方法来注册错误页面的响应规则。当系统中发生异常后，<code>ErrorPageCustomizer</code>组件会自动生效，并将请求转发到<code>/error</code>上，交给<code>BasicErrorController</code>进行处理，其部分代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerErrorPages</span><span class="params">(ErrorPageRegistry errorPageRegistry)</span> &#123;</span><br><span class="line">  <span class="comment">//将请求转发到 /errror（this.properties.getError().getPath()）上</span></span><br><span class="line">  <span class="type">ErrorPage</span> <span class="variable">errorPage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorPage</span>(<span class="built_in">this</span>.dispatcherServletPath.getRelativePath(<span class="built_in">this</span>.properties.getError().getPath()));</span><br><span class="line">  <span class="comment">// 注册错误页面</span></span><br><span class="line">  errorPageRegistry.addErrorPages(errorPage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BasicErrorController"><a href="#BasicErrorController" class="headerlink" title="BasicErrorController"></a>BasicErrorController</h2><p><code>ErrorMvcAutoConfiguration</code>还向容器中注入了一个错误控制器组件<code>BasicErrorController</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">(ErrorAttributes errorAttributes, ObjectProvider&lt;ErrorViewResolver&gt; errorViewResolvers)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(errorAttributes, <span class="built_in">this</span>.serverProperties.getError(), errorViewResolvers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BasicErrorController</code>的定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BasicErrorController 用于处理 “/error” 请求</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicErrorController</span> <span class="keyword">extends</span> <span class="title class_">AbstractErrorController</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 该方法用于处理浏览器客户端的请求发生的异常</span></span><br><span class="line"><span class="comment">    * 生成 html 页面来展示异常信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span></span><br><span class="line">  <span class="keyword">public</span> ModelAndView <span class="title function_">errorHtml</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">//获取错误状态码</span></span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getStatus(request);</span><br><span class="line">    <span class="comment">//getErrorAttributes 根据错误信息来封装一些 model 数据，用于页面显示</span></span><br><span class="line">    Map&lt;String, Object&gt; model = Collections</span><br><span class="line">            .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));</span><br><span class="line">    <span class="comment">//为响应对象设置错误状态码</span></span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line">    <span class="comment">//调用 resolveErrorView() 方法，使用错误视图解析器生成 ModelAndView 对象（包含错误页面地址和页面内容）</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolveErrorView(request, response, status, model);</span><br><span class="line">    <span class="keyword">return</span> (modelAndView != <span class="literal">null</span>) ? modelAndView : <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>, model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 该方法用于处理机器客户端的请求发生的错误</span></span><br><span class="line"><span class="comment">    * 产生 JSON 格式的数据展示错误信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@RequestMapping</span></span><br><span class="line">  <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">error</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getStatus(request);</span><br><span class="line">    <span class="keyword">if</span> (status == HttpStatus.NO_CONTENT) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(body, status);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot 通过<code>BasicErrorController</code>进行统一的错误处理（例如默认的<code>/error</code>请求）。Spring Boot 会自动识别发出请求的客户端的类型（浏览器客户端或机器客户端），并根据客户端类型，将请求分别交给<code>errorHtml()</code>和<code>error()</code>方法进行处理。</p>
<table>
<thead>
<tr>
<th align="center">返回值类型</th>
<th align="center">方法声明</th>
<th align="center">客户端类型</th>
<th align="center">错误信息返类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ModelAndView</td>
<td align="center">errorHtml(HttpServletRequest request, HttpServletResponse response)</td>
<td align="center">浏览器客户端</td>
<td align="center">text&#x2F;html（错误页面）</td>
</tr>
<tr>
<td align="center"><code>ResponseEntity&lt;Map&lt;String, Object&gt;&gt;</code></td>
<td align="center">error(HttpServletRequest request)</td>
<td align="center">机器客户端（例如安卓、IOS、Postman 等等）</td>
<td align="center">JSON</td>
</tr>
</tbody></table>
<p>换句话说，当使用浏览器访问出现异常时，会进入<code>BasicErrorController</code>控制器中的<code>errorHtml()</code>方法进行处理，当使用安卓、IOS、Postman 等机器客户端访问出现异常时，就进入<code>error()</code>方法处理。</p>
<p>在<code>errorHtml()</code>方法中会调用父类（<code>AbstractErrorController</code>）的<code>resolveErrorView()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpStatus status,</span></span><br><span class="line"><span class="params">                          Map&lt;String, Object&gt; model)</span> &#123;</span><br><span class="line">  <span class="comment">//获取容器中的所有的错误视图解析器来处理该异常信息</span></span><br><span class="line">  <span class="keyword">for</span> (ErrorViewResolver resolver : <span class="built_in">this</span>.errorViewResolvers) &#123;</span><br><span class="line">    <span class="comment">//调用错误视图解析器的 resolveErrorView 解析到错误视图页面</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolver.resolveErrorView(request, status, model);</span><br><span class="line">    <span class="keyword">if</span> (modelAndView != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述源码可以看出，在响应页面的时候，会在父类的<code>resolveErrorView</code>方法中获取容器中所有的<code>ErrorViewResolver</code>对象（错误视图解析器，包括<code>DefaultErrorViewResolver</code>在内），一起来解析异常信息。</p>
<h2 id="DefaultErrorViewResolver"><a href="#DefaultErrorViewResolver" class="headerlink" title="DefaultErrorViewResolver"></a>DefaultErrorViewResolver</h2><p><code>ErrorMvcAutoConfiguration</code>还向容器中注入了一个默认的错误视图解析器组件<code>DefaultErrorViewResolver</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(DispatcherServlet.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(ErrorViewResolver.class)</span></span><br><span class="line">DefaultErrorViewResolver <span class="title function_">conventionErrorViewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultErrorViewResolver</span>(<span class="built_in">this</span>.applicationContext, <span class="built_in">this</span>.resources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发出请求的客户端为浏览器时，Spring Boot 会获取容器中所有的<code>ErrorViewResolver</code>对象（错误视图解析器），并分别调用它们的<code>resolveErrorView()</code>方法对异常信息进行解析，其中自然也包括<code>DefaultErrorViewResolver</code>（默认错误信息解析器）。</p>
<p><code>DefaultErrorViewResolver</code>的部分代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultErrorViewResolver</span> <span class="keyword">implements</span> <span class="title class_">ErrorViewResolver</span>, Ordered &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;HttpStatus.Series, String&gt; SERIES_VIEWS;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    Map&lt;HttpStatus.Series, String&gt; views = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(HttpStatus.Series.class);</span><br><span class="line">    views.put(Series.CLIENT_ERROR, <span class="string">&quot;4xx&quot;</span>);</span><br><span class="line">    views.put(Series.SERVER_ERROR, <span class="string">&quot;5xx&quot;</span>);</span><br><span class="line">    SERIES_VIEWS = Collections.unmodifiableMap(views);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试以错误状态码作为错误页面名进行解析</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolve(String.valueOf(status.value()), model);</span><br><span class="line">    <span class="keyword">if</span> (modelAndView == <span class="literal">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">      <span class="comment">//尝试以 4xx 或 5xx 作为错误页面页面进行解析</span></span><br><span class="line">      modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> ModelAndView <span class="title function_">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> &#123;</span><br><span class="line">    <span class="comment">//错误模板页面，例如 error/404、error/4xx、error/500、error/5xx</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">errorViewName</span> <span class="operator">=</span> <span class="string">&quot;error/&quot;</span> + viewName;</span><br><span class="line">    <span class="comment">//当模板引擎可以解析这些模板页面时，就用模板引擎解析</span></span><br><span class="line">    <span class="type">TemplateAvailabilityProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="built_in">this</span>.templateAvailabilityProviders.getProvider(errorViewName,</span><br><span class="line">            <span class="built_in">this</span>.applicationContext);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//在模板能够解析到模板页面的情况下，返回 errorViewName 指定的视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(errorViewName, model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若模板引擎不能解析，则去静态资源文件夹下查找 errorViewName 对应的页面</span></span><br><span class="line">    <span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> ModelAndView <span class="title function_">resolveResource</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历所有静态资源文件夹</span></span><br><span class="line">    <span class="keyword">for</span> (String location : <span class="built_in">this</span>.resources.getStaticLocations()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext.getResource(location);</span><br><span class="line">        <span class="comment">//静态资源文件夹下的错误页面，例如error/404.html、error/4xx.html、error/500.html、error/5xx.html</span></span><br><span class="line">        resource = resource.createRelative(viewName + <span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        <span class="comment">//若静态资源文件夹下存在以上错误页面，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (resource.exists()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="keyword">new</span> <span class="title class_">DefaultErrorViewResolver</span>.HtmlResourceView(resource), model);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultErrorViewResolver</code>解析异常信息的步骤如下：</p>
<ol>
<li>根据错误状态码（例如 404、500、400 等），生成一个错误视图<code>error/status</code>，例如<code>error/404、error/500、error/400</code>。</li>
<li>尝试使用模板引擎解析<code>error/status</code>视图，即尝试从<code>classpath</code>类路径下的<code>templates</code>目录下，查找<code>error/status.html</code>，例如<code>error/404.html、error/500.html、error/400.html</code>。</li>
<li>若模板引擎能够解析到<code>error/status</code>视图，则将视图和数据封装成<code>ModelAndView</code>返回并结束整个解析流程，否则跳转到第 4 步。</li>
<li>依次从各个静态资源文件夹中查找<code>error/status.html</code>，若在静态文件夹中找到了该错误页面，则返回并结束整个解析流程，否则跳转到第 5 步。</li>
<li>将错误状态码（例如 404、500、400 等）转换为<code>4xx</code>或<code>5xx</code>，然后重复前 4 个步骤，若解析成功则返回并结束整个解析流程，否则跳转第 6 步。 </li>
<li>处理默认的<code>/error</code>请求，使用 Spring Boot 默认的错误页面（<code>Whitelabel Error Page</code>）。</li>
</ol>
<h2 id="DefaultErrorAttributes"><a href="#DefaultErrorAttributes" class="headerlink" title="DefaultErrorAttributes"></a>DefaultErrorAttributes</h2><p><code>ErrorMvcAutoConfiguration</code>还向容器中注入了一个组件默认错误属性处理工具<code>DefaultErrorAttributes</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="keyword">public</span> DefaultErrorAttributes <span class="title function_">errorAttributes</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultErrorAttributes</code>是 Spring Boot 的默认错误属性处理工具，它可以从请求中获取异常或错误信息，并将其封装为一个<code>Map</code>对象返回，其部分代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultErrorAttributes</span> <span class="keyword">implements</span> <span class="title class_">ErrorAttributes</span>, HandlerExceptionResolver, Ordered &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getErrorAttributes</span><span class="params">(WebRequest webRequest, ErrorAttributeOptions options)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; errorAttributes = getErrorAttributes(webRequest, options.isIncluded(Include.STACK_TRACE));</span><br><span class="line">    <span class="keyword">if</span> (!options.isIncluded(Include.EXCEPTION)) &#123;</span><br><span class="line">      errorAttributes.remove(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!options.isIncluded(Include.STACK_TRACE)) &#123;</span><br><span class="line">      errorAttributes.remove(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!options.isIncluded(Include.MESSAGE) &amp;&amp; errorAttributes.get(<span class="string">&quot;message&quot;</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">      errorAttributes.remove(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!options.isIncluded(Include.BINDING_ERRORS)) &#123;</span><br><span class="line">      errorAttributes.remove(<span class="string">&quot;errors&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errorAttributes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getErrorAttributes</span><span class="params">(WebRequest webRequest, <span class="type">boolean</span> includeStackTrace)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    errorAttributes.put(<span class="string">&quot;timestamp&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    addStatus(errorAttributes, webRequest);</span><br><span class="line">    addErrorDetails(errorAttributes, webRequest, includeStackTrace);</span><br><span class="line">    addPath(errorAttributes, webRequest);</span><br><span class="line">    <span class="keyword">return</span> errorAttributes;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Spring Boot 默认的<code>Error</code>控制器（<code>BasicErrorController</code>）处理错误时，会调用<code>DefaultErrorAttributes</code>的<code>getErrorAttributes()</code>方法获取错误或异常信息，并封装成<code>model</code>数据（<code>Map</code>对象），返回到页面或 JSON 数据中。该<code>model</code>数据主要包含以下属性：</p>
<ul>
<li><code>timestamp</code>：时间戳；</li>
<li><code>status</code>：错误状态码</li>
<li><code>error</code>：错误的提示</li>
<li><code>exception</code>：导致请求处理失败的异常对象</li>
<li><code>message</code>：错误&#x2F;异常消息</li>
<li><code>trace</code>： 错误&#x2F;异常栈信息</li>
<li><code>path</code>:错误&#x2F;异常抛出时所请求的URL路径</li>
</ul>
<p>所有通过<code>DefaultErrorAttributes</code>封装到<code>model</code>数据中的属性，都可以直接在页面或 JSON 中获取。</p>
<h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><p>Spring Boot 已经提供了一套默认的异常处理机制，但是 Spring Boot 提供的默认异常处理机制却并不一定适合我们实际的业务场景，因此，我们通常会根据自身的需要对 Spring Boot 全局异常进行统一定制，例如定制错误页面，定制错误数据等。</p>
<h2 id="定制错误页面"><a href="#定制错误页面" class="headerlink" title="定制错误页面"></a>定制错误页面</h2><p>我们可以通过以下 3 种方式定制 Spring Boot 错误页面：</p>
<ul>
<li>自定义<code>error.html</code></li>
<li>自定义动态错误页面</li>
<li>自定义静态错误页面</li>
</ul>
<h3 id="自定义-error-html"><a href="#自定义-error-html" class="headerlink" title="自定义 error.html"></a>自定义 error.html</h3><p>我们可以直接在模板引擎文件夹（<code>/resources/templates</code>）下创建<code>error.html</code>，覆盖 Spring Boot 默认的错误视图页面（<code>Whitelabel Error Page</code>）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自定义 error.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>自定义 error.html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>status：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;status&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>error：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;error&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>timestamp：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;timestamp&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>message：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>path：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;path&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h3><p>如果 Sprng Boot 项目使用了模板引擎，当程序发生异常时，Spring Boot 的默认错误视图解析器（<code>DefaultErrorViewResolver</code>）就会解析模板引擎文件夹（<code>resources/templates/</code>）下<code>error</code>目录中的错误视图页面。</p>
<p>我们可以根据错误状态码（例如 404、500、400 等等）的不同，分别创建不同的动态错误页面（例如<code>404.html、500.html、400.html</code>等等），并将它们存放在模板引擎文件夹下的<code>error</code>目录中。当发生异常时，Spring Boot 会根据其错误状态码精确匹配到对应的错误页面上。</p>
<p>我们还可以使用<code>4xx.html</code>和<code>5xx.html</code>作为动态错误页面的文件名，并将它们存放在模板引擎文件夹下的<code>error</code>目录中，来模糊匹配对应类型的所有错误，例如 404、400 等错误状态码以“4”开头的所有异常，都会解析到动态错误页面<code>4xx.html</code>上。</p>
<h3 id="错误页面优先级"><a href="#错误页面优先级" class="headerlink" title="错误页面优先级"></a>错误页面优先级</h3><p>以上 5 种方式均可以定制 Spring Boot 错误页面，且它们的优先级顺序为：自定义动态错误页面（精确匹配）&gt;自定义静态错误页面（精确匹配）&gt;自定义动态错误页面（模糊匹配）&gt;自定义静态错误页面（模糊匹配）&gt;自定义<code>error.html</code>。</p>
<p>当遇到错误时，Spring Boot 会按照优先级由高到低，依次查找解析错误页，一旦找到可用的错误页面，则直接返回客户端展示。</p>
<h2 id="定制错误数据"><a href="#定制错误数据" class="headerlink" title="定制错误数据"></a>定制错误数据</h2><p>Spring Boot 提供了一套默认的异常处理机制，其主要流程如下：</p>
<ul>
<li>发生异常时，将请求转发到<code>/error</code>，交由<code>BasicErrorController</code>（Spring Boot 默认的<code>Error</code>控制器） 进行处理；</li>
<li><code>BasicErrorController</code>根据客户端的不同，自动适配返回的响应形式，浏览器客户端返回错误页面，机器客户端返回 JSON 数据。</li>
<li><code>BasicErrorController</code>处理异常时，会调用<code>DefaultErrorAttributes</code>（默认的错误属性处理工具） 的<code>getErrorAttributes()</code>方法获取错误数据。</li>
</ul>
<p>我们还可以定制 Spring Boot 的错误数据，具体步骤如下。</p>
<ul>
<li>自定义异常处理类，将请求转发到<code>/error</code>，交由 Spring Boot 底层（<code>BasicErrorController</code>）进行处理，自动适配浏览器客户端和机器客户端。</li>
<li>通过继承<code>DefaultErrorAttributes</code>来定义一个错误属性处理工具，并在原来的基础上添加自定义的错误数据。</li>
</ul>
<h3 id="1-自定义异常处理类"><a href="#1-自定义异常处理类" class="headerlink" title="1. 自定义异常处理类"></a>1. 自定义异常处理类</h3><p>被<code>@ControllerAdvice</code>注解的类可以用来实现全局异常处理，这是 Spring MVC 中提供的功能，在 Spring Boot 中可以直接使用。</p>
<p>1）在<code>net.biancheng.net.exception</code>包内，创建一个名为<code>UserNotExistException</code>的异常类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.exception;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserNotExistException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserNotExistException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;用户不存在！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）在<code>IndexController</code>添加以下方法，触发<code>UserNotExistException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexController</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="meta">@GetMapping(value = &#123;&quot;/testException&quot;&#125;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">testException</span><span class="params">(String user)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;user&quot;</span>.equals(user)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跳转到登录页 login.html</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）在<code>net.biancheng.www.controller</code>中，创建一个名为<code>MyExceptionHandler</code>异常处理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.controller;</span><br><span class="line"><span class="keyword">import</span> net.biancheng.www.exception.UserNotExistException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionHandler</span> &#123;</span><br><span class="line">  <span class="meta">@ExceptionHandler(UserNotExistException.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e, HttpServletRequest request)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//向 request 对象传入错误状态码</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>,<span class="number">500</span>);</span><br><span class="line">    <span class="comment">//根据当前处理的异常，自定义的错误数据</span></span><br><span class="line">    map.put(<span class="string">&quot;code&quot;</span>, <span class="string">&quot;user.notexist&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">    <span class="comment">//将自定的错误数据传入 request 域中</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;ext&quot;</span>,map);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/error&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-自定义错误属性处理工具"><a href="#2-自定义错误属性处理工具" class="headerlink" title="2. 自定义错误属性处理工具"></a>2. 自定义错误属性处理工具</h3><p>1）在<code>net.biancheng.www.componet</code>包内，创建一个错误属性处理工具类<code>MyErrorAttributes</code>（继承<code>DefaultErrorAttributes</code>），通过该类我们便可以添加自定义的错误数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.biancheng.www.componet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.error.ErrorAttributeOptions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.error.DefaultErrorAttributes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.request.WebRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">//向容器中添加自定义的储物属性处理工具</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title class_">DefaultErrorAttributes</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getErrorAttributes</span><span class="params">(WebRequest webRequest, ErrorAttributeOptions options)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; errorAttributes = <span class="built_in">super</span>.getErrorAttributes(webRequest, options);</span><br><span class="line">    <span class="comment">//添加自定义的错误数据</span></span><br><span class="line">    errorAttributes.put(<span class="string">&quot;company&quot;</span>, <span class="string">&quot;www.biancheng.net&quot;</span>);</span><br><span class="line">    <span class="comment">//获取 MyExceptionHandler 传入 request 域中的错误数据</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">ext</span> <span class="operator">=</span> (Map) webRequest.getAttribute(<span class="string">&quot;ext&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    errorAttributes.put(<span class="string">&quot;ext&quot;</span>, ext);</span><br><span class="line">    <span class="keyword">return</span> errorAttributes;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）在<code>templates/error</code>目录下，创建动态错误页面<code>5xx.html</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>自定义 error.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>status：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;status&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>error：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;error&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>timestamp：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;timestamp&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>message：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>path：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;path&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--取出定制的错误信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>以下为定制错误数据：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>company：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;company&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>code：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ext.code&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>path：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ext.message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3）启动 Spring Boot，访问<code>http://localhost:8080/testException?user=user</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/SpringBoot/YAML教程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/04/java/SpringBoot/YAML%E6%95%99%E7%A8%8B/"
    >YAML教程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/04/java/SpringBoot/YAML%E6%95%99%E7%A8%8B/" class="article-date">
  <time datetime="2021-09-04T02:59:43.000Z" itemprop="datePublished">2021-09-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Boot/">Spring Boot</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Spring Boot 提供了大量的自动配置，极大地简化了spring 应用的开发过程，当用户创建了一个 Spring Boot 项目后，即使不进行任何配置，该项目也能顺利的运行起来。当然，用户也可以根据自身的需要使用配置文件修改 Spring Boot 的默认设置。</p>
<p>SpringBoot 默认使用以下 2 种全局的配置文件，其文件名是固定的。</p>
<ul>
<li><code>application.properties</code></li>
<li><code>application.yml</code></li>
</ul>
<p>其中，<code>application.yml</code>是一种使用 YAML 语言编写的文件，它与<code>application.properties</code>一样，可以在 Spring Boot 启动时被自动读取，修改 Spring Boot 自动配置的默认值。</p>
<h1 id="YAML-简介"><a href="#YAML-简介" class="headerlink" title="YAML 简介"></a>YAML 简介</h1><p>YAML 全称<code>YAML Ain&#39;t Markup Language</code>，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件。</p>
<p>想要使用 YAML 作为属性配置文件（以<code>.yml</code>或<code>.yaml</code>结尾），需要将 SnakeYAML 库添加到<code>classpath</code>下，Spring Boot 中的<code>spring-boot-starter-web</code>或<code>spring-boot-starter</code>都对 SnakeYAML 库做了集成， 只要项目中引用了这两个<code>Starter</code>中的任何一个，Spring Boot 会自动添加 SnakeYAML 库到<code>classpath</code>下。</p>
<h1 id="YAML-语法"><a href="#YAML-语法" class="headerlink" title="YAML 语法"></a>YAML 语法</h1><p>YAML 的语法如下：</p>
<ul>
<li>使用缩进表示层级关系。</li>
<li>缩进时不允许使用 Tab 键，只允许使用空格。</li>
<li>缩进的空格数不重要，但同级元素必须左侧对齐。</li>
<li>大小写敏感。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://127.0.01/banchengbang_springboot</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>
<h1 id="YAML-常用写法"><a href="#YAML-常用写法" class="headerlink" title="YAML 常用写法"></a>YAML 常用写法</h1><p>YAML 支持以下三种数据结构：</p>
<ul>
<li>对象：键值对的集合</li>
<li>数组：一组按次序排列的值</li>
<li>字面量：单个的、不可拆分的值</li>
</ul>
<h2 id="YAML-字面量写法"><a href="#YAML-字面量写法" class="headerlink" title="YAML 字面量写法"></a>YAML 字面量写法</h2><p>字面量是指单个的，不可拆分的值，例如：数字、字符串、布尔值、以及日期等。</p>
<p>在 YAML 中，使用<code>key:[空格]value</code>的形式表示一对键值对（空格不能省略），如<code>url: www.biancheng.net</code>。</p>
<p>字面量直接写在键值对的<code>value</code>中即可，且默认情况下字符串是不需要使用单引号或双引号的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: bianchengbang</span><br></pre></td></tr></table></figure>
<p>若字符串使用单引号，则会转义特殊字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: zhangsan \n lisi</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan \n lisi</span><br></pre></td></tr></table></figure>
<p>若字符串使用双引号，则不会转义特殊字符，特殊字符会输出为其本身想表达的含义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: zhangsan \n lisi</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan </span><br><span class="line">lisi</span><br></pre></td></tr></table></figure>
<h2 id="YAML-对象写法"><a href="#YAML-对象写法" class="headerlink" title="YAML 对象写法"></a>YAML 对象写法</h2><p>在 YAML 中，对象可能包含多个属性，每一个属性都是一对键值对。</p>
<p>YAML 为对象提供了 2 种写法：</p>
<ul>
<li>普通写法，使用缩进表示对象与属性的层级关系。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">website: </span><br><span class="line">  name: bianchengbang</span><br><span class="line">  url: www.biancheng.net</span><br></pre></td></tr></table></figure></li>
<li>行内写法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">website: &#123;name: bianchengbang,url: www.biancheng.net&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="YAML-数组写法"><a href="#YAML-数组写法" class="headerlink" title="YAML 数组写法"></a>YAML 数组写法</h2><p>YAML 使用“-”表示数组中的元素，普通写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pets:</span><br><span class="line">  -dog</span><br><span class="line">  -cat</span><br><span class="line">  -pig</span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pets: [dog,cat,pig]</span><br></pre></td></tr></table></figure>
<h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><p>以上三种数据结构可以任意组合使用，以实现不同的用户需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">  name: zhangsan</span><br><span class="line">  age: 30</span><br><span class="line">  pets:</span><br><span class="line">    -dog</span><br><span class="line">    -cat</span><br><span class="line">    -pig</span><br><span class="line">  car:</span><br><span class="line">    name: QQ</span><br><span class="line">  child:</span><br><span class="line">    name: zhangxiaosan</span><br><span class="line">    age: 2</span><br></pre></td></tr></table></figure>
<h1 id="YAML-组织结构"><a href="#YAML-组织结构" class="headerlink" title="YAML 组织结构"></a>YAML 组织结构</h1><p>一个 YAML 文件可以由一个或多个文档组成，文档之间使用“—”作为分隔符，且个文档相互独立，互不干扰。如果 YAML 文件只包含一个文档，则“—”分隔符可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">website:</span><br><span class="line">  name: bianchengbang</span><br><span class="line">  url: www.biancheng.net</span><br><span class="line">---</span><br><span class="line">website: &#123;name: bianchengbang,url: www.biancheng.net&#125;</span><br><span class="line">pets:</span><br><span class="line">  -dog</span><br><span class="line">  -cat</span><br><span class="line">  -pig</span><br><span class="line">---</span><br><span class="line">pets: [dog,cat,pig]</span><br><span class="line">name: &quot;zhangsan \n lisi&quot;</span><br><span class="line">---</span><br><span class="line">name: &#x27;zhangsan \n lisi&#x27;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux/打包（归档）和压缩"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/08/17/Linux/%E6%89%93%E5%8C%85%EF%BC%88%E5%BD%92%E6%A1%A3%EF%BC%89%E5%92%8C%E5%8E%8B%E7%BC%A9/"
    >Linux打包（归档）和压缩</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/08/17/Linux/%E6%89%93%E5%8C%85%EF%BC%88%E5%BD%92%E6%A1%A3%EF%BC%89%E5%92%8C%E5%8E%8B%E7%BC%A9/" class="article-date">
  <time datetime="2021-08-17T09:38:41.000Z" itemprop="datePublished">2021-08-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>归档，也称为打包，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。</p>
<p>和归档文件类似，压缩文件也是一个文件和目录的集合，且这个集合也被存储在一个文件中，但它们的不同之处在于，压缩文件采用了不同的存储方式，使其所占用的磁盘空间比集合中所有文件大小的总和要小。</p>
<p>压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。比如，在压缩文件中，有不止一处出现了 “张三”，那么，在压缩文件时，这个词就会用一个代码表示并写入词典文件，这样就可以实现缩小文件体积的目的。</p>
<p>由于计算机处理的信息是以二进制的形式表示的，因此，压缩软件就是把二进制信息中相同的字符串以特殊字符标记，只要通过合理的数学计算，文件的体积就能够被大大压缩。把一个或者多个文件用压缩软件进行压缩，形成一个文件压缩包，既可以节省存储空间，有方便在网络上传送。</p>
<p>对文件进行压缩，很可能损坏文件中的内容，因此，压缩又可以分为有损压缩和无损压缩。无损压缩指的是压缩数据必须准确无误；有损压缩指的是即便丢失个别的数据，对文件也不会造成太大的影响。有损压缩广泛应用于动画、声音和图像文件中。</p>
<p>采用压缩工具对文件进行压缩，生成的文件称为压缩包，该文件的体积通常只有原文件的一半甚至更小。压缩包中的数据无法直接使用，使用前需要利用压缩工具将文件数据还原，此过程又称解压缩。</p>
<p>Linux 下，常用归档命令有 2 个，分别是<code>tar</code>和<code>dd</code>；常用的压缩命令有很多，比如<code>gzip、zip、bzip2</code>等。<code>tar</code>命令也可以作为压缩命令，也很常用。</p>
<h1 id="tar打包命令"><a href="#tar打包命令" class="headerlink" title="tar打包命令"></a>tar打包命令</h1><p>Linux 系统中，最常用的归档（打包）命令就是<code>tar</code>，该命令可以将许多文件一起保存到一个单独的磁盘中进行归档。不仅如此，该命令还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包。</p>
<p>使用<code>tar</code>命令归档的包通常称为<code>tar</code>包（<code>tar</code>包文件都是以<code>.tar</code>结尾的）。</p>
<h2 id="tar命令做打包操作"><a href="#tar命令做打包操作" class="headerlink" title="tar命令做打包操作"></a>tar命令做打包操作</h2><p>当<code>tar</code>命令用于打包操作时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 源文件或目录</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td align="center">将多个文件或目录进行打包。</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">包名	指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示打包文件过程</td>
</tr>
</tbody></table>
<p>需要注意的是，在使用<code>tar</code>命令指定选项时可以不在选项前面输入<code>-</code>。例如，使用<code>cvf</code>选项和<code>-cvf</code>起到的作用一样。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="1-打包文件和目录"><a href="#1-打包文件和目录" class="headerlink" title="1.打包文件和目录"></a>1.打包文件和目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br><span class="line">#把anacondehks.cfg打包为 anacondehks.cfg.tar文件</span><br></pre></td></tr></table></figure>
<p>选项<code>-cvf</code>一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用<code>.tar</code>作为扩展名。打包目录也是如此：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll -d test/</span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test/</span><br><span class="line">#test是我们之前的测试目录</span><br><span class="line">[root@localhost ~]# tar -cvf test.tar test/</span><br><span class="line">test/</span><br><span class="line">test/test3</span><br><span class="line">test/test2</span><br><span class="line">test/test1</span><br><span class="line">#把目录打包为test.tar文件</span><br></pre></td></tr></table></figure>
<p><code>tar</code>命令也可以打包多个文件或目录，只要用空格分开即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -cvf ana.tar anaconda-ks.cfg /tmp/</span><br><span class="line">#把anaconda-ks.cfg文件和/tmp目录打包成ana.tar文件包</span><br></pre></td></tr></table></figure>
<h4 id="2-打包并压缩目录"><a href="#2-打包并压缩目录" class="headerlink" title="2.打包并压缩目录"></a>2.打包并压缩目录</h4><p>首先声明一点，压缩命令不能直接压缩目录，必须先用<code>tar</code>命令将目录打包，然后才能用<code>gzip</code>命令或<code>bzip2</code>命令对打包文件进行压缩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#ll -d test test.tar</span><br><span class="line">drwxr-xr-x 2 root root 4096 6月 17 21:09 test</span><br><span class="line">-rw-r--r-- 1 root root 10240 6月 18 01:06 test.tar</span><br><span class="line">#我们之前已经把test目录打包成test.tar文件</span><br><span class="line">[root@localhost ~]# gzip test.tar</span><br><span class="line">[root@localhost ~]# ll test.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 176 6月 18 01:06 test.tar.gz</span><br><span class="line">#gzip命令会把test.tar压缩成test.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="tar命令做解打包操作"><a href="#tar命令做解打包操作" class="headerlink" title="tar命令做解打包操作"></a>tar命令做解打包操作</h2><p>当<code>tar</code>命令用于对<code>tar</code>包做解打包操作时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 压缩包</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-x</td>
<td align="center">对 tar 包做解打包操作。</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">指定要解压的 tar 包的包名。</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</td>
</tr>
<tr>
<td align="center">-C</td>
<td align="center">目录	指定解打包位置。</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示解打包的具体过程。</td>
</tr>
</tbody></table>
<p>其实解打包和打包相比，只是把打包选项<code>-cvf</code>更换为<code>-xvf</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf anaconda-ks.cfg. tar</span><br><span class="line">#解打包到当前目录下</span><br></pre></td></tr></table></figure>
<p>如果使用<code>-xvf</code>选项，则会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用<code>-C</code>(大写)选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -xvf test.tar -C /tmp</span><br><span class="line">#把文件包test.tar解打包到/tmp/目录下</span><br></pre></td></tr></table></figure>
<p>如果只想查看文件包中有哪些文件，则可以把解打包选项 “-x” 更换为测试选项 “-t”。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -tvf test.tar</span><br><span class="line">drwxr-xr-x root/root 0 2016-06-17 21:09 test/</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test3</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test2</span><br><span class="line">-rw-r-r- root/root 0 2016-06-17 17:51 test/test1</span><br><span class="line">#会用长格式显示test.tar文件包中文件的详细信息</span><br></pre></td></tr></table></figure>
<h2 id="tar命令做打包压缩（解压缩解打包）操作"><a href="#tar命令做打包压缩（解压缩解打包）操作" class="headerlink" title="tar命令做打包压缩（解压缩解打包）操作"></a>tar命令做打包压缩（解压缩解打包）操作</h2><p><code>tar</code>命令是可以同时打包压缩的。</p>
<p>当<code>tar</code>命令同时做打包压缩的操作时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#tar [选项] 压缩包 源文件或目录</span><br></pre></td></tr></table></figure>
<p>常用的选项有以下 2 个，分别是：</p>
<ul>
<li><code>-z</code>：压缩和解压缩<code>.tar.gz</code>格式；</li>
<li><code>-j</code>：压缩和解压缩<code>.tar.bz2</code>格式。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="1-压缩与解压缩”-tar-gz”格式"><a href="#1-压缩与解压缩”-tar-gz”格式" class="headerlink" title="1.压缩与解压缩”.tar.gz”格式"></a>1.压缩与解压缩”.tar.gz”格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -zcvf tmp.tar.gz /tmp/</span><br><span class="line">#把/temp/目录直接打包压缩为&quot;.tar.gz&quot;格式，通过&quot;-z&quot;来识别格式，&quot;-cvf&quot;和打包选项一致</span><br></pre></td></tr></table></figure>
<p>解压缩也只是在解打包选项<code>-xvf</code>前面加了一个<code>-z</code>选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -zxvf tmp.tar.gz</span><br><span class="line">#解压缩与解打包&quot;.tar.gz&quot;格式</span><br></pre></td></tr></table></figure>
<h4 id="2-压缩与解压缩”-tar-bz2”格式"><a href="#2-压缩与解压缩”-tar-bz2”格式" class="headerlink" title="2.压缩与解压缩”.tar.bz2”格式"></a>2.压缩与解压缩”.tar.bz2”格式</h4><p>和<code>.tar.gz</code>格式唯一的不同就是<code>-zcvf</code>选项换成了<code>-jcvf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -jcvf tmp.tar.bz2 /tmp/</span><br><span class="line">#打包压缩为&quot;.tar.bz2&quot;格式，注意压缩包文件名</span><br><span class="line">[root@localhost ~]# tar -jxvf tmp.tar.bz2</span><br><span class="line">#解压缩与解打包&quot;.tar.bz2&quot;格式</span><br></pre></td></tr></table></figure>
<h1 id="zip命令：压缩文件或目录"><a href="#zip命令：压缩文件或目录" class="headerlink" title="zip命令：压缩文件或目录"></a>zip命令：压缩文件或目录</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#zip [选项] 压缩包名 源文件或源目录列表</span><br></pre></td></tr></table></figure>
<p>注意，<code>zip</code>压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用。</p>
<p>该命令常用的几个选项及各自的含义：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-r</td>
<td align="center">递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示详细的压缩过程信息。</td>
</tr>
<tr>
<td align="center">-q</td>
<td align="center">在压缩的时候不显示命令的执行过程。</td>
</tr>
<tr>
<td align="center">-u</td>
<td align="center">更新压缩文件，即往压缩文件中添加新文件。</td>
</tr>
</tbody></table>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h3 id="1-zip-命令的基本使用"><a href="#1-zip-命令的基本使用" class="headerlink" title="1.zip 命令的基本使用"></a>1.zip 命令的基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip ana.zip anaconda-ks.cfg</span><br><span class="line">adding: anaconda-ks.cfg (deflated 37%)</span><br><span class="line">#压缩</span><br><span class="line">[root@localhost ~]# ll ana.zip</span><br><span class="line">-rw-r--r-- 1 root root 935 6月 1716:00 ana.zip</span><br><span class="line">#压缩文件生成</span><br></pre></td></tr></table></figure>
<p>不仅如此，所有的压缩命令都可以同时压缩多个文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zip test.zip install.log install.log.syslog</span><br><span class="line">adding: install.log (deflated 72%)</span><br><span class="line">adding: install.log.syslog (deflated 85%)</span><br><span class="line">#同时压缩多个文件到test.zip压缩包中</span><br><span class="line">[root@localhost ~]#ll test.zip</span><br><span class="line">-rw-r--r-- 1 root root 8368 6月 1716:03 test.zip</span><br><span class="line">#压缩文件生成</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-zip-命令压缩目录"><a href="#2-使用-zip-命令压缩目录" class="headerlink" title="2.使用 zip 命令压缩目录"></a>2.使用 zip 命令压缩目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir dir1</span><br><span class="line">#建立测试目录</span><br><span class="line">[root@localhost ~]# zip -r dir1.zip dir1</span><br><span class="line">adding: dir1/(stored 0%)</span><br><span class="line">#压缩目录</span><br><span class="line">[root@localhost ~]# ls -dl dir1.zip</span><br><span class="line">-rw-r--r-- 1 root root 160 6月 1716:22 dir1.zip</span><br><span class="line">#压缩文件生成</span><br></pre></td></tr></table></figure>
<h1 id="unzip命令：解压zip文件"><a href="#unzip命令：解压zip文件" class="headerlink" title="unzip命令：解压zip文件"></a>unzip命令：解压zip文件</h1><p><code>unzip</code>命令可以查看和解压缩<code>zip</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip [选项] 压缩包名</span><br></pre></td></tr></table></figure>
<p><code>unzip</code>命令常用选项及含义：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-d</td>
<td align="center">目录名	将压缩文件解压到指定目录下。</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="center">解压时并不覆盖已经存在的文件。</td>
</tr>
<tr>
<td align="center">-o</td>
<td align="center">解压时覆盖已经存在的文件，并且无需用户确认。</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作。</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">测试压缩文件有无损坏，但并不解压。</td>
</tr>
<tr>
<td align="center">-x</td>
<td align="center">文件列表	解压文件，但不包含文件列表中指定的文件。</td>
</tr>
</tbody></table>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><h3 id="1-不论是文件压缩包，还是目录压缩包，都可以直接解压缩"><a href="#1-不论是文件压缩包，还是目录压缩包，都可以直接解压缩" class="headerlink" title="1.不论是文件压缩包，还是目录压缩包，都可以直接解压缩"></a>1.不论是文件压缩包，还是目录压缩包，都可以直接解压缩</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip dir1.zip</span><br><span class="line">Archive: dir1.zip</span><br><span class="line">creating: dirl/</span><br><span class="line">#解压缩</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-d-选项手动指定解压缩位置"><a href="#2-使用-d-选项手动指定解压缩位置" class="headerlink" title="2.使用 -d 选项手动指定解压缩位置"></a>2.使用 -d 选项手动指定解压缩位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# unzip -d /tmp/ ana.zip</span><br><span class="line">Archive: ana.zip</span><br><span class="line">inflating: /tmp/anaconda-ks.cfg</span><br><span class="line">#把压缩包解压到指定位置</span><br></pre></td></tr></table></figure>
<h1 id="gzip命令：压缩文件或目录"><a href="#gzip命令：压缩文件或目录" class="headerlink" title="gzip命令：压缩文件或目录"></a>gzip命令：压缩文件或目录</h1><p><code>gzip</code>是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为<code>.gz</code>。</p>
<p><code>gzip</code>命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip [选项] 源文件</span><br></pre></td></tr></table></figure>
<p>命令中的源文件，当进行压缩操作时，指的是普通文件；当进行解压缩操作时，指的是压缩文件。该命令常用的选项及含义：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-c</td>
<td align="center">将压缩数据输出到标准输出中，并保留源文件。</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="center">对压缩文件进行解压缩。</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">递归压缩指定目录下以及子目录下的所有文件。</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">对于每个压缩和解压缩的文件，显示相应的文件名和压缩比。</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称。</td>
</tr>
<tr>
<td align="center">-数字</td>
<td align="center">用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6。</td>
</tr>
</tbody></table>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><h3 id="1-基本压缩"><a href="#1-基本压缩" class="headerlink" title="1.基本压缩"></a>1.基本压缩</h3><p><code>gzip</code>压缩命令非常简单，甚至不需要指定压缩之后的压缩包名，只需指定源文件名即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip install.log</span><br><span class="line">#压缩instal.log 文件</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg install.log.gz install.log.syslog</span><br><span class="line">#压缩文件生成，但是源文件也消失了</span><br></pre></td></tr></table></figure>
<h3 id="2-保留源文件压缩。"><a href="#2-保留源文件压缩。" class="headerlink" title="2.保留源文件压缩。"></a>2.保留源文件压缩。</h3><p>在使用<code>gzip</code>命令压缩文件时，源文件会消失，从而生成压缩文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip -c anaconda-ks.cfg &gt;anaconda-ks.cfg.gz</span><br><span class="line">#使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中，这样可以缩文件的同时不删除源文件</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog</span><br><span class="line">#可以看到压缩文件和源文件都存在</span><br></pre></td></tr></table></figure>
<h3 id="3-压缩目录。"><a href="#3-压缩目录。" class="headerlink" title="3.压缩目录。"></a>3.压缩目录。</h3><p>我们可能会想当然地认为<code>gzip</code>命令可以压缩目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir test</span><br><span class="line">[root@localhost ~]# touch test/test1</span><br><span class="line">[root@localhost ~]# touch test/test2</span><br><span class="line">[root@localhost ~]# touch test/test3 #建立测试目录，并在里面建立几个测试文件</span><br><span class="line">[root@localhost ~]# gzip -r test/</span><br><span class="line">#压缩目录，并没有报错</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog test</span><br><span class="line">#但是查看发现test目录依然存在，并没有变为压缩文件</span><br><span class="line">[root@localhost ~]# ls test/</span><br><span class="line">testl .gz test2.gz test3.gz</span><br><span class="line">#原来gzip命令不会打包目录，而是把目录下所有的子文件分别压缩</span><br></pre></td></tr></table></figure>
<p>在 Linux 中，打包和压缩是分开处理的。而<code>gzip</code>命令只会压缩，不能打包，所以才会出现没有打包目录，而只把目录下的文件进行压缩的情况。</p>
<h1 id="gunzip命令：解压缩文件或目录"><a href="#gunzip命令：解压缩文件或目录" class="headerlink" title="gunzip命令：解压缩文件或目录"></a>gunzip命令：解压缩文件或目录</h1><p><code>gunzip</code>是一个使用广泛的解压缩命令，它用于解压被<code>gzip</code>压缩过的文件（扩展名为<code>.gz</code>）。</p>
<p>对于解压被<code>gzip</code>压缩过的文件，还可以使用<code>gzip</code>自己，即<code>gzip -d</code>压缩包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip [选项] 文件</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-r</td>
<td align="center">递归处理，解压缩指定目录下以及子目录下的所有文件。</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">把解压缩后的文件输出到标准输出设备。</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">强制解压缩文件，不理会文件是否已存在等情况。</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">列出压缩文件内容。</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示命令执行过程。</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">测试压缩文件是否正常，但不对其做解压缩操作。</td>
</tr>
</tbody></table>
<p>直接解压缩文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip install.log.gz</span><br></pre></td></tr></table></figure>
<p>当然，<code>gunzip -r</code>依然只会解压缩目录下的文件，而不会解打包。要想解压缩<code>.gz</code>格式，还可以使用<code>gzip -d</code>命令，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gzip -d anaconda-ks.cfg.gz</span><br></pre></td></tr></table></figure>
<p>要解压缩目录下的内容，则需使用<code>-r</code>选项，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gunzip -r test/</span><br></pre></td></tr></table></figure>
<p>注意，如果我们压缩的是一个纯文本文件，则可以直接使用<code>zcat</code>命令在不解压缩的情况下查看这个文本文件中的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# zcat anaconda-ks.cfg.gz</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Linux/文件和目录管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/08/15/Linux/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"
    >Linux文件和目录管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/08/15/Linux/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2021-08-15T08:24:15.000Z" itemprop="datePublished">2021-08-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h1><p>在 Linux 操作系统中，所有的文件和目录都被组织成以一个根节点“&#x2F;”开始的倒置的树状结构。</p>
<img src="/2021/08/15/Linux/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/1.gif" class="" title="Linux 系统文件和目录组织示意图">

<p>文件系统的最顶层是由根目录开始的，系统使用“&#x2F;”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。</p>
<h1 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a>命令基本格式</h1><h2 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h2><p>登录系统后，第一眼看到的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>
<p>这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢？</p>
<ul>
<li><code>[]</code>：这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>：显示的是当前的登录用户。</li>
<li><code>@</code>：分隔符号，没有特殊含义。</li>
<li><code>localhost</code>：当前系统的简写主机名（完整主机名是<code>localhost.localdomain</code>）。</li>
<li><code>~</code>：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是<code>$</code>。</li>
</ul>
<p>Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的主目录：</p>
<ul>
<li>超级用户的主目录：<code>/root</code>。</li>
<li>普通用户的主目录：<code>/home/用户名</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/local</span><br><span class="line">[root@localhost local]#</span><br></pre></td></tr></table></figure>
<p>如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录<code>/usr/ local</code>，只显示最后一个目录<code>local</code>)。</p>
<h2 id="命令的基本格式"><a href="#命令的基本格式" class="headerlink" title="命令的基本格式"></a>命令的基本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# 命令[选项][参数]</span><br></pre></td></tr></table></figure>
<p>命令格式中的<code>[]</code>代表可选项，也就是有些命令可以不写选项或参数，也能执行。</p>
<h3 id="1-选项的作用"><a href="#1-选项的作用" class="headerlink" title="1.选项的作用"></a>1.选项的作用</h3><p>Linux 的选项又分为短格式选项（<code>-l</code>）和长格式选项（<code>--all</code>）。短格式选项是英文的简写，用一个减号调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -l</span></span><br></pre></td></tr></table></figure>
<p>而长格式选项是英文完整单词，一般用两个减号调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls --all</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如<code>ls</code>命令的短格式选项<code>-l</code>就没有对应的长格式选项。</p>
<h3 id="2-参数的作用"><a href="#2-参数的作用" class="headerlink" title="2.参数的作用"></a>2.参数的作用</h3><p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -l anaconda-ks.cfg</span></span><br><span class="line">-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<p>命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg install.log install.log.syslog</span><br></pre></td></tr></table></figure>
<p>这个<code>ls</code>命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p>
<p>总结一下：命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</p>
<h1 id="cd命令：切换目录"><a href="#cd命令：切换目录" class="headerlink" title="cd命令：切换目录"></a>cd命令：切换目录</h1><p><code>cd</code>命令，是<code>Change Directory</code>的缩写，用来切换工作目录。</p>
<p>Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。内置命令是没有执行文件的；而外部命令是由程序员单独开发的，所以会有命令的执行文件。<code>cd</code>命令是一个 Shell 内置命令，所以<code>cd</code>命令没有执行文件所在路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd [相对路径或绝对路径]</span></span><br></pre></td></tr></table></figure>
<p><code>cd</code>命令后面可以跟一些特殊符号，表达固定的含义：</p>
<table>
<thead>
<tr>
<th align="center">特殊符号</th>
<th align="center">作 用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">~</td>
<td align="center">代表当前登录用户的主目录</td>
</tr>
<tr>
<td align="center">~用户名</td>
<td align="center">表示切换至指定用户的主目录</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">代表上次所在目录</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">代表当前目录</td>
</tr>
<tr>
<td align="center">..</td>
<td align="center">代表上级目录</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vbird]<span class="comment"># cd ~</span></span><br><span class="line"><span class="comment">#表示回到自己的主目录，对于 root 用户，其主目录为 /root</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd</span></span><br><span class="line"><span class="comment">#没有加上任何路径，也代表回到当前登录用户的主目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd ~vbird</span></span><br><span class="line"><span class="comment">#代表切换到 vbird 这个用户的主目录，亦即 /home/vbird</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd ..</span></span><br><span class="line"><span class="comment">#表示切换到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></span><br><span class="line">[root@localhost /]<span class="comment"># cd -</span></span><br><span class="line"><span class="comment">#表示回到刚刚的那个目录</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，在 Linux 系统中，根目录确实存在<code>.</code>（当前目录）以及<code>..</code>（当前目录的父目录）两个目录，但由于根目录是最顶级目录，因此根目录的<code>..</code>和<code>.</code>的属性和权限完全一致，也就是说，根目录的父目录是自身。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1-cd-的用法"><a href="#1-cd-的用法" class="headerlink" title="1. cd - 的用法"></a>1. cd - 的用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /usr/local/src</span></span><br><span class="line"><span class="comment">#进入/usr/local/src目录</span></span><br><span class="line">[root@localhost src]<span class="comment"># cd -</span></span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br><span class="line"><span class="comment">#&quot;cd -&quot;命令回到进入 src 目录之前的主目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd -</span></span><br><span class="line">/usr/local/src</span><br><span class="line">[root@localhost src]<span class="comment">#</span></span><br><span class="line"><span class="comment">#再执行一遍&quot;cd -&quot;命令，又回到了 /usr/local/src 目录</span></span><br></pre></td></tr></table></figure>
<h3 id="2-cd-和-cd-的用法"><a href="#2-cd-和-cd-的用法" class="headerlink" title="2. cd . 和 cd .. 的用法"></a>2. cd . 和 cd .. 的用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /usr/local/src</span></span><br><span class="line"><span class="comment">#进入测试目录</span></span><br><span class="line">[root@localhost src]<span class="comment"># cd ..</span></span><br><span class="line"><span class="comment">#进入上级目录</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/local</span><br><span class="line"><span class="comment">#pwd是査看当前所在目录的命令，可以看到我们进入了上级目录 /usr/local</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># cd .</span></span><br><span class="line"><span class="comment">#进入当前目录</span></span><br><span class="line">[root@localhost <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/local</span><br><span class="line"><span class="comment">#这个命令不会有目录的改变，只是告诉大家&quot;.&quot;代表当前目录</span></span><br></pre></td></tr></table></figure>
<h1 id="pwd命令：显示当前路径"><a href="#pwd命令：显示当前路径" class="headerlink" title="pwd命令：显示当前路径"></a>pwd命令：显示当前路径</h1><p>由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录（目前的工作目录）搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。</p>
<p><code>pwd</code>命令，是<code>Print Working Directory</code> （打印工作目录）的缩写，功能是显示用户当前所处的工作目录的绝对路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># pwd</span></span><br></pre></td></tr></table></figure>
<p><code>whoami</code>命令用于确定当前登陆的用户。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[demo@localhost ~]<span class="comment"># whoami</span></span><br><span class="line">demo</span><br><span class="line">[demo@localhost ~]<span class="comment"># pwd</span></span><br><span class="line">/home/demo</span><br></pre></td></tr></table></figure>
<p>以上代码表明，当前登陆 Linux 系统的是用户<code>demo</code>，当前所在目录为<code>demo</code>的主目录<code>/home/demo</code>。</p>
<p>注意，在<code>[demo@localhost ~]#</code>这一部分中，虽然也显示出当前所在的目录（例如<code>~</code>表示主目录），但此位置只会列出整个路径中最后的那一个目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /var/mail</span></span><br><span class="line">[root@localhost mail]<span class="comment"># pwd</span></span><br><span class="line">/var/mail</span><br></pre></td></tr></table></figure>
<p>不同的目录中，目录名是可以重复的，因此，仅通过<code>[root@localhost mail]</code>中的<code>mail</code>，根本无法判断其所在的具体位置，而使用<code>pwd</code>命令，可以输出当前所在目录的完整路径。</p>
<h1 id="ls命令：查看目录下文件"><a href="#ls命令：查看目录下文件" class="headerlink" title="ls命令：查看目录下文件"></a>ls命令：查看目录下文件</h1><p><code>ls</code>命令，<code>list</code>的缩写，其主要功能是显示当前目录下的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls [选项] 目录名称</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">显示全部的文件，包括隐藏文件（开头为 . 的文件）也一起罗列出来，这是最常用的选项之一。</td>
</tr>
<tr>
<td align="center">-A</td>
<td align="center">显示全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录。</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="center">仅列出目录本身，而不是列出目录内的文件数据。</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">ls 默认会以文件名排序，使用 -f 选项会直接列出结果，而不进行排序。</td>
</tr>
<tr>
<td align="center">-F</td>
<td align="center">在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，&#x2F; 代表目录，&#x3D; 代表 socket 文件，</td>
</tr>
<tr>
<td align="center">-h</td>
<td align="center">以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。</td>
</tr>
<tr>
<td align="center">-i</td>
<td align="center">显示 inode 节点信息。</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">使用长格式列出文件和目录信息。</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="center">以 UID 和 GID 分别代替文件用户名和群组名显示出来。</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。</td>
</tr>
<tr>
<td align="center">-R</td>
<td align="center">连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。</td>
</tr>
<tr>
<td align="center">-S</td>
<td align="center">以文件容量大小排序，而不是以文件名排序。</td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">以时间排序，而不是以文件名排序。</td>
</tr>
<tr>
<td align="center">–full-time</td>
<td align="center">以完整时间模式 （包含年、月、日、时、分）输出</td>
</tr>
</tbody></table>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>当<code>ls</code>命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色（蓝色显示目录，白色显示一般文件）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]<span class="comment"># ls -al ~</span></span><br><span class="line">total 156</span><br><span class="line">drwxr-x---  4 root root  4096 Sep 24 00:07 .</span><br><span class="line">drwxr-xr-x 23 root root  4096 Sep 22 12:09 ..</span><br><span class="line">-rw-------  1 root root  1474 Sep  4 18:27 anaconda-ks.cfg</span><br><span class="line">-rw-------  1 root root   955 Sep 24 00:08 .bash_history</span><br><span class="line">-rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout</span><br><span class="line">-rw-r--r--  1 root root   191 Jan  6  2007 .bash_profile</span><br><span class="line">-rw-r--r--  1 root root   176 Jan  6  2007 .bashrc</span><br><span class="line">drwx------  3 root root  4096 Sep  5 10:37 .gconf</span><br><span class="line">-rw-r--r--  1 root root 42304 Sep  4 18:26 install.log</span><br><span class="line">-rw-r--r--  1 root root  5661 Sep  4 18:25 install.log.syslog</span><br></pre></td></tr></table></figure>
<p>通过使用<code>-a</code>，你会看到以<code>.</code>为开头的几个文件，以及目录文件<code>（.）、（..）、.gconf</code>等等，这些都是隐藏的目录和文件。</p>
<p>不仅如此，这里的<code>ls</code>命令还使用了<code>-l</code>选项，因此才显示出了文件的详细信息，此选项显示的这 7 列的含义分别是：</p>
<ul>
<li>第一列：规定了不同的用户对文件所拥有的权限。</li>
<li>第二列：引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li>
<li>第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</li>
<li>第四列：所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li>
<li>第五列：大小，默认单位是字节。</li>
<li>第六列：文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li>
<li>第七列：文件名或目录名。</li>
</ul>
<h3 id="2-查看某个目录的详细信息"><a href="#2-查看某个目录的详细信息" class="headerlink" title="2.查看某个目录的详细信息"></a>2.查看某个目录的详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost usr]<span class="comment"># ls -l /usr/</span></span><br><span class="line">总用量44</span><br><span class="line">dr-xr-xr-x.  2 root root 20480 8月   4 19:11 bin</span><br><span class="line">drwxr-xr-x.  2 root root     6 4月  11 2018 etc</span><br><span class="line">drwxr-xr-x.  2 root root     6 4月  11 2018 games</span><br><span class="line">drwxr-xr-x. 34 root root  8192 8月   4 19:11 include</span><br><span class="line">drwxr-xr-x.  3 root root    60 8月   3 17:27 java</span><br><span class="line">dr-xr-xr-x. 28 root root  4096 8月   4 19:11 lib</span><br><span class="line">dr-xr-xr-x. 41 root root 28672 8月   4 19:11 lib64</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这个命令会显示目录下的内容，而不会显示这个目录本身的详细信息。如果想显示目录本身的信息，就必须加入<code>-d</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -ld /root/</span></span><br><span class="line">drwxr-xr-x. 15 root root 180 8月   3 17:58 /usr/</span><br></pre></td></tr></table></figure>
<h1 id="mkdir命令：创建目录（文件夹）"><a href="#mkdir命令：创建目录（文件夹）" class="headerlink" title="mkdir命令：创建目录（文件夹）"></a>mkdir命令：创建目录（文件夹）</h1><p><code>mkdir</code>命令，是<code>make directories</code>的缩写，用于创建新目录，此命令所有用户都可以使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir [-mp] 目录名</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>-m</code>选项用于手动配置所创建目录的权限，而不再使用默认权限。</li>
<li><code>-p</code>选项递归创建所有目录，以创建<code>/home/test/demo</code>为例，在默认情况下，你需要一层一层的创建各个目录，而使用<code>-p</code>选项，则系统会自动帮你创建<code>/home、/home/test</code>以及<code>/home/test/demo</code>。</li>
</ul>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h3 id="1-建立目录"><a href="#1-建立目录" class="headerlink" title="1.建立目录"></a>1.建立目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#mkdir cangls</span></span><br><span class="line">[root@localhost ~]<span class="comment">#ls</span></span><br><span class="line">anaconda-ks.cfg cangls install.log install.log.syslog</span><br></pre></td></tr></table></figure>
<p>注意，我们在建立目录的时候使用的是相对路径，所以这个目录被建立到当前目录下。</p>
<h3 id="2-使用-p-选项递归建立目录"><a href="#2-使用-p-选项递归建立目录" class="headerlink" title="2.使用 -p 选项递归建立目录"></a>2.使用 -p 选项递归建立目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir lm/movie/jp/cangls</span></span><br><span class="line"><span class="built_in">mkdir</span>:无法创建目录<span class="string">&quot;lm/movie/jp/cangls&quot;</span>:没有那个文件或目录</span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir -p lm/movie/jp/cangls</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">anaconda-ks.cfg cangls install.log install.log.syslog lm</span><br><span class="line">[root@localhost ~]<span class="comment"># ls lm/</span></span><br><span class="line">movie</span><br><span class="line"><span class="comment">#这里只查看一级子目录，其实后续的jp目录、cangls目录都已经建立</span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用-m-选项自定义目录权限"><a href="#3-使用-m-选项自定义目录权限" class="headerlink" title="3.使用 -m 选项自定义目录权限"></a>3.使用 -m 选项自定义目录权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -m 711 test2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -l</span></span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 <span class="built_in">test</span></span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure>
<h1 id="rmdir命令：删除空目录"><a href="#rmdir命令：删除空目录" class="headerlink" title="rmdir命令：删除空目录"></a>rmdir命令：删除空目录</h1><p>和<code>mkdir</code>命令（创建空目录）恰好相反，<code>rmdir</code>（<code>remove empty directories</code>的缩写）命令用于删除空目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rmdir [-p] 目录名</span></span><br></pre></td></tr></table></figure>
<p><code>-p</code>选项用于递归删除空目录。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#rmdir cangls</span></span><br></pre></td></tr></table></figure>
<p>命令后面加目录名称即可，但命令执行成功与否，取决于要删除目录是否是空目录，因为<code>rmdir</code>命令只能删除空目录。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p><code>rmdir</code>命令可以使用<code>-p</code>选项递归删除目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rmdir -p lm/movie/jp/cangls</span></span><br></pre></td></tr></table></figure>
<p>注意，此方式先删除最低一层地目录（这里先删除<code>cangls</code>），然后逐层删除上级目录，删除时也需要保证各级目录是空目录。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><code>rmdir</code>命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost <span class="comment"># mkdir test</span></span><br><span class="line"><span class="comment">#建立测试目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># touch test/boduo</span></span><br><span class="line">[root@localhost ~]<span class="comment"># touch test/longze</span></span><br><span class="line"><span class="comment">#在测试目录中建立两个文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rmdir test</span></span><br><span class="line"><span class="built_in">rmdir</span>:删除<span class="string">&quot;test&quot;</span>失败：目录非空</span><br></pre></td></tr></table></figure>
<h1 id="touch命令：创建文件及修改文件时间戳"><a href="#touch命令：创建文件及修改文件时间戳" class="headerlink" title="touch命令：创建文件及修改文件时间戳"></a>touch命令：创建文件及修改文件时间戳</h1><p><code>touch</code>命令不光可以用来创建文件（当指定操作文件不存在时，该命令会在当前位置建立一个空文件），此命令更重要的功能是修改文件的时间参数（但当文件存在时，会修改此文件的时间参数）。</p>
<p>Linux 系统中，每个文件主要拥有 3 个时间参数（通过<code>stat</code>命令进行查看），分别是文件的访问时间、数据修改时间以及状态修改时间：</p>
<ul>
<li>访问时间（<code>Access Time</code>，简称<code>atime</code>）：只要文件的内容被读取，访问时间就会更新。例如，使用<code>cat</code>命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间（<code>Modify Time</code>，简称<code>mtime</code>）：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间（<code>Change Time</code>，简称<code>ctime</code>）：当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch [选项] 文件名</span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-a</code>：只修改文件的访问时间；</li>
<li><code>-c</code>：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。</li>
<li><code>-d</code>：后面可以跟欲修订的日期，而不用当前的日期，即把文件的<code>atime</code>和<code>mtime</code>时间改为指定的时间。</li>
<li><code>-m</code>：只修改文件的数据修改时间。</li>
<li><code>-t</code>：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为<code>YYMMDDhhmm</code>。</li>
</ul>
<p>可以看到，<code>touch</code>命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变（更新为操作当前文件的真正时间）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#touch bols</span></span><br><span class="line"><span class="comment">#建立名为 bols 的空文件</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#ll --time=atime bols</span></span><br><span class="line"><span class="comment">#查看文件的访问时间</span></span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 25 21:23 bols</span><br><span class="line"><span class="comment">#文件上次的访问时间为 9 月 25 号 21：23</span></span><br><span class="line">[root@localhost ~]<span class="comment">#touch bols</span></span><br><span class="line">[root@localhost ~]<span class="comment">#ll --time=atime bols</span></span><br><span class="line">-rw-r--r-- 1 root root 0 May 15 16:36 bols</span><br><span class="line"><span class="comment">#而如果文件已经存在，则也不会报错，只是会修改文件的访问时间。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch -d &quot;2017-05-04 15:44&quot; bols</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll bols; ll --time=atime bols; ll --time=ctime bols</span></span><br><span class="line">-rw-r--r-- 1 root root 0 May 4 2017 bols</span><br><span class="line">-rw-r--r-- 1 root root 0 May 4 2017 bols</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep 25 21:40 bols</span><br><span class="line"><span class="comment">#ctime不会变为设定时间，但更新为当前服务器的时间</span></span><br></pre></td></tr></table></figure>
<h1 id="ln命令：建立链接（硬链接和软链接）文件"><a href="#ln命令：建立链接（硬链接和软链接）文件" class="headerlink" title="ln命令：建立链接（硬链接和软链接）文件"></a>ln命令：建立链接（硬链接和软链接）文件</h1><p>如果要想说清楚<code>ln</code>命令，则必须先解释下<code>ext</code>文件系统（Linux 文件系统）是如何工作的。分区的格式化就是写入文件系统，Linux 目前使用的是<code>ext4</code>文件系统。<code>ext4</code>文件系统：</p>
<img src="/2021/08/15/Linux/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/1.jpg" class="" title="ext4 文件系统示意图">

<p><code>ext4</code>文件系统会把分区主要分为两大部分：小部分用于保存文件的<code>inode</code> (<code>i</code>节点）信息；剩余的大部分用于保存<code>block</code>信息。</p>
<p><code>inode</code>的默认大小为<code>128 Byte</code>，用来记录文件的权限（<code>r、w、x</code>）、文件的所有者和属组、文件的大小、文件的状态改变时间（<code>ctime</code>）、文件的最近一次读取时间（<code>atime</code>）、文件的最近一次修改时间（<code>mtime</code>）、文件的数据真正保存的<code>block</code>编号。每个文件需要占用一个<code>inode</code>。<code>inode</code>中是不记录文件名的，那是因为文件名记录在文件所在目录的<code>block</code>中。</p>
<p><code>block</code>的大小可以是<code>1KB、2KB、4KB</code>，默认为<code>4KB</code>。<code>block</code>用于实际的数据存储，如果一个<code>block</code>放不下数据，则可以占用多个<code>block</code>。例如，有一个<code>10KB</code>的文件需要存储，则会占用 3 个<code>block</code>，虽然最后一个<code>block</code>不能占满，但也不能再放入其他文件的数据。这 3 个<code>block</code>有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息：</p>
<ul>
<li>每个文件都独自占用一个<code>inode</code>，文件内容由<code>inode</code>的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的<code>inode</code>，才能成功找到文件内容所在的<code>block</code>块；</li>
</ul>
<p><code>ln</code>命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种：</p>
<ul>
<li>软链接：类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接：文件的基本信息都存储在<code>inode</code>中，而硬链接指的就是给一个文件的<code>inode</code>分配多个文件名，通过任何一个文件名，都可以找到此文件的<code>inode</code>，从而读取该文件的数据信息。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ln [选项] 源文件 目标文件</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-s</code>：建立软链接文件。如果不加<code>-s</code>选项，则建立硬链接文件；</li>
<li><code>-f</code>：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><h3 id="1-创建硬链接"><a href="#1-创建硬链接" class="headerlink" title="1.创建硬链接"></a>1.创建硬链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch cangls</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ln /root/cangls /tmp</span></span><br><span class="line"><span class="comment">#建立硬链接文件，目标文件没有写文件名，会和原名一致</span></span><br><span class="line"><span class="comment">#也就是/tmp/cangls 是硬链接文件</span></span><br></pre></td></tr></table></figure>
<h3 id="2-创建软链接"><a href="#2-创建软链接" class="headerlink" title="2.创建软链接"></a>2.创建软链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch bols</span></span><br><span class="line">[root@localhost ~]<span class="comment"># In -s /root/bols /tmp</span></span><br><span class="line"><span class="comment">#建立软链接文件</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）；否则软链接文件会报错。</p>
<h1 id="cp命令：复制文件和目录"><a href="#cp命令：复制文件和目录" class="headerlink" title="cp命令：复制文件和目录"></a>cp命令：复制文件和目录</h1><p><code>cp</code>命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp [选项] 源文件 目标文件</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-a</code>：相当于<code>-d、-p、-r</code>选项的集合；</li>
<li><code>-d</code>：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接；</li>
<li><code>-i</code>：询问，如果目标文件已经存在，则会询问是否覆盖；</li>
<li><code>-l</code>：把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li>
<li><code>-s</code>：把目标文件建立为源文件的软链接文件，而不是复制源文件；</li>
<li><code>-p</code>：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；</li>
<li><code>-r</code>：递归复制，用于复制目录；</li>
<li><code>-u</code>：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li>
</ul>
<p>需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。<br>这里的软链接，类似于 Windows 系统中的快捷方式，而硬链接则是透过文件系统的<code>inode</code>号产生一个新的文件名。无论是复制软链接还是硬链接，都不是复制源文件。</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立源文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># touch cangls</span></span><br><span class="line"><span class="comment">#把源文件不改名复制到 /tmp/ 目录下</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp cangls /tmp/</span></span><br><span class="line"><span class="comment">#改名复制</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp cangls /tmp/bols</span></span><br></pre></td></tr></table></figure>
<p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为<code>cp</code>命令默认执行的是<code>cp -i</code>的别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp cangls /tmp/</span></span><br><span class="line"><span class="built_in">cp</span>:是否覆盖<span class="string">&quot;/tmp/cangls&quot;</span>?y</span><br><span class="line"><span class="comment">#目标位置有同名文件，所以会提示是否覆盖</span></span><br></pre></td></tr></table></figure>
<p>复制目录只需使用<code>-r</code>选项即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立测试目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir movie</span></span><br><span class="line"><span class="comment">#目录原名复制</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp -r /root/movie/ /tmp/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ln -s /root/cangls /tmp/cangls_slink</span></span><br><span class="line"><span class="comment">#建立一个测试软链接文件/tmp/cangls_slink</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll /tmp/cangls_slink</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 6 月 14 05:53 /tmp/cangls_slink -&gt; /root/cangls</span><br><span class="line"><span class="comment">#源文件本身就是一个软链接文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /tmp/cangls_slink /tmp/cangls_t1</span></span><br><span class="line"><span class="comment">#复制软链接文件，但是不加&quot;-d&quot;选项</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp -d /tmp/cangls_slink /tmp/cangls_t2</span></span><br><span class="line"><span class="comment">#复制软链接文件，加入&quot;-d&quot;选项</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll /tmp/cangls_t1 /tmp/cangls_t2</span></span><br><span class="line">-rw-r--r-- 1 root root 0 6月 14 05:56 /tmp/cangls_t1</span><br><span class="line"><span class="comment">#会发现不加&quot;-d&quot;选项，实际复制的是软链接的源文件，而不是软链接文件</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 6 月 14 05:56/tmp/ cangls_t2-&gt; /root/cangls</span><br><span class="line"><span class="comment">#而如果加入了&quot;-d&quot;选项，则会复制软链接文件</span></span><br></pre></td></tr></table></figure>
<p>这个例子说明，如果在复制软链接文件时不使用<code>-d</code>选项，则<code>cp</code>命令复制的是源文件，而不是软链接文件；只有加入了<code>-d</code>选项，才会复制软链接文件。请大家注意，<code>-d</code>选项对硬链接是无效的。</p>
<p>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cp /var/lib/mlocate/mlocate.db /tmp/</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll /var/lib/mlocate/mlocate.db</span></span><br><span class="line">-rw-r-----1 root slocate2328027 6月 14 02:08/var/lib/mlocate/mlocate.db</span><br><span class="line"><span class="comment">#注意源文件的时间和所属组</span></span><br><span class="line">[root@localhost ~]<span class="comment">#ll /tmp/mlocate.db</span></span><br><span class="line">-rw-r----- 1 root root2328027 6 月 14 06:05/tmp/mlocate.db</span><br><span class="line"><span class="comment">#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间</span></span><br></pre></td></tr></table></figure>
<p>而当我们执行备份、日志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行<code>-p</code>选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用&quot;-p&quot;选项</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span><br><span class="line">-rw-r----- root slocate 2328027 6月 14 02:08 /tmp/mlocate.db_2</span><br><span class="line">-rw-r----- root slocate 2328027 6月 14 02:08 /var/lib/mlocate/mlocate.db</span><br><span class="line"><span class="comment">#源文件和目标文件的所有属性都一致，包括时间</span></span><br></pre></td></tr></table></figure>
<p>当我们使用<code>-a</code>选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用<code>-a</code>选项来取代<code>-d、-p、-r</code>选项更加方便。</p>
<p>我们如果使用<code>-l</code>选项，则目标文件会被建立为源文件的硬链接；而如果使用了<code>-s</code>选项，则目标文件会被建立为源文件的软链接。</p>
<p>这两个选项和<code>&quot;-d&quot;</code>选项是不同的，<code>&quot;d&quot;</code>选项要求源文件必须是软链接，目标文件才会复制为软链接；而<code>-l</code>和<code>-s</code>选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch bols</span></span><br><span class="line"><span class="comment">#建立测试文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -i bols</span></span><br><span class="line">262154-rw-r--r-- 1 root root 0 6月 14 06:26 bols</span><br><span class="line"><span class="comment">#源文件只是一个普通文件，而不是软链接文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp -l /root/bols /tmp/bols_h</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp -s /root/bols /tmp/bols_s</span></span><br><span class="line"><span class="comment">#使用&quot;-l&quot; 和&quot;-s&quot;选项复制</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll -i /tmp/bols_h /tmp/bols_s</span></span><br><span class="line">262154-rw-r--r-- 2root root 0 6 月 14 06:26/tmp/bols_h</span><br><span class="line"><span class="comment">#目标文件 /tmp/bols_h 为源文件的硬链接文件</span></span><br><span class="line">932113 lrwxrwxrwx 1 root root 10 6 月 14 06:27/tmp/bols_s -&gt; /root/bols</span><br><span class="line"><span class="comment">#目标文件 /tmp/bols_s 为源文件的软链接文件</span></span><br></pre></td></tr></table></figure>
<h1 id="rm命令：删除文件或目录"><a href="#rm命令：删除文件或目录" class="headerlink" title="rm命令：删除文件或目录"></a>rm命令：删除文件或目录</h1><p><code>rm</code>是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用<code>rm</code>命令删除文件或目录时，系统不会产生任何提示信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rm[选项] 文件或目录</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-f</code>：强制删除（<code>force</code>），和<code>-i</code>选项相反，使用<code>-f</code>，系统将不再询问，而是直接删除目标文件或目录。</li>
<li><code>-i</code>：和<code>-f</code>正好相反，在删除文件或目录之前，系统会给出提示信息，使用<code>-i</code>可以有效防止不小心删除有用的文件或目录。</li>
<li><code>-r</code>：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li>
</ul>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h3><p><code>rm</code>命令如果任何选项都不加，则默认执行的是”<code>rm -i</code>文件名”，也就是在删除一个文件之前会先询问是否删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch cangls</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm cangls</span></span><br><span class="line"><span class="built_in">rm</span>:是否删除普通空文件<span class="string">&quot;cangls&quot;</span>?y</span><br><span class="line"><span class="comment">#删除前会询问是否删除</span></span><br></pre></td></tr></table></figure>
<h3 id="2-删除目录。"><a href="#2-删除目录。" class="headerlink" title="2.删除目录。"></a>2.删除目录。</h3><p>如果需要删除目录，则需要使用<code>-r</code>选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /test/lm/movie/jp</span></span><br><span class="line"><span class="comment">#递归建立测试目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm /test</span></span><br><span class="line"><span class="built_in">rm</span>:无法删除<span class="string">&quot;/test/&quot;</span>: 是一个目录</span><br><span class="line"><span class="comment">#如果不加&quot;-r&quot;选项，则会报错</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -r /test</span></span><br><span class="line"><span class="built_in">rm</span>:是否进入目录<span class="string">&quot;/test&quot;</span>?y</span><br><span class="line"><span class="built_in">rm</span>:是否进入目录<span class="string">&quot;/test/lm/movie&quot;</span>?y</span><br><span class="line"><span class="built_in">rm</span>:是否删除目录<span class="string">&quot;/test/lm/movie/jp&quot;</span>?y</span><br><span class="line"><span class="built_in">rm</span>:是否删除目录<span class="string">&quot;/test/lm/movie&quot;</span>?y</span><br><span class="line"><span class="built_in">rm</span>:是否删除目录<span class="string">&quot;/test/lm&quot;</span>?y</span><br><span class="line"><span class="built_in">rm</span>:是否删除目录<span class="string">&quot;/test&quot;</span>?y</span><br><span class="line"><span class="comment">#会分别询问是否进入子目录、是否删除子目录</span></span><br></pre></td></tr></table></figure>
<h3 id="3-强制删除"><a href="#3-强制删除" class="headerlink" title="3.强制删除"></a>3.强制删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir -p /test/lm/movie/jp</span></span><br><span class="line"><span class="comment">#重新建立测试目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm -rf /test</span></span><br><span class="line"><span class="comment">#强制删除，一了百了</span></span><br></pre></td></tr></table></figure>
<p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具。但要注意，数据恢复很难恢复完整的数据。</p>
<p>虽然<code>-rf</code>选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用<code>-rf</code>选项。</p>
<h1 id="mv命令：移动文件或改名"><a href="#mv命令：移动文件或改名" class="headerlink" title="mv命令：移动文件或改名"></a>mv命令：移动文件或改名</h1><p><code>mv</code>命令（<code>move</code>的缩写），既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mv [选项] 源文件 目标文件</span></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li><code>-f</code>：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li>
<li><code>-i</code>：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）；</li>
<li><code>-n</code>：如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li>
<li><code>-v</code>：显示文件或目录的移动过程；</li>
<li><code>-u</code>：若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mv cangls /tmp</span></span><br><span class="line"><span class="comment">#移动之后，源文件会被删除，类似剪切</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir movie</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mv movie/ /tmp</span></span><br><span class="line"><span class="comment">#也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 &quot;-r&quot; 选项</span></span><br></pre></td></tr></table></figure>
<p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为<code>mv</code>命令默认执行的也是<code>mv -i</code>的别名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># touch cangls</span></span><br><span class="line"><span class="comment">#重新建立文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mv cangls /tmp</span></span><br><span class="line"><span class="built_in">mv</span>:是否覆盖<span class="string">&quot;tmp/cangls&quot;</span>？y</span><br><span class="line"><span class="comment">#由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动</span></span><br></pre></td></tr></table></figure>
<p>如果源文件和目标文件在同一目录中，那就是改名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把 bols 改名为 lmls</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mv bols lmls</span></span><br></pre></td></tr></table></figure>
<p>目录也可以按照同样的方法改名。</p>
<h1 id="Linux命令的执行过程"><a href="#Linux命令的执行过程" class="headerlink" title="Linux命令的执行过程"></a>Linux命令的执行过程</h1><p>Linux 命令的执行过程分为如下 4 个步骤：</p>
<h2 id="1-判断路径"><a href="#1-判断路径" class="headerlink" title="1. 判断路径"></a>1. 判断路径</h2><p>判断用户是否以绝对路径或相对路径的方式输入命令（如<code>/bin/ls</code>），如果是的话直接执行。</p>
<h2 id="2-检查别名"><a href="#2-检查别名" class="headerlink" title="2. 检查别名"></a>2. 检查别名</h2><p>Linux 系统会检查用户输入的命令是否为“别名命令”。要知道，通过<code>alias</code>命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。</p>
<p>例如，我们经常使用的<code>rm</code>命令，其实就是<code>rm -i</code>这个整体的别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># alias rm</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这使得当使用<code>rm</code>命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># rm a.txt &lt;-- 假定当前目录中已经存在 a.txt 文件</span></span><br><span class="line"><span class="built_in">rm</span>: remove regular file <span class="string">&#x27;a.txt&#x27;</span>? y &lt;-- 手动输入 y，即确定删除</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>这里可以使用<code>unalias</code>命令，将 Linux 系统设置的<code>rm</code>别名删除掉：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># alias rm</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">[root@localhost ~]<span class="comment"># unalias rm</span></span><br><span class="line">[root@localhost ~]<span class="comment"># rm a.txt</span></span><br><span class="line">[root@localhost ~]<span class="comment"># &lt;--直接删除，不再询问</span></span><br></pre></td></tr></table></figure>
<h2 id="3-判断是内部命令还是外部命令"><a href="#3-判断是内部命令还是外部命令" class="headerlink" title="3. 判断是内部命令还是外部命令"></a>3. 判断是内部命令还是外部命令</h2><p>Linux命令行解释器（又称为 shell）会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。</p>
<p>内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。</p>
<p>判断一个命令属于内部命令还是外部命令，可以使用<code>type</code>命令实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># type pwd</span></span><br><span class="line"><span class="built_in">pwd</span> is a shell <span class="built_in">builtin</span> &lt;-- <span class="built_in">pwd</span>是内部命令</span><br><span class="line">[root@localhost ~]<span class="comment"># type top</span></span><br><span class="line">top is /usr/bin/top &lt;-- top是外部命令</span><br></pre></td></tr></table></figure>
<h2 id="4-查找外部命令对应的可执行文件"><a href="#4-查找外部命令对应的可执行文件" class="headerlink" title="4. 查找外部命令对应的可执行文件"></a>4. 查找外部命令对应的可执行文件</h2><p>当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为<code>PATH</code>环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在<code>PATH</code>变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。</p>
<h1 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h1><p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。</p>
<p>值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。</p>
<p>我们可以使用<code>env</code>命令来查看到 Linux 系统中所有的环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># env</span></span><br><span class="line">ORBIT_SOCKETDIR=/tmp/orbit-root</span><br><span class="line">HOSTNAME=livecd.centos</span><br><span class="line">GIO_LAUNCHED_DESKTOP_FILE_PID=2065</span><br><span class="line">TERM=xterm</span><br><span class="line">shell =/bin/bash</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>非常重要的环境变量：</p>
<table>
<thead>
<tr>
<th align="center">环境变量名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HOME</td>
<td align="center">用户的主目录（也称家目录）</td>
</tr>
<tr>
<td align="center">SHELL</td>
<td align="center">用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td align="center">PATH</td>
<td align="center">定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td align="center">EDITOR</td>
<td align="center">用户默认的文本解释器</td>
</tr>
<tr>
<td align="center">RANDOM</td>
<td align="center">生成一个随机数字</td>
</tr>
<tr>
<td align="center">LANG</td>
<td align="center">系统语言、语系名称</td>
</tr>
<tr>
<td align="center">HISTSIZE</td>
<td align="center">输出的历史命令记录条数</td>
</tr>
<tr>
<td align="center">HISTFILESIZE</td>
<td align="center">保存的历史命令记录条数</td>
</tr>
<tr>
<td align="center">PS1</td>
<td align="center">ash解释器的提示符</td>
</tr>
<tr>
<td align="center">MAIL</td>
<td align="center">邮件保存路径</td>
</tr>
</tbody></table>
<p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。</p>
<p>例如，使用下述命令来查看<code>HOME</code>变量在不同用户身份下都有哪些值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo $HOME</span></span><br><span class="line">/root</span><br><span class="line">[root@localhost ~]<span class="comment"># su - user1 &lt;--切换到 user1 用户身份</span></span><br><span class="line">[user1@localhost ~]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/user1</span><br></pre></td></tr></table></figure>
<p>其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为<code>WORKDIR</code>的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /home/work1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># WORKDIR=/home/work1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cd $WORKDIR</span></span><br><span class="line">[root@localhost work1]<span class="comment"># pwd</span></span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure>
<p>但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用<code>export</code>命令将其提升为全局环境变量，这样其他用户就可以使用它了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost work1]<span class="comment"># su user1 &lt;-- 切换到 user1，发现无法使用 WORKDIR 自定义变量</span></span><br><span class="line">[user1@localhost ~]$ <span class="built_in">cd</span> <span class="variable">$WORKDIR</span></span><br><span class="line">[user1@localhost ~]$ <span class="built_in">echo</span> <span class="variable">$WORKDIR</span></span><br><span class="line"></span><br><span class="line">[user1@localhost ~]$ <span class="built_in">exit</span> &lt;--退出user1身份</span><br><span class="line">[root@localhost work1]<span class="comment"># export WORKDIR</span></span><br><span class="line">[root@localhost work1]<span class="comment"># su user1</span></span><br><span class="line">[user1@localhost ~]$ <span class="built_in">cd</span> <span class="variable">$WORKDIR</span></span><br><span class="line">[user1@localhost work1]$ <span class="built_in">pwd</span></span><br><span class="line">/home/work1</span><br></pre></td></tr></table></figure>
<h2 id="PATH-环境变量及作用"><a href="#PATH-环境变量及作用" class="headerlink" title="PATH 环境变量及作用"></a>PATH 环境变量及作用</h2><p><code>which</code>命令，它用于查找某个命令所在的绝对路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># which rm</span></span><br><span class="line">/bin/rm</span><br><span class="line">[root@localhost ~]<span class="comment"># which rmdir</span></span><br><span class="line">/bin/rmdir</span><br><span class="line">[root@localhost ~]<span class="comment"># which ls</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">        /bin/ls</span><br></pre></td></tr></table></figure>
<p>注意，<code>ls</code>是一个相对特殊的命令，它使用<code>alias</code>命令做了别名，也就是说，我们常用的<code>ls</code>实际上执行的是<code>ls --color=auto</code>。</p>
<p>通过使用<code>which</code>命令，可以查找各个外部命令（和 shell 内置命令相对）所在的绝对路径。为什么前面在使用<code>rm、rmdir、ls</code>等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置（绝对路径）呢？其实，这是<code>PATH</code>环境变量在起作用。</p>
<p>首先，执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin</span><br></pre></td></tr></table></figure>
<p>这里的<code>echo</code>命令用来输出<code>PATH</code>环境变量的值（这里的<code>$</code>是<code>PATH</code>的前缀符号），<code>PATH</code>环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开。当执行某个命令时，Linux 会依照<code>PATH</code>中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。</p>
<p>如果在<code>PATH</code>包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。</p>
<p>从执行结果中可以看到，<code>/bin</code>目录已经包含在<code>PATH</code>环境变量中，因此在使用类似<code>rm、rmdir、ls</code>等命令时，即便直接使用其命令名，Linux 也可以找到该命令。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/14/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>