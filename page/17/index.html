<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-密码技术/单向散列函数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/15/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/"
    >单向散列函数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/15/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2020-12-15T02:46:22.000Z" itemprop="datePublished">2020-12-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/">密码技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是单向散列函数"><a href="#什么是单向散列函数" class="headerlink" title="什么是单向散列函数"></a>什么是单向散列函数</h1><p>单向散列函数有一个输入和一个输出。输入称为消息(<code>message</code>)，输出称为散列值(<code>hash value</code>)。</p>
<p>单向散列函数可以根据消息的内容计算出散列值，散列值可以被用来检查消息的完整性。</p>
<img src="/2020/12/15/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/img1.png" class="">

<p>这里的消息也可以是图像文件或声音文件。无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。</p>
<p>散列值的长度和消息的长度无关。无论消息是 1 比特还是 100MB，单向散列函数都会计算出固定长度的散列值。</p>
<p>SHA-256 单向散列函数计算出的散列值的长度永远是 256比特（32字节）。</p>
<p>单向散列函数的性质：</p>
<ul>
<li>根据任意长度的消息计算出固定长度的散列值</li>
<li>能够快速计算出散列值</li>
<li>消息不同散列值也不同</li>
<li>具备单向性：无法通过散列值反算出消息</li>
</ul>
<h1 id="单向散列函数的实际应用"><a href="#单向散列函数的实际应用" class="headerlink" title="单向散列函数的实际应用"></a>单向散列函数的实际应用</h1><ul>
<li>检测软件是否被篡改<br>很多软件都会把通过单向散列函数计算出的散列值公布在自己的网站上。用户在下载到软件之后，可以自行计算散列值，然后与官网上的散列值进行对比。通过散列值，用户可以确认自己下载的文件与软件作者所提供的文件是否一致。</li>
</ul>
<img src="/2020/12/15/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/img2.png" class="">

<ul>
<li>基于口令的加密<br>单向散列函数也被用于基于口令的加密(<code>Password Based Encryption, PBE</code>)。PBE 的原理是将口令和盐（<code>salt</code>，通过伪随机数生成器产生的随机值）混合后计算其散列值，然后将这个散列值用作加密的密钥。通过这样的方法能够防御针对口令的字典攻击。</li>
<li>消息认证码：使用单向散列函数可以构造消息认证码。消息认证码是将发送者和接收者之间的共享密钥和消息进行混合后计算出的散列值。</li>
<li>数字签名</li>
<li>伪随机数生成器</li>
<li>一次性口令</li>
</ul>
<h1 id="单向散列函数的具体例子"><a href="#单向散列函数的具体例子" class="headerlink" title="单向散列函数的具体例子"></a>单向散列函数的具体例子</h1><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>MD5 是 Rivest 设计的单向散列函数，能够产生 128 比特的散列值。MD5 的强抗碰撞性已经被攻破，现在已经能够产生具备相同散列值的两条不同消息，因此它不再安全。</p>
<p>MD 是消息摘要(Message Digest)的缩写。</p>
<h2 id="SHA-1、SHA-256、SHA-384、SHA-512"><a href="#SHA-1、SHA-256、SHA-384、SHA-512" class="headerlink" title="SHA-1、SHA-256、SHA-384、SHA-512"></a>SHA-1、SHA-256、SHA-384、SHA-512</h2><p>SHA-1 是一种能够产生 160 比特的散列值的单向散列函数。1993 年被作为美国联邦信息处理标准规格发布的是 SHA。1995 年发布的修订版称为 SHA-1。SHA-1 除了用于保持兼容的目的外，其他情况不推荐使用。</p>
<p>SHA-256、SHA-384、SHA-512 的散列值长度分别为 256 比特、384 比特和512 比特。这些单向散列函数合起来统称 SHA-2。</p>
<p>SHA-1 的强抗碰撞性已被攻破，SHA-2 还尚未被攻破。</p>
<h2 id="RIPEMD-160"><a href="#RIPEMD-160" class="headerlink" title="RIPEMD-160"></a>RIPEMD-160</h2><p>RIPEMD-160 是一种能够产生 160 比特的散列值的单向散列函数。RIPEMD-160 是 欧盟 RIPE 项目所设计的 RIPEMD 单向散列函数的修订版。这一系列还包括 RIPEMD-128、RIPEMD-256、RIPEMD-320等。</p>
<p>RIPEMD的强抗碰撞性已被攻破，RIPEMD-160 尚未被攻破。比特币中使用的就是 RIPEMD-160。</p>
<h2 id="SHA-3"><a href="#SHA-3" class="headerlink" title="SHA-3"></a>SHA-3</h2><p>用于取代 SHA-1 的 SHA-3 采用公开竞争的方式标准化，一个名叫 Keccak 的算法最终成为了 SHA-3。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/" rel="tag">密码技术</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-密码技术/分组密码的模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/"
    >分组密码的模式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-12-14T08:57:13.000Z" itemprop="datePublished">2020-12-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/">密码技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>AES 和 DES 都属于分组密码，它们只能加密固定长度的明文，如果要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的模式。</p>
<p>分组密码有很多种模式，如果模式的选择不恰当，就无法充分保证机密性。</p>
<h1 id="分组密码的模式"><a href="#分组密码的模式" class="headerlink" title="分组密码的模式"></a>分组密码的模式</h1><h2 id="分组密码与流密码"><a href="#分组密码与流密码" class="headerlink" title="分组密码与流密码"></a>分组密码与流密码</h2><p>密码算法可以分为分组密码和流密码两种。</p>
<p>分组密码时每次只能处理特定长度的一块数据的一类密码算法。这里的一块就称为分组。此外，一个分组的比特数就称为分组长度。</p>
<p>例如 DES 和 3DES 的分组长度都是 64 比特，这些密码算法一次只能加密 64 比特的明文，并生成 64 比特的密文。</p>
<p>AES 的分组长度为 128 比特，因此 AES 一次可加密 128 比特的明文，并生成 128 比特的密文。</p>
<p>流密码是对数据流进行连续处理的一类密码算法。流密码中一般以 1 比特、8 比特或 32 比特等为单位进行加密和解密。</p>
<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度。流密码是对一串数据流进行连续处理，因此需要保持内部状态。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>分组密码算法只能加密固定长度的分组，但我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式。</p>
<p>分组密码的主要模式有5种：</p>
<ul>
<li>ECB 模式：<code>Electronic CodeBook mode</code>（电子密码本模式）</li>
<li>CBC 模式：<code>Cipher Block Chaining mode</code>（密码分组链接模式）</li>
<li>CFB 模式：<code>Cipher FeedBack mode</code>（密文反馈模式）</li>
<li>OFB 模式：<code>Output FeedBack mode</code>（输出反馈模式）</li>
<li>CTR 模式：<code>CounTeR mode</code>（计数器模式）</li>
</ul>
<h2 id="明文分组和密文分组"><a href="#明文分组和密文分组" class="headerlink" title="明文分组和密文分组"></a>明文分组和密文分组</h2><p>明文分组是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</p>
<p>密文分组是指使用分组密码算法将明文分组加密之后所生成的密文。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img1.png" class="">

<h1 id="ECB-模式"><a href="#ECB-模式" class="headerlink" title="ECB 模式"></a>ECB 模式</h1><p>ECB 模式由于存在弱点因此通常不会被使用。</p>
<p>在 ECB 模式中，将明文分组加密之后的结果将直接成为密文分组。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img2.png" class="" title="ECB 模式">

<p>使用 ECB 模式加密时，相同的明文分组会被转换为相同的密文分组，也就是说，我们可以将其理解为是一个巨大的“明文分组-&gt;密文分组”的对应表，因此 ECB 模式也称为电子密码本模式。</p>
<p>当最后一个明文分组的内容小于分组长度时，需要用一些特定的数据进行填充(<code>padding</code>)。</p>
<h2 id="ECB-模式的特点"><a href="#ECB-模式的特点" class="headerlink" title="ECB 模式的特点"></a>ECB 模式的特点</h2><p>ECB 模式中，明文分组和密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此 ECB 模式是不安全的。</p>
<h1 id="CBC-模式"><a href="#CBC-模式" class="headerlink" title="CBC 模式"></a>CBC 模式</h1><p>在 CBC 模式中，首先将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img3.png" class="" title="CBC 模式">

<p>如果将一个分组的加密过程分离出来，我们就可以很容易的比较出 ECB 模式和 CBC 模式的区别：ECB 模式只进行了加密，CBC 模式在加密之前进行了一次 XOR。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img4.png" class="" title="ECB 模式 和 CBC 模式比较">

<h2 id="初始化向量"><a href="#初始化向量" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>当加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量(<code>Initialization Vector</code>)，通常缩写为<code>IV</code>。</p>
<p>一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。</p>
<h2 id="CBC模式的特点"><a href="#CBC模式的特点" class="headerlink" title="CBC模式的特点"></a>CBC模式的特点</h2><p>明文分组在加密之前一定会与“前一个密文分组”进行 XOR 运算，因此，即便明文分组 1 和 2 的值是相等的，密文分组 1 和 2 的值也不一定是相等的。这样一来，ECB 模式的缺陷在 CBC 模式中就不存在了。</p>
<p>在 CBC 模式的加密过程中，无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组 3，则至少需要凑齐明文分组 1、2、3.</p>
<p>在 CBC 模式的解密过程中，现在假设 CBC 模式加密的密文分组中有一个分组损坏了，在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只会有两个分组受到数据损坏的影响。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img7.png" class="">

<p>假设 CBC 模式的密文分组中有一些比特缺失了，那么即便只是缺失了 1 比特，也会导致密文分组的长度发生变化，此后的分组发生错位，这样一来，缺失比特的位置之后的密文分组也就全部无法解密了。</p>
<h2 id="对CBC模式的攻击"><a href="#对CBC模式的攻击" class="headerlink" title="对CBC模式的攻击"></a>对CBC模式的攻击</h2><p>假如主动攻击者的目的是通过修改密文来操纵解密后的明文。如果攻击者能够对初始化向量中的任意比特进行反转（即将 1 变为 0，0 变为 1），则明文分组（解密后得到的明文分组）中相应的比特也会被反转。这是因为在 CBC 模式的解密过程中，第一个明文分组会和初始化向量进行 XOR 运算。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img8.png" class="">
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img9.png" class="">

<p>这样，攻击者就可以对初始化向量进行攻击。</p>
<h2 id="填充提示攻击"><a href="#填充提示攻击" class="headerlink" title="填充提示攻击"></a>填充提示攻击</h2><p>填充提示攻击是一种利用分组密码中的填充部分来进行攻击的方法。在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据使其凑满一个分组长度。在填充提示攻击中，攻击者会反复发送一段密文，每次发送时都对填充的数据进行少许改变。由于接收者（服务器）在无法正确解密时会返回一个错误信息，攻击者通过这一错误消息就可以获得一部分与明文相关的信息。这一攻击方式并不仅限于 CBC 模式，而是适用于所有需要进行分组填充的模式。</p>
<h2 id="对初始化向量（IV）攻击"><a href="#对初始化向量（IV）攻击" class="headerlink" title="对初始化向量（IV）攻击"></a>对初始化向量（IV）攻击</h2><p>初始化向量<code>IV</code>必须使用不可预测的随机数</p>
<h2 id="CBC-模式的应用实例"><a href="#CBC-模式的应用实例" class="headerlink" title="CBC 模式的应用实例"></a>CBC 模式的应用实例</h2><p>SSL&#x2F;TLS 就是使用 CBC 模式来确保通信的机密性的，如使用 CBC 模式三重 DES 的 3DES_EDE_CBC 以及 CBC 模式 256 比特 AES 的 AES_256_CBC等。</p>
<h1 id="CFB-模式"><a href="#CFB-模式" class="headerlink" title="CFB 模式"></a>CFB 模式</h1><p>在 CFB 模式中，前一个密文分组会被送回到密码算法的输入端。所谓反馈，指的就是返回输入端的意思。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img10.png" class="">

<p>在 ECB 模式和 CBC 模式中，明文分组都是通过密码算法进行加密的，然而，在 CFB 模式中，明文分组并没有通过密码算法来直接进行加密。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img11.png" class="" title="CBC 模式与 CFB 模式的对比">

<h2 id="初始化向量-1"><a href="#初始化向量-1" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>在生成第一个密文分组时，由于不存在前一个输出的数据，因此需要使用初始化向量来代替，这一点和 CBC 模式是相同的。一般来说，我们需要在每次加密时生成一个不同的随机比特序列用作初始化向量。</p>
<h2 id="CFB-模式与流密码"><a href="#CFB-模式与流密码" class="headerlink" title="CFB 模式与流密码"></a>CFB 模式与流密码</h2><p>CFB 模式的结构与一次性密码本是非常相似的。一次性密码本是通过将明文与随机比特序列进行 XOR 运算来生成密文的。而 CFB 模式则是通过将明文分组与密码算法的输出进行 XOR 运算来生成密文分组的。在通过 XOR 来进行加密这一点上，两者是非常相似的。</p>
<p>在 CFB 模式中，密码算法的输出相当于一次性密码本中的随机比特序列。由于密码算法的输出是通过计算得到的，并不是真正的随机数，因此 CFB 模式不可能像一次性密码本那样具备理论上不可破译的性质。</p>
<p>CFB 模式中由密码算法所生成的比特序列称为密钥流。在 CFB 模式中，密码算法就相当于用来生成密钥流的伪随机数生成器，而初始化向量就相当于伪随机数生成器的种子。</p>
<p>在 CFB 模式中，明文数据可以被逐比特加密，因此我们可以将 CFB 模式看做是一种使用分组密码来实现流密码的方式。</p>
<h2 id="对-CFB-模式的攻击"><a href="#对-CFB-模式的攻击" class="headerlink" title="对 CFB 模式的攻击"></a>对 CFB 模式的攻击</h2><p>对 CFB 模式可以实施重放攻击。</p>
<p>有一天，发送者向接收者发送了一条消息，这条消息由 4 个密文分组组成。主动攻击者将该消息中的后 3 个密文分组保存了下来。转天，发送者又向接收者发送了内容不同的 4 个密文分组（假设发送者使用了相同的密钥）。攻击者用昨天保存下来的 3 个密文分组将今天发送的后 3 个密文分组进行了替换。</p>
<p>于是，当接收者解密时，4 个分组中就只有第一个可以解密成正确的明文分组，第二个会出错，而第三个和第四个则变成了被攻击者替换的内容。攻击者没有破解密码就成功的将以前的电文混入了新电文中。而第二个分组出错到底是通信错误还是被人攻击造成的，接收者是无法做出判断的。要做出这样的判断，需要使用消息认证码。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img12.png" class="" title="对 CFB 进行重放攻击">

<h1 id="OFB-模式"><a href="#OFB-模式" class="headerlink" title="OFB 模式"></a>OFB 模式</h1><p>在 OFB 模式中，密码算法的输出会反馈到密码算法的输入中。</p>
<p>OFB 模式并不是通过密码算法对明文直接进行加密的，而是通过将明文分组和密码算法的输出进行 XOR 来产生密文分组的。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img13.png" class="">
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img14.png" class="">

<h2 id="初始化向量-2"><a href="#初始化向量-2" class="headerlink" title="初始化向量"></a>初始化向量</h2><p>和 CBC 模式、CFB 模式一样，OFB 模式也需要使用初始化向量(IV)。需要在每次加密时生成一个不同的随机比特序列用作初始化向量。</p>
<h2 id="CFB-模式与-OFB-模式对比"><a href="#CFB-模式与-OFB-模式对比" class="headerlink" title="CFB 模式与 OFB 模式对比"></a>CFB 模式与 OFB 模式对比</h2><p>OFB 模式和 CFB 模式的区别仅仅在于密码算法的输入。</p>
<p>CFB 模式中，密码算法的输入是前一个密文分组，也就是将密文分组反馈到密码算法中，因此有了密文反馈模式这个名字。</p>
<p>OFB 模式中，密码算法的输入是密码算法的前一个输出，也就是将输出反馈给密码算法，因此有了输出反馈模式这个名字。</p>
<p>如果将一个分组抽出来对 CFB 模式和 OFB 模式进行一个对比，就可以很容易看出它们之间的差异。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img15.png" class="">

<p>由于 CFB 模式中是对密文分组进行反馈的，因此必须从第一个明文分组开始按顺序进行加密，也就是说无法跳过明文分组 1 而先对明文分组 2 进行加密。</p>
<p>相对的，在 OFB 模式中，XOR 所需要的比特序列（密钥流）可以事先通过密码算法生成，和明文分组无关。只要提前准备好所需的密钥流，则在实际从明文生成密文的过程中，就完全不需要动用密码算法了，只要将明文与密文流进行 XOR 就可以了。和 AES 等密码算法相比，XOR 运算的速度非常快。这就意味着只要提前准备好密钥流就可以快速完成加密。换个角度看，生成密钥流的操作和进行 XOR 运算的操作是可以并行的。</p>
<h1 id="CTR-模式"><a href="#CTR-模式" class="headerlink" title="CTR 模式"></a>CTR 模式</h1><p>CTR 模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。</p>
<p>CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列与明文分组进行 XOR 得到的。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img5.png" class="">

<h2 id="计数器的生成方法"><a href="#计数器的生成方法" class="headerlink" title="计数器的生成方法"></a>计数器的生成方法</h2><p>每次加密都会生成一个不同的值(<code>nonce</code>)来作为计数器的初始值。当分组长度为 128 比特（16字节）时，计数器初始值可能是像下面这样的形式。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img6.png" class="">

<p>其中前 8 个字节为<code>nonce</code>，这个值在每次加密时必须都是不同的。后 8 个字节为分组序号，这个部分是会逐次累加的。</p>
<p>在加密的过程中，计数器的值会产生如下变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01 // 明文分组1的计数器（初始值）</span><br><span class="line">66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 02 // 明文分组2的计数器</span><br><span class="line">66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 03 // 明文分组3的计数器</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的。也就是说，这种方法就是用分组密码来模拟生成随机的比特序列。</p>
<h2 id="OFB-模式与-CTR-模式的对比"><a href="#OFB-模式与-CTR-模式的对比" class="headerlink" title="OFB 模式与 CTR 模式的对比"></a>OFB 模式与 CTR 模式的对比</h2><p>CTR 模式和 OFB 模式一样，都属于流密码。如果我们将单个分组的加密过程拿出来，那么 OFB 模式和 CTR 模式之间的差异还是很容易理解的。OFB 模式是将加密的输出反馈到输入，而 CTR 模式则是将计数器的值用作输入。</p>
<img src="/2020/12/14/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%A8%A1%E5%BC%8F/img16.png" class="">

<h2 id="CTR-模式的特点"><a href="#CTR-模式的特点" class="headerlink" title="CTR 模式的特点"></a>CTR 模式的特点</h2><p>CTR 模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。</p>
<p>此外，CTR 模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的计数器的值可以由<code>nonce</code>和分组序号直接计算出来。这一性质是 OFB 模式所不具备的。</p>
<p>能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR 模式的速度非常快。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/" rel="tag">密码技术</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-密码技术/对称密码"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/"
    >对称密码</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/" class="article-date">
  <time datetime="2020-12-10T03:25:51.000Z" itemprop="datePublished">2020-12-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/">密码技术</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>计算机的操作对象是由 0 和 1 排列而成的比特序列。无论是文字、图像、声音、视频还是程序，在计算机中都是用比特序列来表示的。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。</p>
<p>将现实世界中的东西映射为比特序列的操作称为编码(<code>encoding</code>)。例如<code>midnight</code>这个单词，我们可以对其中的每一个字母逐一进行编码，这种编码规则叫 ASCII。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m  -&gt;  01101101</span><br><span class="line">i  -&gt;  01101001</span><br><span class="line">d  -&gt;  01100100</span><br><span class="line">n  -&gt;  01101110</span><br><span class="line">i  -&gt;  01101001</span><br><span class="line">g  -&gt;  01100111</span><br><span class="line">h  -&gt;  01101000</span><br><span class="line">t  -&gt;  01110100</span><br></pre></td></tr></table></figure>
<h2 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h2><p>XOR(<code>exclusive or</code>)异或运算。</p>
<h3 id="1个比特的XOR"><a href="#1个比特的XOR" class="headerlink" title="1个比特的XOR"></a>1个比特的XOR</h3><p>1个比特的XOR运算规则如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 XOR 0 = 0</span><br><span class="line">0 XOR 1 = 1</span><br><span class="line">1 XOR 0 = 1</span><br><span class="line">1 XOR 1 = 0</span><br></pre></td></tr></table></figure>
<p>可以将 0 理解为偶数，1理解为奇数，就可以将 XOR 和加法运算等同起来。</p>
<p>由于 XOR 和加法运算很相似，因此一般用 + 和 O 组合而成的符号 ⊕ 来表示 XOR。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 ⊕ 0 = 0</span><br><span class="line">0 ⊕ 1 = 1</span><br><span class="line">1 ⊕ 0 = 1</span><br><span class="line">1 ⊕ 1 = 0</span><br></pre></td></tr></table></figure>
<p>规律：两个相同的数进行 XOR 运算的结果一定为 0。</p>
<h3 id="比特序列的-XOR"><a href="#比特序列的-XOR" class="headerlink" title="比特序列的 XOR"></a>比特序列的 XOR</h3><p>长比特序列之间的 XOR 运算只需对其中每个相对应的比特进行 XOR 运算就可以了。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img1.png" class="">

<p>由于两个相同的数进行 XOR 运算的结果一定为 0，因此如果将 A ⊕ B 的结果再与 B 进行 XOR 运算，则结果会变回 A。也就是说，两个公式中的 B 会相互抵消。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img2.png" class="">

<p>上面的计算和加密、解密的步骤非常相似。</p>
<ul>
<li>将明文 A 用密钥 B 进行加密，得到密文 A ⊕ B</li>
<li>将密文 A ⊕ B 用密钥 B 进行解密，得到明文 A</li>
</ul>
<h2 id="一次性密码本"><a href="#一次性密码本" class="headerlink" title="一次性密码本"></a>一次性密码本</h2><p>只要通过暴力破解法对密钥空间进行遍历，无论什么密文总有一天也能够被破译。一次性密码本是个例外，即便使用暴力破解法遍历整个密钥空间，一次性密码本也绝对无法被破译。</p>
<h3 id="一次性密码本的加密"><a href="#一次性密码本的加密" class="headerlink" title="一次性密码本的加密"></a>一次性密码本的加密</h3><p>一次性密码本的原理是将明文与一串随机的比特序列进行 XOR 运算。</p>
<p>下面将明文<code>midnight</code>这个字符串通过 ASCII 进行编码并产生一串比特序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m         i         d         n         i         g         h         t</span><br><span class="line">01101101  01101001  01100100  01101110  01101001  01100111  01101000  01110100</span><br></pre></td></tr></table></figure>
<p>明文被编码为一串 64 比特的比特序列。</p>
<p>然后再来产生一个和明文长度相同的 64 比特的随机比特序列，这个序列就是 XOR 加密的密钥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01101011  11111010  01001000  11011000  01100101  11010101  10101111  00011100</span><br></pre></td></tr></table></figure>
<p>将明文与密钥的比特序列进行 XOR 运算，并得到一串新的比特序列，这次运算的结果就是一次性密码本的密文。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img3.png" class="">

<p>这样产生的比特序列如果要显示在计算机上，看上去就像乱码一样，因此密文通常不会被还原成字符，而是被作为二进制数据来处理。</p>
<h3 id="一次性密码本的解密"><a href="#一次性密码本的解密" class="headerlink" title="一次性密码本的解密"></a>一次性密码本的解密</h3><p>解密就是加密的反向运算。也就是说，用密文和密钥进行 XOR 运算就可以得到明文。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img4.png" class="">

<h3 id="一次性密码本是无法破译的"><a href="#一次性密码本是无法破译的" class="headerlink" title="一次性密码本是无法破译的"></a>一次性密码本是无法破译的</h3><p>这里说的无法破译并不是指在现实的时间内难以破译，而是指即使拥有一种运算能力无穷大的计算机，可以在一瞬间遍历任意大小的密钥空间，也依然无法破译。</p>
<p>我们假设对一次性密码本的密文尝试进行暴力破解，那么总有一天我们会尝试到和加密时相同的密钥，也就能解除明文<code>midnight</code>，这时毋庸置疑的事实。然而，即使我们能解密出<code>midnight</code>这个字符串，我们也无法判断它是否是正确的明文。</p>
<p>这是因为在对一次性密码本尝试解密的过程中，所有的 64 比特的排列组合都会出现，这其中既会包含像<code>aaaaaaaa</code>、<code>abcdefg</code>、<code>ZZZZZZZZ</code>这样的规则字符串，也会包含<code>midnight</code>、<code>onenight</code>、<code>mistress</code>等英文单词，还会包含<code>%Ta_AjvX</code>、<code>ER#f6</code>等看不懂的组合。由于明文中所有可能的排列组合都会出现，因此我们无法判断其中哪一个才是正确的明文。</p>
<p>所谓暴力破解，就是按顺序将所有的密钥都尝试一遍，并判断所得到的是不是正确的明文的方法。</p>
<p>在一次性密码本中，由于我们无法判断得到的是不是正确的明文，因此一次性密码本是无法破译的。</p>
<h3 id="一次性密码本为什么没有被使用"><a href="#一次性密码本为什么没有被使用" class="headerlink" title="一次性密码本为什么没有被使用"></a>一次性密码本为什么没有被使用</h3><h4 id="密钥的配送"><a href="#密钥的配送" class="headerlink" title="密钥的配送"></a>密钥的配送</h4><p>接收者收到了发送者发来的密文，接收者要想进行解密，就必须使用和发送者进行加密时相同的密钥，因此发送者必须将密钥也发给接收者，且该密钥的长度和密文是相等的。但这样就产生了一个矛盾：如果能有一种方法将密钥安全的发出去，那么岂不是也可以用同样的方法来安全的发送明文吗？</p>
<h4 id="密钥的保存"><a href="#密钥的保存" class="headerlink" title="密钥的保存"></a>密钥的保存</h4><p>为了保护明文，就需要保护和明文一样长的密钥。密钥不能丢弃或删除，因为没有密钥就无法解密，丢弃密钥就等于丢弃明文。也就是说，我们只是将保护明文这一命题替换成了保护和明文一样长的密钥而已，问题没有得到实质性的解决。</p>
<h4 id="密钥的重用"><a href="#密钥的重用" class="headerlink" title="密钥的重用"></a>密钥的重用</h4><p>在一次性密码本中绝对不能重用过去用过的随机比特序列，因为作为密钥的比特序列一旦泄露，过去所有的机密通信内容将全部被解密。</p>
<h4 id="密钥的同步"><a href="#密钥的同步" class="headerlink" title="密钥的同步"></a>密钥的同步</h4><p>当明文很长时，一次性密码本的密钥也会跟着变长。而且在通信过程中，发送者和接收者的密钥比特序列不允许有任何错位，否则错位的比特后的所有信息都将无法解密。</p>
<h4 id="密钥的生成"><a href="#密钥的生成" class="headerlink" title="密钥的生成"></a>密钥的生成</h4><p>在一次性密码本中，需要生成大量的随机数。这里的随机数必须是无重现性的真正随机数。出于这个原因，能够真正使用一次性密码本的，只有那些机密性重过一切，且可以花费大量财力和人力来生成并配送密钥的场合。</p>
<p>综上所述，一次性密码本是一种几乎没有实用价值的密码。</p>
<h1 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h1><p>随着计算机的进步，现在 DES 已经能够被暴力破解，因此除了用它来解密以前的密文外，不应该再使用 DES 了。</p>
<h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>DES 是一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，它的密钥长度是 56 比特。尽管从规格上来说，DES 的密钥长度是 64 比特，但由于每隔 7 比特会设置一个用于错误检查的比特，因此实质上其密钥长度是 56 比特。</p>
<p>DES 是以 64 比特的明文（比特序列）为一个单位来进行加密的，这个 64 比特的单位称为分组。一般来说，以分组为单位进行处理的密码算法称为分组密码(<code>block cipher</code>)，DES 就是分组密码的一种。</p>
<p>DES 每次只能加密 64 比特的数据，如果要加密的明文比较长，就需要对 DES 加密进行迭代，而迭代的具体方式就称为模式。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img9.png" class="" title="DES 的加密与解密">

<h2 id="DES-的结构（Feistel-网络）"><a href="#DES-的结构（Feistel-网络）" class="headerlink" title="DES 的结构（Feistel 网络）"></a>DES 的结构（Feistel 网络）</h2><p>DES 的基本结构是由 Horst Feistel 设计的，因此也称为 Feistel 网络、Feistel 结构。</p>
<p>在 Feistel 网络中，加密的各个步骤称为轮，整个加密过程就是进行若干次轮的循环。</p>
<p>下图是 Feistel 网络中一轮的计算流程。DES 是一种 16 轮循环的 Feistel 网络。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img10.png" class="" title="Feistel 网络中的一轮">

<p>上图中，子密钥指的是本轮加密所使用的密钥。在 Feistel 网络中，每一轮都需要使用一个不同的子密钥。</p>
<p>轮函数的作用是根据右侧和子密钥生成对左侧进行加密的比特序列，它是密码系统的核心。将轮函数的输出与左侧进行 XOR 运算，其结果是加密后的左侧。也就是说，我们用 XOR 将轮函数的输出与左侧进行了合并。而输入的右侧则会直接成为输出的右侧。</p>
<p>一轮的具体计算步骤：</p>
<ol>
<li>将输入的数据等分为左右两部分</li>
<li>将输入的右侧直接发送到输出的右侧</li>
<li>将输入的右侧发送到轮函数</li>
<li>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的比特序列</li>
<li>将上一步得到的比特序列与左侧数据进行 XOR 运算，并将结果作为加密后的左侧</li>
</ol>
<p>但是这样一来右侧根本没有被加密，因此我们需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧的数据对调。</p>
<p>下图展示了一个 3 轮的 Feistel 网络，3 轮加密计算需要进行两次左右对调。对调只在两轮之间进行，最后一轮结束之后不需要对调。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img11.png" class="" title="Feistel 网络的加密(3轮)">

<p>将一轮加密的输出结果用相同的子密钥重新运行一次，无论轮函数的具体算法是什么，都能将密文正确的还原为明文。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img12.png" class="">

<p>有多个轮的情况下也是一样。也就是说，Feistel 网络的解密操作只要按照相反的顺序来使用子密钥就可以完成了，而 Feistel 网络本身的结构，在加密和解密时都是完全相同的。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img13.png" class="" title="Feistel 网络的解密(3轮)">

<p>Feistel 网络的性质：</p>
<ul>
<li>Feistel 网络的轮数可以任意增加。无论进行多少轮的加密计算，都不会发生无法解密的情况。</li>
<li>加密时无论使用任何函数作为轮函数都可以正确解密。轮函数可以无需考虑解密的问题，可以被设计的任意复杂。</li>
<li>加密和解密可以用完全相同的结构来实现，因此用于实现 DES 算法的硬件设备的设计也变容易了。</li>
</ul>
<p>综上所述，无论是任意轮数，任何轮函数，Feistel 网络都可以用相同的结构实现加密和解密，且加密的结果必定能够正确解密。</p>
<h1 id="三重-DES"><a href="#三重-DES" class="headerlink" title="三重 DES"></a>三重 DES</h1><p>现在 DES 可以被暴力破解，因此我们需要一种用来替代 DES 的分组密码，三重 DES 就是出于这个目的被开发出来的。</p>
<p>三重 DES 是将 DES 重复 3 次所得到的一种密码算法，缩写为 3DES。</p>
<h2 id="三重-DES-的加密"><a href="#三重-DES-的加密" class="headerlink" title="三重 DES 的加密"></a>三重 DES 的加密</h2><p>下图是 3DES 的加密机制。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img14.png" class="" title="3DES 的加密">

<h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p>AES(<code>Advanced Encryption Standard</code>) 是取代其前任标准（DES）而成为新标准的一种对称密码算法。</p>
<h2 id="Rijndael"><a href="#Rijndael" class="headerlink" title="Rijndael"></a>Rijndael</h2><p>Rijndael 是由密码学家 Joan Daemen 和 Vincent Rijmen 设计的分组密码算法，于 2000 年被选为新一代的标准密码算法——AES。</p>
<p>Rijndael 的分组长度和密钥长度可以分别以 32 比特为单位在 128 比特到 256 比特的范围内进行选择。不过在 AES 的规格中，分组长度固定为 128 比特，密钥长度只有 128、192 和 256 比特三种。</p>
<h2 id="Rijndael-的加密和解密"><a href="#Rijndael-的加密和解密" class="headerlink" title="Rijndael 的加密和解密"></a>Rijndael 的加密和解密</h2><p>和 DES 一样，Rijndael 算法也是由多个轮构成的，其中每一轮分为<code>SubBytes</code>、<code>ShiftRows</code>、<code>MixColumns</code>和<code>AddRoundKey</code>共 4 个步骤。DES 使用 Feistel 网络作为其基本结构，而 Rijndael 没有使用 Feistel 网络，而是使用了 SPN 结构。</p>
<p>Rijndael 的输入分组为 128 比特，也就是 16字节。首先，需要逐个字节的对 16 字节的输入数据<code>SubBytes</code>处理。所谓<code>SubBytes</code>，就是以每个字节（0~255 的任意值）的值为索引，从一张拥有 256 个值的替换表中查找出对应值的处理。也就是说，要将一个 1 字节的值替换成另一个 1 字节的值。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img5.png" class="">

<p><code>SubBytes</code>之后需要进行<code>ShiftRows</code>处理，这一步是将以 4 字节为单位的行按照一定的规则向左平移，且每一行平移的字节数是不同的。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img6.png" class="">

<p><code>ShiftRows</code>之后需要进行<code>MixColumns</code>处理。这一步是对一个 4 字节的值进行比特运算，将其变为另外一个 4 字节值。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img7.png" class="" title="混合列">

<p>最后，需要将<code>MixColumns</code>的输出与轮密钥进行 XOR，即进行<code>AddRoundKey</code>处理。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img8.png" class="" title="与轮密钥进行 XOR">

<p>到这里，Rijndael 的一轮就结束了。实际上，在 Rijndael 中需要重复进行 10~14轮计算。</p>
<p>通过上面的结构可以发现输入的所有比特在一轮中都会被加密。和每一轮都只加密一半输入的比特的 Feistel 网络相比，这种方式的优势在于加密所需要的的轮数更少。此外，<code>SubBytes、ShifRows</code>和<code>MixColumns</code>可以分别以字节、行和列为单位进行并行计算。</p>
<p>在 Rijndael 的加密过程中，每一轮所进行的处理为：<code>SubBytes -&gt; ShifRows -&gt; MixColumns -&gt; AddRoundKey</code>。</p>
<p>在解密时，则是按照相反的顺序来进行的，即<code>AddRoundKey -&gt; InvMixColumns -&gt; InvShifRows -&gt; InvSubBytes</code>。其中，<code>AddRoundKey</code>是与轮密钥进行 XOR 运算，因此这一步在加密和解密时是完全相同的，剩下的步骤中名字前面都带有<code>Inv</code>，表示与原始步骤相对应的逆运算。</p>
<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img15.png" class="" title="InvMixColumns">

<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img16.png" class="" title="InvShifRows">

<img src="/2020/12/10/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/img17.png" class="" title="InvSubBytes"> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/" rel="tag">密码技术</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java 注解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/15/java/%E5%9F%BA%E7%A1%80/Java%20%E6%B3%A8%E8%A7%A3/"
    >Java 注解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/15/java/%E5%9F%BA%E7%A1%80/Java%20%E6%B3%A8%E8%A7%A3/" class="article-date">
  <time datetime="2020-11-15T03:31:41.000Z" itemprop="datePublished">2020-11-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>注解（<code>Annotation</code>）都是<code>@</code>符号开头的。</p>
<p>注解并不能改变程序的运行结果，也不会影响程序运行的性能。有些注解可以在编译时给用户提示或警告，有的注解可以在运行时读写字节码文件信息。</p>
<p>注解可以用元数据这个词来描述，即一种描述数据的数据。所以可以说注解就是源代码的元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码重写了<code>Object</code>类的<code>toString()</code>方法并使用了<code>@Override</code>注解。如果不使用<code>@Override</code>注解标记代码，程序也能够正常执行。使用<code>@Override</code>注解就相当于告诉编译器这个方法是一个重写方法，如果父类中不存在该方法，编译器便会报错，提示该方法没有重写父类中的方法。这样可以防止不小心拼写错误造成麻烦。</p>
<p>注解常见的作用有以下几种：</p>
<ul>
<li>生成帮助文档。这是最常见的，也是 Java 最早提供的注解。常用的有<code>@see、@param</code>和<code>@return</code>等；</li>
<li>跟踪代码依赖性，实现替代配置文件功能。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量；</li>
<li>在编译时进行格式检查。如把<code>@Override</code>注解放在方法前，如果这个方法并不是重写了父类方法，则编译时就能检查出。</li>
</ul>
<p>无论是哪一种注解，本质上都是一种接口类型。到 Java 8 为止 Java SE 提供了 11 个内置注解。其中有 5 个是基本注解，它们来自于<code>java.lang</code>包。有 6 个是元注解，它们来自于<code>java.lang.annotation</code>包，自定义注解会用到元注解。</p>
<blockquote>
<p>提示：元注解就是负责注解其他的注解。</p>
</blockquote>
<p>基本注解包括：<code>@Override、@Deprecated、@SuppressWarnings、@SafeVarargs</code>和<code>@FunctionalInterface</code>。</p>
<h1 id="Override注解"><a href="#Override注解" class="headerlink" title="@Override注解"></a>@Override注解</h1><p><code>@Override</code>注解是用来指定方法重写的，只能修饰方法并且只能用于方法重写，不能修饰其它的元素。它可以强制一个子类必须重写父类方法或者实现接口的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">t0String</span><span class="params">()</span> &#123; <span class="comment">//toString()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码第 6 行是重写<code>Object</code>类的<code>toString()</code>方法，该方法使用<code>@Override</code>注解。如果<code>toString()</code>不小心写成了<code>t0String()</code>，那么程序会发生编译错误。</p>
<p>所以<code>@Override</code>的作用是告诉编译器检查这个方法，保证父类要包含一个被该方法重写的方法，否则就会编译出错。这样可以避免一些低级错误。</p>
<p>当然如果代码中的方法前面不加<code>@Override</code>注解，即便是方法编辑错误了，编译器也不会有提示。这时<code>Object</code>父类的<code>toString()</code>方法并没有被重写，将会引起程序出现 Bug。</p>
<h1 id="Deprecated注解"><a href="#Deprecated注解" class="headerlink" title="@Deprecated注解"></a>@Deprecated注解</h1><p><code>@Deprecated</code>可以用来注解类、接口、成员方法和成员变量等，用于表示某个元素（类、方法等）已过时。当其他程序使用已过时的元素时，编译器将会给出警告。</p>
<p>Java 9 为<code>@Deprecated</code>注解增加了以下两个属性：</p>
<ul>
<li><code>forRemoval</code>：该<code>boolean</code>类型的属性指定该 API 在将来是否会被删除。</li>
<li><code>since</code>：该<code>String</code>类型的属性指定该 API 从哪个版本被标记为过时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="comment">// since属性指定从哪个版本开始被标记成过时，forRemoval指定该API将来会被删除</span></span><br><span class="line">  <span class="meta">@Deprecated(since = &quot;9&quot;, forRemoval = true)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeprecatedTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 下面使用info()方法时将会被编译器警告</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Test</span>().print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的第 12 行代码使用了<code>Test</code>的<code>print()</code>方法，而<code>Test</code>类中定义<code>print()</code>方法时使用了<code>@Deprecated</code>修饰，表明该方法已过时，所以将会引起编译器警告。</p>
<p><code>@Deprecated</code>的作用与文档注释中的<code>@deprecated</code>标记的作用基本相同，但它们的用法不同，前者无须放在文档注释语法（<code>/** ... */</code>部分）中，而是直接用于修饰程序中的程序单元，如方法、类和接口等。</p>
<h1 id="SuppressWarnings：抑制编译器警告"><a href="#SuppressWarnings：抑制编译器警告" class="headerlink" title="@SuppressWarnings：抑制编译器警告"></a>@SuppressWarnings：抑制编译器警告</h1><p><code>@SuppressWarnings</code>注解指示被该注解修饰的程序元素（以及该程序元素中的所有子元素）取消显示指定的编译器警告，且会一直作用于该程序元素的所有子元素。例如，使用<code>@SuppressWarnings</code>修饰某个类取消显示某个编译器警告，同时又修饰该类里的某个方法取消显示另一个编译器警告，那么该方法将会同时取消显示这两个编译器警告。</p>
<p><code>@SuppressWarnings</code>注解主要用在取消一些编译器产生的警告对代码左侧行列的遮挡，有时候这样会挡住我们断点调试时打的断点。</p>
<p>如果你确认程序中的警告没有问题，可以不用理会。通常情况下，如果程序中使用没有泛型限制的集合将会引起编译器警告，为了避免这种编译器警告，可以使用<code>@SuppressWarnings</code>注解消除这些警告。</p>
<p>注解的使用有以下三种：</p>
<ul>
<li>抑制单类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li>
<li>抑制多类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;)</code></li>
<li>抑制所有类型的警告：<code>@SuppressWarnings(&quot;unchecked&quot;)</code></li>
</ul>
<p>抑制警告的关键字如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">all</td>
<td align="center">抑制所有警告</td>
</tr>
<tr>
<td align="center">boxing</td>
<td align="center">抑制装箱、拆箱操作时候的警告</td>
</tr>
<tr>
<td align="center">cast</td>
<td align="center">抑制映射相关的警告</td>
</tr>
<tr>
<td align="center">dep-ann</td>
<td align="center">抑制启用注释的警告</td>
</tr>
<tr>
<td align="center">deprecation</td>
<td align="center">抑制过期方法警告</td>
</tr>
<tr>
<td align="center">fallthrough</td>
<td align="center">抑制在 switch 中缺失 breaks 的警告</td>
</tr>
<tr>
<td align="center">finally</td>
<td align="center">抑制 finally 模块没有返回的警告</td>
</tr>
<tr>
<td align="center">hiding</td>
<td align="center">抑制相对于隐藏变量的局部变量的警告</td>
</tr>
<tr>
<td align="center">incomplete-switch</td>
<td align="center">忽略不完整的 switch 语句</td>
</tr>
<tr>
<td align="center">nls</td>
<td align="center">忽略非 nls 格式的字符</td>
</tr>
<tr>
<td align="center">null</td>
<td align="center">忽略对 null 的操作</td>
</tr>
<tr>
<td align="center">rawtypes</td>
<td align="center">使用 generics 时忽略没有指定相应的类型</td>
</tr>
<tr>
<td align="center">restriction</td>
<td align="center">抑制禁止使用劝阻或禁止引用的警告</td>
</tr>
<tr>
<td align="center">serial</td>
<td align="center">忽略在 serializable 类中没有声明 serialVersionUID 变量</td>
</tr>
<tr>
<td align="center">static-access</td>
<td align="center">抑制不正确的静态访问方式警告</td>
</tr>
<tr>
<td align="center">synthetic-access</td>
<td align="center">抑制子类没有按最优方法访问内部类的警告</td>
</tr>
<tr>
<td align="center">unchecked</td>
<td align="center">抑制没有进行类型检查操作的警告</td>
</tr>
<tr>
<td align="center">unqualified-field-access</td>
<td align="center">抑制没有权限访问的域的警告</td>
</tr>
<tr>
<td align="center">unused</td>
<td align="center">抑制没被使用过的代码的警告</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123; &quot;deprecation&quot; &#125;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.setNameAndAge(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    p.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SafeVarargs注解"><a href="#SafeVarargs注解" class="headerlink" title="@SafeVarargs注解"></a>@SafeVarargs注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 传递可变参数，参数是泛型集合</span></span><br><span class="line">    display(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 传递可变参数，参数是非泛型集合</span></span><br><span class="line">    display(<span class="string">&quot;10&quot;</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 会有编译警告</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(T... array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T arg : array) &#123;</span><br><span class="line">      System.out.println(arg.getClass().getName() + <span class="string">&quot;:&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码第 8 行声明了一种可变参数方法<code>display</code>，<code>display</code>方法参数个数可以变化，它可以接受不确定数量的相同类型的参数。可以通过在参数类型名后面加入…的方式来表示这是可变参数。可变参数方法中的参数类型相同，为此声明参数是需要指定泛型。</p>
<p>但是调用可变参数方法时，应该提供相同类型的参数，代码第 4 行调用时没有警告，而代码第 6 行调用时则会发生警告，这个警告是<code>unchecked</code>（未检查不安全代码），就是因为将非泛型变量赋值给泛型变量所发生的。</p>
<p>可用<code>@SafeVarargs</code>注解抑制编译器警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 传递可变参数，参数是泛型集合</span></span><br><span class="line">    display(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// 传递可变参数，参数是非泛型集合</span></span><br><span class="line">    display(<span class="string">&quot;10&quot;</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 没有@SafeVarargs会有编译警告</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@SafeVarargs</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(T... array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T arg : array) &#123;</span><br><span class="line">      System.out.println(arg.getClass().getName() + <span class="string">&quot;：&quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码在可变参数<code>display</code>前添加了<code>@SafeVarargs</code>注解，当然也可以使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解，但是两者相比较来说<code>@SafeVarargs</code>注解更适合。</p>
<p>注意：<code>@SafeVarargs</code>注解不适用于非<code>static</code>或非<code>final</code>声明的方法，对于未声明为<code>static</code>或<code>final</code>的方法，如果要抑制<code>unchecked</code>警告，可以使用<code>@SuppressWarnings</code>注解。</p>
<h1 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h1><p>如果接口中只有一个抽象方法（可以包含多个默认方法或多个<code>static</code>方法），那么该接口就是函数式接口。<code>@FunctionalInterface</code>就是用来指定某个接口必须是函数式接口，所以<code>@FunInterface</code>只能修饰接口，不能修饰其它程序元素。</p>
<p>函数式接口就是为 Java 8 的<code>Lambda</code>表达式准备的，Java 8 允许使用<code>Lambda</code>表达式创建函数式接口的实例，因此 Java 8 专门增加了<code>@FunctionalInterface</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FunInterface</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;zhangsaan&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>; <span class="comment">// 只定义一个抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上面程序，可能丝毫看不出程序中的<code>@FunctionalInterface</code>有何作用，因为<code>@FunctionalInterface</code>注解的作用只是告诉编译器检查这个接口，保证该接口只能包含一个抽象方法，否则就会编译出错。如果在上面的<code>FunInterface</code>接口中再增加一个抽象方法<code>abc()</code>，编译程序时将出现如下错误提示：<br><code>“@FunctionInterface”批注无效；FunInterface不是functional接口</code>。</p>
<h1 id="元注解作用及使用"><a href="#元注解作用及使用" class="headerlink" title="元注解作用及使用"></a>元注解作用及使用</h1><p>元注解是负责对其它注解进行说明的注解，自定义注解时可以使用元注解。Java 5 定义了 4 个注解，分别是<code>@Documented、@Target、@Retention</code>和<code>@Inherited</code>。Java 8 又增加了<code>@Repeatable</code>和<code>@Native</code>两个注解。这些注解都可以在<code>java.lang.annotation</code>包中找到。</p>
<h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p><code>@Documented</code>是一个标记注解，没有成员变量。用<code>@Documented</code>注解修饰的注解类会被 JavaDoc 工具提取成文档。默认情况下，JavaDoc 是不包括注解的，但如果声明注解时指定了<code>@Documented</code>，就会被 JavaDoc 之类的工具处理，所以注解类型信息就会被包括在生成的帮助文档中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyDocumented &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;这是@Documented注解&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类：</span></span><br><span class="line"><span class="meta">@MyDocumented</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DocumentedTest</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试document</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@MyDocumented</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p><code>@Target</code>注解用来指定一个注解的使用范围，即被<code>@Target</code>修饰的注解可以用在什么地方。<code>@Target</code>注解有一个成员变量（<code>value</code>）用来设置适用目标，<code>value</code>是<code>java.lang.annotation.ElementType</code>枚举类型的数组，下表为<code>ElementType</code>常用的枚举常量。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CONSTRUCTOR</td>
<td align="center">用于构造方法</td>
</tr>
<tr>
<td align="center">FIELD</td>
<td align="center">用于成员变量（包括枚举常量）</td>
</tr>
<tr>
<td align="center">LOCAL_VARIABLE</td>
<td align="center">用于局部变量</td>
</tr>
<tr>
<td align="center">METHOD</td>
<td align="center">用于方法</td>
</tr>
<tr>
<td align="center">PACKAGE</td>
<td align="center">用于包</td>
</tr>
<tr>
<td align="center">PARAMETER</td>
<td align="center">用于类型参数</td>
</tr>
<tr>
<td align="center">TYPE</td>
<td align="center">用于类、接口（包括注解类型）或 enum 声明</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTarget &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="meta">@MyTarget</span></span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码第 4 行会编译错误，错误信息为：<code>The annotation @MyTarget is disallowed for this location</code>。提示此位置不允许使用注解<code>@MyDocumented</code>，<code>@MyTarget</code>不能修饰成员变量，只能修饰方法。</p>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p><code>@Retention</code>用于描述注解的生命周期，也就是该注解被保留的时间长短。<code>@Retention</code>注解中的成员变量（<code>value</code>）用来设置保留策略，<code>value</code>是<code>java.lang.annotation.RetentionPolicy</code>枚举类型，<code>RetentionPolicy</code>有 3 个枚举常量。</p>
<ul>
<li><code>SOURCE</code>：在源文件中有效（即源文件保留）</li>
<li><code>CLASS</code>：在<code>class</code>文件中有效（即 class 保留）</li>
<li><code>RUNTIME</code>：在运行时有效（即运行时保留）</li>
</ul>
<p>生命周期大小排序为<code>SOURCE &lt; CLASS &lt; RUNTIME</code>，前者能使用的地方后者一定也能使用。如果需要在运行时去动态获取注解信息，那只能用<code>RUNTIME</code>注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如<code>ButterKnife</code>），就用<code>CLASS</code>注解；如果只是做一些检查性的操作，比如<code>@Override</code>和<code>@SuppressWarnings</code>，则可选用<code>SOURCE</code>注解。</p>
<h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p><code>@Inherited</code>是一个标记注解，用来指定该注解可以被继承。使用<code>@Inherited</code>注解的<code>Class</code>类，表示这个注解可以被用于该<code>Class</code>类的子类。就是说如果某个类使用了被<code>@Inherited</code>修饰的注解，则其子类将自动具有该注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个自定义注解</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyInherited &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试类代码如下：</span></span><br><span class="line"><span class="meta">@MyInherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestA</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(TestA.class.getAnnotation(MyInherited.class));</span><br><span class="line">    System.out.println(TestB.class.getAnnotation(MyInherited.class));</span><br><span class="line">    System.out.println(TestC.class.getAnnotation(MyInherited.class));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestB</span> <span class="keyword">extends</span> <span class="title class_">TestA</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestC</span> <span class="keyword">extends</span> <span class="title class_">TestB</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 运行结果为：</span></span><br><span class="line"><span class="comment">//@MyInherited()</span></span><br><span class="line"><span class="comment">//@MyInherited()</span></span><br><span class="line"><span class="comment">//@MyInherited()</span></span><br></pre></td></tr></table></figure>
<h2 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h2><p><code>@Repeatable</code>注解是 Java 8 新增加的，它允许在相同的程序元素中重复注解，在需要对同一种注解多次使用时，往往需要借助<code>@Repeatable</code>注解。Java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。</p>
<p>Java 8 之前的做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Roles &#123;</span><br><span class="line">  Role[] roles();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Roles &#123;</span><br><span class="line">  Role[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleTest</span> &#123;</span><br><span class="line">  <span class="meta">@Roles(roles = &#123;@Role(roleName = &quot;role1&quot;), @Role(roleName = &quot;role2&quot;)&#125;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">doString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 8 之后增加了重复注解，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Roles &#123;</span><br><span class="line">  Role[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable(Roles.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Role &#123;</span><br><span class="line">  String <span class="title function_">roleName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleTest</span> &#123;</span><br><span class="line">  <span class="meta">@Role(roleName = &quot;role1&quot;)</span></span><br><span class="line">  <span class="meta">@Role(roleName = &quot;role2&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">doString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的地方是，创建重复注解<code>Role</code>时加上了<code>@Repeatable</code>注解，指向存储注解<code>Roles</code>，这样在使用时就可以直接重复使用<code>Role</code>注解。从上面例子看出，使用<code>@Repeatable</code>注解更符合常规思维，可读性强一点。</p>
<p>两种方法获得的效果相同。重复注解只是一种简化写法，这种简化写法是一种假象，多个重复注解其实会被作为“容器”注解的<code>value</code>成员的数组元素处理。</p>
<h2 id="Native"><a href="#Native" class="headerlink" title="@Native"></a>@Native</h2><p>使用<code>@Native</code>注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。<code>@Native</code>注解不常使用。</p>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p>声明自定义注解使用<code>@interface</code>关键字实现。定义注解与定义接口非常像。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的注解类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码声明了一个<code>Test</code>注解。默认情况下，注解可以在程序的任何地方使用，通常用于修饰类、接口、方法和变量等。</p>
<p>定义注解和定义类相似，注解前面的访问修饰符和类一样有两种，分别是公有访问权限（<code>public</code>）和默认访问权限（默认不写）。一个源程序文件中可以声明多个注解，但只能有一个是公有访问权限的注解。且源程序文件命名和公有访问权限的注解名一致。</p>
<p>不包含任何成员变量的注解称为标记注解，例如上面声明的<code>Test</code>注解以及基本注解中的<code>@Override</code>注解都属于标记注解。根据需要，注解中可以定义成员变量，成员变量以无形参的方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTag &#123;</span><br><span class="line">  <span class="comment">// 定义带两个成员变量的注解</span></span><br><span class="line">  <span class="comment">// 注解中的成员变量以方法的形式来定义</span></span><br><span class="line">  String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中声明了一个<code>MyTag</code>注解，定义了两个成员变量，分别是<code>name</code>和<code>age</code>。成员变量也可以有访问权限修饰符，但是只能有公有权限和默认权限。</p>
<p>如果在注解里定义了成员变量，那么使用该注解时就应该为它的成员变量指定值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="comment">// 使用带成员变量的注解时，需要为成员变量赋值</span></span><br><span class="line">  <span class="meta">@MyTag(name=&quot;xx&quot;, age=6)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解中的成员变量也可以有默认值，可使用<code>default</code>关键字。如下代码定义了<code>@MyTag</code>注解，该注解里包含了<code>name</code>和<code>age</code>两个成员变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTag &#123;</span><br><span class="line">  <span class="comment">// 定义了两个成员变量的注解</span></span><br><span class="line">  <span class="comment">// 使用default为两个成员变量指定初始值</span></span><br><span class="line">  String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果为注解的成员变量指定了默认值，那么使用该注解时就可以不为这些成员变量赋值，而是直接使用默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="comment">// 使用带成员变量的注解</span></span><br><span class="line">  <span class="comment">// MyTag注释的成员变量有默认值，所以可以不为它的成员变量赋值</span></span><br><span class="line">  <span class="meta">@MyTag</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以在使用<code>MyTag</code>注解时为成员变量指定值，如果为<code>MyTag</code>的成员变量指定了值，则默认值不会起作用。</p>
<p>根据注解是否包含成员变量，可以分为如下两类。</p>
<ul>
<li>标记注解：没有定义成员变量的注解类型被称为标记注解。这种注解仅利用自身的存在与否来提供信息，<code>@Override、@Test</code>等都是标记注解。</li>
<li>元数据注解：包含成员变量的注解，因为它们可以接受更多的元数据，所以也被称为元数据注解。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java输入输出流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"
    >Java 输入输出流</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/" class="article-date">
  <time datetime="2020-11-14T08:31:41.000Z" itemprop="datePublished">2020-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h1><p>Java 程序通过流来完成输入&#x2F;输出，所有的输入&#x2F;输出以流的形式处理。</p>
<p>输入就是将数据从各种输入设备（包括文件、键盘等）中读取到内存中，输出则正好相反，是将数据写入到各种输出设备（比如文件、显示器、磁盘等）。</p>
<p>数据流是 Java 进行 I&#x2F;O 操作的对象，它按照不同的标准可以分为不同的类别。</p>
<ul>
<li>按照流的方向主要分为输入流和输出流两大类。</li>
<li>数据流按照数据单位的不同分为字节流和字符流。</li>
<li>按照功能可以划分为节点流和处理流。</li>
</ul>
<p>数据流的处理只能按照数据序列的顺序来进行，即前一个数据处理完之后才能处理后一个数据。数据流以输入流的形式被程序获取，再以输出流的形式将数据输出到其它设备。</p>
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/1.png" class="" title="输入流模式">
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/2.png" class="" title="输出流模式">

<h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p>Java 流相关的类都封装在<code>java.io</code>包中，而且每个数据流都是一个对象。所有输入流类都是<code>InputStream</code>抽象类（字节输入流）和<code>Reader</code>抽象类（字符输入流）的子类。</p>
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/3.png" class="" title="InputStream类的层次结构图">

<p><code>InputStream</code>类中所有方法遇到错误时都会引发<code>IOException</code>异常。如下是该类中包含的常用方法。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流读入一个 8 字节的数据，将它转换成一个 0~ 255 的整数，返回一个整数，如果遇到输入流的结尾返回 -1</td>
</tr>
<tr>
<td align="center">int read(byte[] b)</td>
<td align="center">从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，返回的字节数表示读取的字节数，如果遇到输入流的结尾返回 -1</td>
</tr>
<tr>
<td align="center">int read(byte[] b,int off,int len)</td>
<td align="center">从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，其中 off 是指在数组中开始保存数据位置的起始下标，len 是指读取字节的位数。返回的是实际读取的字节数，如果遇到输入流的结尾则返回 -1</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭数据流，当完成对数据流的操作之后需要关闭数据流</td>
</tr>
<tr>
<td align="center">int available()</td>
<td align="center">返回可以从数据源读取的数据流的位数。</td>
</tr>
<tr>
<td align="center">skip(long n)</td>
<td align="center">从输入流跳过参数 n 指定的字节数目</td>
</tr>
<tr>
<td align="center">boolean markSupported()</td>
<td align="center">判断输入流是否可以重复读取，如果可以就返回 true</td>
</tr>
<tr>
<td align="center">void mark(int readLimit)</td>
<td align="center">如果输入流可以被重复读取，从流的当前位置开始设置标记，readLimit 指定可以设置标记的字节数</td>
</tr>
<tr>
<td align="center">void reset()</td>
<td align="center">使输入流重新定位到刚才被标记的位置，这样可以重新读取标记过的数据</td>
</tr>
</tbody></table>
<p>上述最后 3 个方法一般会结合在一起使用，首先使用<code>markSupported()</code>判断，如果可以重复读取，则使用<code>mark(int readLimit)</code>方法进行标记，标记完成之后可以使用<code>read()</code>方法读取标记范围内的字节数，最后使用<code>reset()</code>方法使输入流重新定位到标记的位置，继而完成重复读取操作。</p>
<p>Java 中的字符是 Unicode 编码，即双字节的，而<code>InputerStream</code>是用来处理单字节的，在处理字符文本时不是很方便。这时可以使用文本输入流<code>Reader</code>类，该类是字符输入流的抽象类，即所有字符输入流的实现都是它的子类，该类的方法与<code>InputerSteam</code>类的方法类似。</p>
<h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>所有输出流类都是<code>OutputStream</code>抽象类（字节输出流）和<code>Writer</code>抽象类（字符输出流）的子类。其中<code>OutputStream</code>类是字节输出流的抽象类，是所有字节输出流的父类。</p>
<img src="/2020/11/14/java/%E5%9F%BA%E7%A1%80/Java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/4.png" class="" title="OutputStream类的层次结构图">

<p><code>OutputStream</code>类用于以二进制的形式将数据写入目标设备，该类是抽象类，不能被实例化。<code>OutputStream</code>类提供了一系列跟数据输出有关的方法。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int write(b)</td>
<td align="center">将指定字节的数据写入到输出流</td>
</tr>
<tr>
<td align="center">int write (byte[] b)</td>
<td align="center">将指定字节数组的内容写入输出流</td>
</tr>
<tr>
<td align="center">int write (byte[] b,int off,int len)</td>
<td align="center">将指定字节数组从 off 位置开始的 len 字节的内容写入输出流</td>
</tr>
<tr>
<td align="center">close()</td>
<td align="center">关闭数据流，当完成对数据流的操作之后需要关闭数据流</td>
</tr>
<tr>
<td align="center">flush()</td>
<td align="center">刷新输出流，强行将缓冲区的内容写入输出流</td>
</tr>
</tbody></table>
<h1 id="系统流"><a href="#系统流" class="headerlink" title="系统流"></a>系统流</h1><p>每个 Java 程序运行时都带有一个系统流，系统流对应的类为<code>java.lang.System</code>。<code>Sytem</code>类封装了 Java 程序运行时的 3 个系统流，分别通过<code>in、out</code>和<code>err</code>变量来引用。</p>
<ul>
<li><code>System.in</code>：标准输入流，默认设备是键盘。</li>
<li><code>System.out</code>：标准输出流，默认设备是控制台。</li>
<li><code>System.err</code>：标准错误流，默认设备是控制台。</li>
</ul>
<p>以上变量的作用域为<code>public</code>和<code>static</code>，因此在程序的任何部分都不需引用<code>System</code>对象就可以使用它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] byteData = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>]; <span class="comment">// 声明一个字节数组</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请输入英文：&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.in.read(byteData);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;您输入的内容如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; byteData.length; i++) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) byteData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>System.in</code>是<code>InputStream</code>类的一个对象，因此上述代码的<code>System.in.read()</code>方法实际是访问<code>InputStream</code>类定义的<code>read()</code>方法。该方法可以从键盘读取一个或多个字符。对于<code>System.out</code>输出流主要用于将指定内容输出到控制台。</p>
<p><code>System.out</code>和<code>System.error</code>是<code>PrintStream</code>类的对象。因为<code>PrintStream</code>是一个从<code>OutputStream</code>派生的输出流，所以它还执行低级别的<code>write()</code>方法。因此，除了<code>print()</code>和<code>println()</code>方法可以完成控制台输出以外，<code>System.out</code>还可以调用<code>write()</code>方法实现控制台输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void write(int byteval) throws IOException</span><br></pre></td></tr></table></figure>
<p>该方法通过<code>byteval</code>参数向文件写入指定的字节。在实际操作中，<code>print()</code>方法和<code>println()</code>方法比<code>write()</code>方法更常用。</p>
<p>注意：尽管它们通常用于对控制台进行读取和写入字符，但是这些都是字节流。因为预定义流是没有引入字符流的 Java 原始规范的一部分，所以它们不是字符流而是字节流，但是在 Java 中可以将它们打包到基于字符的流中使用。</p>
<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>计算机中，任何的文字都是以指定的编码方式存在的，最常见的是 ISO8859-1、GBK&#x2F;GB2312、Unicode、 UTF 编码。</p>
<ul>
<li>ISO8859-1：属于单字节编码，最多只能表示 0~255 的字符范围。</li>
<li>GBK&#x2F;GB2312：中文的国标编码，用来表示汉字，属于双字节编码。GBK 可以表示简体中文和繁体中文，而 GB2312 只能表示简体中文。GBK 兼容 GB2312。</li>
<li>Unicode：是一种编码规范，是为解决全球字符通用编码而设计的。UTF-8 和 UTF-16 是这种规范的一种实现，此编码不兼容 ISO8859-1 编码。Java 内部采用此编码。</li>
<li>UTF：UTF 编码兼容了 ISO8859-1 编码，同时也可以用来表示所有的语言字符，不过 UTF 编码是不定长编码，每一个字符的长度为 1~6 个字节不等。一般在中文网页中使用此编码，可以节省空间。</li>
</ul>
<p>在程序中如果处理不好字符编码，就有可能出现乱码问题。例如现在本机的默认编码是 GBK，但在程序中使用了 ISO8859-1 编码，则就会出现字符的乱码问题。为了避免产生乱码，程序编码应与本地的默认编码保持一致。</p>
<p>本地的默认编码可以使用<code>System</code>类查看。Java 中 System 类可以取得与系统有关的信息，所以直接使用此类可以找到系统的默认编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title function_">getProperty</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>使用上述方法可以查看 JVM 的默认编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前系统编码</span></span><br><span class="line">  System.out.println(<span class="string">&quot;系统默认编码：&quot;</span> + System.getProperty(<span class="string">&quot;file.encoding&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果如下：</span></span><br><span class="line"><span class="comment">// 系统默认编码：GBK</span></span><br></pre></td></tr></table></figure>
<p>现在本地的默认编码是 GBK，下面通过 ISO8859-1 编码对文字进行编码转换。如果要实现编码的转换可以使用<code>String</code>类中的<code>getBytes(String charset)</code>方法，此方法可以设置指定的编码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charset);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 实例化输出流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">    <span class="comment">// 指定ISO8859-1编码</span></span><br><span class="line">    <span class="type">byte</span> b[] = <span class="string">&quot;hello！&quot;</span>.getBytes(<span class="string">&quot;ISO8859-1&quot;</span>);</span><br><span class="line">    <span class="comment">// 保存转码之后的数据</span></span><br><span class="line">    out.write(b);</span><br><span class="line">    <span class="comment">// 关闭输出流</span></span><br><span class="line">    out.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后可以发现，因为编码不一致，所以在保存时出现了乱码。在 Java 的开发中，乱码是一个比较常见的问题，乱码的产生就有一个原因，即输出内容的编码与接收内容的编码不一致。</p>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p><code>File</code>类是<code>java.io</code>包中唯一代表磁盘文件本身的对象，也就是说，如果希望在程序中操作文件和目录，则都可以通过<code>File</code>类来完成。<code>File</code>类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等。</p>
<p><code>File</code>类不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</p>
<p><code>File</code>类提供了如下三种形式构造方法。</p>
<ul>
<li><code>File(String path)</code>：如果<code>path</code>是实际存在的路径，则该<code>File</code>对象表示的是目录；如果<code>path</code>是文件名，则该<code>File</code>对象表示的是文件。</li>
<li><code>File(String path, String name)</code>：<code>path</code>是路径名，<code>name</code>是文件名。</li>
<li><code>File(File dir, String name)</code>：<code>dir</code>是路径对象，<code>name</code>是文件名。</li>
</ul>
<p><code>File</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean canRead()</td>
<td align="center">测试应用程序是否能从指定的文件中进行读取</td>
</tr>
<tr>
<td align="center">boolean canWrite()</td>
<td align="center">测试应用程序是否能写当前文件</td>
</tr>
<tr>
<td align="center">boolean delete()</td>
<td align="center">删除当前对象指定的文件</td>
</tr>
<tr>
<td align="center">boolean exists()</td>
<td align="center">测试当前 File 是否存在</td>
</tr>
<tr>
<td align="center">String getAbsolutePath()</td>
<td align="center">返回由该对象表示的文件的绝对路径名</td>
</tr>
<tr>
<td align="center">String getName()</td>
<td align="center">返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</td>
</tr>
<tr>
<td align="center">String getParent()</td>
<td align="center">返回当前 File 对象所对应目录（最后一级子目录）的父目录名</td>
</tr>
<tr>
<td align="center">boolean isAbsolute()</td>
<td align="center">测试当前 File 对象表示的文件是否为一个绝对路径名。该方法消除了不同平台的差异，可以直接判断 file 对象是否为绝对路径。在 UNIX&#x2F;Linux&#x2F;BSD 等系统上，如果路径名开头是一条斜线&#x2F;，则表明该 File 对象对应一个绝对路径；在 Windows 等系统上，如果路径开头是盘符，则说明它是一个绝对路径。</td>
</tr>
<tr>
<td align="center">boolean isDirectory()</td>
<td align="center">测试当前 File 对象表示的文件是否为一个路径</td>
</tr>
<tr>
<td align="center">boolean isFile()</td>
<td align="center">测试当前 File 对象表示的文件是否为一个“普通”文件</td>
</tr>
<tr>
<td align="center">long lastModified()</td>
<td align="center">返回当前 File 对象表示的文件最后修改的时间</td>
</tr>
<tr>
<td align="center">long length()</td>
<td align="center">返回当前 File 对象表示的文件长度</td>
</tr>
<tr>
<td align="center">String[] list()</td>
<td align="center">返回当前 File 对象指定的路径文件列表</td>
</tr>
<tr>
<td align="center">String[] list(FilenameFilter)</td>
<td align="center">返回当前 File 对象指定的目录中满足指定过滤器的文件列表</td>
</tr>
<tr>
<td align="center">boolean mkdir()</td>
<td align="center">创建一个目录，它的路径名由当前 File 对象指定</td>
</tr>
<tr>
<td align="center">boolean mkdirs()</td>
<td align="center">创建一个目录，它的路径名由当前 File 对象指定</td>
</tr>
<tr>
<td align="center">boolean renameTo(File)</td>
<td align="center">将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</td>
</tr>
</tbody></table>
<p><code>File</code>类中有以下两个常用常量：</p>
<ul>
<li><code>public static final String pathSeparator</code>：指的是分隔连续多个路径字符串的分隔符，Windows 下指<code>;</code>。例如<code>java -cp test.jar;abc.jar HelloWorld</code>。</li>
<li><code>public static final String separator</code>：用来分隔同一个路径字符串中的目录的，Windows 下指<code>/</code>。例如<code>C:/Program Files/Common Files</code>。</li>
</ul>
<p>注意：可以看到<code>File</code>类的常量定义的命名规则不符合标准命名规则，常量名没有全部大写，这是因为 Java 的发展经过了一段相当长的时间，而命名规范也是逐步形成的，<code>File</code>类出现较早，所以当时并没有对命名规范有严格的要求，这些都属于 Java 的历史遗留问题。</p>
<p>Windows 的路径分隔符使用反斜线“\”，而 Java 程序中的反斜线表示转义字符，所以如果需要在 Windows 的路径下包括反斜线，则应该使用两条反斜线或直接使用斜线“&#x2F;”也可以。Java 程序支持将斜线当成平台无关的路径分隔符。</p>
<p>假设在 Windows 操作系统中有一文件<code>D:\javaspace\hello.java</code>，在 Java 中使用的时候，其路径的写法应该为<code>D:/javaspace/hello.java</code>或者<code>D:\\javaspace\\hello.java</code>。</p>
<h2 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h2><p>获取文件属性信息的第一步是先创建一个<code>File</code>类对象并指向一个已存在的文件， 然后调用<code>File</code>的方法进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:/windows/&quot;</span>; <span class="comment">// 指定文件所在的目录</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path, <span class="string">&quot;notepad.exe&quot;</span>); <span class="comment">// 建立File变量,并设定由f变量引用</span></span><br><span class="line">    System.out.println(<span class="string">&quot;C:\\windows\\notepad.exe文件信息如下：&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;文件长度：&quot;</span> + f.length() + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;文件或者目录：&quot;</span> + (f.isFile() ? <span class="string">&quot;是文件&quot;</span> : <span class="string">&quot;不是文件&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;文件或者目录：&quot;</span> + (f.isDirectory() ? <span class="string">&quot;是目录&quot;</span> : <span class="string">&quot;不是目录&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;是否可读：&quot;</span> + (f.canRead() ? <span class="string">&quot;可读取&quot;</span> : <span class="string">&quot;不可读取&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;是否可写：&quot;</span> + (f.canWrite() ? <span class="string">&quot;可写入&quot;</span> : <span class="string">&quot;不可写入&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;是否隐藏：&quot;</span> + (f.isHidden() ? <span class="string">&quot;是隐藏文件&quot;</span> : <span class="string">&quot;不是隐藏文件&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;最后修改日期：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(f.lastModified()));</span><br><span class="line">    System.out.println(<span class="string">&quot;文件名称：&quot;</span> + f.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件路径：&quot;</span> + f.getPath());</span><br><span class="line">    System.out.println(<span class="string">&quot;绝对路径：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终运行效果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\windows\notepad.exe文件信息如下：</span><br><span class="line">============================================</span><br><span class="line">文件长度：193536字节</span><br><span class="line">文件或者目录：是文件</span><br><span class="line">文件或者目录：不是目录</span><br><span class="line">是否可读：可读取</span><br><span class="line">是否可写：可写入</span><br><span class="line">是否隐藏：不是隐藏文件</span><br><span class="line">最后修改日期：Mon Dec 28 02:55:19 CST 2016</span><br><span class="line">文件名称：notepad.exe</span><br><span class="line">文件路径：C:\windows\notepad.exe</span><br><span class="line">绝对路径：C:\windows\notepad.exe</span><br></pre></td></tr></table></figure>
<h2 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h2><p><code>File</code>类不仅可以获取已知文件的属性信息，还可以在指定路径创建文件，以及删除一个文件。创建文件需要调用<code>createNewFile()</code>方法，删除文件需要调用<code>delete()</code>方法。无论是创建还是删除文件通常都先调用<code>exists()</code>方法判断文件是否存在。</p>
<p>假设要在 C 盘上创建一个<code>test.txt</code>文件，程序启动时会检测该文件是否存在，如果不存在则创建；如果存在则删除它再创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\test.txt&quot;</span>); <span class="comment">// 创建指向文件的File对象</span></span><br><span class="line">    <span class="keyword">if</span> (f.exists()) <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">      f.delete(); <span class="comment">// 存在则先删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.createNewFile(); <span class="comment">// 再创建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序之后可以发现，在 C 盘中已经创建好了<code>test.txt</code>文件。但是如果在不同的操作系统中，路径的分隔符是不一样的，例如：</p>
<ul>
<li>Windows 中使用反斜杠<code>\</code>表示目录的分隔符。</li>
<li>Linux 中使用正斜杠<code>/</code>表示目录的分隔符。</li>
</ul>
<p>那么既然 Java 程序本身具有可移植性的特点，则在编写路径时最好可以根据程序所在的操作系统自动使用符合本地操作系统要求的分隔符，这样才能达到可移植性的目的。要实现这样的功能，则就需要使用<code>File</code>类中提供的两个常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:&quot;</span> + File.separator + <span class="string">&quot;test.txt&quot;</span>; <span class="comment">// 拼凑出可以适应操作系统的路径</span></span><br><span class="line">  <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">  <span class="keyword">if</span> (f.exists()) <span class="comment">// 判断文件是否存在</span></span><br><span class="line">  &#123;</span><br><span class="line">    f.delete(); <span class="comment">// 存在则先删除</span></span><br><span class="line">  &#125;</span><br><span class="line">  f.createNewFile(); <span class="comment">// 再创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果和前面程序一样，但是此时的程序可以在任意的操作系统中使用。</p>
<p>注意：在操作文件时一定要使用<code>File.separator</code>表示分隔符。在程序的开发中，往往会使用 Windows 开发环境，因为在 Windows 操作系统中支持的开发工具较多，使用方便，而在程序发布时往往是直接在 Linux 或其它操作系统上部署，所以这时如果不使用<code>File.separator</code>，则程序运行就有可能存在问题。</p>
<h2 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h2><p><code>File</code>类除了对文件的创建和删除外，还可以创建和删除目录。创建目录需要调用<code>mkdir()</code>方法，删除目录需要调用<code>delete()</code>方法。无论是创建还是删除目录都可以调用<code>exists()</code>方法判断目录是否存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:/config/&quot;</span>; <span class="comment">// 指定目录位置</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path); <span class="comment">// 创建File对象</span></span><br><span class="line">    <span class="keyword">if</span> (f.exists()) &#123;</span><br><span class="line">      f.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    f.mkdir(); <span class="comment">// 创建目录</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><p>通过遍历目录可以在指定的目录中查找文件，或者显示所有的文件列表。<code>File</code>类的<code>list()</code>方法提供了遍历目录功能，该方法有如下两种重载形式。</p>
<ol>
<li><code>String[] list()</code><br>该方法表示返回由<code>File</code>对象表示目录中所有文件和子目录名称组成的字符串数组，如果调用的<code>File</code>对象不是目录，则返回<code>null</code>。<br>提示：<code>list()</code>方法返回的数组中仅包含文件名称，而不包含路径。但不保证所得数组中的相同字符串将以特定顺序出现，特别是不保证它们按字母顺序出现。</li>
<li><code>String[] list(FilenameFilter filter)</code><br>该方法的作用与<code>list()</code>方法相同，不同的是返回数组中仅包含符合<code>filter</code>过滤器的文件和目录，如果<code>filter</code>为<code>null</code>，则接受所有名称。</li>
</ol>
<p>假设要遍历 C 盘根目录下的所有文件和目录，并显示文件或目录名称、类型及大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/&quot;</span>); <span class="comment">// 建立File变量,并设定由f变量变数引用</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件名称\t\t文件类型\t\t文件大小&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;===================================================&quot;</span>);</span><br><span class="line">    String fileList[] = f.list(); <span class="comment">// 调用不带参数的list()方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fileList.length; i++) &#123; <span class="comment">// 遍历返回的字符数组</span></span><br><span class="line">      System.out.print(fileList[i] + <span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">      System.out.print((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/&quot;</span>, fileList[i])).isFile() ? <span class="string">&quot;文件&quot;</span> + <span class="string">&quot;\t\t&quot;</span> : <span class="string">&quot;文件夹&quot;</span> + <span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">      System.out.println((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:/&quot;</span>, fileList[i])).length() + <span class="string">&quot;字节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>list()</code>方法返回的字符数组中仅包含文件名称，因此为了获取文件类型和大小，必须先转换为<code>File</code>对象再调用其方法。如下所示的是实例的运行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">文件名称  文件类型  文件大小</span><br><span class="line">===================================================</span><br><span class="line">$Recycle.Bin  文件夹  4096字节</span><br><span class="line">Documents and Settings  文件夹  0字节</span><br><span class="line">Download  文件夹  0字节</span><br><span class="line">DRIVERS  文件夹  0字节</span><br><span class="line">FibocomLog  文件夹  0字节</span><br><span class="line">Gateface  文件夹  0字节</span><br><span class="line">GFPageCache  文件夹  0字节</span><br><span class="line">hiberfil.sys  文件  3375026176字节</span><br><span class="line">Intel  文件夹  0字节</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>假设希望只列出目录下的某些文件，这就需要调用带过滤器参数的<code>list()</code>方法。首先需要创建文件过滤器，该过滤器必须实现<code>java.io.FilenameFilter</code>接口，并在<code>accept()</code>方法中指定允许的文件类型。</p>
<p>如下所示为允许 SYS、TXT 和 BAK 格式文件的过滤器实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageFilter</span> <span class="keyword">implements</span> <span class="title class_">FilenameFilter</span> &#123;</span><br><span class="line">  <span class="comment">// 实现 FilenameFilter 接口</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定允许的文件类型</span></span><br><span class="line">    <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.sys&quot;</span>) || name.endsWith(<span class="string">&quot;.txt&quot;</span>) || name.endsWith(<span class="string">&quot;.bak&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建的过滤器名称为<code>ImageFilter</code>，接下来只需要将该名称传递给<code>list()</code>方法即可实现筛选文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fileList[] = f.list(<span class="keyword">new</span> <span class="title class_">ImageFilter</span>());</span><br></pre></td></tr></table></figure>
<p>再次运行程序，遍历结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件名称        文件类型        文件大小</span><br><span class="line">===================================================</span><br><span class="line">offline_FtnInfo.txt        文件        296字节</span><br><span class="line">pagefile.sys        文件        8436592640字节</span><br></pre></td></tr></table></figure>
<h1 id="字节流的使用"><a href="#字节流的使用" class="headerlink" title="字节流的使用"></a>字节流的使用</h1><h2 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h2><p><code>InputStream</code>类及其子类的对象表示字节输入流，<code>InputStream</code>类的常用子类：</p>
<ul>
<li><code>ByteArrayInputStream</code>类：将字节数组转换为字节输入流，从中读取字节。</li>
<li><code>FileInputStream</code>类：从文件中读取数据。</li>
<li><code>PipedInputStream</code>类：连接到一个<code>PipedOutputStream</code>（管道输出流）。</li>
<li><code>SequenceInputStream</code>类：将多个字节输入流串联成一个字节输入流。</li>
<li><code>ObjectInputStream</code>类：将对象反序列化。</li>
</ul>
<p>使用<code>InputStream</code>类的方法可以从流中读取一个或一批字节。<code>InputStream</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流中读取一个 8 位的字节，并把它转换为 0~255 的整数，最后返回整数。<br>如果返回 -1，则表示已经到了输入流的末尾。<br>为了提高 I&#x2F;O 操作的效率，建议尽量使用 read() 方法的另外两种形式</td>
</tr>
<tr>
<td align="center">int read(byte[] b)</td>
<td align="center">从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。<br>该方法返回读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="center">int read(byte[] b, int off, int len)</td>
<td align="center">从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。<br>其中，off 指定在字节数组中开始保存数据的起始下标；len 指定读取的字节数。<br>该方法返回实际读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输入流。在读操作完成后，应该关闭输入流，系统将会释放与这个输入流相关的资源。<br>注意，InputStream 类本身的 close() 方法不执行任何操作，但是它的许多子类重写了 close() 方法</td>
</tr>
<tr>
<td align="center">int available()</td>
<td align="center">返回可以从输入流中读取的字节数</td>
</tr>
<tr>
<td align="center">long skip(long n)</td>
<td align="center">从输入流中跳过参数 n 指定数目的字节。该方法返回跳过的字节数</td>
</tr>
<tr>
<td align="center">void mark(int readLimit)</td>
<td align="center">在输入流的当前位置开始设置标记，参数 readLimit 则指定了最多被设置标记的字节数</td>
</tr>
<tr>
<td align="center">boolean markSupported()</td>
<td align="center">判断当前输入流是否允许设置标记，是则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">void reset()</td>
<td align="center">将输入流的指针返回到设置标记的起始处</td>
</tr>
</tbody></table>
<p>注意：在使用<code>mark()</code>方法和<code>reset()</code>方法之前，需要判断该文件系统是否支持这两个方法，以避免对程序造成影响。</p>
<h2 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h2><p><code>OutputStream</code>类及其子类的对象表示一个字节输出流。<code>OutputStream</code>类的常用子类如下。</p>
<ul>
<li><code>ByteArrayOutputStream</code>类：向内存缓冲区的字节数组中写数据。</li>
<li><code>FileOutputStream</code>类：向文件中写数据。</li>
<li><code>PipedOutputStream</code>类：连接到一个<code>PipedlntputStream</code>（管道输入流）。</li>
<li><code>ObjectOutputStream</code>类：将对象序列化。</li>
</ul>
<p>利用<code>OutputStream</code>类的方法可以从流中写入一个或一批字节。<code>OutputStream</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int b)</td>
<td align="center">向输出流写入一个字节。<br>这里的参数是 int 类型，但是它允许使用表达式，<br>而不用强制转换成 byte 类型。<br>为了提高 I&#x2F;O 操作的效率，建议尽量使用 write() 方法的另外两种形式</td>
</tr>
<tr>
<td align="center">void write(byte[] b)</td>
<td align="center">把参数 b 指定的字节数组中的所有字节写到输出流中</td>
</tr>
<tr>
<td align="center">void write(byte[] b,int off,int len)</td>
<td align="center">把参数 b 指定的字节数组中的若干字节写到输出流中。<br>其中，off 指定字节数组中的起始下标，len 表示元素个数</td>
</tr>
<tr>
<td align="center">void close()</td>
<td align="center">关闭输出流。写操作完成后，应该关闭输出流。<br>系统将会释放与这个输出流相关的资源。<br>注意，OutputStream 类本身的 close() 方法不执行任何操作，但是它的许多子类重写了 close() 方法</td>
</tr>
<tr>
<td align="center">void flush()</td>
<td align="center">为了提高效率，在向输出流中写入数据时，数据一般会先保存到内存缓冲区中，只有当缓冲区中的数据达到一定程度时，缓冲区中的数据才会被写入输出流中。<br>使用 flush() 方法则可以强制将缓冲区中的数据写入输出流，并清空缓冲区</td>
</tr>
</tbody></table>
<h2 id="字节数组输入流"><a href="#字节数组输入流" class="headerlink" title="字节数组输入流"></a>字节数组输入流</h2><p><code>ByteArrayInputStream</code>类可以从内存的字节数组中读取数据，该类有如下两种构造方法重载形式。</p>
<ul>
<li><code>ByteArrayInputStream(byte[] buf)</code>：创建一个字节数组输入流，字节数组类型的数据源由参数 buf 指定。</li>
<li><code>ByteArrayInputStream(byte[] buf,int offse,int length)</code>：创建一个字节数组输入流，其中，参数 buf 指定字节数组类型的数据源，offset 指定在数组中开始读取数据的起始下标位置，length 指定读取的元素个数。</li>
</ul>
<p>使用<code>ByteArrayInputStream</code>类实现从一个字节数组中读取数据，再转换为<code>int</code>型进行输出。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test08</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">25</span>, -<span class="number">22</span>, -<span class="number">5</span>, <span class="number">23</span> &#125;; <span class="comment">// 创建数组</span></span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(b, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// 创建字节数组输入流</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> bais.read(); <span class="comment">// 从输入流中读取下一个字节，并转换成int型数据</span></span><br><span class="line">    <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123; <span class="comment">// 如果不返回-1，则表示没有到输入流的末尾</span></span><br><span class="line">      System.out.println(<span class="string">&quot;原值=&quot;</span> + (<span class="type">byte</span>) i + <span class="string">&quot;\t\t\t转换为int类型=&quot;</span> + i);</span><br><span class="line">      i = bais.read(); <span class="comment">// 读取下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，字节输入流<code>bais</code>从字节数组<code>b</code>的第一个元素开始读取 4 字节元素，并将这 4 字节转换为<code>int</code>类型数据，最后返回。</p>
<p>提示：上述示例中除了打印<code>i</code>的值外，还打印出了<code>(byte) i</code>的值，由于<code>i</code>的值是从<code>byte</code>类型的数据转换过来的，所以使用<code>(byte) i</code>可以获取原来的<code>byte</code>数据。</p>
<p>该程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原值=1   转换为int类型=1</span><br><span class="line">原值=-1   转换为int类型=255</span><br><span class="line">原值=25   转换为int类型=25</span><br><span class="line">原值=-22   转换为int类型=234</span><br><span class="line">原值=-5   转换为int类型=251</span><br><span class="line">原值=23   转换为int类型=23</span><br></pre></td></tr></table></figure>
<p>从上述的运行结果可以看出，字节类型的数据 -1 和 -22 转换成<code>int</code>类型的数据后变成了 255 和 234，对这种结果的解释如下：</p>
<ul>
<li>字节类型的 1，二进制形式为<code>00000001</code>，转换为<code>int</code>类型后的二进制形式为<code>00000000 00000000 0000000000000001</code>，对应的十进制数为 1。</li>
<li>字节类型的 -1，二进制形式为<code>11111111</code>，转换为<code>int</code>类型后的二进制形式为<code>00000000 00000000 0000000011111111</code>，对应的十进制数为 255。</li>
</ul>
<p>可见，从字节类型的数转换成<code>int</code>类型的数时，如果是正数，则数值不变；如果是负数，则由于转换后，二进制形式前面直接补了 24 个 0，这样就改变了原来表示负数的二进制补码形式，所以数值发生了变化，即变成了正数。</p>
<p>提示：负数的二进制形式以补码形式存在，例如 -1，其二进制形式是这样得来的：首先获取 1 的原码<code>00000001</code>，然后进行反码操作，1 变成 0，0 变成 1，这样就得到<code>11111110</code>，最后进行补码操作，就是在反码的末尾位加 1，这样就变成了<code>11111111</code>。</p>
<h2 id="字节数组输出流"><a href="#字节数组输出流" class="headerlink" title="字节数组输出流"></a>字节数组输出流</h2><p><code>ByteArrayOutputStream</code>类可以向内存的字节数组中写入数据，该类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>ByteArrayOutputStream()</code>：创建一个字节数组输出流，输出流缓冲区的初始容量大小为 32 字节。</li>
<li><code>ByteArrayOutputStream(int size)</code>：创建一个字节数组输出流，输出流缓冲区的初始容量大小由参数<code>size</code>指定。</li>
</ul>
<p><code>ByteArrayOutputStream</code>类中除了有前面介绍的字节输出流中的常用方法以外，还有如下两个方法。</p>
<ul>
<li><code>intsize()</code>：返回缓冲区中的当前字节数。</li>
<li><code>byte[] toByteArray()</code>：以字节数组的形式返回输出流中的当前内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[] &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">25</span>, -<span class="number">22</span>, -<span class="number">5</span>, <span class="number">23</span> &#125;; <span class="comment">// 创建数组</span></span><br><span class="line">    baos.write(b, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// 将字节数组b中的前4个字节元素写到输出流中</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数组中一共包含：&quot;</span> + baos.size() + <span class="string">&quot;字节&quot;</span>); <span class="comment">// 输出缓冲区中的字节数</span></span><br><span class="line">    <span class="type">byte</span>[] newByteArray = baos.toByteArray(); <span class="comment">// 将输出流中的当前内容转换成字节数组</span></span><br><span class="line">    System.out.println(Arrays.toString(newByteArray)); <span class="comment">// 输出数组中的内容</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组中一共包含：6字节</span><br><span class="line">[1, -1, 25, -22, -5, 23]</span><br></pre></td></tr></table></figure>
<h2 id="文件输入流"><a href="#文件输入流" class="headerlink" title="文件输入流"></a>文件输入流</h2><p><code>FileInputStream</code>表示从文件系统的某个文件中获取输入字节。通过使用<code>FileInputStream</code>可以访问文件中的一个字节、一批字节或整个文件。</p>
<p>在创建<code>FileInputStream</code>类的对象时，如果找不到指定的文件将拋出<code>FileNotFoundException</code>异常，该异常必须捕获或声明拋出。</p>
<p><code>FileInputStream</code>常用的构造方法主要有如下两种重载形式。</p>
<ul>
<li><code>FileInputStream(File file)</code>：通过打开一个到实际文件的连接来创建一个<code>FileInputStream</code>，该文件通过文件系统中的<code>File</code>对象<code>file</code>指定。</li>
<li><code>FileInputStream(String name)</code>：通过打开一个到实际文件的链接来创建一个<code>FileInputStream</code>，该文件通过文件系统中的路径名<code>name</code>指定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 以File对象作为参数创建FileInputStream对象</span></span><br><span class="line">  <span class="type">FileInputStream</span> <span class="variable">fis1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:/mxl.txt&quot;</span>));</span><br><span class="line">  <span class="comment">// 以字符串值作为参数创建FilelnputStream对象</span></span><br><span class="line">  <span class="type">FileInputStream</span> <span class="variable">fis2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;F:/mxl.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;指定的文件找不到!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个 D:\myJava\HelloJava.java 文件，下面使用 FileInputStream 类读取并输出该文件的内容。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/myJava/HelloJava.java&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 因为File没有读写的能力,所以需要有个InputStream</span></span><br><span class="line">      fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">      <span class="comment">// 定义一个字节数组</span></span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 得到实际读取到的字节数</span></span><br><span class="line">      System.out.println(<span class="string">&quot;D:\\myJava\\HelloJava.java文件内容如下：&quot;</span>);</span><br><span class="line">      <span class="comment">// 循环读取</span></span><br><span class="line">      <span class="keyword">while</span> ((n = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, n); <span class="comment">// 将数组中从下标0到n的内容给s</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>FileInputStream</code>类重写了父类<code>InputStream</code>中的<code>read()</code>方法、<code>skip()</code>方法、<code>available()</code>方法和<code>close()</code>方法，不支持<code>mark()</code>方法和<code>reset()</code>方法。</p>
</blockquote>
<h2 id="文件输出流"><a href="#文件输出流" class="headerlink" title="文件输出流"></a>文件输出流</h2><p><code>FileOutputStream</code>类继承自<code>OutputStream</code>类，重写和实现了父类中的所有方法。<code>FileOutputStream</code>类的对象表示一个文件字节输出流，可以向流中写入一个字节或一批字节。在创建<code>FileOutputStream</code>类的对象时，如果指定的文件不存在，则创建一个新文件；如果文件已存在，则清除原文件的内容重新写入。</p>
<p><code>FileOutputStream</code>类的构造方法主要有如下 4 种重载形式。</p>
<ul>
<li><code>FileOutputStream(File file)</code>：创建一个文件输出流，参数<code>file</code>指定目标文件。</li>
<li><code>FileOutputStream(File file,boolean append)</code>：创建一个文件输出流，参数<code>file</code>指定目标文件，<code>append</code>指定是否将数据添加到目标文件的内容末尾，如果为<code>true</code>，则在末尾添加；如果为<code>false</code>，则覆盖原有内容；其默认值为<code>false</code>。</li>
<li><code>FileOutputStream(String name)</code>：创建一个文件输出流，参数<code>name</code>指定目标文件的文件路径信息。</li>
<li><code>FileOutputStream(String name,boolean append)</code>：创建一个文件输出流，参数<code>name</code>和<code>append</code>的含义同上。</li>
</ul>
<p>注意：使用构造方法<code>FileOutputStream(String name,boolean append)</code>创建一个文件输出流对象，它将数据附加在现有文件的末尾。该字符串<code>name</code>指明了原文件，如果只是为了附加数据而不是重写任何已有的数据，布尔类型参数<code>append</code>的值应为<code>true</code>。</p>
<p>对文件输出流有如下四点说明：<br>在<code>FileOutputStream</code>类的构造方法中指定目标文件时，目标文件可以不存在。<br>目标文件的名称可以是任意的，例如<code>D:\\abc、D:\\abc.de 和 D:\\abc.de.fg</code>等都可以，可以使用记事本等工具打开并浏览这些文件中的内容。<br>目标文件所在目录必须存在，否则会拋出<code>java.io.FileNotFoundException</code>异常。<br>目标文件的名称不能是已存在的目录。例如 D 盘下已存在 Java 文件夹，那么就不能使用 Java 作为文件名，即不能使用<code>D:\\Java</code>，否则抛出<code>java.io.FileNotFoundException</code>异常。</p>
<p>读取<code>D:\myJava\HelloJava.java</code>文件的内容，在这里使用<code>FileInputStream</code>类实现，然后再将内容写入新的文件<code>D:\myJava\HelloJava.txt</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明FileInputStream对象fis</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明FileOutputStream对象fos</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/myJava/HelloJava.java&quot;</span>);</span><br><span class="line">      fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile); <span class="comment">// 实例化FileInputStream对象</span></span><br><span class="line">      <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/myJava/HelloJava.txt&quot;</span>); <span class="comment">// 创建目标文件对象，该文件不存在</span></span><br><span class="line">      fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile); <span class="comment">// 实例化FileOutputStream对象</span></span><br><span class="line">      <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 每次读取1024字节</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fis.read(bytes);</span><br><span class="line">      <span class="keyword">while</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(bytes, <span class="number">0</span>, i); <span class="comment">// 向D:\HelloJava.txt文件中写入内容</span></span><br><span class="line">        i = fis.read(bytes);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;写入结束！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fis.close(); <span class="comment">// 关闭FileInputStream对象</span></span><br><span class="line">        fos.close(); <span class="comment">// 关闭FileOutputStream对象</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，将<code>D:\myJava\HelloJava.java</code>文件中的内容通过文件输入&#x2F;输出流写入到了<code>D:\myJava\HelloJava.txt</code>文件中。由于<code>HelloJava.txt</code>文件并不存在，所以在执行程序时将新建此文件，并写入相应内容。</p>
<p>运行程序，成功后会在控制台输出“写入结束！”。此时，打开<code>D:\myJava\HelloJava.txt</code>文件会发现，其内容与<code>HelloJava.java</code>文件的内容相同。</p>
<p>技巧：在创建<code>FileOutputStream</code>对象时，如果将<code>append</code>参数设置为<code>true</code>，则可以在目标文件的内容末尾添加数据，此时目标文件仍然可以暂不存在。</p>
<h1 id="字符流的使用"><a href="#字符流的使用" class="headerlink" title="字符流的使用"></a>字符流的使用</h1><p>尽管 Java 中字节流的功能十分强大，几乎可以直接或间接地处理任何类型的输入&#x2F;输出操作，但利用它却不能直接操作 16 位的 Unicode 字符。这就要用到字符流。</p>
<h2 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h2><p><code>Reader</code>类是所有字符流输入类的父类，该类定义了许多方法，这些方法对所有子类都是有效的。</p>
<p><code>Reader</code>类的常用子类如下。</p>
<ul>
<li><code>CharArrayReader</code>类：将字符数组转换为字符输入流，从中读取字符。</li>
<li><code>StringReader</code>类：将字符串转换为字符输入流，从中读取字符。</li>
<li><code>BufferedReader</code>类：为其他字符输入流提供读缓冲区。</li>
<li><code>PipedReader</code>类：连接到一个<code>PipedWriter</code>。</li>
<li><code>InputStreamReader</code>类：将字节输入流转换为字符输入流，可以指定字符编码。</li>
</ul>
<p>与<code>InputStream</code>类相同，在<code>Reader</code>类中也包含<code>close()、mark()、skip()</code>和<code>reset()</code>等方法，这些方法可以参考<code>InputStream</code>类的方法。<code>Reader</code>类中的<code>read()</code>方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int read()</td>
<td align="center">从输入流中读取一个字符，并把它转换为 0~65535 的整数。如果返回 -1， 则表示已经到了输入流的末尾。为了提高 I&#x2F;O 操作的效率，建议尽量使用下面两种 read() 方法</td>
</tr>
<tr>
<td align="center">int read(char[] cbuf)</td>
<td align="center">从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。 该方法返回读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="center">int read(char[] cbuf,int off,int len)</td>
<td align="center">从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。其中，off 指定在字符数组中开始保存数据的起始下标，len 指定读取的字符数。该方法返回实际读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
</tbody></table>
<h2 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h2><p>与<code>Reader</code>类相反，<code>Writer</code>类是所有字符输出流的父类，该类中有许多方法，这些方法对继承该类的所有子类都是有效的。</p>
<p><code>Writer</code>类的常用子类如下。</p>
<ul>
<li><code>CharArrayWriter</code>类：向内存缓冲区的字符数组写数据。</li>
<li><code>StringWriter</code>类：向内存缓冲区的字符串（<code>StringBuffer</code>）写数据。</li>
<li><code>BufferedWriter</code>类：为其他字符输出流提供写缓冲区。</li>
<li><code>PipedWriter</code>类：连接到一个<code>PipedReader</code>。</li>
<li><code>OutputStreamReader</code>类：将字节输出流转换为字符输出流，可以指定字符编码。</li>
</ul>
<p>与<code>OutputStream</code>类相同，<code>Writer</code>类也包含<code>close()、flush()</code>等方法，这些方法可以参考<code>OutputStream</code>类的方法。<code>Writer</code>类中的<code>write()</code>方法和<code>append()</code>方法：</p>
<table>
<thead>
<tr>
<th align="center">方法名及返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void write(int c)</td>
<td align="center">向输出流中写入一个字符</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf)</td>
<td align="center">把参数 cbuf 指定的字符数组中的所有字符写到输出流中</td>
</tr>
<tr>
<td align="center">void write(char[] cbuf,int off,int len)</td>
<td align="center">把参数 cbuf 指定的字符数组中的若干字符写到输出流中。其中，off 指定字符数组中的起始下标，len 表示元素个数</td>
</tr>
<tr>
<td align="center">void write(String str)</td>
<td align="center">向输出流中写入一个字符串</td>
</tr>
<tr>
<td align="center">void write(String str, int off,int len)</td>
<td align="center">向输出流中写入一个字符串中的部分字符。其中，off 指定字符串中的起始偏移量，len 表示字符个数</td>
</tr>
<tr>
<td align="center">append(char c)</td>
<td align="center">将参数 c 指定的字符添加到输出流中</td>
</tr>
<tr>
<td align="center">append(charSequence esq)</td>
<td align="center">将参数 esq 指定的字符序列添加到输出流中</td>
</tr>
<tr>
<td align="center">append(charSequence esq,int start,int end)</td>
<td align="center">将参数 esq 指定的字符序列的子序列添加到输出流中。其中，start 指定子序列的第一个字符的索引，end 指定子序列中最后一个字符后面的字符的索引，也就是说子序列的内容包含 start 索引处的字符，但不包括 end索引处的字符</td>
</tr>
</tbody></table>
<p>注意：<code>Writer</code>类所有的方法在出错的情况下都会引发<code>IOException</code>异常。关闭一个流后，再对其进行任何操作都会产生错误。</p>
<h2 id="字符文件输入流"><a href="#字符文件输入流" class="headerlink" title="字符文件输入流"></a>字符文件输入流</h2><p>为了读取方便，Java 提供了用来读取字符文件的便捷类——<code>FileReader</code>。该类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>FileReader(File file)</code>：在给定要读取数据的文件的情况下创建一个新的<code>FileReader</code>对象。其中，<code>file</code>表示要从中读取数据的文件。</li>
<li><code>FileReader(String fileName)</code>：在给定从中读取数据的文件名的情况下创建一个新<code>FileReader</code>对象。其中，<code>fileName</code>表示要从中读取数据的文件的名称，表示的是一个文件的完整路径。</li>
</ul>
<p>在用该类的构造方法创建<code>FileReader</code>读取对象时，默认的字符编码及字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在<code>FilelnputStream</code>上构造一个<code>InputStreamReader</code>。</p>
<p>注意：在创建<code>FileReader</code>对象时可能会引发一个<code>FileNotFoundException</code>异常，因此需要使用<code>try catch</code>语句捕获该异常。</p>
<p>字符流和字节流的操作步骤相同，都是首先创建输入流或输出流对象，即建立连接管道，建立完成后进行读或写操作，最后关闭输入&#x2F;输出流通道。</p>
<p>要将<code>D:\myJava\HelloJava.java</code>文件中的内容读取并输出到控制台，使用<code>FileReader</code>类的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test12</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/myJava/HelloJava.java&quot;</span>); <span class="comment">// 创建FileReader对象</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;D:\\myJava\\HelloJava.java文件内容如下：&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> ((i = fr.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 循环读取</span></span><br><span class="line">        System.out.print((<span class="type">char</span>) i); <span class="comment">// 将读取的内容强制转换为char类型</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.print(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close(); <span class="comment">// 关闭对象</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先创建了<code>FileReader</code>字符输入流对象<code>fr</code>，该对象指向<code>D:\myJava\HelloJava.java</code>文件，然后定义变量<code>i</code>来接收调用<code>read()</code>方法的返回值，即读取的字符。在<code>while</code>循环中，每次读取一个字符赋给整型变量<code>i</code>，直到读取到文件末尾时退出循环（当输入流读取到文件末尾时，会返回值 -1）。</p>
<h2 id="字符文件输出流"><a href="#字符文件输出流" class="headerlink" title="字符文件输出流"></a>字符文件输出流</h2><p>Java 提供了写入字符文件的便捷类——<code>FileWriter</code>，该类的构造方法有如下 4 种重载形式。</p>
<ul>
<li><code>FileWriter(File file)</code>：在指定<code>File</code>对象的情况下构造一个<code>FileWriter</code>对象。其中，<code>file</code>表示要写入数据的<code>File</code>对象。</li>
<li><code>FileWriter(File file,boolean append)</code>：在指定<code>File</code>对象的情况下构造一个<code>FileWriter</code>对象，如果<code>append</code>的值为<code>true</code>，则将字节写入文件末尾，而不是写入文件开始处。</li>
<li><code>FileWriter(String fileName)</code>：在指定文件名的情况下构造一个<code>FileWriter</code>对象。其中，<code>fileName</code>表示要写入字符的文件名，表示的是完整路径。</li>
<li><code>FileWriter(String fileName,boolean append)</code>：在指定文件名以及要写入文件的位置的情况下构造<code>FileWriter</code>对象。其中，<code>append</code>是一个<code>boolean</code>值，如果为<code>true</code>，则将数据写入文件末尾，而不是文件开始处。</li>
</ul>
<p>在创建<code>FileWriter</code>对象时，默认字符编码和默认字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在<code>FileOutputStream</code>上构造一个<code>OutputStreamWriter</code>对象。</p>
<p><code>FileWriter</code>类的创建不依赖于文件存在与否，如果关联文件不存在，则会自动生成一个新的文件。在创建文件之前，<code>FileWriter</code>将在创建对象时打开它作为输出。如果试图打开一个只读文件，将引发一个<code>IOException</code>异常。</p>
<p>注意：在创建<code>FileWriter</code>对象时可能会引发<code>IOException</code>或<code>SecurityException</code>异常，因此需要使用<code>try catch</code>语句捕获该异常。</p>
<p>编写一个程序，将用户输入的 4 个字符串保存到<code>D:\myJava\book.txt</code>文件中。在这里使用<code>FileWriter</code>类中的<code>write()</code>方法循环向指定文件中写入数据，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\myJava\\book.txt&quot;</span>); <span class="comment">// 创建FileWriter对象</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next(); <span class="comment">// 读取输入的名称</span></span><br><span class="line">        fw.write(name + <span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 循环写入文件</span></span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;录入完成！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fw.close(); <span class="comment">// 关闭对象</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先创建了一个指向<code>D:\myJava\book.txt</code>文件的字符文件输出流对象<code>fw</code>，然后使用<code>for</code>循环录入 4 个字符串，并调用<code>write()</code>方法将字符串写入到指定的文件中。最后在<code>finally</code>语句中关闭字符文件输出流。</p>
<h2 id="字符缓冲区输入流"><a href="#字符缓冲区输入流" class="headerlink" title="字符缓冲区输入流"></a>字符缓冲区输入流</h2><p><code>BufferedReader</code>类主要用于辅助其他字符输入流，它带有缓冲区，可以先将一批数据读到内存缓冲区。接下来的读操作就可以直接从缓冲区中获取数据，而不需要每次都从数据源读取数据并进行字符编码转换，这样就可以提高数据的读取效率。</p>
<p><code>BufferedReader</code>类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>BufferedReader(Reader in)</code>：创建一个<code>BufferedReader</code>来修饰参数<code>in</code>指定的字符输入流。</li>
<li><code>BufferedReader(Reader in,int size)</code>：创建一个<code>BufferedReader</code>来修饰参数<code>in</code>指定的字符输入流，参数<code>size</code>则用于指定缓冲区的大小，单位为字符。</li>
</ul>
<p>除了可以为字符输入流提供缓冲区以外，<code>BufferedReader</code>还提供了<code>readLine()</code>方法，该方法返回包含该行内容的字符串，但该字符串中不包含任何终止符，如果已到达流末尾，则返回<code>null</code>。<code>readLine()</code>方法表示每次读取一行文本内容，当遇到换行（<code>\n</code>）、回车（<code>\r</code>）或回车后直接跟着换行标记符即可认为某行已终止。</p>
<p>使用<code>BufferedReader</code>类中的<code>readLine()</code>方法逐行读取<code>D:\myJava\Book.txt</code>文件中的内容，并将读取的内容在控制台中打印输出，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\myJava\\book.txt&quot;</span>); <span class="comment">// 创建 FileReader 对象</span></span><br><span class="line">      br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr); <span class="comment">// 创建 BufferedReader 对象</span></span><br><span class="line">      System.out.println(<span class="string">&quot;D:\\myJava\\book.txt 文件中的内容如下：&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">strLine</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> ((strLine = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 循环读取每行数据</span></span><br><span class="line">        System.out.println(strLine);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e1) &#123;</span><br><span class="line">      e1.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fr.close(); <span class="comment">// 关闭 FileReader 对象</span></span><br><span class="line">        br.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，首先分别创建了名称为<code>fr</code>的<code>FileReader</code>对象和名称为<code>br</code>的<code>BufferedReader</code>对象，然后调用<code>BufferedReader</code>对象的<code>readLine()</code>方法逐行读取文件中的内容。如果读取的文件内容为<code>Null</code>，即表明已经读取到文件尾部，此时退出循环不再进行读取操作。最后将字符文件输入流和带缓冲的字符输入流关闭。</p>
<p>运行该程序，输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\myJava\book.txt 文件中的内容如下：</span><br><span class="line">热点要闻</span><br><span class="line">个性推荐</span><br><span class="line">热搜新闻词</span><br><span class="line">本地看点</span><br></pre></td></tr></table></figure>
<h2 id="字符缓冲区输出流"><a href="#字符缓冲区输出流" class="headerlink" title="字符缓冲区输出流"></a>字符缓冲区输出流</h2><p><code>BufferedWriter</code>类主要用于辅助其他字符输出流，它同样带有缓冲区，可以先将一批数据写入缓冲区，当缓冲区满了以后，再将缓冲区的数据一次性写到字符输出流，其目的是为了提高数据的写效率。</p>
<p><code>BufferedWriter</code>类的构造方法有如下两种重载形式。</p>
<ul>
<li><code>*ufferedWriter(Writer out)</code>：创建一个<code>BufferedWriter</code>来修饰参数<code>out</code>指定的字符输出流。</li>
<li><code>*ufferedWriter(Writer out,int size)</code>：创建一个<code>BufferedWriter</code>来修饰参数<code>out</code>指定的字符输出流，参数<code>size</code>则用于指定缓冲区的大小，单位为字符。</li>
</ul>
<p>该类除了可以给字符输出流提供缓冲区之外，还提供了一个新的方法<code>newLine()</code>，该方法用于写入一个行分隔符。行分隔符字符串由系统属性<code>line.separator</code>定义，并且不一定是单个新行（\n）符。</p>
<p>提示：<code>BufferedWriter</code>类的使用与<code>FileWriter</code>类相同，这里不再重述。</p>
<h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><p>正常情况下，字节流可以对所有的数据进行操作，但是有些时候在处理一些文本时我们要用到字符流，比如，查看文本的中文时就是需要采用字符流更为方便。所以 Java IO 流中提供了两种用于将字节流转换为字符流的转换流。</p>
<p><code>InputStreamReader</code>用于将字节输入流转换为字符输入流，其中<code>OutputStreamWriter</code>用于将字节输出流转换为字符输出流。使用转换流可以在一定程度上避免乱码，还可以指定输入输出所使用的字符集。</p>
<p>在<code>java.txt</code>中输出你好，将<code>java.txt</code>保存为“UTF-8”的格式，然后通过字节流的方式读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://java.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为 C??????????，我们发现都是乱码。下面用字节数组，并通过字符串设定编码格式来显式内容，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://java.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span> b[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当存储的文字较多时，会出现解码不正确的问题，且字节长度无法根据解码内容自动设定，此时就需要转换流来完成。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://java.txt&quot;</span>);</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((b = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">      System.out.print((<span class="type">char</span>) b); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面以获取键盘输入为例来介绍转换流的用法。Java 使用<code>System.in</code>代表标准输出，即键盘输入，但这个标准输入流是<code>InputStream</code>类的实例，使用不太方便，而且键盘输入内容都是文本内容，所以可以使用<code>InputStreamReader</code>将其转换成字符输入流，普通的<code>Reader</code>读取输入内容时依然不太方便，可以将普通的<code>Reader</code>再次包装成<code>BufferedReader</code>，利用<code>BufferedReader</code>的<code>readLine()</code>方法可以一次读取一行内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将 System.in 对象转换成 Reader 对象</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">    <span class="comment">// 将普通的Reader 包装成 BufferedReader</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 利用循环方式来逐行的读取</span></span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果读取的字符串为“exit”，则程序退出</span></span><br><span class="line">      <span class="keyword">if</span> (line.equals(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 打印读取的内容</span></span><br><span class="line">      System.out.println(<span class="string">&quot;输入内容为：&quot;</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码第 4 行和第 6 行将<code>System.in</code>包装成<code>BufferedReader</code>，<code>BufferReader</code>流具有缓冲功能，它可以一次读取一行文本，以换行符为标志，如果它没有读到换行符，则程序堵塞，等到读到换行符为止。运行上面程序可以发现这个特征，在控制台执行输入时，只有按下回车键，程序才会打印出刚刚输入的内容。</p>
<p>由于<code>BufferedReader</code>具有一个<code>readLine()</code>方法，可以非常方便地进行一次读入一行内容，所以经常把读入文本内容地输入流包装成<code>BufferedReader</code>，用来方便地读取输入流的文本内容。</p>
<p>既然有字节流转字符流的转换流，那么为什么没有字符流转字节流的转换流呢？</p>
<p>这个问题一语指出了 Java 设计的遗漏之处，想一想字符流和字节流的差别。字节流比字符流的使用范围要更广，但字符流比字节流操作方便。如果有一个流已经是字符流了，也就是说，是一个用起来更方便的流，为什么要转换成字节流呢？反之，如果现在有一个字节流，但可以确定这个字节流的内容都是文本内容，那么把它转换成字符流来处理就会更方便一些，所以 Java 只提供了将字节流转换成字符流的转换流，没有提供将字符流转换成字节流的转换流。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/网络安全——互联网使用的安全协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"
    >网络安全——互联网使用的安全协议</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-10-30T07:47:52.000Z" itemprop="datePublished">2020-10-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="网络层安全协议"><a href="#网络层安全协议" class="headerlink" title="网络层安全协议"></a>网络层安全协议</h1><p>IP 安全性很差：</p>
<ul>
<li>没有为通信提供良好的数据源鉴别机制；</li>
<li>没有为数据提供强大的完整性保护机制；</li>
<li>没有为数据提供任何机密性保护；</li>
<li>在设计和实现上存在安全漏洞，使各种攻击有机可乘。例如：攻击者很容易构造一个包含虚假地址的 IP 数据报。</li>
</ul>
<p>IP 几乎不具备任何安全性，不能保证：数据机密性、数据完整性、数据来源认证。</p>
<p>IPsec 提供了标准、健壮且包含广泛的机制保证 IP 层安全。</p>
<h2 id="IPsec协议族"><a href="#IPsec协议族" class="headerlink" title="IPsec协议族"></a>IPsec协议族</h2><p>IPsec 就是“IP 安全(<code>security</code>)”的缩写。IPsec 并不是一个单个的协议，而是能够在 IP 层提供互联网通信安全的协议族。</p>
<p>IPsec 是个框架，它允许通信双方选择合适的算法和参数（例如，密钥长度）。</p>
<p>为保证互操作性，IPsec 还包含了所有 IPsec 的实现都必须有的一套加密算法。</p>
<h3 id="IPsec协议组成"><a href="#IPsec协议组成" class="headerlink" title="IPsec协议组成"></a>IPsec协议组成</h3><p>IPsec 由三部分组成：</p>
<ul>
<li>IP 安全数据报格式的两个协议：鉴别首部 AH(<code>Authentication Header</code>)协议、封装安全有效载荷 ESP(<code>Encapsulation Security Payload</code>)协议</li>
<li>有关加密算法的三个协议</li>
<li>互联网密钥交换 IKE(<code>Internet Key Exchange</code>)协议</li>
</ul>
<p>AH 协议提供源点鉴别和数据完整性，但不能保密。ESP 协议比 AH 协议复杂得多，它提供源点鉴别、数据完整性和保密。</p>
<p>使用 ESP 或 AH 协议的 IP 数据报称为 IP 安全数据报（或 IPsec数据报）。</p>
<p>IPsec 支持 IPv4 和 IPv6。</p>
<p>AH 协议的功能都已包含在 ESP 协议中。因此使用 ESP 协议就可以不使用 AH 协议。</p>
<h3 id="IP-安全数据报有两种工作方式"><a href="#IP-安全数据报有两种工作方式" class="headerlink" title="IP 安全数据报有两种工作方式"></a>IP 安全数据报有两种工作方式</h3><p>运输方式：在整个运输层报文段的前后分别添加若干控制信息，再加上 IP 首部，构成 IP 安全数据报。适合于主机到主机之间的安全传送。 需要使用 IPsec 的主机都运行 IPsec 协议。</p>
<img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img1.png" class="">

<p>隧道方式：在原始的 IP 数据报的前后分别添加若干控制信息，再加上新的 IP 首部，构成一个 IP 安全数据报。需要在 IPsec 数据报所经过的所有路由器上都运行 IPsec 协议。隧道方式常用来实现虚拟专用网 VPN。</p>
<img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img2.png" class="">

<p>无论使用哪种方式，最后得出的 IP 安全数据报的 IP 首部都是不加密的。</p>
<p>所谓“安全数据报”是指数据报的数据部分是经过加密的，并能够被鉴别的。</p>
<p>通常把数据报的数据部分称为数据报的有效载荷(<code>payload</code>)。</p>
<h2 id="安全关联"><a href="#安全关联" class="headerlink" title="安全关联"></a>安全关联</h2><p>在发送 IP 安全数据报之前，在源实体和目的实体之间必须创建一条网络层的逻辑连接。此逻辑连接叫做安全关联 SA(<code>Security Association</code>)。</p>
<p>IPsec 就把传统互联网无连接的网络层转换为具有逻辑连接的网络层。 </p>
<p>安全关联是从源点到终点的单向连接，它能够提供安全服务。</p>
<p>在安全关联 SA 上传送的就是 IP 安全数据报。</p>
<p>如要进行双向安全通信，则两个方向都需要建立安全关联。</p>
<p>若 n 个员工进行双向安全通信，一共需要创建(<code>2 + 2n</code>)条安全关联 SA。</p>
<p>路由器 R1 到 R2 的安全关联 SA<br>假定公司总部的主机 H1 要和分公司的主机 H2 通过互联网进行安全通信。公司总部与分公司之间的安全关联 SA 就是在路由器 R1 和 R2 之间建立的。</p>
<img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img3.png" class="">

<p>主机 H1 到 H3 之间的通信<br>假定公司总部的主机 H1 要和内部的主机 H3 进行通信。由于都在公司内部，不需要加密，因此不需要建立安全关联。</p>
<img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img4.png" class="">

<p>路由器 R1 到主机 H2 的安全关联 SA<br>若公司总部的主机 H1 要和某外地业务员的主机 H2 进行安全通信，需要在公司总部的路由器 R1 和外地业务员的主机 H2 建立安全关联 SA。</p>
<img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img5.png" class="">

<p>安全关联 SA 状态信息：</p>
<ol>
<li>一个 32 位的连接标识符，称为安全参数索引 SPI(<code>Security Parameter Index</code>)。</li>
<li>安全关联 SA 的源点和终点的 IP 地址（例如路由器 R1 和 R2 的 IP 地址）。</li>
<li>所使用的加密类型（例如，DES 或 AES）。</li>
<li>加密的密钥。</li>
<li>完整性检查的类型（例如，使用报文摘要 MD5 或 SHA-1 的报文鉴别码 MAC）。</li>
<li>鉴别使用的密钥。</li>
</ol>
<h2 id="IP-安全数据报的格式"><a href="#IP-安全数据报的格式" class="headerlink" title="IP 安全数据报的格式"></a>IP 安全数据报的格式</h2><img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img6.png" class="">

<p>注意：在“原始的 IP 首部”中，用主机 H1 和 H2 的 IP 地址分别作为源地址和目的地址。而在 IP 安全数据报的“新的 IP 首部”中，用路由器 R1 和 R2 的 IP 地址分别作为源地址和目的地址。</p>
<h2 id="IPsec-的其他构件"><a href="#IPsec-的其他构件" class="headerlink" title="IPsec 的其他构件"></a>IPsec 的其他构件</h2><p>安全关联数据库 SAD(<code>Security Association Database</code>) 存放SA。<br>安全策略数据库 SPD(<code>Security Policy Database</code>) 指明什么样的数据报需要进行 IPsec 处理。<br>互联网密钥交换 IKE(<code>Internet Key Exchange</code>) 为 IP 安全数据报创建安全关联 SA。</p>
<p>IKE 是个非常复杂的协议，以另外三个协议为基础：</p>
<ul>
<li>Oakley —— 是密钥生成协议。</li>
<li>安全密钥交换机制 SKEME(<code>Secure Key Exchange Mechanism</code>) —— 是用于密钥交换的协议。它利用公钥加密来实现密钥交换协议中的实体鉴别。</li>
<li>互联网安全关联和密钥管理协议 ISAKMP(<code>Internet Secure Association and Key Management Mechanism</code>) —— 用于实现 IKE 中定义的密钥交换，使 IKE 的交换能够以标准化、格式化的报文创建安全关联 SA。</li>
</ul>
<h1 id="运输层安全协议"><a href="#运输层安全协议" class="headerlink" title="运输层安全协议"></a>运输层安全协议</h1><p>现在广泛使用的有以下两个协议： </p>
<ul>
<li>安全套接字层 SSL(<code>Secure Socket Layer</code>) </li>
<li>运输层安全 TLS(<code>Transport Layer Security</code>)</li>
</ul>
<p>安全套接层 SSL 由 Netscape 于 1994 年开发，广泛应用于基于万维网的各种网络应用（但不限于万维网应用）。SSL 作用在端系统应用层的 HTTP 和运输层之间，在 TCP 之上建立起一个安全通道，为通过 TCP 传输的应用层数据提供安全保障。</p>
<p>1996 年发布 SSL 3.0，成为 Web 安全的事实标准。</p>
<p>1999 年，IETF 在 SSL 3.0 基础上推出了传输层安全标准 TLS，为所有基于 TCP 的网络应用提供安全数据传输服务。</p>
<h2 id="SSL-x2F-TLS-的位置"><a href="#SSL-x2F-TLS-的位置" class="headerlink" title="SSL &#x2F; TLS 的位置"></a>SSL &#x2F; TLS 的位置</h2><img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img7.png" class="">

<p>在发送方，SSL 接收应用层的数据，对数据进行加密，然后把加了密的数据送往 TCP 套接字。在接收方，SSL 从 TCP 套接字读取数据，解密后把数据交给应用层。 </p>
<h2 id="运输层不使用安全协议和使用安全协议的对比"><a href="#运输层不使用安全协议和使用安全协议的对比" class="headerlink" title="运输层不使用安全协议和使用安全协议的对比"></a>运输层不使用安全协议和使用安全协议的对比</h2><img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img8.png" class="">

<p>SSL &#x2F; TLS 建立在可靠的 TCP 之上，与应用层协议独立无关。</p>
<p>SSL &#x2F; TLS 已被所有常用的浏览器和万维网服务器所支持。</p>
<p>SSL &#x2F; TLS 基本目标：实现两个应用实体之间的安全可靠通信。</p>
<p>应用层使用 SSL 最多的就是 HTTP，但 SSL 并非仅用于 HTTP，而是可用于任何应用层的协议。</p>
<p>TCP 的 HTTPS 端口号是 443，而不是平时使用的端口号 80。</p>
<h2 id="SSL提供的安全服务"><a href="#SSL提供的安全服务" class="headerlink" title="SSL提供的安全服务"></a>SSL提供的安全服务</h2><p>SSL提供的安全服务：</p>
<ul>
<li>SSL 服务器鉴别，允许用户证实服务器的身份。支持 SSL 的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥。</li>
<li>SSL 客户鉴别，SSL 的可选安全服务，允许服务器证实客户的身份。</li>
<li>加密的 SSL 会话，对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。</li>
</ul>
<h2 id="SSL安全会话建立过程"><a href="#SSL安全会话建立过程" class="headerlink" title="SSL安全会话建立过程"></a>SSL安全会话建立过程</h2><img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img9.png" class="">

<p>简要过程：</p>
<ol>
<li>协商加密算法。浏览器 A 向服务器 B 发送浏览器的 SSL 版本号和一些可选的加密算法。B 从中选定自己所支持的算法（如 RSA），并告知 A。</li>
<li>服务器鉴别。服务器 B 向浏览器 A 发送包含其 RSA 公钥的数字证书。A 使用该证书的认证机构 CA 公开发布的RSA公钥对该证书进行验证。</li>
<li>会话密钥计算。由浏览器 A 随机产生一个秘密数。用服务器 B 的 RSA 公钥进行加密后发送给 B。双方根据协商的算法产生共享的对称会话密钥。</li>
<li>安全数据传输。双方用会话密钥加密和解密它们之间传送的数据并验证其完整性。</li>
</ol>
<h1 id="应用层安全协议"><a href="#应用层安全协议" class="headerlink" title="应用层安全协议"></a>应用层安全协议</h1><h2 id="应用层中有关电子邮件的安全协议。"><a href="#应用层中有关电子邮件的安全协议。" class="headerlink" title="应用层中有关电子邮件的安全协议。"></a>应用层中有关电子邮件的安全协议。</h2><p>发送电子邮件是个即时的行为。发送方 A 和接收方 B 并不会为此而建立任何会话。</p>
<p>电子邮件安全协议就应当为每种加密操作定义相应的算法，以及密钥管理、鉴别、完整性保护等方法。</p>
<h2 id="PGP-Pretty-Good-Privacy"><a href="#PGP-Pretty-Good-Privacy" class="headerlink" title="PGP (Pretty Good Privacy)"></a>PGP (Pretty Good Privacy)</h2><p>PGP(<code>Pretty Good Privacy</code>)是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。</p>
<p>PGP 并没有使用什么新的概念，它只是将现有的一些算法如 MD5，RSA，以及 IDEA 等综合在一起而已。</p>
<h3 id="PGP-工作原理"><a href="#PGP-工作原理" class="headerlink" title="PGP 工作原理"></a>PGP 工作原理</h3><p>假定 A 向 B 发送电子邮件明文X，使用 PGP 进行加密。A 有三个密钥：A的私钥、B的公钥和A生成的一次性密钥。B 有两个密钥：B的私钥和A的公钥。</p>
<p>PGP 提供电子邮件的安全性、发送方鉴别和报文完整性。</p>
<img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img10.png" class="">
<img src="/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E4%BA%92%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/img11.png" class="">

<p>发送方 A 的工作：</p>
<ol>
<li>对明文邮件 X 进行 MD5 运算，得出 MD5 报文摘要 H。用 A 的私钥对 H 进行加密（即数字签名），得出报文鉴别码 MAC，把它拼接在明文 X 后面，得到扩展的邮件(<code>X, MAC</code>)。</li>
<li>使用 A 自己生成的一次性密钥对扩展的邮件(<code>X, MAC</code>)进行加密。</li>
<li>用 B 的公钥对 A 生成的一次性密钥进行加密。</li>
<li>把加了密的一次性密钥和加了密的扩展的邮件发送给 B。</li>
</ol>
<p>接收方 B 的工作：</p>
<ol>
<li>把被加密的一次性密钥和被加密的扩展报文(<code>X, MAC</code>)分离开。</li>
<li>用 B 自己的私钥解出 A 的一次性密钥。</li>
<li>用解出的一次性密钥对报文进行解密，然后分离出明文 X 和 MAC。</li>
<li>用 A 的公钥对 MAC 进行解密（即签名核实），得出报文摘要 H。这个报文摘要就是 A 原先用明文邮件 X 通过 MD5 运算生成的那个报文摘要。</li>
<li>对分离出的明文邮件 X 进行 MD5 报文摘要运算，得出另一个报文摘要<code>H(X)</code>。把<code>H(X)</code>和前面得出的 H 进行比较，是否一样。如一样，则对邮件的发送方的鉴别就通过了，报文的完整性也得到肯定。</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/网络安全——概述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"
    >网络安全——概述</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2020-10-29T06:30:16.000Z" itemprop="datePublished">2020-10-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="网络安全问题概述"><a href="#网络安全问题概述" class="headerlink" title="网络安全问题概述"></a>网络安全问题概述</h1><h2 id="计算机网络面临的安全性威胁"><a href="#计算机网络面临的安全性威胁" class="headerlink" title="计算机网络面临的安全性威胁"></a>计算机网络面临的安全性威胁</h2><p>计算机网络上的通信面临两大类威胁：被动攻击和主动攻击。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img1.png" class="">

<p>被动攻击是指攻击者从网络上窃听他人的通信内容。通常把这类攻击称为截获。在被动攻击中，攻击者只是观察和分析某一个协议数据单元 PDU，以便了解所交换的数据的某种性质。但不干扰信息流。这种被动攻击又称为流量分析(<code>traffic analysis</code>)。</p>
<p>主动攻击主要有：</p>
<ul>
<li>篡改：故意篡改网络上传送的报文。这种攻击方式有时也称为更改报文流。</li>
<li>恶意程序：种类繁多，对网络安全威胁较大的主要包括：计算机病毒、计算机蠕虫、特洛伊木马、逻辑炸弹、后门入侵、流氓软件等。</li>
<li>拒绝服务DoS(<code>Denial of Service</code>)：指攻击者向互联网上的某个服务器不停地发送大量分组，使该服务器无法提供正常服务，甚至完全瘫痪。</li>
</ul>
<p>若从互联网上的成百上千的网站集中攻击一个网站，则称为分布式拒绝服务 DDoS(<code>Distributed Denial of Service</code>)。有时也把这种攻击称为网络带宽攻击或连通性攻击。</p>
<h3 id="计算机网络通信安全的目标"><a href="#计算机网络通信安全的目标" class="headerlink" title="计算机网络通信安全的目标"></a>计算机网络通信安全的目标</h3><p>对于主动攻击，可以采取适当措施加以检测。对于被动攻击，通常却是检测不出来的。</p>
<p>根据这些特点，可得出计算机网络通信安全的目标：</p>
<ul>
<li>防止分析出报文内容和流量分析。</li>
<li>防止恶意程序。</li>
<li>检测更改报文流和拒绝服务。</li>
</ul>
<p>对付被动攻击可采用各种数据加密技术。对付主动攻击则需将加密技术与适当的鉴别技术相结合。</p>
<h2 id="安全的计算机网络"><a href="#安全的计算机网络" class="headerlink" title="安全的计算机网络"></a>安全的计算机网络</h2><p>网络的安全性是不可判定的。一个安全的计算机网络应达到四个目标：</p>
<ul>
<li>保密性：只有信息的发送方和接收方才能懂得所发送信息的内容。是网络安全通信的最基本的内容，也是对付被动攻击必须具备的功能。为了使网络具有保密性，需要使用各种密码技术。</li>
<li>端点鉴别：鉴别信息的发送方和接收方的真实身份。 在对付主动攻击中是非常重要的。</li>
<li>信息的完整性：信息的内容未被篡改过。在应对主动攻击中是必不可少的。信息的完整性与端点鉴别往往是不可分割的。在谈到“鉴别”时，也同时包含了端点鉴别和报文完整性。</li>
<li>运行的安全性：系统能正常运行并提供服务。访问控制对计算机系统的安全性是非常重要的。必须对访问网络的权限加以控制，并规定每个用户的访问权限。</li>
</ul>
<h2 id="数据加密模型"><a href="#数据加密模型" class="headerlink" title="数据加密模型"></a>数据加密模型</h2><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img2.png" class="">

<p>加密和解密用的密钥<code>K(key)</code>是一串秘密的字符串（即比特串）。</p>
<p>明文通过加密算法 E 和加密密钥 K 变成密文：Y &#x3D; E<sub>k</sub>(X)。</p>
<p>接收端利用解密算法 D 运算和解密密钥 K 解出明文 X。解密算法是加密算法的逆运算。</p>
<p>D<sub>k</sub>(Y) &#x3D; D<sub>k</sub>(E<sub>k</sub>(X)) &#x3D; X </p>
<p>加密密钥和解密密钥可以一样，也可以不一样。密钥通常由密钥中心提供。当密钥需要向远地传送时，一定要通过另一个安全信道。</p>
<h1 id="两类密码体制"><a href="#两类密码体制" class="headerlink" title="两类密码体制"></a>两类密码体制</h1><h2 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h2><p>所谓对称密钥密码体制，即加密密钥与解密密钥是相同的密码体制。这种加密系统又称为对称密钥系统。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img3.png" class="">

<h3 id="数据加密标准-DES"><a href="#数据加密标准-DES" class="headerlink" title="数据加密标准 DES"></a>数据加密标准 DES</h3><p>数据加密标准 DES 属于对称密钥密码体制，是一种分组密码。</p>
<p>在加密前，先对整个明文进行分组。每一个组长为 64 位。然后对每一个 64 位二进制数据进行加密处理，产生一组 64 位密文数据。最后将各组密文串接起来，即得出整个的密文。</p>
<p>使用的密钥为 64 位（实际密钥长度为 56 位，有 8 位用于奇偶校验)。</p>
<p>DES 的保密性仅取决于对密钥的保密，其算法是公开的。</p>
<p>目前较为严重的问题是 DES 的密钥的长度。56 位长的密钥意味着共有2<sup>56</sup>种可能的密钥。现在已经设计出搜索 DES 密钥的专用芯片。56位 DES 已不再认为是安全的了。 </p>
<h3 id="三重-DES"><a href="#三重-DES" class="headerlink" title="三重 DES"></a>三重 DES</h3><p>使用两个 56 位的密钥。把一个 64 位明文用一个密钥加密，再用另一个密钥解密，然后再使用第一个密钥加密，即：</p>
<p>Y &#x3D; DES<sub>K1</sub>(DES<sup>-1</sup><sub>K2</sub>(DES<sub>K1</sub>(X)))</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img4.png" class="">

<h2 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h2><p>公钥密码体制（又称为公开密钥密码体制）使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。</p>
<p>公钥密码体制产生的主要原因：</p>
<ul>
<li>常规密钥密码体制的密钥分配问题。</li>
<li>对数字签名的需求。</li>
</ul>
<p>在公钥密码体制中，加密密钥 PK（<code>public key</code>，即公钥）是向公众公开的，而解密密钥 SK（<code>secret key</code>，即私钥或秘钥）则是需要保密的。</p>
<p>加密算法 E 和解密算法 D 也都是公开的。</p>
<p>虽然私钥 SK 是由公钥 PK 决定的，但却不能根据 PK 计算出 SK。</p>
<p>任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量。在这方面，公钥密码体制并不具有比传统加密体制更加优越之处。</p>
<p>公钥还需要密钥分配协议，具体的分配过程并不比采用传统加密方法时更简单。 </p>
<h3 id="公钥算法的特点"><a href="#公钥算法的特点" class="headerlink" title="公钥算法的特点"></a>公钥算法的特点</h3><ol>
<li>密钥对产生器产生出接收者 B 的一对密钥：加密密钥 PK<sub>B</sub> 和解密密钥 SK<sub>B</sub>。<br>加密密钥 PK<sub>B</sub> 就是接收者B的公钥，它向公众公开。解密密钥 SK<sub>B</sub> 就是接收者B的私钥，对其他人都保密。</li>
<li>发送者 A 用 B 的公钥 PK<sub>B</sub> 对明文 X 加密（E 运算）后，接收者 B 用自己的私钥 SK<sub>B</sub> 解密（D 运算），即可恢复出明文：<br>D<sub>SK<sub>B</sub></sub>(Y) &#x3D; D<sub>SK<sub>B</sub></sub>(E<sub>PK<sub>B</sub></sub>(X)) &#x3D; X</li>
</ol>
<p>加密密钥是公开的，但不能用它来解密，即：</p>
<p>D<sub>PK<sub>B</sub></sub>(E<sub>PK<sub>B</sub></sub>(X)) ≠ X</p>
<p>加密和解密运算可以对调，即加密和解密是互逆的：</p>
<p>E<sub>PK<sub>B</sub></sub>(D<sub>SK<sub>B</sub></sub>(X)) &#x3D; D<sub>SK<sub>B</sub></sub>(E<sub>PK<sub>B</sub></sub>(X)) &#x3D; X</p>
<p>公钥密码体制</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img5.png" class="">

<h3 id="公开密钥与对称密钥的区别"><a href="#公开密钥与对称密钥的区别" class="headerlink" title="公开密钥与对称密钥的区别"></a>公开密钥与对称密钥的区别</h3><p>在使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行一对一的双向保密通信，每一方既可用此密钥加密明文，并发送给对方，也可接收密文，用同一密钥对密文解密。这种保密通信仅限于持有此密钥的双方（如再有第三方就不保密了）。</p>
<p>在使用公开密钥时，在通信信道上可以是多对一的单向保密通信。</p>
<h3 id="公钥密码体制-1"><a href="#公钥密码体制-1" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h3><p>如果某一信息用公开密钥加密，则必须用私有密钥解密，这就是实现保密的方法。</p>
<p>如果某一信息用私有密钥加密，那么，它必须用公开密钥解密。这就是实现数字签名的方法。</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>用于证明真实性。</p>
<p>数字签名必须保证以下三点：</p>
<ul>
<li>报文鉴别——接收者能够核实发送者对报文的签名（证明来源）；</li>
<li>报文的完整性——发送者事后不能抵赖对报文的签名（防否认）；</li>
<li>不可否认——接收者不能伪造对报文的签名（防伪造）。</li>
</ul>
<p>现在已有多种实现各种数字签名的方法。但采用公钥算法更容易实现。</p>
<p>基于公钥的数字签名的实现</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img6.png" class="">

<p>因为除 A 外没有别人能具有 A 的私钥，所以除 A 外没有别人能产生这个密文。因此 B 相信报文 X 是 A 签名发送的。</p>
<p>若 A 要抵赖曾发送报文给 B，B 可将明文和对应的密文出示给第三者。第三者很容易用 A 的公钥去证实 A 确实发送 X 给 B。</p>
<p>反之，若 B 将 X 伪造成 X’，则 B 不能在第三者前出示对应的密文。这样就证明了 B 伪造了报文。 </p>
<p>具有保密性的数字签名 </p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img7.png" class="">

<h1 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h1><p>在信息的安全领域中，对付被动攻击的重要措施是加密，而对付主动攻击中的篡改和伪造则要用鉴别(<code>authentication</code>)。</p>
<p>报文鉴别使得通信的接收方能够验证所收到的报文（发送者和报文内容、发送时间、序列等）的真伪。</p>
<p>使用加密就可达到报文鉴别的目的。但在网络的应用中，许多报文并不需要加密。应当使接收者能用很简单的方法鉴别报文的真伪。 </p>
<p>鉴别与授权(<code>authorization</code>)是不同的概念。授权涉及到的问题是：所进行的过程是否被允许（如是否可以对某文件进行读或写）。 </p>
<h2 id="鉴别分类"><a href="#鉴别分类" class="headerlink" title="鉴别分类"></a>鉴别分类</h2><p>可再把鉴别细分为两种。</p>
<ul>
<li>报文鉴别：即鉴别所收到的报文的确是报文的发送者所发送的，而不是其他人伪造的或篡改的。这就包含了端点鉴别和报文完整性的鉴别。</li>
<li>实体鉴别：仅仅鉴别发送报文的实体。实体可以是一个人，也可以是一个进程（客户或服务器）。这就是端点鉴别。</li>
</ul>
<h2 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h2><p>许多报文并不需要加密，但却需要数字签名，以便让报文的接收者能够鉴别报文的真伪。</p>
<p>然而对很长的报文进行数字签名会使计算机增加很大的负担（需要进行很长时间的运算）。</p>
<p>当我们传送不需要加密的报文时，应当使接收者能用很简单的方法鉴别报文的真伪。</p>
<h2 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a>密码散列函数</h2><p>数字签名就能够实现对报文的鉴别。但这种方法有一个很大的缺点：对较长的报文（这是很常见的）进行数字签名会使计算机增加非常大的负担，因为这需要较多的时间来进行运算。</p>
<p>密码散列函数(<code>cryptographic hash function</code>)是一种相对简单的对报文进行鉴别的方法。</p>
<p>散列函数的两个特点：</p>
<ul>
<li>散列函数的输入长度可以很长，但其输出长度则是固定的，并且较短。散列函数的输出叫做散列值，或称为散列。</li>
<li>不同的散列值肯定对应于不同的输入，但不同的输入却可能得出相同的散列值。这就是说，散列函数的输入和输出并非一一对应，而是多对一的。</li>
</ul>
<h2 id="密码散列函数的特点"><a href="#密码散列函数的特点" class="headerlink" title="密码散列函数的特点"></a>密码散列函数的特点</h2><p>在密码学中使用的散列函数称为密码散列函数。</p>
<p>特点：单向性。</p>
<p>要找到两个不同的报文，它们具有同样的密码散列函数输出，在计算上是不可行的。</p>
<p>也就是说，密码散列函数实际上是一种单向函数。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img8.png" class="">

<h2 id="实用的密码散列函数-MD5-和-SHA-1"><a href="#实用的密码散列函数-MD5-和-SHA-1" class="headerlink" title="实用的密码散列函数 MD5 和 SHA-1"></a>实用的密码散列函数 MD5 和 SHA-1</h2><h3 id="MD5-算法"><a href="#MD5-算法" class="headerlink" title="MD5 算法"></a>MD5 算法</h3><p>MD5 是报文摘要 MD(<code>Message Digest</code>) 的第 5 个版本。</p>
<p>根据给定的 MD5 报文摘要代码，要找出一个与原来报文有相同报文摘要的另一报文，其难度在计算上几乎是不可能的。</p>
<p>基本思想：用足够复杂的方法将报文的数据位充分“弄乱”，报文摘要代码中的每一位都与原来报文中的每一位有关。</p>
<p>计算步骤：</p>
<ul>
<li>附加：把任意长的报文按模 2<sup>64</sup> 计算其余数（64位），追加在报文的后面（长度项）。</li>
<li>填充：在报文和长度项之间填充 1～512 位，使得填充后的总长度是 512 的整数倍。填充的首位是 1，后面都是 0。<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img9.png" class=""></li>
<li>分组：把追加和填充后的报文分割为一个个 512 位的数据块，每个 512 位的报文数据再分成 4 个 128 位的数据块。</li>
<li>计算：将 4 个 128 位的数据块依次送到不同的散列函数进行 4 轮计算。每一轮又都按 32 位的小数据块进行复杂的运算。一直到最后计算出 MD5 报文摘要代码（128 位）。</li>
</ul>
<h3 id="安全散列算法（SHA-1）"><a href="#安全散列算法（SHA-1）" class="headerlink" title="安全散列算法（SHA-1）"></a>安全散列算法（SHA-1）</h3><p>安全散列算法 SHA(<code>Secure Hash Algorithm</code>)是由美国标准与技术协会 NIST 提出的一个散列算法系列。</p>
<p>SHA 比 MD5 更安全，但计算起来却比 MD5 要慢些。</p>
<p>已制定 SHA-1、SHA-2、 SHA-3 等版本。</p>
<p>基本思想：</p>
<ul>
<li>要求输入码长小于 264 位，输出码长为 160 位。</li>
<li>将明文分成若干 512 位的定长块，每一块与当前的报文摘要值结合，产生报文摘要的下一个中间结果，直到处理完毕。</li>
<li>共扫描 5 遍，效率略低于 MD5，抗穷举性更高。</li>
</ul>
<h3 id="报文鉴别码-MAC"><a href="#报文鉴别码-MAC" class="headerlink" title="报文鉴别码 MAC"></a>报文鉴别码 MAC</h3><p>MD5 实现的报文鉴别可以防篡改，但不能防伪造，因而不能真正实现报文鉴别。</p>
<p>例如：</p>
<ol>
<li>入侵者创建了一个伪造的报文 M，然后计算出其散列 H(M)，并把拼接有散列的扩展报文冒充 A 发送给 B。</li>
<li>B 收到扩展的报文 (M, H(M)) 后， 通过散列函数的运算，计算出收到的报文 MR 的散列 H(MR)。</li>
<li>若 H(M) &#x3D; H(MR)，则 B 就会误认为所收到的伪造报文就是 A 发送的。</li>
</ol>
<p>为防范上述攻击，可以对散列进行一次加密。散列加密后的结果叫做报文鉴别码 MAC(<code>Message Authentication Code</code>)。</p>
<p>由于入侵者不掌握密钥 K，所以入侵者无法伪造 A 的报文鉴别码 MAC，因而无法伪造 A 发送的报文。这样就完成了对报文的鉴别。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img10.png" class="">

<p>现在整个的报文是不需要加密的。</p>
<p>虽然从散列 H 导出报文鉴别码 MAC 需要加密算法，但由于散列 H 的长度通常都远远小于报文 X 的长度，因此这种加密不会消耗很多的计算资源。因此，使用鉴别码 MAC 就能够很方便地保护报文的完整性。</p>
<h2 id="实体鉴别"><a href="#实体鉴别" class="headerlink" title="实体鉴别"></a>实体鉴别</h2><p>实体鉴别与报文鉴别不同。</p>
<p>报文鉴别是对每一个收到的报文都要鉴别报文的发送者。</p>
<p>实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体只需验证一次。 </p>
<h3 id="最简单的实体鉴别过程"><a href="#最简单的实体鉴别过程" class="headerlink" title="最简单的实体鉴别过程"></a>最简单的实体鉴别过程</h3><p>可以使用共享的对称密钥实现实体鉴别。</p>
<p>A 发送给 B 的报文加密，使用的是对称密钥 K<sub>AB</sub>。</p>
<p>B 收到此报文后，用共享对称密钥 K<sub>AB</sub> 进行解密，因而鉴别了实体 A 的身份。 因为该密钥只有 A 和 B 知道。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img11.png" class="">

<h3 id="存在明显漏洞"><a href="#存在明显漏洞" class="headerlink" title="存在明显漏洞"></a>存在明显漏洞</h3><p>入侵者 C 可以从网络上截获 A 发给 B 的报文。</p>
<p>C 并不需要破译这个报文，而是直接把这个截获的、由 A 加密的报文发送给 B，使 B 误认为 C 就是 A。然后 B 就向伪装是 A 的 C 发送应发给 A 的报文。</p>
<p>这种攻击被称为重放攻击。C 甚至还可以截获 A 的 IP 地址，然后把 A 的 IP 地址冒充为自己的 IP 地址（这叫做 IP 欺骗），使 B 更加容易受骗。</p>
<p>为了对付重放攻击，可以使用不重数进行鉴别。</p>
<p>不重数就是一个不重复使用的大随机数，即“一次一数”。由于不重数不能重复使用，所以 C 在进行重放攻击时无法重复使用所截获的不重数。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img12.png" class="">

<p>在使用公钥密码体制时，可以对不重数进行签名鉴别。</p>
<p>B 用其私钥对不重数 R<sub>A</sub> 进行签名后发回给 A。A 用 B 的公钥核实签名。如能得出自己原来发送的不重数 R<sub>A</sub>，就核实了和自己通信的对方的确是 B。</p>
<p>同样，A 也用自己的私钥对不重数 R<sub>B</sub> 进行签名后发送给 B。B 用 A 的公钥核实签名，鉴别了 A 的身份。</p>
<p>公钥密码体制虽然不必在互相通信的用户之间秘密地分配共享密钥，但仍有受到攻击的可能。</p>
<p>C 冒充是 A，发送报文给 B，说：“我是 A”。<br>B 选择一个不重数 R<sub>B</sub>，发送给 A，但被 C 截获了。<br>C 用自己的私钥 SK<sub>C</sub> 冒充是 A 的私钥，对 RB 加密，并发送给 B。<br>B 向 A 发送报文，要求对方把解密用的公钥发送过来，但这报文也被 C 截获了。<br>C 把自己的公钥 PK<sub>C</sub> 冒充是 A 的公钥发送给 B。<br>B 用收到的公钥 PK<sub>C</sub> 对收到的加密的 R<sub>B</sub> 进行解密，其结果当然正确。于是 B 相信通信的对方是 A，接着就向 A 发送许多敏感数据，但都被 C 截获了。</p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img13.png" class="">

<p>A 想和 B 通信。A 向 B 发送“我是 A”的报文，并给出了自己的身份。此报文被 “中间人” C 截获，C 把此报文原封不动地转发给 B。B 选择一个不重数 R<sub>B</sub> 发送给 A，但同样被 C 截获后也照样转发给 A。</p>
<p>中间人 C 用自己的私钥 SK<sub>C</sub> 对 R<sub>B</sub> 加密后发回给 B，使 B 误以为是 A 发来的。A 收到 R<sub>B</sub> 后也用自己的私钥 SK<sub>A</sub> 对 R<sub>B</sub> 加密后发回给 B，中途被 C 截获并丢弃。B 向 A 索取其公钥，此报文被 C 截获后转发给 A。</p>
<p>C 把自己的公钥 PK<sub>C</sub> 冒充是 A 的发送给 B，而 C 也截获到 A 发送给 B 的公钥 PK<sub>A</sub>。</p>
<p>B 用收到的公钥 PK<sub>C</sub> （以为是 A 的）对数据加密发送给 A。C 截获后用自己的私钥 SK<sub>C</sub> 解密，复制一份留下，再用 A 的公钥 PK<sub>A</sub> 对数据加密后发送给 A。</p>
<p>A 收到数据后，用自己的私钥 SK<sub>A</sub> 解密，以为和 B 进行了保密通信。其实，B 发送给 A 的加密数据已被中间人 C 截获并解密了一份。但 A 和 B 却都不知道。</p>
<p>由此可见，公钥的分配以及认证公钥的真实性也是一个非常重要的问题。</p>
<h1 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h1><p>由于密码算法是公开的，网络的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支——密钥管理。</p>
<p>密钥管理包括：密钥的产生、分配、注入、验证和使用。</p>
<p>密钥分配是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。</p>
<p>网外分配方式：派非常可靠的信使携带密钥分配给互相通信的各用户。</p>
<p>网内分配方式：密钥自动分配。</p>
<p>但随着用户的增多和网络流量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法已不再适用，而应采用网内分配方式。</p>
<h2 id="对称密钥的分配"><a href="#对称密钥的分配" class="headerlink" title="对称密钥的分配"></a>对称密钥的分配</h2><p>目前常用的密钥分配方式是设立密钥分配中心 KDC(<code>Key Distribution Center</code>)。</p>
<p>KDC 是大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分配一个会话密钥（仅使用一次）。</p>
<h3 id="密钥分配步骤"><a href="#密钥分配步骤" class="headerlink" title="密钥分配步骤"></a>密钥分配步骤</h3><p>假设用户 A 和 B 都是 KDC 的登记用户，并已经在 KDC 的服务器上安装了各自和 KDC 进行通信的主密钥 K<sub>A</sub> 和 K<sub>B</sub>。 “主密钥”可简称为“密钥”。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img14.png" class="">

<p>密钥分配分的三个步骤：</p>
<ol>
<li>用户 A 向 KDC 发送时用明文，说明想和 B 通信。在明文中给出 A 和 B 在 KDC 登记的身份。</li>
<li>KDC 用随机数产生“一次一密”的会话秘钥 K<sub>AB</sub> 供 A 和 B 的这次会话使用，然后向 A 发送回答报文。这个回答报文用 A 的密钥 K<sub>A</sub> 加密。这个报文中包含这次会话使用的密钥 K<sub>AB</sub> 和请 A 转给 B 的一个票据(<code>ticket</code>)，该票据包括 A 和 B 在 KDC 登记的身份，以及这次会话将要使用的密钥 K<sub>AB</sub>。票据用 B 的密钥 K<sub>B</sub> 加密，A 无法知道此票据的内容，因为 A 没有 B 的密钥 K<sub>B</sub>，当然 A 也不需要知道此票据的内容。</li>
<li>当 B 收到 A 转来的票据并使用自己的密钥 K<sub>B</sub> 解密后，就知道 A 要和它通信，同时也知道 KDC 为这次和 A 通信所分配的会话密钥K<sub>AB</sub>。</li>
</ol>
<p>此后，A 和 B 就可以使用会话秘钥 K<sub>AB</sub> 进行通信了。</p>
<h3 id="对称密钥的分配说明"><a href="#对称密钥的分配说明" class="headerlink" title="对称密钥的分配说明"></a>对称密钥的分配说明</h3><p>为防止重放攻击，KDC 还可在报文中加入时间戳。</p>
<p>会话密钥 K<sub>AB</sub> 是一次性的，因此保密性较高。</p>
<p>KDC 分配给用户的密钥 K<sub>A</sub> 和 K<sub>B</sub>，应定期更换，以减少攻击者破译密钥的机会。</p>
<h3 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h3><p>目前最出名的密钥分配协议是 Kerberos V5。Kerberos 既是鉴别协议，同时也是 KDC，现在是互联网建议标准。</p>
<p>Kerberos 使用比 DES 更加安全的高级加密标准 AES 进行加密。</p>
<p>Kerberos 使用两个服务器：鉴别服务器 AS(<code>Authentication Server</code>)、票据授予服务器 TGS(<code>Ticket-Granting Server</code>)。</p>
<p>Kerberos 只用于客户与服务器之间的鉴别，而不用于人对人的鉴别。</p>
<p>下图中，A 是请求服务的客户，B 是被请求的服务器。A 通过 Kerberos 向 B 请求服务。Kerberos 需要经过 6 个步骤鉴别是 A 向 B 请求服务后，才向 A 和 B 分配会话使用的密钥。</p>
<img src="/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/img16.png" class="">

<h3 id="Kerberos密钥分配步骤"><a href="#Kerberos密钥分配步骤" class="headerlink" title="Kerberos密钥分配步骤"></a>Kerberos密钥分配步骤</h3><ol>
<li>A 用明文（包括登记的身份）向鉴别服务器 AS 表明自己的身份。AS 就是 KDC，它掌握各实体登记的身份和相应的口令。</li>
<li>AS 向 A 发送用 A 的对称密钥 K<sub>A</sub> 加密的报文，这个报文包含 A 和 TGS 通信的会话密钥 K<sub>S</sub>，以及 AS 要发送给 TGS 的票据（这个票据是用 TGS 的对称密钥 K<sub>TG</sub> 加密的）。<br>A 并不保存密钥 K<sub>A</sub>。A 需键入正确口令，利用适当的算法生成密钥 K<sub>A</sub>，这个口令随即被销毁。<br>密钥 K<sub>A</sub> 用来对 AS 发送过来的报文进行解密。</li>
<li>A 向 TGS 发送三个项目：</li>
</ol>
<ul>
<li>转发鉴别服务器 AS 发来的票据。</li>
<li>服务器 B 的名字。这表明 A 请求 B 的服务。请注意，现在 A 向 TGS 证明自己的身份并非通过键入口令（因为入侵者能够从网上截获明文口令），而是通过转发 AS 发出的票据（只有 A 才能提取出）。票据是加密的，入侵者伪造不了。</li>
<li>用 K<sub>S</sub> 加密的时间戳 T 。它用来防止入侵者的重放攻击。</li>
</ul>
<ol start="4">
<li>TGS 发送两个票据，每一个都包含 A 和 B 通信的会话密钥 K<sub>AB</sub>。给 A 的票据用 K<sub>S</sub> 加密；给 B 的票据用 B 的密钥 K<sub>B</sub> 加密。请注意，现在入侵者不能提取 K<sub>AB</sub>，因为不知道 K<sub>A</sub> 和 K<sub>B</sub>。入侵者也不能重放步骤 3，因为入侵者不能把时间戳更换为一个新的（因为不知道 K<sub>S</sub>）。</li>
<li>A 向 B 转发 TGS 发来的票据，同时发送用 K<sub>AB</sub> 加密的时间戳 T。</li>
<li>B 把时间戳 T 加 1 来证实收到了票据。B 向 A 发送的报文用密钥 K<sub>AB</sub> 加密。</li>
</ol>
<p>以后，A 和 B 就使用 TGS 给出的会话密钥 K<sub>AB</sub> 进行通信。</p>
<p>Kerberos 要求所有使用 Kerberos 的主机必须在时钟上进行“松散的”同步。所谓“松散的”同步是要求所有主机的时钟误差不能太大，例如，不能超过 5 分钟的数量级。这个要求是为了防止重放攻击。</p>
<h2 id="公钥的分配"><a href="#公钥的分配" class="headerlink" title="公钥的分配"></a>公钥的分配</h2><p>在公钥密码体制中，如果每个用户都具有其他用户的公钥，就可实现安全通信。</p>
<p>但不能随意公布用户的公钥，因为无法防止假冒和欺骗。使用者也无法确定公钥的真正拥有者。</p>
<p>需要有一个值得信赖的机构，即认证中心 CA(<code>Certification Authority</code>)，来将公钥与其对应的实体（人或机器）进行绑定。认证中心一般由政府出资建立。</p>
<p>每个实体都有 CA 发来的证书，里面有公钥及其拥有者的标识信息。此证书被 CA 进行了数字签名，是不可伪造的，可以信任。证书是一种身份证明，用于解决信任问题。</p>
<p>任何用户都可从可信的地方获得认证中心 CA 的公钥，此公钥用来验证某个公钥是否为某个实体所拥有（通过向 CA 查询）。有的大公司也提供认证中心服务。</p>
<h3 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h3><p>CA 证书具有统一的格式，ITU-T 制定了 X.509 协议标准，用来描述证书的结构。</p>
<p>IETF 接受了 X.509，仅做了少量的改动，给出了互联网 X.509 公钥基础结构  PKI(<code>Public Key Infrastructure</code>)。</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">版本号</td>
<td align="center">区分 X.509 不同版本</td>
</tr>
<tr>
<td align="center">序列号</td>
<td align="center">CA 发放，唯一</td>
</tr>
<tr>
<td align="center">签名算法</td>
<td align="center">签署证书所使用的算法和参数</td>
</tr>
<tr>
<td align="center">发行者</td>
<td align="center">CA 的 X.509 名字</td>
</tr>
<tr>
<td align="center">有效期</td>
<td align="center">包括起始时间和终止时间</td>
</tr>
<tr>
<td align="center">主体名</td>
<td align="center">证书持有者的名称及有关信息</td>
</tr>
<tr>
<td align="center">公钥</td>
<td align="center">有效的公钥及其使用方法</td>
</tr>
<tr>
<td align="center">发行者 ID</td>
<td align="center">任选，唯一，标识发行者</td>
</tr>
<tr>
<td align="center">主体 ID</td>
<td align="center">任选，唯一，标识证书持有者</td>
</tr>
<tr>
<td align="center">扩展域</td>
<td align="center">扩充信息</td>
</tr>
<tr>
<td align="center">认证机构签名</td>
<td align="center">用 CA 私钥对证书签名</td>
</tr>
</tbody></table>
<h3 id="CA-证书的吊销"><a href="#CA-证书的吊销" class="headerlink" title="CA 证书的吊销"></a>CA 证书的吊销</h3><p>证书不是永久有效，它可以过期，也可以被吊销。</p>
<p>有很多原因导致证书被吊销，例如：</p>
<ul>
<li>用户的私钥已被泄漏</li>
<li>该用户不再被该 CA 认证</li>
<li>CA 签署用户证书的私钥已被泄漏</li>
</ul>
<p>CA 建立并维护一个证书吊销列表。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/应用层——SNMP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/"
    >应用层——SNMP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/" class="article-date">
  <time datetime="2020-10-26T03:41:11.000Z" itemprop="datePublished">2020-10-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="网络管理的基本概念"><a href="#网络管理的基本概念" class="headerlink" title="网络管理的基本概念"></a>网络管理的基本概念</h1><p>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。</p>
<p>网络管理并不是指对网络进行行政上的管理。</p>
<p>网络是一个非常复杂的分布式系统。这时因为在网络上有很多不同厂家生产的、运行着多种协议的节点，而这些节点还在相互通信和交换信息，有时还需要把一些新的状态信息写入到这些节点上。</p>
<h2 id="网络管理的五大功能"><a href="#网络管理的五大功能" class="headerlink" title="网络管理的五大功能"></a>网络管理的五大功能</h2><ul>
<li>故障管理：故障检测、隔离和纠正。</li>
<li>配置管理：初始化网络、并配置网络。</li>
<li>计费管理：记录网络资源的使用。</li>
<li>性能管理：估价系统资源的运行状况及通信效率等。</li>
<li>网络安全管理：对授权机制、访问控制、加密和加密关键字的管理。</li>
</ul>
<h2 id="网络管理的一般模型"><a href="#网络管理的一般模型" class="headerlink" title="网络管理的一般模型"></a>网络管理的一般模型</h2><img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img1.png" class="">

<h2 id="网络管理模型中的主要构件"><a href="#网络管理模型中的主要构件" class="headerlink" title="网络管理模型中的主要构件"></a>网络管理模型中的主要构件</h2><h3 id="管理站"><a href="#管理站" class="headerlink" title="管理站"></a>管理站</h3><p>管理站也常称为网络运行中心，是网络管理系统的核心。它通常是个有图形界面的高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理站发出的。</p>
<p>管理站中的关键构件是管理程序，管理程序在运行时就成为管理进程。</p>
<p>管理站（硬件）或管理程序（软件）都可称为管理者。管理者不是指人，而是指机器或软件。</p>
<p>网络管理员指的是负责网络管理的人员。</p>
<p>大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的设备。</p>
<h3 id="被管对象"><a href="#被管对象" class="headerlink" title="被管对象"></a>被管对象</h3><p>在被管网络中有很多的被管设备，被管设备可以是主机、路由器、打印机、集线器、网桥或调制解调器等。</p>
<p>网络的每一个被管设备中可能有多个被管对象。被管对象可以是被管设备中的某个硬件，也可以是某些硬件或软件的配置参数的集合。</p>
<p>被管设备有时可称为网络元素或网元。</p>
<p>在被管设备中也会有一些不能被管的对象。 </p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>在每一个被管设备中都要运行一个程序以便和管理站中的管理程序进行通信。这些运行着的程序叫做网络管理代理程序，或简称为代理。</p>
<p>代理程序在管理程序的命令和控制下在被管设备上采取本地的行动。</p>
<h3 id="网络管理协议"><a href="#网络管理协议" class="headerlink" title="网络管理协议"></a>网络管理协议</h3><p>网络管理协议简称为网管协议。网络管理协议是管理程序和代理程序之间进行通信的规则。</p>
<p>网络管理员利用网络管理协议，通过管理站对网络中的被管设备进行管理。 </p>
<p>需要注意的是，网管协议本身不管理网络。</p>
<h3 id="简单网络管理协议-SNMP"><a href="#简单网络管理协议-SNMP" class="headerlink" title="简单网络管理协议 SNMP"></a>简单网络管理协议 SNMP</h3><p>简单网络管理协议 SNMP(<code>Simple Network Management Protocol</code>) 中的管理程序和代理程序按客户–服务器方式工作。SNMP 使用无连接的 UDP。</p>
<p>管理程序运行 SNMP 客户程序，向某个代理程序发出请求（或命令），代理程序运行 SNMP 服务器程序，返回响应（或执行某个动作）。</p>
<p>在网管系统中，往往是一个（或少数几个）客户程序与很多的服务器程序进行交互。</p>
<h2 id="SNMP-的指导思想"><a href="#SNMP-的指导思想" class="headerlink" title="SNMP 的指导思想"></a>SNMP 的指导思想</h2><p>SNMP 最重要的指导思想就是要尽可能简单。</p>
<p>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。</p>
<p>在网络正常工作时，SNMP 可实现统计、配置、和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</p>
<p>虽然 SNMP 是在 TCP&#x2F;IP 基础上的网络管理协议，但也可扩展到其他类型的网络设备上。 </p>
<h2 id="SNMP-的管理站和委托代理"><a href="#SNMP-的管理站和委托代理" class="headerlink" title="SNMP 的管理站和委托代理"></a>SNMP 的管理站和委托代理</h2><p>整个系统必须有一个管理站。</p>
<p>若网络元素使用的不是 SNMP 而是另一种网络管理协议，SNMP 协议就无法控制该网络元素。这时可使用委托代理。</p>
<p>委托代理能提供协议转换和过滤操作等功能，对被管对象进行管理。</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img2.png" class="">

<h2 id="SNMP-网络管理组成"><a href="#SNMP-网络管理组成" class="headerlink" title="SNMP 网络管理组成"></a>SNMP 网络管理组成</h2><p>SNMP 的网络管理由三个部分组成：</p>
<ul>
<li>SNMP 本身</li>
<li>管理信息结构 SMI(<code>Structure of Management Information</code>)，关于 MIB 的一套公用的结构和表示符号。</li>
<li>管理信息库 MIB (<code>Management Information Base</code>)，管理信息库包含所有代理进程的所有可被查询和修改的参数。</li>
</ul>
<p>SNMP 定义了管理站和代理之间所交换的分组格式。</p>
<p>所交换的分组包含各代理中的对象（变量）名及其状态（值）。SNMP 负责读取和改变这些数值。 </p>
<p>SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的规则。这样做是为了确保网络管理数据的语法和语义的无二义性。但从 SMI 的名称并不能看出它的功能。SMI 并不定义一个实体应管理的对象数目，也不定义被管对象名以及对象名及其值之间的关联。 </p>
<p>MIB 在被管理的实体中创建了命名对象，并规定了其类型。管理程序使用 MIB 中的信息，对网络进行管理。</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img3.png" class="">

<h1 id="管理信息结构-SMI"><a href="#管理信息结构-SMI" class="headerlink" title="管理信息结构 SMI"></a>管理信息结构 SMI</h1><p>SMI 主要说明了怎样定义管理对象和怎样访问管理对象。<br>SMI 的功能：</p>
<ul>
<li>被管对象应怎样命名；</li>
<li>用来存储被管对象的数据类型有哪些种；</li>
<li>在网络上传送的管理数据应如何编码。</li>
</ul>
<p>SMI 规定所有被管对象必须在命名树上。</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img4.png" class="">

<h2 id="对象标识符"><a href="#对象标识符" class="headerlink" title="对象标识符"></a>对象标识符</h2><p>对象标识是一种数据类型，它指明一种“授权”命名的对象。“授权”的意思就是这些标识不是随便分配的，它是由一些权威机构进行管理和分配的。</p>
<p>对象标识是一个整数序列，以点（“.”）分隔。这些整数构成一个树型结构，类似于 DNS 或 Unix 的文件系统。对象标识从树的顶部开始，顶部没有标识，以<code>root</code>表示（这和 Unix 中文件系统的树遍历方向非常类似）。</p>
<p>上面的图显示了在 SNMP 中用到的这种树型结构。所有的 MIB 变量都从<code>1.3.6.1.2.1</code>这个标识开始。</p>
<p>树上的每个结点同时还有一个文字名。例如标识<code>1.3.6.1.2.1</code>就和<code>iso.org.dod.internet.memt.mib-2</code>对应。这主要是为了人们阅读方便。在实际应用中，也就是说在管理进程和代理进程进行数据报交互时，MIB 变量名是以对象标识来标识的，当然都是以<code>1.3.6.1.2.1</code>开头的。</p>
<h2 id="SMI-数据类型"><a href="#SMI-数据类型" class="headerlink" title="SMI 数据类型"></a>SMI 数据类型</h2><p>SMI 把数据类型分为两大类：简单类型、结构化类型。 </p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img5.png" class="">

<h1 id="管理信息库-MIB"><a href="#管理信息库-MIB" class="headerlink" title="管理信息库 MIB"></a>管理信息库 MIB</h1><p>管理信息库 MIB(<code>Management Information Base</code>)就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</p>
<p>管理进程使用 MIB 中这些信息的值对网络进行管理（如读取或重新设置这些值）。只有在 MIB 中的对象才是 SNMP 所能够管理的。</p>
<p>MIB 被划分为若干个组，如<code>system、interfaces、at</code>（地址转换）和<code>ip</code>组等。</p>
<h1 id="SNMP的协议数据单元和报文"><a href="#SNMP的协议数据单元和报文" class="headerlink" title="SNMP的协议数据单元和报文"></a>SNMP的协议数据单元和报文</h1><p>SNMP 的操作只有两种基本的管理功能：</p>
<ul>
<li>“读”操作，用<code>get</code>报文来检测各被管对象的状况；</li>
<li>“写”操作，用<code>set</code>报文来改变各被管对象的状况。</li>
</ul>
<p>SNMP 的这些功能通过探询操作来实现。探询操作——SNMP 管理进程定时向被管理设备周期性地发送探询信息。</p>
<p>探询的好处：可使系统相对简单。能限制通过网络所产生的管理信息的通信量。</p>
<p>探询的缺点：不够灵活，而且所能管理的设备数目不能太多。开销也较大。</p>
<p>关于管理进程和代理进程之间的交互信息， SNMP 定义了 5 种报文：</p>
<ol>
<li><code>get-request</code>操作：从代理进程处提取一个或多个参数值。</li>
<li><code>get-next-request</code>操作：从代理进程处提取一个或多个参数的下一个参数值。</li>
<li><code>set-request</code>操作：设置代理进程的一个或多个参数值。</li>
<li><code>get-response</code>操作：返回的一个或多个参数值。这个操作是由代理进程发出的。它是前面3中操作的响应操作。</li>
<li><code>trap</code>操作：代理进程主动发出的报文，通知管理进程有某些事情发生。</li>
</ol>
<p>前面的 3 个操作是由管理进程向代理进程发出的。后面两个是代理进程发给管理进程的。</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/20.png" class="">

<p>既然这些操作中的前 4 种操作是简单的请求-应答方式（也就是管理进程发出请求，代理进程应答响应），而且在 SNMP 中往往使用 UDP 协议，所以可能发生管理进程和代理进程之间数据报丢失的情况。因此一定要有超时和重传机制。</p>
<p>管理进程发出的前面 3 种操作采用 UDP 的 161 端口。代理进程发出的<code>Trap</code>操作采用 UDP 的 162 端口。由于收发采用了不同的端口号，所以一个系统可以同时为管理进程和代理进程。</p>
<h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><p>SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为陷阱，表示它能够捕捉“事件”。</p>
<p>当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件（即过滤）。</p>
<p>过滤的好处是：</p>
<ul>
<li>仅在严重事件发生时才发送陷阱；</li>
<li>陷阱信息很简单且所需字节数很少。</li>
</ul>
<p>使用探询（至少是周期性地）以维持对网络资源的实时监视。同时也采用陷阱机制报告特殊事件，使得 SNMP 成为一种有效的网络管理协议。</p>
<h2 id="SNMP-的-UDP-报文格式"><a href="#SNMP-的-UDP-报文格式" class="headerlink" title="SNMP 的 UDP 报文格式"></a>SNMP 的 UDP 报文格式</h2><img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img17.png" class="">

<p>由于 SNMP 报文的编码采用了 ASN.1 和 BER，这就使得报文的长度取决于变量的类型和值。</p>
<p>各字段含义：</p>
<h3 id="版本字段"><a href="#版本字段" class="headerlink" title="版本字段"></a>版本字段</h3><p>版本字段是 0。该字段的值是通过 SNMP 版本号减去 1 得到的。显然 0 代表 SNMPv1。</p>
<h3 id="团体名"><a href="#团体名" class="headerlink" title="团体名"></a>团体名</h3><p>团体名字段是一个字符串。这是管理进程和代理进程之间的口令，是明文格式。默认的值是<code>public</code>。SNMPv1 用团体名验证来控制访问权限。</p>
<h3 id="PDU-类型字段"><a href="#PDU-类型字段" class="headerlink" title="PDU 类型字段"></a>PDU 类型字段</h3><p>各种 PDU 对应的值（PDU 即协议数据单元，也就是分组）：</p>
<table>
<thead>
<tr>
<th align="center">PDU编号(T字段)</th>
<th align="center">PDU名称</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0(A0)</td>
<td align="center">get-request</td>
<td align="center">从代理进程处提取一个或多个参数值</td>
</tr>
<tr>
<td align="center">1(A1)</td>
<td align="center">get-next-request</td>
<td align="center">从代理进程处提取一个或多个参数的下一个参数值</td>
</tr>
<tr>
<td align="center">2(A2)</td>
<td align="center">get-reponse</td>
<td align="center">代理向管理者或管理者向管理者发送响应</td>
</tr>
<tr>
<td align="center">3(A3)</td>
<td align="center">set-request</td>
<td align="center">设置代理进程的一个或多个参数值</td>
</tr>
<tr>
<td align="center">4(A5)</td>
<td align="center">get-bulk-request</td>
<td align="center">管理者从代理读取大数据块的值</td>
</tr>
<tr>
<td align="center">5(A6)</td>
<td align="center">inform-request</td>
<td align="center">管理者从另一管理者读取代理的变量</td>
</tr>
<tr>
<td align="center">6(A7)</td>
<td align="center">SNMPv2-trap</td>
<td align="center">代理向管理者报告异常事件</td>
</tr>
<tr>
<td align="center">8(A8)</td>
<td align="center">report</td>
<td align="center">管理者之间报告某些差错</td>
</tr>
</tbody></table>
<p>对于<code>get-request、get-next-request</code>和<code>set-request</code>操作，请求标识由管理进程设置，然后由代理进程在<code>get-response</code>中返回。这个字段的作用是使客户进程（在目前情况下是管理进程）能够将服务器进程（即代理进程）发出的响应和客户进程发出的查询进行匹配。这个字段允许管理进程对一个或多个代理进程发出多个请求，并且从返回的众多应答中进行分类。</p>
<h3 id="差错状态字段"><a href="#差错状态字段" class="headerlink" title="差错状态字段"></a>差错状态字段</h3><p>差错状态字段是一个整数，它是由代理进程标注的，指明有差错发生。</p>
<table>
<thead>
<tr>
<th align="center">差错状态</th>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">noError</td>
<td align="center">没有错误</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">tooBig</td>
<td align="center">代理进程无法把响应放在一个SNMP消息中发送</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">noSuchName</td>
<td align="center">操作一个不存在的变量</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">badValue</td>
<td align="center">set操作的值或语义有错误</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">readOnly</td>
<td align="center">管理进程试图修改一个只读变量</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">genErr</td>
<td align="center">其他错误</td>
</tr>
</tbody></table>
<h3 id="差错索引字段"><a href="#差错索引字段" class="headerlink" title="差错索引字段"></a>差错索引字段</h3><p>差错索引字段是一个整数偏移量，指明当有差错发生时，差错发生在哪个参数。它是由代理进程标注的，并且只有在发生<code>noSuchName、readOnly</code>和<code>badValue</code>差错时才进行标注。</p>
<h3 id="名-x2F-值字段"><a href="#名-x2F-值字段" class="headerlink" title="名&#x2F;值字段"></a>名&#x2F;值字段</h3><p>在<code>get-request、get-next-request</code>和<code>set-request</code>的请求数据报中，包含变量名称和变量值的一张表。对于<code>get-request</code>和<code>get-next-request</code>操作，变量值部分被忽略，也就是不需要填写。对于<code>trap</code>操作符（PDU 类型是 4），SNMP 报文格式有所变化。</p>
<h1 id="ASN-1-和-BER"><a href="#ASN-1-和-BER" class="headerlink" title="ASN.1 和 BER"></a>ASN.1 和 BER</h1><p><code>ASN.1(Abstract Syntax Notation 1)</code>是一种描述数据和数据特征的正式语言。它和数据的存储及编码无关。在正式的 SNMP 规范中 MIB 和 SNMP 报文中的所有的字段都是用 ASN.1 描述的。</p>
<p>例如<code>Get-request</code>报文的 ASN.1 定义: </p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img19.png" class="">

<p>当有了这样的 ASN.1 定义，可以有多种编码方法把数据编码为传输的比特流。在 SNMP 报文中比特的编码采用<code>BER(Basic Encoding Rule)</code>。例如，对于一个简单的整数如 64，在 BER 中需要用 3 个字节来表示。第一个字节说明类型是一个整数，下个字节说明用了多少个字节来存储该整数（在这里是 1），最后一个字节才是该整数的值。</p>
<h2 id="用-TLV-方法进行编码"><a href="#用-TLV-方法进行编码" class="headerlink" title="用 TLV 方法进行编码"></a>用 TLV 方法进行编码</h2><img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img6.png" class="">

<h2 id="TLV-中的-T-字段定义数据的类型"><a href="#TLV-中的-T-字段定义数据的类型" class="headerlink" title="TLV 中的 T 字段定义数据的类型"></a>TLV 中的 T 字段定义数据的类型</h2><img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img7.png" class="">
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img8.png" class="">

<h2 id="TLV-中的-L-字段定义-V-字段的长度"><a href="#TLV-中的-L-字段定义-V-字段的长度" class="headerlink" title="TLV 中的 L 字段定义 V 字段的长度"></a>TLV 中的 L 字段定义 V 字段的长度</h2><img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img9.png" class="">
<h2 id="TLV-中的-V-字段定义数据的值"><a href="#TLV-中的-V-字段定义数据的值" class="headerlink" title="TLV 中的 V 字段定义数据的值"></a>TLV 中的 V 字段定义数据的值</h2><img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img10.png" class="">

<p>例如，<code>INTEGER 15</code>，其<code>T</code>字段是 02，<code>INTEGER</code>类型要用 4 字节编码。最后得出 TLV 编码为<code>02 04 00 00 00 0F</code>。</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img11.png" class="">

<p>例如，<code>IPAddress 192.1.2.3</code>，其<code>T</code>字段是 40，<code>V</code>字段需要 4 字节表示，因此得出 TLV 编码是<code>40 04 C0 01 02 03</code>。</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img12.png" class="">

<p>TLV 中的 V 字段可嵌套其他数据元素的 TLV 字段</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img13.png" class="">

<p><code>Get-request</code>报文 ASN.1 编码：</p>
<img src="/2020/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94SNMP/img18.png" class="">

<p>BER 指明了每种数据类型中每个数据的值的表示。发送端用 BER 编码，可将用 ASN.1 所表述的报文转换成唯一的比特序列。接收端用 BER 进行解码，得到该比特序列所表示的 ASN.1 报文。 </p>
<h1 id="SNMPv2"><a href="#SNMPv2" class="headerlink" title="SNMPv2"></a>SNMPv2</h1><p>SNMPv2 既可以支持完全集中的网络管理，又可以支持分布式网络管理。</p>
<p>SNMPv2 的增强主要在 3 个方面：</p>
<ol>
<li>管理信息结构的扩充</li>
<li>管理站之间的通信能力</li>
<li>新的协议操作</li>
</ol>
<p>SNMPv2 引入了新的数据类型，增强了对象的表达能力，提供了更完善的表操作功能。SNMPv2 还定义了新的 MIB 功能组，包含了关于协议操作的通信消息，以及有关管理站和代理系统配置的信息。在协议操作方面，引入了两种新的 PDU，<code>get-bulk-request</code>和<code>inform-request</code>分别用于大块数据的传输和管理站之间的通信。</p>
<p>SNMPv2 的安全性比 SNMPv1 大有提高。在 SNMPv1 中，从管理进程到代理进程的共同体名称是以明文方式传送的。而 SNMPv2 可以提供鉴别和加密。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/应用层——DHCP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/"
    >应用层——DHCP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/" class="article-date">
  <time datetime="2020-10-23T02:01:42.000Z" itemprop="datePublished">2020-10-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="刚插上网线，电脑怎么知道自己的-IP-地址的？"><a href="#刚插上网线，电脑怎么知道自己的-IP-地址的？" class="headerlink" title="刚插上网线，电脑怎么知道自己的 IP 地址的？"></a>刚插上网线，电脑怎么知道自己的 IP 地址的？</h1><img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/20.png" class="" title="五层网络协议对应的消息体变化分析">

<p>如果你知道某台电脑的 IP，就可以向这个 IP 发起连接请求，建立连接后就可以操作收发数据。</p>
<p>要发送的数据，会在网络层里加入 IP 头。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/21.png" class="" title="ip报头">

<p>这里面最重要的是发送端和接收端的 IP 地址。有了 IP 地址，数据包就能在网络世界里找到该由谁来接收这个数据包。</p>
<p>所以说上面的网络通信离不开 IP。</p>
<p>假设我有一台新买的电脑，还没联网呢，这时候拿着新买的网线，插入网线口，网线插口亮起来了。</p>
<p>然后就可以开始用它上网了。</p>
<p>那么问题来了。</p>
<p>刚插上网线，电脑怎么知道自己的 IP 是什么？怎么就突然能上网了呢？</p>
<p>这个话题，我们从 DHCP 聊起。</p>
<h1 id="DHCP是什么"><a href="#DHCP是什么" class="headerlink" title="DHCP是什么"></a>DHCP是什么</h1><p>插上网线之后，获得 IP 的方式主要有两种。</p>
<p>第一种是，自己手动在电脑里配。在选择手动配置之后，除了 IP 地址还需要配上子网掩码和路由器的地址。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/22.png" class="" title="手动配IP">

<p>这几个词对于大部分普通人来说，很难理解。大部分人没事都不会去配这玩意。有没有办法可以让这些IP信息自动获得？</p>
<p>有，这就是第二种获取 IP 的方式，DHCP。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/23.png" class="" title="DHCP自动生成IP">

<p>通过 DHCP，在联网之后可以自动获取到本机需要的 IP 地址，子网掩码还有路由器地址。</p>
<h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h1><p>动态主机配置协议 DHCP(<code>Dynamic Host Configuration Protocol</code>) 提供了即插即用连网的机制。</p>
<p>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</p>
<p>DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。</p>
<p>DHCP 给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。</p>
<p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文（将目的 IP 地址置为全1，即<code>255.255.255.255</code>），这时该主机就成为 DHCP 客户。发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，因此要发现 DHCP 服务器的 IP 地址。</p>
<p>这台主机目前还没有 IP 地址，因此它将 IP 数据报的源 IP 地址设为全 0。这样，在本地网络上的所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p>
<p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。</p>
<p>DHCP 服务器的回答报文叫做提供报文。 </p>
<p>DHCP 说白了，就是向某个管 IP 分配的服务器，也就是 DHCP 服务器，申请 IP 地址。其实一般家里用的路由器就自带这个功能。</p>
<h2 id="协议配置"><a href="#协议配置" class="headerlink" title="协议配置"></a>协议配置</h2><p>在协议软件中给参数赋值的动作叫做协议配置。</p>
<p>一个软件协议在使用之前必须是已正确配置的。具体的配置信息有哪些则取决于协议栈。 </p>
<p>例如，连接到互联网的计算机的协议软件需要配置的参数包括：</p>
<ul>
<li>IP 地址</li>
<li>子网掩码</li>
<li>默认路由器的 IP 地址</li>
<li>域名服务器的 IP 地址</li>
</ul>
<p>这些信息通常存储在一个配置文件中，计算机在引导过程中可以对这个文件进行存取。 </p>
<h2 id="DHCP-工作方式"><a href="#DHCP-工作方式" class="headerlink" title="DHCP 工作方式"></a>DHCP 工作方式</h2><p>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</p>
<p>DHCP 基于 UDP 工作，DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/img1.png" class="">
<br>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/img2.png" class="">
<br>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/img3.png" class="">

<h2 id="DHCP-中继代理"><a href="#DHCP-中继代理" class="headerlink" title="DHCP 中继代理"></a>DHCP 中继代理</h2><p>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。</p>
<p>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p>
<p>DHCP 中继代理以单播方式转发发现报文。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/img4.png" class="">

<h2 id="租用期"><a href="#租用期" class="headerlink" title="租用期"></a>租用期</h2><p>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为租用期（默认为 8 天）。 </p>
<p>租用期的数值应由 DHCP 服务器自己决定。</p>
<p>DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求。 </p>
<h2 id="DHCP-协议的工作过程"><a href="#DHCP-协议的工作过程" class="headerlink" title="DHCP 协议的工作过程"></a>DHCP 协议的工作过程</h2><img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/img5.png" class="">

<ol>
<li>DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。</li>
<li>DHCP 客户从 UDP 端口 68 广播发送 DHCP 发现报文<code>DHCP DISCOVER</code>。</li>
<li>凡收到 DHCP 发现报文的 DHCP 服务器收到消息后，会在自己维护的一个 IP 池里拿出一个空闲 IP，通过单播的形式发出 DHCP 提供报文<code>DHCP OFFER</code>，因此 DHCP 客户可能收到多个 DHCP 提供报文 。</li>
<li>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文<code>DHCP REQUEST</code>。</li>
<li>被选择的 DHCP 服务器发送确认报文<code>DHCP ACK</code>，进入已绑定状态，并可开始使用得到的临时 IP 地址了。<br>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T<sub>1</sub> 和 T<sub>2</sub>，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。</li>
<li>租用期过了一半（T<sub>1</sub> 时间到），DHCP 发送请求报文<code>DHCP REQUEST</code>，要求更新租用期。 </li>
<li>DHCP 服务器若同意，则发回确认报文<code>DHCP ACK</code>。DHCP 客户得到了新的租用期，重新设置计时器。</li>
<li>DHCP 服务器若不同意，则发回否认报<code>DHCP NACK</code>。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤 2）。<br>若 DHCP 服务器不响应步骤 6 的请求报文<code>DHCP REQUEST</code>，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文<code>DHCP REQUEST</code>（重复步骤 6），然后又继续后面的步骤。 </li>
<li>DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文<code>DHCP RELEASE</code>即可。</li>
</ol>
<p>自动获得 IP 地址和自动获得 DNS 服务器地址就表示是使用 DHCP 协议。</p>
<p>可以发现，DHCP 交互中，全程都是使用 UDP 广播通信。</p>
<p>用的是广播，那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络都要配一个 DHCP 服务器？</p>
<p>所以，为了解决这一问题，就出现了 DHCP 中继代理。有了 DHCP 中继代理以后，对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/29.png" class="">

<p>HCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以单播的形式发给 DHCP 服务器。</p>
<p>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</p>
<p>因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。</p>
<h2 id="为什么要有第三和第四阶段"><a href="#为什么要有第三和第四阶段" class="headerlink" title="为什么要有第三和第四阶段"></a>为什么要有第三和第四阶段</h2><p>大家有没有发现，在<code>Offer</code>阶段，就已经拿到了 IP 了，为什么还要有后面的<code>Request</code>和<code>ACK</code>呢？</p>
<p>这是因为本地网段内，可能有不止一台 DHCP 服务器，在你广播之后，每个 DHCP 服务器都有可能给你发<code>Offer</code>。</p>
<p>本着先到先得的原则，你的机子一般会对第一个到的<code>Offer</code>响应<code>DHCP Request</code>，目的是为了确认<code>Offer</code>，在你确认<code>Offer</code>这段时间内，DHCP 服务器确认这个 IP 还没被分出去，你才可以安心使用这个 IP。</p>
<p>就像你找工作的过程。你海投简历（<code>DHCP Discover</code>），然后拿到了多个<code>offer(DHCP Offer)</code>。</p>
<p>这时候事情还没完，你一般会跟 HR 说：”你给我两天时间，我要跟家里人商量下”。</p>
<p>HR 也会对你说：”那你尽快确认，我这边还有不少候选人等着”。</p>
<p>之后你考虑下来觉得不错，跟HR说要接这个<code>Offer（DHCP Request）</code>，HR 看了下这个岗位还在，才能确认让你第二天来上班（<code>DHCP ACK</code>）。如果这个公司的岗位已经招到其他候选人了，第四阶段的消息就会改为发<code>DHCP NAK</code>，意思是拒绝了你的接<code>Offer</code>请求。</p>
<h2 id="DHCP抓包"><a href="#DHCP抓包" class="headerlink" title="DHCP抓包"></a>DHCP抓包</h2><p>在命令行里执行下面的命令，可以强行让电脑的<code>en0</code>网卡重新走一遍 DHCP 流程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ipconfig set en0 DHCP</span><br></pre></td></tr></table></figure>
<p><code>en0</code>可以替换成其他网卡，比如<code>eth0</code>啥的。</p>
<p>这时候就可以抓到相关的数据包。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/25.png" class="">

<p>我们可以看到蓝色的四个数据包，分别对应上面提到的四个 DHCP 阶段。</p>
<p>其中第二阶段中的<code>DHCP Offer</code>里会返回给我们需要的 IP、子网掩码、路由器地址以及DNS服务器地址。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/26.png" class="" title="offer阶段">

<p>另外，通过抓包，我们可以发现 DHCP 是应用层的协议，基于传输层 UDP 协议进行数据传输。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/27.png" class="">

<h2 id="为什么DHCP用UDP，能不能改用TCP？"><a href="#为什么DHCP用UDP，能不能改用TCP？" class="headerlink" title="为什么DHCP用UDP，能不能改用TCP？"></a>为什么DHCP用UDP，能不能改用TCP？</h2><p>主要原因还是因为 TCP 是面向连接的，而 UDP 是无连接的。</p>
<p>所谓”连接”，他就只有一个发送端和一个接收端，就跟水管一样。</p>
<p>而 DHCP 由于一开始并不知道要跟谁建立连接，所以只能通过广播的形式发送消息。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/28.png" class="" title="广播寻找DHCP服务器">

<p>同样是在本地网段内发广播消息，UDP 只需要发给<code>255.255.255.255</code>。它实际上并不是值某个具体的机器，而是一个特殊地址，这个地址有特殊含义，只要设了这个目的地址，就会在一定本地网段内进行广播。</p>
<p>而 TCP 却不同，它需要先建立连接，但实际上<code>255.255.255.255</code>对应的机器并不存在，因此也不能建立连接。如果同样要做到广播的效果，就需要先得到本地网段内所有机器的 IP，然后挨个建立连接，再挨个发消息。这就很低效了。</p>
<p>因此 DHCP 选择了 UDP，而不是 TCP。</p>
<h2 id="为什么第二阶段不是广播，而是单播"><a href="#为什么第二阶段不是广播，而是单播" class="headerlink" title="为什么第二阶段不是广播，而是单播"></a>为什么第二阶段不是广播，而是单播</h2><p>其实，这是 DHCP 协议的一个小优化。原则上大家在<code>DHCP Offer</code>阶段，都用广播，那肯定是最稳的，目标机器收到后自然就会进入第三阶段<code>DHCP Request</code>。而非目标机器，收到后解包后发现目的机器的 mac 地址跟自己的不同，也会丢掉这个包。</p>
<p>但是问题就出在，这个非目的机器需要每次都在网卡收到包，并解完包，才发现原来这不是给它的消息，这。。。真，有被打扰到。</p>
<p>如果本地网段内这样的包满天飞，也浪费机器性能。</p>
<p>如果能用单播，那当然是最好的。但这时候目的机器其实并没有 IP 地址，有些系统在这种情况下能收单播包，有些则认为不能收，这个跟系统的实现有关。因此，对于能收单播包的系统，会在发<code>DHCP Discover</code>阶段设一个<code>Broadcast flag = 0 (unicast)</code>的标志位，告诉服务器，支持单播回复，于是服务器就会在<code>DHCP Offer</code>阶段以单播的形式进行回复。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/30.png" class="">

<h2 id="是不是每次联网都要经历DHCP四个阶段？"><a href="#是不是每次联网都要经历DHCP四个阶段？" class="headerlink" title="是不是每次联网都要经历DHCP四个阶段？"></a>是不是每次联网都要经历DHCP四个阶段？</h2><p>只要想联网，就需要 IP，要用 IP，就得走 DHCP 协议去分配。</p>
<p>但大家也发现了，DHCP 第一阶段和第二阶段都可能会发广播消息。对于家用电脑还好，插个网线，之后就雷打不动。但像手机这样的移动设备，是要带着到处跑的，坐个地铁，进个电梯，公司里到处走走，都可能会涉及到网络切换。</p>
<p>这每次都要来一个完整的四阶段，各种广播消息满天飞，其实对网络环境不太友好。</p>
<p>于是问题叒来了，是不是每次联网都要经历 DHCP 四个阶段？</p>
<p>当然不需要。</p>
<p>我们会发现每次断开wifi再打开wifi时，机子会经历一个从没网到有网的过程。</p>
<p>这时候去抓个包，会发现。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/31.png" class="">

<p>其实只发生了 DHCP 的第三和第四阶段。这是因为机子记录了曾经使用过<code>192.168.31.170</code>这个 IP，重新联网后，会优先再次请求这个 IP，这样就省下了第一第二阶段的广播了。</p>
<p>另外需要注意的是，抓包图里<code>DHCP Request</code>之所以出现两次，是因为第一次<code>Request</code>发出后太久没得到回应，因此重发。</p>
<h2 id="DHCP分配下来的IP一定不会重复吗？"><a href="#DHCP分配下来的IP一定不会重复吗？" class="headerlink" title="DHCP分配下来的IP一定不会重复吗？"></a>DHCP分配下来的IP一定不会重复吗？</h2><p>一般来说 DHCP 服务器会在它维护的 IP 池里找到一个没人用的 IP 分配给机子，</p>
<p>这个 IP 如果重复分配了，那本地网段内就会出现两个同样的 IP，这个 IP 下面却对应两个不同的 mac 地址。但其他机器上的 ARP 缓存中却只会记录其中一条 mac 地址到 IP 的映射关系。</p>
<p>于是，数据在传递的过程中就会出错。</p>
<p>因此本地网段内 IP 必须唯一。</p>
<p>那么 DHCP 分配下来的 IP 有没有可能跟别的 IP 是重复的？</p>
<p>都这么问了，那肯定是可能的。</p>
<p>有两个常见的情况会出现 IP 重复。</p>
<p>IP 是可以自己手动配的，自己配的 IP 是有可能跟其他 DHCP 分配下来的 IP 是相同的。解决方案也很简单，尽量不要手动去配 IP，统一走 DHCP。或者在 DHCP 服务器里维护的 IP 范围里，将这条 IP剔除。</p>
<p>一个本地网段内，是可以有多个 DHCP 服务器的，而他们维护的 IP 地址范围是有可能重叠的，于是就有可能将相同的 IP 给到不同的机子。解决方案也很简单，修改两台 DHCP 服务器的维护的 IP 地址范围，让它们不重叠就行了。</p>
<p>不过吧，上面的解决方案，都需要有权限去修改 DHCP 服务器。</p>
<p>得到<code>DHCP ACK</code>之后立马就能使用这个 IP 了吗？</p>
<p>不。</p>
<p>在得到<code>DHCP ACK</code>之后，机子不会立刻就用这个 IP。</p>
<p>而是会先发三条 ARP 消息。</p>
<img src="/2020/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E2%80%94%E2%80%94DHCP/32.png" class="">

<p>大家知道 ARP 消息的目的是通过 IP 地址去获得 mac 地址。所以普通的 ARP 消息里，是填了 IP 地址，不填 mac 地址的。</p>
<p>但这三条 ARP 协议，比较特殊，它们叫无偿 ARP，特点是它会把 IP 和 mac 地址都填好了，而且填的还是自己的 IP 和 mac 地址。</p>
<p>目的有两个。</p>
<p>一个是为了告诉本地网段内所有机子，从现在起，xx IP 地址属于 xx mac 地址，让大家记录在 ARP 缓存中。</p>
<p>另一个就是看下本地网段里有没有其他机子也用了这个 IP，如果有冲突的话，那需要重新再走一次 DHCP 流程。</p>
<p>在三次无偿 ARP 消息之后，确认没有冲突了，才会开始使用这个 IP 地址进行通信。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>电脑插上网线，联网后会通过 DHCP 协议动态申请一个 IP，同时获得子网掩码，路由器地址等信息。</p>
<p>DHCP 分为四个阶段，分别是<code>Discover，Offer，Request</code>和<code>ACK</code>。如果曾经连过这个网，机器会记录你上次使用的 IP，再次连接时优先使用原来的那个 IP，因此只需要经历第三第四阶段。</p>
<p>DHCP 是应用层协议，考虑到需要支持广播功能，底层使用的是 UDP 协议，而不是 TCP 协议。</p>
<p>DHCP 分配下来的 IP 是有可能跟某台手动配置的 IP 地址重复的。</p>
<p>DHCP 得到 IP 之后还会发3次无偿 ARP 通告，在确认没有冲突后开始使用这个 IP。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/电子邮件相关协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/"
    >应用层——电子邮件</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2020-10-22T02:25:51.000Z" itemprop="datePublished">2020-10-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>电子邮件的重要标准：</p>
<ul>
<li>简单邮件发送协议：SMTP</li>
<li>互联网文本报文格式</li>
<li>通用互联网邮件扩充 MIME</li>
<li>邮件读取协议：POP3 和 IMAP</li>
</ul>
<h1 id="通信架构"><a href="#通信架构" class="headerlink" title="通信架构"></a>通信架构</h1><p>电子邮件在几十年的发展过程中出现了明显的变化，从原始的发送方电脑直接向接收方电脑发送电子邮件，演变成收发双方都使用邮件服务器代为收发邮件。通过这种方式，电子邮件通信不再依赖接收方当前是否在线，而电子邮件的通信过程由简单的发送方到接收方，演变成发送方电脑到发送方邮件服务器，发送方邮件服务器到接收方邮件服务器，以及接收方邮件服务器到接收方电脑的三个通信过程。并且参与通信的四方都不是直接相连，而是分别独立连接到互联网中。这个架构中，邮件发送方和接收方使用的电脑称为用户代理。</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1.png" class="">

<h1 id="电子邮件的组成：三个主要构件"><a href="#电子邮件的组成：三个主要构件" class="headerlink" title="电子邮件的组成：三个主要构件"></a>电子邮件的组成：三个主要构件</h1><img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img1.png" class="">

<h3 id="用户代理-UA-User-Agent"><a href="#用户代理-UA-User-Agent" class="headerlink" title="用户代理 UA (User Agent)"></a>用户代理 UA (User Agent)</h3><p>用户代理 UA 就是用户与电子邮件系统的接口，是电子邮件客户端软件。用户代理向用户提供一个很友好的接口来发送和接收邮件。</p>
<p>用户代理的功能：撰写、显示、处理和通信。</p>
<h3 id="邮件服务器-Mail-Server"><a href="#邮件服务器-Mail-Server" class="headerlink" title="邮件服务器 (Mail Server)"></a>邮件服务器 (Mail Server)</h3><p>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</p>
<p>邮件服务器按照客户-服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议：SMTP，POP3。</p>
<h3 id="邮件发送和读取协议"><a href="#邮件发送和读取协议" class="headerlink" title="邮件发送和读取协议"></a>邮件发送和读取协议</h3><p>简单邮件发送协议 SMTP：用于在用户代理向邮件服务器或邮件服务器之间发送邮件。</p>
<p>邮局协议 POP3：用于用户代理从邮件服务器读取邮件。</p>
<p>一个邮件服务器既可以作为客户，也可以作为服务器。</p>
<p>例如，当邮件服务器 A 向另一个邮件服务器 B 发送邮件时，邮件服务器 A 就作为 SMTP 客户，而 B 是 SMTP 服务器。</p>
<p>当邮件服务器 A 从另一个邮件服务器 B 接收邮件时，邮件服务器 A 就作为 SMTP 服务器，而 B 是 SMTP 客户。</p>
<p>SMTP 和 POP3（或IMAP）都是使用 TCP 连接来传送邮件的，目的是为了可靠地传送邮件。</p>
<h1 id="发送和接收电子邮件的几个重要步骤"><a href="#发送和接收电子邮件的几个重要步骤" class="headerlink" title="发送和接收电子邮件的几个重要步骤"></a>发送和接收电子邮件的几个重要步骤</h1><ol>
<li>发件人调用 PC 中的用户代理撰写和编辑要发送的邮件。</li>
<li>发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器。</li>
<li>SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</li>
<li>发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。</li>
<li>运行在接收方邮件服务器中的 SMTP 服务器进程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。</li>
<li>收件人在打算收信时，就运行PC机中的用户代理，使用POP3（或 IMAP）协议读取发送给自己的邮件。</li>
</ol>
<h1 id="电子邮件的组成"><a href="#电子邮件的组成" class="headerlink" title="电子邮件的组成"></a>电子邮件的组成</h1><p>电子邮件由信封和内容两部分组成。</p>
<p>电子邮件的传输程序根据邮件信封上的信息来传送邮件。用户在从自己的邮箱中读取邮件时才能见到邮件的内容。</p>
<p>在邮件的信封上，最重要的就是收件人的地址。 </p>
<h1 id="电子邮件地址的格式"><a href="#电子邮件地址的格式" class="headerlink" title="电子邮件地址的格式"></a>电子邮件地址的格式</h1><p>使用电子邮件时，需要拥有一个地址，这个地址叫做邮件地址，也叫邮箱地址。它相当于通信地址和姓名。</p>
<p>TCP&#x2F;IP 体系的电子邮件系统规定电子邮件地址的格式如下：收件人邮箱名@邮箱所在主机的域名。</p>
<p>符号<code>@</code>表示“在”的意思。例如电子邮件地址<code>wsq@qq.com</code></p>
<p><code>wsq</code>表示用户的名称，同一个通信地址内，名称必须是唯一的，不能出现重复；<code>@</code>表示分隔符；<code>qq.com</code>是用户邮箱的邮件接收服务器的域名。</p>
<p>电子邮件的发送地址由 DNS 管理。DNS 中注册了邮件地址和对应邮件服务器的域名。这些映射信息被称为 MX 记录。比如：<code>qq.com</code>的 MX 记录中指定了<code>mail.qq.com</code>。那么任何发送给<code>qq.com</code>结尾的邮件都被发送到<code>mail.qq.com</code>服务器。就这样，根据 MX 记录中指定的邮件服务器，可以管理不同邮件地址与特定邮件服务器之间的映射关系。</p>
<h1 id="简单邮件传送协议-SMTP"><a href="#简单邮件传送协议-SMTP" class="headerlink" title="简单邮件传送协议 SMTP"></a>简单邮件传送协议 SMTP</h1><ul>
<li>SMTP 规定了在两个相互通信的 SMTP 进程交换信息的方法。</li>
<li>SMTP 使用客户–服务器方式。</li>
<li>SMTP 基于 TCP 实现客户与服务器的通信。</li>
<li>SMTP 是一个基于文本的 （即 ASCII 码）的协议。</li>
<li>SMTP 客户与服务器之间采用命令-响应方式进行交互。</li>
</ul>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img2.png" class="">
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img3.png" class="">

<p>SMTP 规定了 14 条命令和 21 种应答信息。每条命令用几个字母组成，每一种应答信息一般只有一行信息，由一个 3 位数字的代码开始，后面附上很简单的文字说明。</p>
<h2 id="SMTP通信的三个阶段"><a href="#SMTP通信的三个阶段" class="headerlink" title="SMTP通信的三个阶段"></a>SMTP通信的三个阶段</h2><h3 id="1-连接建立"><a href="#1-连接建立" class="headerlink" title="1. 连接建立"></a>1. 连接建立</h3><p>连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。   </p>
<p>发送人的邮件送到发送方邮件服务器的邮件缓存后，SMTP 客户就每隔一定时间对邮件缓存扫描一次。如发现有邮件，就使用 SMTP 的熟知端口号 25 与接收方邮件服务器的 SMTP 服务器建立 TCP 连接。在连接建立后，接收方 SMTP 服务器要发出<code>220 Service Ready</code>。然后 SMTP 客户向 SMTP 服务器发送<code>HELLO</code>命令，并附上发送方的主机名。SMTP 服务器若有能力接收邮件，则回答<code>250 OK</code>，表示已准备好接收。若 SMTP 服务器不可用，则回答 <code>421 Service not available</code>。</p>
<p>如果一定时间内发送不了邮件，邮件服务器会把这个情况通知发件人。</p>
<h3 id="2-邮件传送"><a href="#2-邮件传送" class="headerlink" title="2. 邮件传送"></a>2. 邮件传送</h3><p>邮件的传送从<code>MAIL</code>命令开始，<code>MAIL</code>命令后面有发件人的地址。若 SMTP 服务器已准备好接收邮件，则回答<code>250 OK</code>。否则，返回一个代码，指出原因。</p>
<p>下面跟着一个或多个<code>RCPT(recipient)</code>命令，取决于把同一个邮件发送给一个或多个收件人。每发送一个<code>RCPT</code>命令，都应当有相应的信息从 SMTP 服务器返回，如<code>250 OK</code>，表示指明的邮箱在接收方的系统中，或<code>550 No such user here</code>，不存在此邮箱。</p>
<p><code>RCPT</code>命令的作用就是：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件。这样做是为了避免浪费通信资源，不至于发送了很长的邮件以后才知道地址错误。</p>
<p>再下面就是<code>DATA</code>命令，表示要开始传送邮件的内容了。若不能接收邮件，则返回 421（服务器不可用）、500（命令无法识别）等。接着 SMTP 客户就发送邮件内容。发送完毕后，再发送<code>&lt;CRLF&gt;.&lt;CRLF&gt;</code>表示邮件内容结束。实际上在服务器看到的可打印字符只是一个英文的句点。若邮件收到了，则 SMTP 服务器返回信息<code>250 OK</code>或差错代码。</p>
<h3 id="3-连接释放"><a href="#3-连接释放" class="headerlink" title="3. 连接释放"></a>3. 连接释放</h3><p>邮件发送完毕后，SMTP 客户应发送<code>QUIT</code>命令。SMTP 服务器返回的信息是<code>221(服务器关闭)</code>，表示 SMTP 同意释放 TCP 连接。</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img4.png" class="">
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img5.png" class="">
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img6.png" class="">

<h2 id="SMTP-缺点"><a href="#SMTP-缺点" class="headerlink" title="SMTP 缺点"></a>SMTP 缺点</h2><ul>
<li>发送电子邮件不需要经过鉴别。</li>
<li>SMTP 传送的邮件是明文的，不利于保密。</li>
<li>在网络上的传输效率不高。SMTP 本来就是为传送的是ASCII 码设计的，在传输非 ASCII 码的长报文时效率不高。</li>
</ul>
<h1 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h1><p>一个电子邮件分为信封和内容两大部分。</p>
<p>RFC 5322 只规定了邮件内容中的首部格式，而对邮件的主体部分则让用户自由撰写。</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img7.png" class="">

<h2 id="邮件内容的首部"><a href="#邮件内容的首部" class="headerlink" title="邮件内容的首部"></a>邮件内容的首部</h2><p>邮件内容首部的关键字：</p>
<ul>
<li><code>To:</code>：后面填入一个或多个收件人的电子邮件地址。</li>
<li><code>Subject:</code>：邮件的主题。它反映了邮件的主要内容，便于用户查找邮件。</li>
<li><code>Cc:</code>：抄送，表示应给某某人发送一个邮件副本。</li>
<li><code>From:</code>和<code>Date:</code>：表示发信人的电子邮件地址和发信日期。</li>
<li><code>Reply-To:</code>：是对方回信所用的地址。这个地址可以与发件人发信时使用的地址不同。</li>
</ul>
<h1 id="邮件读取协议-POP3-和-IMAP-协议"><a href="#邮件读取协议-POP3-和-IMAP-协议" class="headerlink" title="邮件读取协议 POP3 和 IMAP 协议"></a>邮件读取协议 POP3 和 IMAP 协议</h1><p>两个常用的邮件读取协议：</p>
<ul>
<li>POP3：邮局协议(<code>Post Office Protocol</code>)第3个版本 </li>
<li>IMAP：网际报文存取协议(<code>Internet Message Access Protocol</code>)</li>
</ul>
<h2 id="POP3-协议"><a href="#POP3-协议" class="headerlink" title="POP3 协议"></a>POP3 协议</h2><p>电子邮件通过 SMTP 协议到达接收方服务器，个人电脑不可能长期处于开机状态，用户希望一开机就能收到邮件，然而 SMTP 没有这种功能。</p>
<p>为了解决这个问题，就引入了 POP3 协议。POP3 协议是用于接收电子邮件的协议。发送端的邮件使用 SMTP 协议将电子邮件转发给一直在线的 POP3 服务器。客户端再根据 POP3 协议从 POP3 服务器接收邮件。这个过程中，为了防止别人盗取邮件内容，还要进行用户认证。</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/8.png" class="">

<p>POP3 协议和 SMTP 协议一样，是基于 TCP 的应用层协议，使用 TCP 110 端口连接邮件服务器。接收方的邮件客户端程序首先使用 TCP 连接到 POP3 服务器的 TCP 端口 110；再进行用户认证、邮件列表查询、邮件下载、邮件删除等操作；操作完成后，客户端与邮件服务器之间再断开 TCP 连接。</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/9.png" class="">

<p>POP3 仅负责邮件的下载，邮件从客户端上传到邮件服务器由 SMTP 协议完成。</p>
<h2 id="IMAP-协议"><a href="#IMAP-协议" class="headerlink" title="IMAP 协议"></a>IMAP 协议</h2><p>POP3 协议的邮件客户端能够在邮件服务器上执行的操作很少，而且邮件要下载到客户端本地，而不保留在邮件服务器，实际使用时很不方便。目前使用更广泛的接收电子邮件的协议是 IMAP。在 IMAP 中邮件则由服务器进行管理。</p>
<p>使用 IMAP 时，不必从服务器上下载所有的邮件也可以查看。由于 IMAP 是在服务器端处理 MIME 信息，它可以实现邮件附件的选择性下载功能。比如：一封邮件有 5 个附件时，可以只下载其中的 3 个附件。IMAP 还会在服务器上对 “已读&#x2F;未读” 信息和邮件分类进行管理，所以在不同的电脑上打开邮箱，也能保持同步，使用起来非常方便。</p>
<p>IMAP 使用客户–服务器方式。基于 TCP 实现客户与服务器的通信。</p>
<p>IMAP 是一个联机协议。</p>
<p>IMAP 的特点：</p>
<ul>
<li>连接后只下载邮件首部（部分下载）。</li>
<li>用户直接在 IMAP 服务器上创建和管理文件夹。</li>
<li>用户可以搜索邮件内容。</li>
<li>用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。</li>
<li>允许收信人只读取邮件中的某一个部分。</li>
</ul>
<p>缺点：要想查阅邮件，必须先联网。</p>
<h2 id="IMAP-与-POP3-比较"><a href="#IMAP-与-POP3-比较" class="headerlink" title="IMAP 与 POP3 比较"></a>IMAP 与 POP3 比较</h2><table>
<thead>
<tr>
<th align="center">操作位置</th>
<th align="center">操作内容</th>
<th align="center">IMAP</th>
<th align="center">POP3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">收件箱</td>
<td align="center">阅读、标记、移动、删除邮件等</td>
<td align="center">客户端与邮箱更新同步</td>
<td align="center">仅在客户端内</td>
</tr>
<tr>
<td align="center">发件箱</td>
<td align="center">保存到已发送</td>
<td align="center">客户端与邮箱更新同步</td>
<td align="center">仅在客户端内</td>
</tr>
<tr>
<td align="center">创建文件夹</td>
<td align="center">新建自定义的文件夹</td>
<td align="center">客户端与邮箱更新同步</td>
<td align="center">仅在客户端内</td>
</tr>
<tr>
<td align="center">草稿</td>
<td align="center">保存草稿</td>
<td align="center">客户端与邮箱更新同步</td>
<td align="center">仅在客户端内</td>
</tr>
<tr>
<td align="center">垃圾文件夹</td>
<td align="center">接收并移入垃圾文件夹的邮件</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center">广告邮件</td>
<td align="center">接收并移入广告邮件夹的邮件</td>
<td align="center">支持</td>
<td align="center">不支持</td>
</tr>
</tbody></table>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img9.png" class="">

<p>邮件读取协议 POP 或 IMAP 与邮件传送协议 SMTP 完全不同。发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。 </p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img10.png" class="">

<h1 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h1><p>用户代理 (UA) 的缺点：</p>
<ul>
<li>必须在计算机中安装用户代理软件。</li>
<li>但可能不能安装或不允许安装。因此，不方便收发邮件。</li>
</ul>
<p>万维网电子邮件优点：</p>
<ul>
<li>不需要在计算机中再安装用户代理软件。</li>
<li>计算机能联网，就能非常方便地收发电子邮件。</li>
<li>电子邮件界面非常友好。</li>
</ul>
<h2 id="万维网电子邮件"><a href="#万维网电子邮件" class="headerlink" title="万维网电子邮件"></a>万维网电子邮件</h2><img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img11.png" class="">

<p>发送、接收电子邮件时使用 HTTP 协议。</p>
<p>两个邮件服务器之间传送邮件时使用 SMTP。</p>
<h1 id="通用互联网邮件扩充-MIME"><a href="#通用互联网邮件扩充-MIME" class="headerlink" title="通用互联网邮件扩充 MIME"></a>通用互联网邮件扩充 MIME</h1><p>SMTP 有以下缺点：</p>
<ul>
<li>SMTP 不能传送可执行文件或其他的二进制对象。</li>
<li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文或德文）就无法传送。</li>
<li>SMTP 服务器会拒绝超过一定长度的邮件。</li>
<li>某些 SMTP 的实现并没有完全按照 SMTP 的标准。</li>
</ul>
<p>于是在这种情况下提出了通用互联网邮件扩充 MIME。</p>
<h2 id="1-MIME-概述"><a href="#1-MIME-概述" class="headerlink" title="1.MIME 概述"></a>1.MIME 概述</h2><p>MMIE 并没有改动或修改 SMTP，MIME 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说 MIME 邮件可在现有的电子邮件程序和协议下传送。</p>
<p>MIME 和 SMTP 的关系：</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img12.png" class="">

<p>MIME 主要包括三个部分：</p>
<ul>
<li>5 个新的邮件首部字段，它们可包含在原有首部中。这些字段提供了有关邮件主体的信息。</li>
<li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li>
<li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li>
</ul>
<p>MIME 增加 5 个新的邮件首部：</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img13.png" class="">

<h2 id="2-内容传送编码-Content-Transfer-Encoding"><a href="#2-内容传送编码-Content-Transfer-Encoding" class="headerlink" title="2.内容传送编码(Content-Transfer-Encoding)"></a>2.内容传送编码(Content-Transfer-Encoding)</h2><img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img14.png" class="">

<p><code>Quoted-printable</code>编码适用于所传送的数据中只有少量的非 ASCII 码的情况。</p>
<p><code>Base64</code>编码适合任意长度的二进制数据。</p>
<h2 id="3-内容类型"><a href="#3-内容类型" class="headerlink" title="3. 内容类型"></a>3. 内容类型</h2><p>MIME 标准规定<code>Content-Type</code>说明必须含有两个标识符，即内容类型和子类型，中间用<code>/</code>分开。</p>
<p>MIME 标准原先定义了 7 个基本内容类型和 15 种子类型。 </p>
<p>MIME允许发件人和收件人自己定义专用的内容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串<code>X-</code>开始。</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img17.png" class="">

<p>MIME 举例</p>
<img src="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/img18.png" class="">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/18/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>