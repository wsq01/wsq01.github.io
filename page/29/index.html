<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/js/深入/JS内存机制——栈空间和堆空间"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/"
    >JS内存机制——栈空间和堆空间</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/" class="article-date">
  <time datetime="2019-11-20T03:01:23.000Z" itemprop="datePublished">2019-11-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JavaScript-是什么类型的语言"><a href="#JavaScript-是什么类型的语言" class="headerlink" title="JavaScript 是什么类型的语言"></a>JavaScript 是什么类型的语言</h1><p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型，你可以看下面这段 C 代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">   <span class="type">char</span>* b = <span class="string">&quot; 极客时间 &quot;</span>;</span><br><span class="line">   <span class="type">bool</span> c = <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。</p>
<p>相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。</p>
<p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型数据赋予给一个声明好的变量，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a</span><br></pre></td></tr></table></figure>
<p>前面代码中，我们把<code>int</code>型的变量<code>a</code>赋值给了<code>bool</code>型的变量<code>c</code>，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把<code>int</code>型的变量悄悄转换为<code>bool</code>型的变量，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。</p>
<p>对于各种语言的类型，你可以参考下图：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img1.png" class="" title="语言类型图">

<h1 id="JavaScript-的数据类型"><a href="#JavaScript-的数据类型" class="headerlink" title="JavaScript 的数据类型"></a>JavaScript 的数据类型</h1><p>现在我们知道了，JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？</p>
<ul>
<li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li>
<li>动态，意味着你可以使用同一个变量保存不同类型的数据。</li>
</ul>
<p>JavaScript 中的数据类型一种有 8 种，它们分别是：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img2.png" class="">

<p>了解这些类型之后，还有三点需要你注意一下。</p>
<p>第一点，使用<code>typeof</code>检测<code>Null</code>类型时，返回的是<code>Object</code>。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>
<p>第二点，<code>Object</code>类型比较特殊，它是由上述 7 种类型组成的一个包含了<code>key-value</code>对的数据类型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;极客时间&#x27;</span>,</span><br><span class="line">  <span class="attr">update</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中你可以看出来，<code>Object</code>是由<code>key-value</code>组成的，其中的<code>vaule</code>可以是任何类型，包括函数，这也就意味着你可以通过<code>Object</code>来存储函数，<code>Object</code>中的函数又称为方法，比如上述代码中的<code>update</code>方法。</p>
<p>第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。到底怎么个不一样法呢？接下来，我们就来讲解一下 JavaScript 的原始类型和引用类型到底是怎么储存的。</p>
<h1 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h1><p>要理解 JavaScript 在运行过程中数据是如何存储的，你就得先搞清楚其存储空间的种类。JavaScript 的内存模型图如下：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img3.png" class="" title="JavaScript 内存模型">

<p>从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。</p>
<p>其中的代码空间主要是存储可执行代码的。</p>
<h1 id="栈空间和堆空间"><a href="#栈空间和堆空间" class="headerlink" title="栈空间和堆空间"></a>栈空间和堆空间</h1><p>这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，我们还是先看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    <span class="keyword">var</span> c = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> d = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。那么下面我们来看看，当执行到第 3 行代码时，其调用栈的状态，你可以参考下面这张调用栈状态图：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img4.png" class="" title="执行到第 3 行时的调用栈状态图">

<p>从图中可以看出来，当执行到第 3 行时，变量<code>a</code>和变量<code>b</code>的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量<code>a</code>和变量<code>b</code>的值都是存放在栈中的。</p>
<p>接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进<code>c</code>的变量值，最终分配好内存的示意图如下所示：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img5.png" class="" title="对象类型是“堆”来存储">

<p>从上图你可以清晰地观察到，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。</p>
<p>好了，现在你应该知道了原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。不过你也许会好奇，为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</p>
<p>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的<code>foo</code>函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，<code>foo</code>函数执行上下文栈区空间全部回收，具体过程你可以参考下图：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img6.png" class="" title="调用栈中切换执行上下文状态">

<p>所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。</p>
<p>解释了程序在执行过程中为什么需要堆和栈两种数据结构后，我们还是回到示例代码那里，看看它最后一步将变量<code>c</code>赋值给变量<code>d</code>是怎么执行的？</p>
<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>
<p>所以<code>d=c</code>的操作就是把<code>c</code>的引用地址赋值给<code>d</code>，你可以参考下图：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img7.png" class="" title="引用赋值">

<p>从图中你可以看到，变量<code>c</code>和变量<code>d</code>都指向了同一个堆中的对象，通过<code>c</code>修改<code>name</code>的值，变量<code>d</code>的值也跟着改变，归根结底它们是同一个对象。</p>
<h1 id="闭包的内存模型"><a href="#闭包的内存模型" class="headerlink" title="闭包的内存模型"></a>闭包的内存模型</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> innerBar = &#123; </span><br><span class="line">    <span class="attr">setName</span>: <span class="keyword">function</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">      myName = newName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(test1)</span><br><span class="line">      <span class="keyword">return</span> myName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>()</span><br><span class="line">bar.<span class="title function_">setName</span>(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.<span class="title function_">getName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure>
<p>当执行这段代码的时候，你应该有过这样的分析：由于变量<code>myName、test1、test2</code>都是原始类型数据，所以在执行<code>foo</code>函数的时候，它们会被压入到调用栈中；当<code>foo</code>函数执行结束之后，调用栈中<code>foo</code>函数的执行上下文会被销毁，其内部变量<code>myName、test1、test2</code>也应该一同被销毁。</p>
<p>当<code>foo</code>函数的执行上下文销毁时，由于<code>foo</code>函数产生了闭包，所以变量<code>myName</code>和<code>test1</code>并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？</p>
<p>要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。</p>
<ol>
<li>当 JavaScript 引擎执行到<code>foo</code>函数时，首先会编译，并创建一个空执行上下文。</li>
<li>在编译过程中，遇到内部函数<code>setName</code>，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了<code>foo</code>函数中的<code>myName</code>变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个<code>closure(foo)</code>的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存<code>myName</code>变量。</li>
<li>接着继续扫描到<code>getName</code>方法时，发现该函数内部还引用变量<code>test1</code>，于是 JavaScript 引擎又将<code>test1</code>添加到<code>closure(foo)</code>对象中。这时候堆中的<code>closure(foo)</code>对象中就包含了<code>myName</code>和<code>test1</code>两个变量了。</li>
<li>由于<code>test2</code>并没有被内部函数引用，所以<code>test2</code>依然保存在调用栈中。</li>
</ol>
<p>通过上面的分析，我们可以画出执行到<code>foo</code>函数中<code>return innerBar</code>语句时的调用栈状态，如下图所示：</p>
<img src="/2019/11/20/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%A0%88%E7%A9%BA%E9%97%B4%E5%92%8C%E5%A0%86%E7%A9%BA%E9%97%B4/img8.png" class="" title="闭包的产生过程">

<p>从上图你可以清晰地看出，当执行到<code>foo</code>函数时，闭包就产生了；当<code>foo</code>函数执行结束之后，返回的<code>getName</code>和<code>setName</code>方法都引用<code>clourse(foo)</code>对象，所以即使<code>foo</code>函数退出了，<code>clourse(foo)</code>依然被其内部的<code>getName</code>和<code>setName</code>方法引用。所以在下次调用<code>bar.setName</code>或者<code>bar.getName</code>时，创建的执行上下文中就包含了<code>clourse(foo)</code>。</p>
<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">JS内存机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-vue/前端路由原理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/14/vue/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/"
    >前端路由原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/14/vue/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2019-11-14T13:12:35.000Z" itemprop="datePublished">2019-11-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是SPA"><a href="#什么是SPA" class="headerlink" title="什么是SPA"></a>什么是SPA</h1><p>SPA是<code>single page web application</code>的简称，译为单页Web应用。<br>简单的说SPA就是一个WEB项目只有一个HTML页面，一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转。<br>取而代之的是利用JS动态的变换HTML的内容，从而来模拟多个视图间跳转。</p>
<h1 id="前端路由的由来"><a href="#前端路由的由来" class="headerlink" title="前端路由的由来"></a>前端路由的由来</h1><p>最开始的网页是多页面的，直到Ajax的出现，才慢慢有了SPA。<br>SPA的出现大大提高了WEB应用的交互体验。在与用户的交互过程中，不再需要重新刷新页面，获取数据也是通过Ajax异步获取，页面显示变的更加流畅。<br>但由于SPA中用户的交互是通过JS改变HTML内容来实现的，页面本身的URL并没有变化，这导致了两个问题：</p>
<ul>
<li>SPA无法记住用户的操作记录，无论是刷新、前进还是后退，都无法展示用户真实的期望内容。</li>
<li>SPA中虽然由于业务的不同会有多种页面展示形式，但只有一个URL，对SEO不友好，不方便搜索引擎进行收录。</li>
</ul>
<p>前端路由就是为了解决上述问题而出现的。</p>
<h1 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h1><p>简单的说，就是在保证只有一个HTML页面，且与用户交互时不刷新和跳转页面的同时，为SPA中的每个视图展示形式匹配一个特殊的URL。在刷新、前进、后退和SEO时均通过这个特殊的URL来实现。<br>为实现这一目标，我们需要做到以下二点：</p>
<ul>
<li>改变URL且不让浏览器像服务器发送请求。</li>
<li>可以监听到URL的变化</li>
</ul>
<p><code>hash</code>模式和<code>history</code>模式，就是实现了上面的功能。</p>
<h2 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h2><p>这里的<code>hash</code>就是指<code>url</code>后的<code>#</code>号以及后面的字符。比如说<code>www.baidu.com/#hashhash</code>，其中<code>&quot;#hashhash&quot;</code>就是我们期望的<code>hash</code>值。</p>
<p>由于<code>hash</code>值的变化不会导致浏览器像服务器发送请求，而且<code>hash</code>的改变会触发<code>hashchange</code>事件，浏览器的前进后退也能对其进行控制，所以在H5的<code>history</code>模式出现之前，基本都是使用<code>hash</code>模式来实现前端路由。<br>使用到的API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span> = <span class="string">&#x27;hash字符串&#x27;</span>; <span class="comment">// 用于设置 hash 值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hash = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span>; <span class="comment">// 获取当前 hash 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听hash变化，点击浏览器的前进后退会触发</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> newURL = event.<span class="property">newURL</span>; <span class="comment">// hash 改变后的新 url</span></span><br><span class="line">  <span class="keyword">let</span> oldURL = event.<span class="property">oldURL</span>; <span class="comment">// hash 改变前的旧 url</span></span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>接下来我们来实现一个路由对象。<br>创建一个路由对象, 实现<code>register</code>方法用于注册每个<code>hash</code>值对应的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashRouter</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于存储不同hash值对应的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册每个视图</span></span><br><span class="line">  <span class="title function_">register</span>(<span class="params">hash,callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[hash] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不存在<code>hash</code>值时，认为是首页，所以实现<code>registerIndex</code>方法用于注册首页时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashRouter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于存储不同hash值对应的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册每个视图</span></span><br><span class="line">  <span class="title function_">register</span>(<span class="params">hash,callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[hash] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册首页</span></span><br><span class="line">  <span class="title function_">registerIndex</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;index&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>hashchange</code>监听<code>hash</code>变化，并定义<code>hash</code>变化时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashRouter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//用于存储不同hash值对应的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>,<span class="variable language_">this</span>.<span class="property">load</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册每个视图</span></span><br><span class="line">  <span class="title function_">register</span>(<span class="params">hash,callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[hash] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册首页</span></span><br><span class="line">  <span class="title function_">registerIndex</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;index&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于调用不同视图的回调函数</span></span><br><span class="line">  <span class="title function_">load</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>), handler;</span><br><span class="line">    <span class="comment">//没有hash 默认为首页</span></span><br><span class="line">    <span class="keyword">if</span>(!hash) &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>.<span class="property">index</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[hash];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行注册的回调函数</span></span><br><span class="line">    handler.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们做一个例子来演示一下我们刚刚完成的<code>HashRouter</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page1&quot;</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page2&quot;</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page3&quot;</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> <span class="title class_">HashRouter</span>();</span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册首页回调函数</span></span><br><span class="line">router.<span class="title function_">registerIndex</span>(<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是首页&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册其他视图回到函数</span></span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page1&#x27;</span>,<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page1&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page2&#x27;</span>,<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page2&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page3&#x27;</span>,<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载视图</span></span><br><span class="line">router.<span class="title function_">load</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/3534846-5b28ab000cf54b83?imageMogr2/auto-orient/strip" alt="image"></p>
<p>基本的路由功能我们已经实现了，但依然有点小问题：</p>
<ul>
<li>视图切换后，新的<code>hash</code>值没有在路由中注册</li>
<li><code>hash</code>值对应的回调函数在执行过程中抛出异常</li>
</ul>
<p>对应的解决办法如下：</p>
<ul>
<li>我们追加<code>registerNotFound</code>方法，用于注册<code>hash</code>值为找到时的默认回调函数；</li>
<li>修改<code>load</code>方法，追加<code>try/catch</code>用于捕获异常，追加<code>registerError</code>方法，用于处理异常</li>
</ul>
<p>代码修改后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashRouter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">//用于存储不同hash值对应的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routers</span> = &#123;&#125;;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>,<span class="variable language_">this</span>.<span class="property">load</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册每个视图</span></span><br><span class="line">  <span class="title function_">register</span>(<span class="params">hash,callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routers</span>[hash] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册首页</span></span><br><span class="line">  <span class="title function_">registerIndex</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;index&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于处理视图未找到的情况</span></span><br><span class="line">  <span class="title function_">registerNotFound</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于处理异常情况</span></span><br><span class="line">  <span class="title function_">registerError</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于调用不同视图的回调函数</span></span><br><span class="line">  <span class="title function_">load</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> hash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>), handler;</span><br><span class="line">    <span class="comment">//没有hash 默认为首页</span></span><br><span class="line">    <span class="keyword">if</span>(!hash)&#123;</span><br><span class="line">        handler = <span class="variable language_">this</span>.<span class="property">routers</span>.<span class="property">index</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未找到对应hash值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">routers</span>.<span class="title function_">hasOwnProperty</span>(hash)) &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[hash]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行注册的回调函数</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      handler.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">      (<span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="title function_">call</span>(<span class="variable language_">this</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来一个例子，演示一下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page1&quot;</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page2&quot;</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page3&quot;</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page4&quot;</span>&gt;</span>page4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/page5&quot;</span>&gt;</span>page5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> <span class="title class_">HashRouter</span>();</span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册首页回调函数</span></span><br><span class="line">router.<span class="title function_">registerIndex</span>(<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是首页&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册其他视图回到函数</span></span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page1&#x27;</span>,<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page1&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page2&#x27;</span>,<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page2&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page3&#x27;</span>,<span class="function">()=&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page3&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page4&#x27;</span>,<span class="function">()=&gt;</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出一个异常&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载视图</span></span><br><span class="line">router.<span class="title function_">load</span>();</span><br><span class="line"><span class="comment">//注册未找到对应hash值时的回调</span></span><br><span class="line">router.<span class="title function_">registerNotFound</span>(<span class="function">()=&gt;</span>container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面未找到&#x27;</span>);</span><br><span class="line"><span class="comment">//注册出现异常时的回调</span></span><br><span class="line">router.<span class="title function_">registerError</span>(<span class="function">(<span class="params">e</span>)=&gt;</span>container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面异常，错误消息：&lt;br&gt;&#x27;</span> + e.<span class="property">message</span>);</span><br></pre></td></tr></table></figure>
<p>来看一下效果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-004471032a1af8bc?imageMogr2/auto-orient/strip"></p>
<p>至此，基于<code>hash</code>方式实现的前端路由，我们已经将基本雏形实现完成了。</p>
<h1 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h1><p>在H5之前，浏览器就已经有了<code>history</code>对象。但在早期的<code>history</code>中只能用于多页面的跳转：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>); <span class="comment">// 后退一页</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">2</span>); <span class="comment">// 前进两页</span></span><br><span class="line">history.<span class="title function_">forward</span>(); <span class="comment">// 前进一页</span></span><br><span class="line">history.<span class="title function_">back</span>(); <span class="comment">// 后退一页</span></span><br></pre></td></tr></table></figure>
<p>在H5的规范中，<code>history</code>新增了以下几个API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>(); <span class="comment">// 添加新的状态到历史状态栈</span></span><br><span class="line">history.<span class="title function_">replaceState</span>(); <span class="comment">// 用新的状态代替当前状态</span></span><br><span class="line">history.<span class="property">state</span> <span class="comment">// 返回当前状态对象</span></span><br></pre></td></tr></table></figure>
<p>这些方法通常与<code>window.onpopstate</code>配合使用。<br><code>history.pushState()</code>和<code>history.replaceState()</code>均接收三个参数（<code>state, title, url</code>）<br>参数说明如下：</p>
<ul>
<li><code>state</code>：合法的Javascript对象，可以用在<code>popstate</code>事件中</li>
<li><code>title</code>：现在大多浏览器忽略这个参数，可以直接用<code>null</code>代替</li>
<li><code>url</code>：任意有效的URL，用于更新浏览器的地址栏</li>
</ul>
<p><code>history.pushState()</code>和<code>history.replaceState()</code>的区别在于：</p>
<ul>
<li><code>history.pushState()</code>在保留现有历史记录的同时，将<code>url</code>加入到历史记录中。</li>
<li><code>history.replaceState()</code>会将历史记录中的当前页面历史替换为<code>url</code>。</li>
</ul>
<p>由于<code>history.pushState()</code>和<code>history.replaceState()</code>可以改变<code>url</code>同时，不会刷新页面，所以在 HTML5中的<code>histroy</code>具备了实现前端路由的能力。<br>回想我们之前完成的<code>hash</code>模式，当<code>hash</code>变化时，可以通过<code>hashchange</code>进行监听。<br>而<code>history</code>的改变并不会触发任何事件，所以我们无法直接监听<code>history</code>的改变而做出相应的改变。<br>所以，我们需要换个思路，我们可以罗列出所有可能触发<code>history</code>改变的情况，并且将这些方式一一进行拦截，变相地监听<code>history</code>的改变。<br>对于单页应用的<code>history</code>模式而言，<code>url</code>的改变只能由下面四种方式引起：</p>
<ul>
<li>点击浏览器的前进或后退按钮</li>
<li>点击<code>a</code>标签</li>
<li>在JS代码中触发<code>history.pushState</code>函数</li>
<li>在JS代码中触发<code>history.replaceState</code>函数</li>
</ul>
<p>思路已经有了，接下来我们来实现一个路由对象。</p>
<ol>
<li>创建一个路由对象, 实现<code>register</code>方法用于注册每个<code>location.pathname</code>值对应的回调函数</li>
<li>当<code>location.pathname === &#39;/&#39;</code>时，认为是首页，所以实现<code>registerIndex</code>方法用于注册首页时的回调函数</li>
<li>解决<code>location.path</code>没有对应的匹配，增加方法<code>registerNotFound</code>用于注册默认回调函数</li>
<li>解决注册的回到函数执行时出现异常，增加方法<code>registerError</code>用于处理异常情况</li>
<li>定义<code>assign</code>方法，用于通过JS触发<code>history.pushState</code>函数</li>
<li>定义<code>replace</code>方法，用于通过JS触发<code>history.replaceState</code>函数</li>
<li>监听<code>popstate</code>用于处理前进后退时调用对应的回调函数</li>
<li>全局阻止<code>a</code>链接的默认事件，获取<code>a</code>链接的<code>href</code>属性，并调用<code>history.pushState</code>方法</li>
<li>定义<code>load</code>方法，用于首次进入页面时 根据<code>location.pathname</code>调用对应的回调函数</li>
</ol>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HistoryRouter</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//用于存储不同path值对应的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">listenPopState</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">listenLink</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//监听popstate</span></span><br><span class="line">  <span class="title function_">listenPopState</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> state = e.<span class="property">state</span> || &#123;&#125;, path = state.<span class="property">path</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">    &#125;,<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//全局监听A链接</span></span><br><span class="line">  <span class="title function_">listenLink</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> dom = e.<span class="property">target</span>;</span><br><span class="line">      <span class="keyword">if</span>(dom.<span class="property">tagName</span>.<span class="title function_">toUpperCase</span>() === <span class="string">&#x27;A&#x27;</span> &amp;&amp; dom.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>)) &#123;</span><br><span class="line">        e.<span class="title function_">preventDefault</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">assign</span>(dom.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于首次进入页面时调用</span></span><br><span class="line">  <span class="title function_">load</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> path = location.<span class="property">pathname</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册每个视图</span></span><br><span class="line">  <span class="title function_">register</span>(<span class="params">path,callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[path] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于注册首页</span></span><br><span class="line">  <span class="title function_">registerIndex</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;/&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于处理视图未找到的情况</span></span><br><span class="line">  <span class="title function_">registerNotFound</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于处理异常情况</span></span><br><span class="line">  <span class="title function_">registerError</span>(<span class="params">callback = <span class="keyword">function</span>()&#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//跳转到path</span></span><br><span class="line">  <span class="title function_">assign</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">pushState</span>(&#123;path&#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//替换为path</span></span><br><span class="line">  <span class="title function_">replace</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    history.<span class="title function_">replaceState</span>(&#123;path&#125;, <span class="literal">null</span>, path);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">dealPathHandler</span>(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通用处理 path 调用回调函数</span></span><br><span class="line">  <span class="title function_">dealPathHandler</span>(<span class="params">path</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> handler;</span><br><span class="line">    <span class="comment">//没有对应path</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">routers</span>.<span class="title function_">hasOwnProperty</span>(path)) &#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;404&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有对应path</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      handler = <span class="variable language_">this</span>.<span class="property">routers</span>[path];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      handler.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">      (<span class="variable language_">this</span>.<span class="property">routers</span>[<span class="string">&#x27;error&#x27;</span>] || <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="title function_">call</span>(<span class="variable language_">this</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再做一个例子来演示一下我们刚刚完成的<code>HistoryRouter</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page1&quot;</span>&gt;</span>page1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page2&quot;</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page3&quot;</span>&gt;</span>page3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page4&quot;</span>&gt;</span>page4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page5&quot;</span>&gt;</span>page5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>page2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> <span class="title class_">HistoryRouter</span>();</span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册首页回调函数</span></span><br><span class="line">router.<span class="title function_">registerIndex</span>(<span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是首页&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册其他视图回到函数</span></span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page1&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page1&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page2&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page2&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page3&#x27;</span>, <span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;我是page3&#x27;</span>);</span><br><span class="line">router.<span class="title function_">register</span>(<span class="string">&#x27;/page4&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出一个异常&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="function">() =&gt;</span> router.<span class="title function_">assign</span>(<span class="string">&#x27;/page2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册未找到对应path值时的回调</span></span><br><span class="line">router.<span class="title function_">registerNotFound</span>(<span class="function">() =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面未找到&#x27;</span>);</span><br><span class="line"><span class="comment">//注册出现异常时的回调</span></span><br><span class="line">router.<span class="title function_">registerError</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> container.<span class="property">innerHTML</span> = <span class="string">&#x27;页面异常，错误消息：&lt;br&gt;&#x27;</span> + e.<span class="property">message</span>);</span><br><span class="line"><span class="comment">//加载页面</span></span><br><span class="line">router.<span class="title function_">load</span>();</span><br></pre></td></tr></table></figure>
<p>来看一下效果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-a50416628e6234dd.gif?imageMogr2/auto-orient/strip"></p>
<p>至此，基于<code>history</code>方式实现的前端路由，我们已经将基本雏形实现完成了。<br>但需要注意的是，<code>history</code>在修改<code>url</code>后，虽然页面并不会刷新，但我们在手动刷新，或通过<code>url</code>直接进入应用的时候，服务端是无法识别这个<code>url</code>的。因为我们是单页应用，只有一个HTML文件，服务端在处理其他路径的<code>url</code>的时候，就会出现404的情况。</p>
<p>所以，如果要应用<code>history</code>模式，需要在服务端增加一个覆盖所有情况的候选资源：如果URL匹配不到任何静态资源，则应该返回单页应用的HTML文件。<br>接下来，我们来探究一下，何时使用<code>hash</code>模式，何时使用<code>history</code>模式。</p>
<h1 id="hash、history-如何抉择"><a href="#hash、history-如何抉择" class="headerlink" title="hash、history 如何抉择"></a>hash、history 如何抉择</h1><p><code>hash</code>模式相比于<code>history</code>模式的优点：</p>
<ul>
<li>兼容性更好，可以兼容到IE8</li>
<li>无需服务端配合处理非单页的url地址</li>
</ul>
<p><code>hash</code>模式相比于<code>history</code>模式的缺点：</p>
<ul>
<li>看起来更丑</li>
<li>会导致锚点功能失效</li>
<li>相同<code>hash</code>值不会触发动作将记录加入到历史栈中，而<code>pushState</code>则可以</li>
</ul>
<p>综上所述，当我们不需要兼容老版本IE浏览器，并且可以控制服务端覆盖所有情况的候选资源时，我们可以愉快的使用<code>history</code>模式了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS执行机制——this"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/07/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94this/"
    >JS执行机制——this</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/07/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94this/" class="article-date">
  <time datetime="2019-11-07T13:09:11.000Z" itemprop="datePublished">2019-11-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>先来看一段代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">myName</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="attr">printName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myName)</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myName = <span class="string">&quot; 张三 &quot;</span></span><br><span class="line">  <span class="keyword">return</span> bar.<span class="property">printName</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot; 李四 &quot;</span></span><br><span class="line"><span class="keyword">let</span> _printName = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">_printName</span>()</span><br><span class="line">bar.<span class="title function_">printName</span>()</span><br></pre></td></tr></table></figure>
<p>在<code>printName</code>函数里面使用的变量<code>myName</code>是属于全局作用域下面的，所以最终打印出来的值都是“李四”。这是因为 JavaScript 语言的作用域链是由词法作用域决定的，而词法作用域是由代码结构来确定的。</p>
<p>不过按照常理来说，调用<code>bar.printName</code>方法时，该方法内部的变量<code>myName</code>应该使用<code>bar</code>对象中的，因为它们是一个整体，大多数面向对象语言都是这样设计的，比如我用 C++ 改写了上面那段代码，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span>* myName;</span><br><span class="line">  <span class="built_in">Bar</span>()&#123;</span><br><span class="line">    myName = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt; myName &lt;&lt;endl;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125; bar;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span>* myName = <span class="string">&quot; 李四 &quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	bar.<span class="built_in">printName</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段 C++ 代码中，我同样调用了<code>bar</code>对象中的<code>printName</code>方法，最后打印出来的值就是<code>bar</code>对象的内部变量<code>myName</code>值——<code>test</code>，而并不是最外面定义变量<code>myName</code>的值——“李四”，所以在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套<code>this</code>机制。</p>
<p>所以，在 JavaScript 中可以使用<code>this</code>实现在<code>printName</code>函数中访问到<code>bar</code>对象的<code>myName</code>属性了。具体该怎么操作呢？你可以调整<code>printName</code>的代码，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">printName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">myName</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用域链和<code>this</code>是两套不同的系统，它们之间基本没太多联系。</p>
<h1 id="JavaScript-中的-this-是什么"><a href="#JavaScript-中的-this-是什么" class="headerlink" title="JavaScript 中的 this 是什么"></a>JavaScript 中的 this 是什么</h1><p>关于<code>this</code>，我们还是得先从执行上下文说起。执行上下文中包含了变量环境、词法环境、外部环境，还有一个<code>this</code>，具体你可以参考下图：</p>
<img src="/2019/11/07/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94this/img1.png" class="" title="执行上下文中的 this">

<p>从图中可以看出，<code>this</code>是和执行上下文绑定的，也就是说每个执行上下文中都有一个<code>this</code>。执行上下文主要分为三种——全局执行上下文、函数执行上下文和<code>eval</code>执行上下文，所以对应的<code>this</code>也只有这三种——全局执行上下文中的<code>this</code>、函数中的<code>this</code>和<code>eval</code>中的<code>this</code>。</p>
<h1 id="全局执行上下文中的-this"><a href="#全局执行上下文中的-this" class="headerlink" title="全局执行上下文中的 this"></a>全局执行上下文中的 this</h1><p>你可以在控制台中输入<code>console.log(this)</code>来打印出来全局执行上下文中的<code>this</code>，最终输出的是<code>window</code>对象。所以你可以得出这样一个结论：全局执行上下文中的<code>this</code>是指向<code>window</code>对象的。这也是<code>this</code>和作用域链的唯一交点，作用域链的最底端包含了<code>window</code>对象，全局执行上下文中的<code>this</code>也是指向<code>window</code>对象。</p>
<h1 id="函数执行上下文中的-this"><a href="#函数执行上下文中的-this" class="headerlink" title="函数执行上下文中的 this"></a>函数执行上下文中的 this</h1><p>还是先看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>我们在<code>foo</code>函数内部打印出来<code>this</code>值，执行这段代码，打印出来的也是<code>window</code>对象，这说明在默认情况下调用一个函数，其执行上下文中的<code>this</code>也是指向<code>window</code>对象的。估计你会好奇，那能不能设置执行上下文中的<code>this</code>来指向其他对象呢？答案是肯定的。通常情况下，有下面三种方式来设置函数执行上下文中的<code>this</code>值。</p>
<h2 id="1-通过函数的-call-方法设置"><a href="#1-通过函数的-call-方法设置" class="headerlink" title="1. 通过函数的 call 方法设置"></a>1. 通过函数的 call 方法设置</h2><p>你可以通过函数的<code>call</code>方法来设置函数执行上下文的<code>this</code>指向，比如下面这段代码，我们就并没有直接调用<code>foo</code>函数，而是调用了<code>foo</code>的<code>call</code>方法，并将<code>bar</code>对象作为<code>call</code>方法的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;</span><br><span class="line">  myName : <span class="string">&quot; 李四 &quot;</span>,</span><br><span class="line">  test1 : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">myName</span> = <span class="string">&quot; 张三 &quot;</span></span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">call</span>(bar)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName)</span><br></pre></td></tr></table></figure>
<p>执行这段代码，然后观察输出结果，你就能发现<code>foo</code>函数内部的<code>this</code>已经指向了<code>bar</code>对象，因为通过打印<code>bar</code>对象，可以看出<code>bar</code>的<code>myName</code>属性已经由“李四”变为“张三”了，同时在全局执行上下文中打印<code>myName</code>，JavaScript 引擎提示该变量未定义。</p>
<p>其实除了<code>call</code>方法，你还可以使用<code>bind</code>和<code>apply</code>方法来设置函数执行上下文中的<code>this</code>。</p>
<h2 id="2-通过对象调用方法设置"><a href="#2-通过对象调用方法设置" class="headerlink" title="2. 通过对象调用方法设置"></a>2. 通过对象调用方法设置</h2><p>要改变函数执行上下文中的<code>this</code>指向，除了通过函数的<code>call</code>方法来实现外，还可以通过对象调用的方式，比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">&quot; 张三 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.<span class="title function_">showThis</span>()</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们定义了一个<code>myObj</code>对象，该对象是由一个<code>name</code>属性和一个<code>showThis</code>方法组成的，然后再通过<code>myObj</code>对象来调用<code>showThis</code>方法。执行这段代码，你可以看到，最终输出的<code>this</code>值是指向<code>myObj</code>的。</p>
<p>所以，你可以得出这样的结论：使用对象来调用其内部的一个方法，该方法的<code>this</code>是指向对象本身的。</p>
<p>其实，你也可以认为 JavaScript 引擎在执行<code>myObject.showThis()</code>时，将其转化为了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObj.<span class="property">showThis</span>.<span class="title function_">call</span>(myObj)</span><br></pre></td></tr></table></figure>
<p>接下来我们稍微改变下调用方式，把<code>showThis</code>赋给一个全局对象，然后再调用该对象，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">&quot; 张三 &quot;</span>,</span><br><span class="line">  <span class="attr">showThis</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot; 李四 &quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = myObj.<span class="property">showThis</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>执行这段代码，你会发现<code>this</code>又指向了全局<code>window</code>对象。</p>
<p>所以通过以上两个例子的对比，你可以得出下面这样两个结论：</p>
<p>在全局环境中调用一个函数，函数内部的<code>this</code>指向的是全局变量<code>window</code>。<br>通过一个对象来调用其内部的一个方法，该方法的执行上下文中的<code>this</code>指向对象本身。</p>
<h2 id="3-通过构造函数中设置"><a href="#3-通过构造函数中设置" class="headerlink" title="3. 通过构造函数中设置"></a>3. 通过构造函数中设置</h2><p>你可以像这样设置构造函数中的<code>this</code>，如下面的示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CreateObj</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot; 张三 &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="title class_">CreateObj</span>()</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们使用<code>new</code>创建了对象<code>myObj</code>，那你知道此时的构造函数<code>CreateObj</code>中的<code>this</code>到底指向了谁吗？</p>
<p>其实，当执行<code>new CreateObj()</code>的时候，JavaScript 引擎做了如下四件事：</p>
<ul>
<li>首先创建了一个空对象<code>tempObj</code>；</li>
<li>接着调用<code>CreateObj.call</code>方法，并将<code>tempObj</code>作为<code>call</code>方法的参数，这样当<code>CreateObj</code>的执行上下文创建时，它的<code>this</code>就指向了<code>tempObj</code>对象；</li>
<li>然后执行<code>CreateObj</code>函数，此时的<code>CreateObj</code>函数执行上下文中的<code>this</code>指向了<code>tempObj</code>对象；</li>
<li>最后返回<code>tempObj</code>对象。</li>
</ul>
<p>为了直观理解，我们可以用代码来演示下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempObj = &#123;&#125;</span><br><span class="line"><span class="title class_">CreateObj</span>.<span class="title function_">call</span>(tempObj)</span><br><span class="line"><span class="keyword">return</span> tempObj</span><br></pre></td></tr></table></figure>
<p>这样，我们就通过<code>new</code>关键字构建好了一个新对象，并且构造函数中的<code>this</code>其实就是新对象本身。</p>
<h1 id="this-的设计缺陷以及应对方案"><a href="#this-的设计缺陷以及应对方案" class="headerlink" title="this 的设计缺陷以及应对方案"></a>this 的设计缺陷以及应对方案</h1><p><code>this</code>并不是一个很好的设计，因为它的很多使用方法都冲击人的直觉，在使用过程中存在着非常多的坑。下面咱们就来一起看看那些<code>this</code>设计缺陷。</p>
<h2 id="1-嵌套函数中的-this-不会从外层函数中继承"><a href="#1-嵌套函数中的-this-不会从外层函数中继承" class="headerlink" title="1. 嵌套函数中的 this 不会从外层函数中继承"></a>1. 嵌套函数中的 this 不会从外层函数中继承</h2><p>我们还是结合下面这样一段代码来分析下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">&quot; 张三 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;</span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.<span class="title function_">showThis</span>()</span><br></pre></td></tr></table></figure>
<p>我们在这段代码的<code>showThis</code>方法里面添加了一个<code>bar</code>方法，然后接着在<code>showThis</code>函数中调用了<code>bar</code>函数，那么现在的问题是<code>bar</code>函数中的<code>this</code>是什么？</p>
<p>你可能会很自然地觉得，<code>bar</code>中的<code>this</code>应该和其外层<code>showThis</code>函数中的<code>this</code>是一致的，都是指向<code>myObj</code>对象的，这很符合人的直觉。但实际情况却并非如此，执行这段代码后，你会发现函数<code>bar</code>中的<code>this</code>指向的是全局<code>window</code>对象，而函数<code>showThis</code>中的<code>this</code>指向的是<code>myObj</code>对象。这就是 JavaScript 中非常容易让人迷惑的地方之一，也是很多问题的源头。</p>
<p>你可以通过一个小技巧来解决这个问题，比如在<code>showThis</code>函数中声明一个变量<code>self</code>用来保存<code>this</code>，然后在<code>bar</code>函数中使用<code>self</code>，代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">&quot; 张三 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">      self.<span class="property">name</span> = <span class="string">&quot; 李四 &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.<span class="title function_">showThis</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObj.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>
<p>执行这段代码，你可以看到它输出了我们想要的结果，最终<code>myObj</code>中的<code>name</code>属性值变成了“李四”。其实，这个方法的的本质是把<code>this</code>体系转换为了作用域的体系。</p>
<p>其实，你也可以使用 ES6 中的箭头函数来解决这个问题，结合下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  name : <span class="string">&quot; 张三 &quot;</span>, </span><br><span class="line">  <span class="attr">showThis</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">bar</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot; 李四 &quot;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObj.<span class="title function_">showThis</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myObj.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>
<p>执行这段代码，你会发现它也输出了我们想要的结果，也就是箭头函数<code>bar</code>里面的<code>this</code>是指向<code>myObj</code>对象的。这是因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的<code>this</code>取决于它的外部函数。</p>
<p>你现在应该知道了<code>this</code>没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承<code>this</code>，这样会造成很多不符合直觉的代码。要解决这个问题，你可以有两种思路：</p>
<ul>
<li>第一种是把<code>this</code>保存为一个<code>self</code>变量，再利用变量的作用域机制传递给嵌套函数。</li>
<li>第二种是继续使用<code>this</code>，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的<code>this</code>。</li>
</ul>
<h2 id="2-普通函数中的-this-默认指向全局对象-window"><a href="#2-普通函数中的-this-默认指向全局对象-window" class="headerlink" title="2. 普通函数中的 this 默认指向全局对象 window"></a>2. 普通函数中的 this 默认指向全局对象 window</h2><p>在默认情况下调用一个函数，其执行上下文中的<code>this</code>是默认指向全局对象<code>window</code>的。</p>
<p>不过这个设计也是一种缺陷，因为在实际工作中，我们并不希望函数执行上下文中的<code>this</code>默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的<code>this</code>指向某个对象，最好的方式是通过<code>call</code>方法来显示调用。</p>
<p>这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的<code>this</code>值是<code>undefined</code>，这就解决上面的问题了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先，在使用<code>this</code>时，为了避坑，你要谨记以下三点：</p>
<ul>
<li>当函数作为对象的方法调用时，函数中的<code>this</code>就是该对象；</li>
<li>当函数被正常调用时，在严格模式下，<code>this</code>值是<code>undefined</code>，非严格模式下<code>this</code>指向的是全局对象<code>window</code>；</li>
<li>嵌套函数中的<code>this</code>不会继承外层函数的<code>this</code>值。</li>
</ul>
<p>最后，因为箭头函数没有自己的执行上下文，所以箭头函数的<code>this</code>就是它外层函数的<code>this</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="tag">JS执行机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS执行机制——作用域链和闭包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/"
    >JS执行机制——作用域链和闭包</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/" class="article-date">
  <time datetime="2019-11-06T06:51:08.000Z" itemprop="datePublished">2019-11-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>首先我们来看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>当这段代码执行到<code>bar</code>函数内部时，其调用栈的状态图如下所示：</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img1.png" class="" title="执行 bar 函数时的调用栈">

<p>从图中可以看出，全局执行上下文和<code>foo</code>函数的执行上下文中都包含变量<code>myName</code>，那<code>bar</code>函数里面<code>myName</code>的值到底该选择哪个呢？</p>
<p>也许你的第一反应是按照调用栈的顺序来查找变量，查找方式如下：</p>
<ol>
<li>先查找栈顶是否存在<code>myName</code>变量，但是这里没有，所以接着往下查找<code>foo</code>函数中的变量。</li>
<li>在<code>foo</code>函数中查找到了<code>myName</code>变量，这时候就使用<code>foo</code>函数中的<code>myName</code>。</li>
</ol>
<p>如果按照这种方式来查找变量，那么最终执行<code>bar</code>函数打印出来的结果就应该是“极客邦”。但实际情况并非如此，如果你试着执行上述代码，你会发现打印出来的结果是“极客时间”。为什么会是这种情况呢？要解释清楚这个问题，就需要先搞清楚作用域链。</p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为<code>outer</code>。</p>
<p>当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找<code>myName</code>变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在<code>outer</code>所指向的执行上下文中查找。为了直观理解，你可以看下面这张图：</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img2.png" class="" title="带有外部引用的调用栈示意图">

<p>从图中可以看出，<code>bar</code>函数和<code>foo</code>函数的<code>outer</code>都是指向全局上下文的，这也就意味着如果在<code>bar</code>函数或者<code>foo</code>函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。</p>
<p>现在你知道变量是通过作用域链来查找的了，不过还有一个疑问，<code>foo</code>函数调用的<code>bar</code>函数，那为什么<code>bar</code>函数的外部引用是全局执行上下文，而不是<code>foo</code>函数的执行上下文？</p>
<p>要回答这个问题，还需要知道什么是词法作用域。这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。</p>
<h1 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h1><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img3.png" class="" title="词法作用域">

<p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中<code>main</code>函数包含了<code>bar</code>函数，<code>bar</code>函数中包含了<code>foo</code>函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：<code>foo</code>函数作用域—&gt;<code>bar</code>函数作用域—&gt;<code>main</code>函数作用域—&gt; 全局作用域。</p>
<p>了解了词法作用域以及 JavaScript 中的作用域链，我们再回过头来看看上面的那个问题：在开头那段代码中，<code>foo</code>函数调用了<code>bar</code>函数，那为什么<code>bar</code>函数的外部引用是全局执行上下文，而不是<code>foo</code>函数的执行上下文?</p>
<p>这是因为根据词法作用域，<code>foo</code>和<code>bar</code>的上级作用域都是全局作用域，所以如果<code>foo</code>或者<code>bar</code>函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</p>
<h1 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h1><p>在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客世界 &quot;</span></span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="number">100</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> myName = <span class="string">&quot;Chrome 浏览器 &quot;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(test)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">  <span class="keyword">let</span> test = <span class="number">2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> test = <span class="number">3</span></span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>要想得出其执行结果，那接下来我们就得站在作用域链和词法环境的角度来分析下其执行过程。</p>
<p>ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有<code>let</code>或者<code>const</code>声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到<code>bar</code>函数内部的<code>if</code>语句块时，其调用栈的情况如下图所示：</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img4.png" class="" title="块级作用域中是如何查找变量的">

<p>现在是执行到<code>bar</code>函数的<code>if</code>语块之内，需要打印出来变量<code>test</code>，那么就需要查找到<code>test</code>变量的值，其查找过程我已经在上图中使用序号 1、2、3、4、5 标记出来了。</p>
<p>首先是在<code>bar</code>函数的执行上下文中查找，但因为<code>bar</code>函数的执行上下文中没有定义<code>test</code>变量，所以根据词法作用域的规则，下一步就在<code>bar</code>函数的外部作用域中查找，也就是全局作用域。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> test2 = <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> innerBar = &#123;</span><br><span class="line">    <span class="attr">getName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(test1)</span><br><span class="line">      <span class="keyword">return</span> myName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">newName</span>)&#123;</span><br><span class="line">      myName = newName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerBar</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>()</span><br><span class="line">bar.<span class="title function_">setName</span>(<span class="string">&quot; 极客邦 &quot;</span>)</span><br><span class="line">bar.<span class="title function_">getName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure>
<p>首先我们看看当执行到<code>foo</code>函数内部的<code>return innerBar</code>这行代码时调用栈的情况，你可以参考下图：</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img5.png" class="" title="执行到 return bar 时候的调用栈">

<p>从上面的代码可以看出，<code>innerBar</code>是一个对象，包含了<code>getName</code>和<code>setName</code>的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在<code>foo</code>函数内部定义的，并且这两个方法内部都使用了<code>myName</code>和<code>test1</code>两个变量。</p>
<p>根据词法作用域的规则，内部函数<code>getName</code>和<code>setName</code>总是可以访问它们的外部函数<code>foo</code>中的变量，所以当<code>innerBar</code>对象返回给全局变量<code>bar</code>时，虽然<code>foo</code>函数已经执行结束，但是<code>getName</code>和<code>setName</code>函数依然可以使用<code>foo</code>函数中的变量<code>myName</code>和<code>test1</code>。所以当<code>foo</code>函数执行完成之后，其整个调用栈的状态如下图所示：</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img6.png" class="" title="闭包的产生过程">

<p>从上图可以看出，<code>foo</code>函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的<code>setName</code>和<code>getName</code>方法中使用了<code>foo</code>函数内部的变量<code>myName</code>和<code>test1</code>，所以这两个变量依然保存在内存中。这像极了<code>setName</code>和<code>getName</code>方法背的一个专属背包，无论在哪里调用了<code>setName</code>和<code>getName</code>方法，它们都会背着这个<code>foo</code>函数的专属背包。</p>
<p>之所以是专属背包，是因为除了<code>setName</code>和<code>getName</code>函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为<code>foo</code>函数的闭包。</p>
<p>现在我们终于可以给闭包一个正式的定义了。在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是<code>foo</code>，那么这些变量的集合就称为<code>foo</code>函数的闭包。</p>
<p>那这些闭包是如何使用的呢？当执行到<code>bar.setName</code>方法中的<code>myName = &quot;极客邦&quot;</code>这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;<code>foo</code>函数闭包–&gt; 全局执行上下文”的顺序来查找<code>myName</code>变量，你可以参考下面的调用栈状态图：</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img7.png" class="" title="执行 bar 时调用栈状态">

<p>从图中可以看出，<code>setName</code>的执行上下文中没有<code>myName</code>变量，<code>foo</code>函数的闭包中包含了变量<code>myName</code>，所以调用<code>setName</code>时，会修改<code>foo</code>闭包中的<code>myName</code>变量的值。</p>
<p>同样的流程，当调用<code>bar.getName</code>的时候，所访问的变量<code>myName</code>也是位于<code>foo</code>函数闭包中的。</p>
<p>你也可以通过“开发者工具”来看看闭包的情况，打开 Chrome 的“开发者工具”，在<code>bar</code>函数任意地方打上断点，然后刷新页面，可以看到如下内容：</p>
<img src="/2019/11/06/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/img8.png" class="" title="开发者工具中的闭包展示">

<p>从图中可以看出来，当调用<code>bar.getName</code>的时候，右边<code>Scope</code>项就体现出了作用域链的情况：<code>Local</code>就是当前的<code>getName</code>函数的作用域，<code>Closure(foo)</code>是指<code>foo</code>函数的闭包，最下面的<code>Global</code>就是指全局作用域，从<code>Local–&gt;Closure(foo)–&gt;Global</code>就是一个完整的作用域链。</p>
<p>所以说，你以后也可以通过<code>Scope</code>来查看实际代码作用域链的情况，这样调试代码也会比较方便。</p>
<h1 id="闭包是怎么回收的"><a href="#闭包是怎么回收的" class="headerlink" title="闭包是怎么回收的"></a>闭包是怎么回收的</h1><p>如果闭包使用不正确，会很容易造成内存泄漏的，关注闭包是如何回收的能让你正确地使用闭包。</p>
<p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p>
<p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</p>
<p>所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p>
<p>其实闭包是如何回收的还牵涉到了 JavaScript 的垃圾回收机制。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="tag">JS执行机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS执行机制——块级作用域"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/"
    >JS执行机制——块级作用域</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="article-date">
  <time datetime="2019-11-05T08:18:43.000Z" itemprop="datePublished">2019-11-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h1><p>为什么 JavaScript 中会存在变量提升这个特性，而其他语言似乎都没有这个特性呢？要讲清楚这个问题，我们就得先从作用域讲起。</p>
<p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</p>
<p>在 ES6 之前，JS 的作用域只有两种：全局作用域和函数作用域。</p>
<ul>
<li>全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。</li>
<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li>
</ul>
<p>相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个<code>&#123;&#125;</code>都可以被看作是一个块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if 块</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//while 块</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数块</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//for 循环块</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单独一个块</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。你可以看下面这段 C 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char* myname = <span class="string">&quot; 张三 &quot;</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">printf</span>(<span class="string">&quot;%s \n&quot;</span>,myname);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    char* myname = <span class="string">&quot; 李四 &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">showName</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段 C 代码执行后，最终打印出来的是上面全局变量<code>myname</code>的值，之所以这样，是因为 C 语言是支持块级作用域的，所以<code>if </code>块里面定义的变量是不能被<code>if</code>块外面的语句访问到的。</p>
<p>和 Java、C&#x2F;C++ 不同，ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。</p>
<h1 id="变量提升所带来的问题"><a href="#变量提升所带来的问题" class="headerlink" title="变量提升所带来的问题"></a>变量提升所带来的问题</h1><p>由于变量提升作用，使用 JavaScript 来编写和其他语言相同逻辑的代码，都有可能会导致不一样的执行结果。出现这种情况主要有以下两种原因。</p>
<h2 id="1-变量容易在不被察觉的情况下被覆盖掉"><a href="#1-变量容易在不被察觉的情况下被覆盖掉" class="headerlink" title="1. 变量容易在不被察觉的情况下被覆盖掉"></a>1. 变量容易在不被察觉的情况下被覆盖掉</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> myname = <span class="string">&quot; 极客邦 &quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showName</span>()</span><br></pre></td></tr></table></figure>
<p>执行上面这段代码，打印出来的是<code>undefined</code>，而并没有像前面 C 代码那样打印出来“极客时间”的字符串。为什么输出的内容是<code>undefined</code>呢？我们再来分析一下。</p>
<p>最终的调用栈状态如下图所示：</p>
<img src="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/img1.png" class="" title="开始执行 showName 函数时的调用栈">

<p><code>showName</code>函数的执行上下文创建后，JavaScript 引擎便开始执行<code>showName</code>函数内部的代码了。首先执行的是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br></pre></td></tr></table></figure>
<p>执行这段代码需要使用变量<code>myname</code>，结合上面的调用栈状态图，你可以看到这里有两个<code>myname</code>变量：一个在全局执行上下文中，其值是“极客时间”；另外一个在<code>showName</code>函数的执行上下文中，其值是<code>undefined</code>。那么到底该使用哪个呢？</p>
<p>当然是先使用函数执行上下文里面的变量啦。这是因为在函数执行过程中，JavaScript 会优先从当前的执行上下文中查找变量，由于变量提升，当前的执行上下文中就包含了变量<code>myname</code>，而值是<code>undefined</code>，所以获取到的<code>myname</code>的值就是<code>undefined</code>。</p>
<p>这输出的结果和其他大部分支持块级作用域的语言都不一样，比如上面 C 语言输出的就是全局变量，所以这会很容易造成误解。</p>
<h2 id="2-本应销毁的变量没有被销毁"><a href="#2-本应销毁的变量没有被销毁" class="headerlink" title="2. 本应销毁的变量没有被销毁"></a>2. 本应销毁的变量没有被销毁</h2><p>接下来我们再来看下面这段让人误解更大的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>如果你使用 C 语言或者其他的大部分语言实现类似代码，在<code>for</code>循环结束之后，<code>i</code>就已经被销毁了，但是在 JavaScript 代码中，<code>i</code>的值并未被销毁，所以最后打印出来的是 7。</p>
<p>这同样也是由变量提升而导致的，在创建执行上下文阶段，变量<code>i</code>就已经被提升了，所以当<code>for</code>循环结束之后，变量<code>i</code>并没有被销毁。</p>
<p>这依旧和其他支持块级作用域的语言表现是不一致的，所以必然会给一些人造成误解。</p>
<h1 id="ES6-是如何解决变量提升带来的缺陷"><a href="#ES6-是如何解决变量提升带来的缺陷" class="headerlink" title="ES6 是如何解决变量提升带来的缺陷"></a>ES6 是如何解决变量提升带来的缺陷</h1><p>变量提升而带来了一系列问题，为了解决这些问题，ES6 引入了<code>let</code>和<code>const</code>关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="number">6</span></span><br><span class="line">x = <span class="number">7</span></span><br><span class="line">y = <span class="number">9</span> <span class="comment">// 报错，const 声明的变量不可以修改</span></span><br></pre></td></tr></table></figure>
<p>从这段代码你可以看出来，两者之间的区别是，使用<code>let</code>关键字声明的变量是可以被改变的，而使用<code>const</code>声明的变量其值是不可以被改变的。但不管怎样，两者都可以生成块级作用域。</p>
<p>那么接下来，我们就通过实际的例子来分析下，ES6 是如何通过块级作用域来解决上面的问题的？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">varTest</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，有两个地方都定义了变量<code>x</code>，第一个地方在函数块的顶部，第二个地方在<code>if</code>块的内部，由于<code>var</code>的作用范围是整个函数，所以在编译阶段，会生成如下的执行上下文：</p>
<img src="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/img2.png" class="" title="varTest 函数的执行上下文">

<p>从执行上下文的变量环境中可以看出，最终只生成了一个变量<code>x</code>，函数体内所有对<code>x</code>的赋值操作都会直接改变变量环境中的<code>x</code>值。</p>
<p>所以上述代码最后通过<code>console.log(x)</code>输出的是 2，而对于相同逻辑的代码，其他语言最后一步输出的值应该是 1，因为在<code>if</code>块里面的声明不应该影响到块外面的变量。</p>
<p>既然支持块级作用域和不支持块级作用域的代码执行逻辑是不一样的，那么接下来我们就来改造上面的代码，让其支持块级作用域。</p>
<p>这个改造过程其实很简单，只需要把<code>var</code>关键字替换为<code>let</code>关键字，改造后的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">letTest</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行这段代码，其输出结果就和我们的预期是一致的。这是因为<code>let</code>关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把<code>if</code>块中通过<code>let</code>声明的变量存放到变量环境中，这也就意味着在<code>if</code>块通过<code>let</code>声明的关键字，并不会提升到全函数可见。所以在<code>if</code>块之内打印出来的值是 2，跳出语块之后，打印出来的值就是 1 了。这种就非常符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量。</p>
<h1 id="JavaScript-是如何支持块级作用域的"><a href="#JavaScript-是如何支持块级作用域的" class="headerlink" title="JavaScript 是如何支持块级作用域的"></a>JavaScript 是如何支持块级作用域的</h1><p>现在你知道了 JS 可以通过使用<code>let</code>或者<code>const</code>关键字来实现块级作用域，不过你是否有过这样的疑问：“在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”</p>
<p>那么接下来，我们就要站在执行上下文的角度来揭开答案。</p>
<p>你已经知道 JavaScript 引擎是通过变量环境实现函数级作用域的，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(d)</span><br><span class="line">&#125;   </span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>当执行上面这段代码的时候，JavaScript 引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，但是现在，我们引入了<code>let</code>关键字，<code>let</code>关键字会创建块级作用域，那么<code>let</code>关键字是如何影响执行上下文的呢？</p>
<p>接下来我们就来一步步分析上面这段代码的执行流程。</p>
<p>第一步是编译并创建执行上下文，下面是执行上下文示意图：</p>
<img src="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/img3.png" class="" title="刚执行时 foo 函数的执行上下文">

<p>通过上图，我们可以得出以下结论：</p>
<ul>
<li>函数内部通过<code>var</code>声明的变量，在编译阶段全都被存放到变量环境里面了。</li>
<li>通过<code>let</code>声明的变量，在编译阶段会被存放到词法环境（<code>Lexical Environment</code>）中。</li>
<li>在函数的作用域内部，通过<code>let</code>声明的变量并没有被存放到词法环境中。</li>
</ul>
<p>接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中<code>a</code>的值已经被设置成了 1，词法环境中<code>b</code>的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：</p>
<img src="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/img4.png" class="" title="执行 foo 函数内部作用域块时的执行上下文">

<p>从图中可以看出，当进入函数的作用域块时，作用域块中通过<code>let</code>声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量<code>b</code>，在该作用域块内部也声明了变量<code>b</code>，当执行到作用域内部时，它们都是独立的存在。</p>
<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过<code>let</code>或者<code>const</code>声明的变量。</p>
<p>再接下来，当执行到作用域块中的<code>console.log(a)</code>这行代码时，就需要在词法环境和变量环境中查找变量<code>a</code>的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p>
<p>这样一个变量查找过程就完成了，你可以参考下图：</p>
<img src="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/img5.png" class="" title="变量查找过程">

<p>从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了。</p>
<p>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：</p>
<img src="/2019/11/05/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/img6.png" class="" title="作用域执行完成示意图">

<p>通过上面的分析，想必你已经理解了词法环境的结构和工作机制，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="tag">JS执行机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS执行机制——调用栈"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/"
    >JS执行机制——调用栈</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/" class="article-date">
  <time datetime="2019-11-04T09:08:05.000Z" itemprop="datePublished">2019-11-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。</p>
<p>那么哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文？一般说来，有这么三种情况：</p>
<ul>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用<code>eval</code>函数的时候，<code>eval</code>的代码也会被编译，并创建执行上下文。</li>
</ul>
<p>JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。因此要理解调用栈，要先弄明白函数调用和栈结构。</p>
<h1 id="什么是函数调用"><a href="#什么是函数调用" class="headerlink" title="什么是函数调用"></a>什么是函数调用</h1><p>函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span>  a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>()</span><br></pre></td></tr></table></figure>
<p>我们利用这段简单的代码来解释下函数调用的过程。</p>
<p>在执行到函数<code>add()</code>之前，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img2.png" class="" title="全局执行上下文">

<p>从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。</p>
<p>执行上下文准备好之后，便开始执行全局代码，当执行到<code>add</code>这儿时，JavaScript 判断这是一个函数调用，那么将执行以下操作：</p>
<ul>
<li>首先，从全局执行上下文中，取出<code>add</code>函数代码。</li>
<li>其次，对<code>add</code>函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。</li>
<li>最后，执行代码，输出结果。</li>
</ul>
<p>完整流程你可以参考下图：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img3.png" class="" title="函数调用过程">

<p>就这样，当执行到<code>add</code>函数的时候，我们就有了两个执行上下文了——全局执行上下文和<code>add</code>函数的执行上下文。</p>
<p>也就是说在执行 JavaScript 时，可能会存在多个执行上下文，JavaScript 引擎通过一种叫栈的数据结构来管理这些执行上下文。</p>
<h1 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h1><p>关于栈，你可以结合这么一个贴切的例子来理解，一条单车道的单行线，一端被堵住了，而另一端入口处没有任何提示信息，堵住之后就只能后进去的车子先出来，这时这个堵住的单行线就可以被看作是一个栈容器，车子开进单行线的操作叫做入栈，车子倒出去的操作叫做出栈。</p>
<p>在车流量较大的场景中，就会发生反复的入栈、栈满、出栈、空栈和再次入栈，一直循环。</p>
<p>所以，栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足后进先出的特点。</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img4.png" class="" title="栈示意图">

<h1 id="什么是-JavaScript-的调用栈"><a href="#什么是-JavaScript-的调用栈" class="headerlink" title="什么是 JavaScript 的调用栈"></a>什么是 JavaScript 的调用栈</h1><p>JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addAll</span>(<span class="params">b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">10</span></span><br><span class="line">  result = <span class="title function_">add</span>(b, c)</span><br><span class="line">  <span class="keyword">return</span> a + result + d</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">addAll</span>(<span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们就一步步地分析在代码的执行过程中，调用栈的状态变化情况。</p>
<h4 id="第一步，创建全局上下文，并将其压入栈底。"><a href="#第一步，创建全局上下文，并将其压入栈底。" class="headerlink" title="第一步，创建全局上下文，并将其压入栈底。"></a>第一步，创建全局上下文，并将其压入栈底。</h4><img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img5.png" class="" title="全局执行上下文压栈">

<p>从图中你也可以看出，变量<code>a</code>、函数<code>add</code>和<code>addAll</code>都保存到了全局上下文的变量环境对象中。</p>
<p>全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码了。首先会执行<code>a=2</code>的赋值操作，执行该语句会将全局上下文变量环境中<code>a</code>的值设置为 2。设置后的全局上下文的状态如下图所示：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img6.png" class="" title="赋值操作改变执行上下文中的值">

<h4 id="第二步是调用-addAll-函数。"><a href="#第二步是调用-addAll-函数。" class="headerlink" title="第二步是调用 addAll 函数。"></a>第二步是调用 addAll 函数。</h4><p>当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img7.png" class="" title="执行 addAll 函数时的调用栈">

<p><code>addAll</code>函数的执行上下文创建好之后，便进入了函数代码的执行阶段了，这里先执行的是<code>d=10</code>的赋值操作，执行语句会将<code>addAll</code>函数执行上下文中的<code>d</code>由<code>undefined</code>变成了 10。</p>
<p>然后接着往下执行。</p>
<h4 id="第三步，当执行到-add-函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈。"><a href="#第三步，当执行到-add-函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈。" class="headerlink" title="第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈。"></a>第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈。</h4><img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img8.png" class="" title="执行 add 函数时的调用栈">

<p>当<code>add</code>函数返回时，该函数的执行上下文就会从栈顶弹出，并将<code>result</code>的值设置为<code>add</code>函数的返回值，也就是 9。如下图所示：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img9.png" class="" title="add 函数执行结束时的调用栈">

<p>紧接着<code>addAll</code>执行最后一个相加操作后并返回，<code>addAll</code>的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img10.png" class="" title="addAll 函数执行结束时的调用栈">

<p>至此，整个 JavaScript 流程执行结束了。</p>
<p>现在你应该知道了调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。</p>
<h1 id="在开发中，如何利用好调用栈"><a href="#在开发中，如何利用好调用栈" class="headerlink" title="在开发中，如何利用好调用栈"></a>在开发中，如何利用好调用栈</h1><h2 id="1-如何利用浏览器查看调用栈的信息"><a href="#1-如何利用浏览器查看调用栈的信息" class="headerlink" title="1. 如何利用浏览器查看调用栈的信息"></a>1. 如何利用浏览器查看调用栈的信息</h2><p>当你执行一段复杂的代码时，你可能很难从代码文件中分析其调用关系，这时候你可以在你想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。</p>
<p>这么说可能有点抽象，这里我们拿上面的那段代码做个演示，打开开发者工具，点击<code>Source</code>标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。你可以看到执行到<code>add</code>函数时，执行流程就暂停了，这时可以通过右边<code>call stack</code>来查看当前的调用栈的情况，如下图：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img11.png" class="" title="addAll 查看函数调用关系">

<p>从图中可以看出，右边的<code>call stack</code>下面显示出来了函数的调用关系：栈的最底部是<code>anonymous</code>，也就是全局的函数入口；中间是<code>addAll</code>函数；顶部是<code>add</code>函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。</p>
<p>除了通过断点来查看调用栈，你还可以使用<code>console.trace()</code>来输出当前的函数调用关系，比如在示例代码中的<code>add</code>函数里面加上了<code>console.trace()</code>，你就可以看到控制台输出的结果，如下图：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img12.png" class="" title="使用 trace 函数输出当前调用栈信息">

<h2 id="2-栈溢出（Stack-Overflow）"><a href="#2-栈溢出（Stack-Overflow）" class="headerlink" title="2. 栈溢出（Stack Overflow）"></a>2. 栈溢出（Stack Overflow）</h2><p>现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。</p>
<p>特别是在写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">division</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">division</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">division</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>当执行时，就会抛出栈溢出错误，如下图：</p>
<img src="/2019/11/04/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E8%B0%83%E7%94%A8%E6%A0%88/img13.png" class="" title="使用 trace 函数输出当前调用栈信息">

<p>从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（<code>Maximum call stack size exceeded</code>）。</p>
<p>那为什么会出现这个问题呢？这是因为当 JavaScript 引擎开始执行这段代码时，它首先调用函数<code>division</code>，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。</p>
<p>理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。</li>
<li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。</li>
<li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。</li>
<li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="tag">JS执行机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/JS执行机制——执行上下文"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"
    >JS执行机制——执行上下文</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/" class="article-date">
  <time datetime="2019-11-03T03:43:26.000Z" itemprop="datePublished">2019-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h1><p>我们先来看看什么是 JavaScript 中的声明和赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这段代码你可以把它看成是两行代码组成的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname <span class="comment">// 声明部分</span></span><br><span class="line">myname = <span class="string">&#x27;张三&#x27;</span> <span class="comment">// 赋值部分</span></span><br></pre></td></tr></table></figure>
<p>上面是变量的声明和赋值，下面是函数的声明和赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个函数<code>foo</code>是一个完整的函数声明，也就是说没有涉及到赋值操作；第二个函数是先声明变量<code>bar</code>，再把<code>function()&#123;console.log(&#39;bar&#39;)&#125;</code>赋值给<code>bar</code>。</p>
<img src="/2019/11/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/img2.png" class="" title="函数的声明和赋值">

<p>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 变量提升部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 把变量 myname 提升到开头，</span></span><br><span class="line"><span class="comment">// 同时给 myname 赋值为 undefined</span></span><br><span class="line"><span class="keyword">var</span> myname = <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 把函数 showName 提升到开头</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;showName 被调用&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 可执行代码部分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">showName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname)</span><br><span class="line"><span class="comment">// 去掉 var 声明部分，保留赋值语句</span></span><br><span class="line">myname = <span class="string">&#x27;极客时间&#x27;</span></span><br></pre></td></tr></table></figure>
<p>为了模拟变量提升的效果，对代码做以下调整，如下图：</p>
<img src="/2019/11/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/img3.png" class="" title="模拟变量提升示意图">

<p>通过这段模拟的变量提升代码，明白了可以在定义之前使用变量或者函数的原因：函数和变量在执行之前都提升到了代码开头。</p>
<h1 id="JavaScript-代码的执行流程"><a href="#JavaScript-代码的执行流程" class="headerlink" title="JavaScript 代码的执行流程"></a>JavaScript 代码的执行流程</h1><p>“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面。但这并不准确。实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。大致流程：</p>
<img src="/2019/11/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/img4.png" class="" title="JavaScript 的执行流程图">

<h2 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1. 编译阶段"></a>1. 编译阶段</h2><p>那么编译阶段和变量提升存在什么关系呢？</p>
<p>为了搞清楚这个问题，我们还是回过头来看上面那段模拟变量提升的代码，为了方便，可以把这段代码分成两部分。</p>
<p>第一部分：变量提升部分的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数 showName 被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二部分：执行部分的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname)</span><br><span class="line">myname = <span class="string">&#x27;极客时间&#x27;</span></span><br></pre></td></tr></table></figure>
<p>下面我们就可以把 JavaScript 的执行流程细化，如下图所示：</p>
<img src="/2019/11/03/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/img5.png" class="" title="JavaScript 执行流程细化图">

<p>从上图可以看出，输入一段代码，经过编译后，会生成两部分内容：执行上下文（<code>Execution context</code>）和可执行代码。</p>
<p>执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如<code>this</code>、变量、对象以及函数等。</p>
<p>在执行上下文中存在一个变量环境的对象（<code>Viriable Environment</code>），该对象中保存了变量提升的内容，比如上面代码中的变量<code>myname</code>和函数<code>showName</code>，都保存在该对象中。</p>
<p>你可以简单地把变量环境对象看成是如下结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">VariableEnvironment</span>:</span><br><span class="line">    myname -&gt; <span class="literal">undefined</span>, </span><br><span class="line">    showName -&gt; <span class="keyword">function</span> : &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(myname)</span><br></pre></td></tr></table></figure>
<p>了解完变量环境对象的结构后，接下来，我们再结合下面这段代码来分析下是如何生成变量环境对象的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;极客时间&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数 showName 被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以一行一行来分析上述代码：</p>
<ul>
<li>第 1 行和第 2 行，由于这两行代码不是声明操作，所以 JavaScript 引擎不会做任何处理；</li>
<li>第 3 行，由于这行是经过<code>var</code>声明的，因此 JavaScript 引擎将在环境对象中创建一个名为<code>myname</code>的属性，并使用<code>undefined</code>对其初始化；</li>
<li>第 4 行，JavaScript 引擎发现了一个通过<code>function</code>定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个<code>showName</code>的属性，然后将该属性值指向堆中函数的位置。</li>
</ul>
<p>这样就生成了变量环境对象。接下来 JavaScript 引擎会把声明以外的代码编译为字节码。</p>
<p>现在有了执行上下文和可执行代码了，那么接下来就到了执行阶段了。</p>
<h2 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2. 执行阶段"></a>2. 执行阶段</h2><p>JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。下面我们就来一行一行分析下这个执行过程：</p>
<ul>
<li>当执行到<code>showName</code>函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数<code>showName</code>被执行”结果。</li>
<li>接下来打印<code>“myname”</code>信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在<code>myname</code>变量，并且其值为 <code>undefined</code>，所以这时候就输出<code>undefined</code>。</li>
<li>接下来执行第 3 行，把“极客时间”赋给<code>myname</code>变量，赋值后变量环境中的<code>myname</code>属性值改变为“极客时间”，变量环境如下所示：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">VariableEnvironment</span>:</span><br><span class="line">    myname -&gt; <span class="string">&quot; 极客时间 &quot;</span>, </span><br><span class="line">    showName -&gt;<span class="keyword">function</span> : &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(myname)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等。</p>
<h1 id="代码中出现相同的变量或者函数怎么办？"><a href="#代码中出现相同的变量或者函数怎么办？" class="headerlink" title="代码中出现相同的变量或者函数怎么办？"></a>代码中出现相同的变量或者函数怎么办？</h1><p>现在你已经知道了，在执行一段 JavaScript 代码之前，会编译代码，并将代码中的函数和变量保存到执行上下文的变量环境中，那么如果代码中出现了重名的函数或者变量，JavaScript 引擎会如何处理？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showName</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showName</span>(); </span><br></pre></td></tr></table></figure>
<p>完整执行流程：</p>
<ul>
<li>首先是编译阶段。遇到了第一个<code>showName</code>函数，会将该函数体存放到变量环境中。接下来是第二个<code>showName</code>函数，继续存放至变量环境中，但是变量环境中已经存在一个<code>showName</code>函数了，此时，第二个<code>showName</code>函数会将第一个<code>showName</code>函数覆盖掉。这样变量环境中就只存在第二个<code>showName</code>函数了。</li>
<li>接下来是执行阶段。先执行第一个<code>showName</code>函数，但由于是从变量环境中查找<code>showName</code>函数，而变量环境中只保存了第二个<code>showName</code>函数，所以最终调用的是第二个函数，打印的内容是“李四”。第二次执行<code>showName</code>函数也是走同样的流程，所以输出的结果也是“李四”。</li>
</ul>
<p>综上所述，一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。</li>
<li>在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为<code>undefined</code>；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。</li>
<li>如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" rel="tag">JS执行机制</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/浏览器工作原理——WebComponent"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/23/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94WebComponent/"
    >浏览器工作原理——WebComponent</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/10/23/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94WebComponent/" class="article-date">
  <time datetime="2019-10-23T06:21:51.000Z" itemprop="datePublished">2019-10-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>WebComponent是一套技术的组合，能提供给开发者组件化开发的能力。</p>
<p>那什么是组件化呢？</p>
<p>其实组件化并没有一个明确的定义，不过这里我们可以使用 10 个字来形容什么是组件化，那就是：对内高内聚，对外低耦合。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。</p>
<p>可以说，程序员对组件化开发有着天生的需求，因为一个稍微复杂点的项目，就涉及到多人协作开发的问题，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。</p>
<p>使用组件化能带来很多优势，所以很多语言天生就对组件化提供了很好的支持，比如 C&#x2F;C++ 就可以很好地将功能封装成模块，无论是业务逻辑，还是基础功能，抑或是 UI，都能很好地将其组合在一起，实现组件内部的高度内聚、组件之间的低耦合。</p>
<p>大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。</p>
<p>JavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。</p>
<p>既然 JavaScript 可以很好地实现组件化，那么我们所谈论的 WebComponent 到底又是什么呢？</p>
<h1 id="阻碍前端组件化的因素"><a href="#阻碍前端组件化的因素" class="headerlink" title="阻碍前端组件化的因素"></a>阻碍前端组件化的因素</h1><p>在前端虽然 HTML、CSS 和 JavaScript 是强大的开发语言，但是在大型项目中维护起来会比较困难，如果在页面中嵌入第三方内容时，还需要确保第三方的内容样式不会影响到当前内容，同样也要确保当前的 DOM 不会影响到第三方的内容。</p>
<p>所以要聊 WebComponent，得先看看 HTML 和 CSS 是如何阻碍前端组件化的，这里我们就通过下面这样一个简单的例子来分析下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: brown;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: cornsilk</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: blue</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>time.geekbang<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这两段代码分别实现了自己<code>p</code>标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的<code>p</code>标签的，之所以会这样，是因为 CSS 是影响全局的。</p>
<p>渲染引擎会将所有的 CSS 内容解析为 CSSOM，在生成布局树的时候，会在 CSSOM 中为布局树中的元素查找样式，所以有两个相同标签最终所显示出来的效果是一样的，渲染引擎是不能为它们分别单独设置样式的。</p>
<p>除了 CSS 的全局属性会阻碍组件化，DOM 也是阻碍组件化的一个因素，因为在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了。</p>
<h1 id="WebComponent-组件化开发"><a href="#WebComponent-组件化开发" class="headerlink" title="WebComponent 组件化开发"></a>WebComponent 组件化开发</h1><p>现在我们了解了CSS 和 DOM 是阻碍组件化的两个因素，那要怎么解决呢？</p>
<p>WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。</p>
<p>了解了这些，下面我们就结合具体代码来看看 WebComponent 是怎么实现组件化的。</p>
<p>WebComponent 是一套技术的组合，具体涉及到了<code>Custom elements</code>（自定义元素）、<code>Shadow DOM</code>（影子 DOM）和<code>HTML templates</code>（HTML 模板）。</p>
<p>下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    一：定义模板</span></span><br><span class="line"><span class="comment">    二：定义内部 CSS 样式</span></span><br><span class="line"><span class="comment">    三：定义 JavaScript 行为</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;geekbang-t&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: brown;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: cornsilk</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: bisque;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">3px</span> solid chocolate;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>time.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>time1.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inner log&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">class</span> <span class="title class_">GeekBang</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">super</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取组件模板</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> content = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#geekbang-t&#x27;</span>).<span class="property">content</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建影子 DOM 节点</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> shadowDOM = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 将模板添加到影子 DOM 上</span></span></span><br><span class="line"><span class="language-javascript">        shadowDOM.<span class="title function_">appendChild</span>(content.<span class="title function_">cloneNode</span>(<span class="literal">true</span>))</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    customElements.<span class="title function_">define</span>(<span class="string">&#x27;geek-bang&#x27;</span>, <span class="title class_">GeekBang</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">geek-bang</span>&gt;</span><span class="tag">&lt;/<span class="name">geek-bang</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>time.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>time1.geekbang.org<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">geek-bang</span>&gt;</span><span class="tag">&lt;/<span class="name">geek-bang</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>详细观察上面这段代码，我们可以得出：要使用 WebComponent，通常要实现下面三个步骤。</p>
<p>首先，使用<code>template</code>属性来创建模板。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的<code>template</code>节点不会出现在布局树中，所以我们可以使用<code>template</code>来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。</p>
<p>其次，我们需要创建一个<code>GeekBang</code>的类。在该类的构造函数中要完成三件事：</p>
<ul>
<li>查找模板内容；</li>
<li>创建影子 DOM；</li>
<li>再将模板添加到影子 DOM 上。</li>
</ul>
<p>上面最难理解的是影子 DOM，其实影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。</p>
<p>总之，通过影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用<code>customElements.define</code>来自定义元素了（可参考上述代码定义元素的方式）。</p>
<p>最后，就很简单了，可以像正常使用 HTML 元素一样使用该元素，如上述代码中的<code>&lt;geek-bang&gt;&lt;/geek-bang&gt;</code>。</p>
<p>上述代码最终渲染出来的页面，如下图所示：</p>
<img src="/2019/10/23/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94WebComponent/img1.png" class="" title="使用影子 DOM 的输出效果">

<p>从图中我们可以看出，影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用<code>document.getElementsByTagName(&#39;div&#39;)</code>来查找所有<code>div</code>元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。</p>
<p>通过影子 DOM 可以隔离 CSS 和 DOM，不过需要注意一点，影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。</p>
<h1 id="浏览器如何实现影子-DOM"><a href="#浏览器如何实现影子-DOM" class="headerlink" title="浏览器如何实现影子 DOM"></a>浏览器如何实现影子 DOM</h1><p>WebComponent 整体知识点不多，内容也不复杂，核心就是影子 DOM。影子 DOM 的作用主要有以下两点：</p>
<ul>
<li>影子 DOM 中的元素对于整个网页是不可见的；</li>
<li>影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。</li>
</ul>
<p>那么浏览器是如何实现影子 DOM 的呢？下面我们就来分析下，如下图：</p>
<img src="/2019/10/23/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94WebComponent/img1.png" class="" title="影子 DOM 示意图">

<p>该图是上面那段示例代码对应的 DOM 结构图，从图中可以看出，我们使用了两次<code>geek-bang</code>属性，那么就会生成两个影子 DOM，并且每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。</p>
<p>浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断<code>geek-bang</code>属性下面的<code>shadow-root</code>元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过<code>shadow-root</code>元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。</p>
<p>另外，当生成布局树的时候，渲染引擎也会判断<code>geek-bang</code>属性下面的<code>shadow-root</code>元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="tag">浏览器工作原理与实践</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/浏览器工作原理——虚拟DOM"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/21/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9FDOM/"
    >浏览器工作原理——虚拟DOM</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/10/21/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9FDOM/" class="article-date">
  <time datetime="2019-10-21T07:12:34.000Z" itemprop="datePublished">2019-10-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="DOM-的缺陷"><a href="#DOM-的缺陷" class="headerlink" title="DOM 的缺陷"></a>DOM 的缺陷</h1><p>通过 JavaScript 操纵 DOM 是会影响到整个渲染流水线的。另外，DOM 还提供了一组 JavaScript 接口用来遍历或者修改节点，这套接口包含了<code>getElementById、removeChild、appendChild</code>等方法。</p>
<p>比如，我们可以调用<code>document.body.appendChild(node)</code>往<code>body</code>节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将<code>node</code>节点添加到<code>body</code>节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。</p>
<p>当然，对于简单的页面来说，其 DOM 结构还是比较简单的，所以以上这些操作 DOM 的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM 渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。</p>
<p>所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了。</p>
<h1 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h1><p>在谈论什么是虚拟 DOM 之前，我们先来看看虚拟 DOM 到底要解决哪些事情。</p>
<ul>
<li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li>
<li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li>
<li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li>
</ul>
<p>基于以上三点，我们再来看看什么是虚拟 DOM。</p>
<img src="/2019/10/21/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9FDOM/img1.png" class="" title="虚拟 DOM 执行流程">

<p>该图是结合 React 流程画的一张虚拟 DOM 执行流程图，下面我们就结合这张图来分析下虚拟 DOM 到底怎么运行的。</p>
<ul>
<li>创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li>
<li>更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。</li>
</ul>
<p>既然聊到虚拟 DOM 的更新，那我们就不得不聊聊最新的<code>React Fiber</code>更新机制。通过上图我们知道，当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。</p>
<p>这里我们重点关注下比较过程，最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其核心算法是<code>reconciliation</code>。通常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React 团队重写了<code>reconciliation</code>算法，新的算法称为<code>Fiber reconciler</code>，之前老的算法称为<code>Stack reconciler</code>。</p>
<p>其实协程的另外一个称呼就是<code>Fiber</code>，所以在这里我们可以把<code>Fiber</code>和协程关联起来，那么所谓的<code>Fiber reconciler</code>相信你也很清楚了，就是在执行算法的过程中出让主线程，这样就解决了<code>Stack reconciler</code>函数占用时间过久的问题。</p>
<p>了解完虚拟 DOM 的大致执行流程，你应该也就知道为何需要虚拟 DOM 了。不过以上都从单纯的技术视角来分析虚拟 DOM 的，那接下来我们再从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM。</p>
<h2 id="1-双缓存"><a href="#1-双缓存" class="headerlink" title="1. 双缓存"></a>1. 双缓存</h2><p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p>
<p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p>
<p>在这里，你可以把虚拟 DOM 看成是 DOM 的一个<code>buffer</code>，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</p>
<h2 id="2-MVC-模式"><a href="#2-MVC-模式" class="headerlink" title="2. MVC 模式"></a>2. MVC 模式</h2><p>到这里我们了解了虚拟 DOM 是一种类似双缓存的实现。不过如果站在技术角度来理解虚拟缓存，依然不能全面理解其含义。那么接下来我们再来看看虚拟 DOM 在 MVC 模式中所扮演的角色。</p>
<p>在各大设计模式当中，MVC 是一个非常重要且应用广泛的模式，因为它能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。</p>
<p>关于 MVC 的基础结构，你可以先参考下图：</p>
<img src="/2019/10/21/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9FDOM/img2.png" class="" title="MVC 基础结构">

<p>通过上图你可以发现，MVC 的整体结构比较简单，由模型、视图和控制器组成，其核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。</p>
<p>所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：</p>
<img src="/2019/10/21/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9FDOM/img3.png" class="" title="基于 React 和 Redux 构建 MVC 模型">

<p>在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</p>
<ul>
<li>图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li>
<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>
<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li>
<li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li>
<li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li>
<li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先我们分析了直接操作 DOM 会触发渲染流水线的一系列反应，如果对 DOM 操作不当的话甚至还会触发强制同步布局和布局抖动的问题，这也是我们在操作 DOM 时需要非常小心谨慎的原因。</p>
<p>在此分析的基础上，我们介绍了虚拟 DOM 是怎么解决直接操作 DOM 所带来的问题以及 React Fiber 更新机制。</p>
<p>要聊前端框架，就绕不开设计模式，所以接下来我们又从双缓存和 MVC 角度分析了虚拟 DOM。双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟 DOM 就是双缓存思想的一种体现。而基于 MVC 的设计思想也广泛地渗透到各种场合，并且基于 MVC 又衍生出了很多其他模式（如 MVP、MVVM 等），不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。站在 MVC 视角来理解虚拟 DOM 能让你看到更为“广阔的世界”。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="tag">浏览器工作原理与实践</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-vue/vuex 核心概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/18/vue/vuex%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"
    >vuex 核心概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/10/18/vue/vuex%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2019-10-18T11:09:12.000Z" itemprop="datePublished">2019-10-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/vue/">vue</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="State"><a href="#State" class="headerlink" title="State"></a>State</h1><h2 id="单一状态树"><a href="#单一状态树" class="headerlink" title="单一状态树"></a>单一状态树</h2><p>Vuex使用单一状态树——用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源”而存在。这也意味着，每个应用将仅仅包含一个<code>store</code>实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>
<h2 id="在Vue组件中获得Vuex状态"><a href="#在Vue组件中获得Vuex状态" class="headerlink" title="在Vue组件中获得Vuex状态"></a>在Vue组件中获得Vuex状态</h2><p>由于Vuex的状态存储是响应式的，从<code>store</code>实例中读取状态最简单的方法就是在计算属性中返回某个状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Counter 组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> store.<span class="property">state</span>.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当<code>store.state.count</code>变化的时候, 都会重新求取计算属性，并且触发更新相关联的DOM。<br>然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用<code>state</code>的组件中需要频繁地导入，并且在测试组件时需要模拟状态。<br>Vuex通过<code>store</code>选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用<code>Vue.use(Vuex)</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">Counter</span> &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过在根实例中注册<code>store</code>选项，该<code>store</code>实例会注入到根组件下的所有子组件中，且子组件能通过<code>this.$store</code>访问到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Counter</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h2><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用<code>mapState</code>辅助函数帮助我们生成计算属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: <span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> + <span class="variable language_">this</span>.<span class="property">localCount</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当映射的计算属性的名称与<code>state</code>的子节点名称相同时，我们也可以给<code>mapState</code>传一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: <span class="title function_">mapState</span>([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h2><p><code>mapState</code>函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给<code>computed</code>属性。但是自从有了对象展开运算符，我们可以极大地简化写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  localComputed () &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h1><p>有时候我们需要从<code>store</code>中的<code>state</code>中派生出一些状态，例如对列表进行过滤并计数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">todos</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">done</span>).<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。<br>Vuex允许我们在<code>store</code>中定义<code>getter</code>（可以认为是<code>store</code>的计算属性）。就像计算属性一样，<code>getter</code>的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><code>Getter</code>接受<code>state</code>作为其第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">todos</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">done</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h2><p><code>Getter</code>会暴露为<code>store.getters</code>对象，你可以以属性的形式访问这些值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">getters</span>.<span class="property">doneTodos</span> <span class="comment">// -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]</span></span><br></pre></td></tr></table></figure>
<p><code>Getter</code>也可以接受其他<code>getter</code>作为第二个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">doneTodosCount</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.<span class="property">doneTodos</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">getters</span>.<span class="property">doneTodosCount</span> <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>我们可以很容易地在任何组件中使用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">doneTodosCount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>getter</code>在通过属性访问时是作为Vue的响应式系统的一部分缓存其中的。</p>
<h2 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h2><p>你也可以通过让<code>getter</code>返回一个函数，来实现给<code>getter</code>传参。在你对<code>store</code>里的数组进行查询时非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">getters</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">getTodoById</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">todos</span>.<span class="title function_">find</span>(<span class="function"><span class="params">todo</span> =&gt;</span> todo.<span class="property">id</span> === id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="property">getters</span>.<span class="title function_">getTodoById</span>(<span class="number">2</span>) <span class="comment">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>getter</code>在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>
<h2 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h2><p><code>mapGetters</code>辅助函数仅仅是将<code>store</code>中的<code>getter</code>映射到局部计算属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想将一个<code>getter</code>属性另取一个名字，使用对象形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mapGetters</span>(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  <span class="attr">doneCount</span>: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h1><p>更改Vuex的<code>store</code>中的状态的唯一方法是提交<code>mutation</code>。Vuex中的<code>mutation</code>非常类似于事件：每个<code>mutation</code>都有一个字符串的事件类型(<code>type</code>)和一个回调函数 (<code>handler</code>)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受<code>state</code>作为第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你不能直接调用一个<code>mutation handler</code>。这个选项更像是事件注册：“当触发一个类型为<code>increment</code>的<code>mutation</code>时，调用此函数。”要唤醒一个<code>mutation handler</code>，你需要以相应的<code>type</code>调用<code>store.commit</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h2><p>你可以向<code>store.commit</code>传入额外的参数，即<code>mutation</code>的载荷（<code>payload</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.<span class="property">count</span> += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的<code>mutation</code>会更易读：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.<span class="property">count</span> += payload.<span class="property">amount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h2><p>提交<code>mutation</code>的另一种方式是直接使用包含<code>type</code>属性的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当使用对象风格的提交方式，整个对象都作为载荷传给<code>mutation</code>函数，因此<code>handler</code>保持不变：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  increment (state, payload) &#123;</span><br><span class="line">    state.<span class="property">count</span> += payload.<span class="property">amount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mutation需遵守Vue的响应规则"><a href="#Mutation需遵守Vue的响应规则" class="headerlink" title="Mutation需遵守Vue的响应规则"></a>Mutation需遵守Vue的响应规则</h2><p>既然Vuex的<code>store</code>中的状态是响应式的，那么当我们变更状态时，监视状态的Vue组件也会自动更新。这也意味着Vuex中的<code>mutation</code>也需要与使用Vue一样遵守一些注意事项：</p>
<ol>
<li>最好提前在你的<code>store</code>中初始化好所有所需属性。</li>
<li>当需要在对象上添加新属性时，你应该使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者以新对象替换老对象。例如，对象展开运算符我们可以这样写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.<span class="property">obj</span> = &#123; ...state.<span class="property">obj</span>, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用常量替代Mutation事件类型"><a href="#使用常量替代Mutation事件类型" class="headerlink" title="使用常量替代Mutation事件类型"></a>使用常量替代Mutation事件类型</h2><p>使用常量替代<code>mutation</code>事件类型在各种Flux实现中是很常见的模式。这样可以使<code>linter</code>之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 <code>app</code>包含的<code>mutation</code>一目了然：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">SOME_MUTATION</span> = <span class="string">&#x27;SOME_MUTATION&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">SOME_MUTATION</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./mutation-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [<span class="variable constant_">SOME_MUTATION</span>] (state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Mutation必须是同步函数"><a href="#Mutation必须是同步函数" class="headerlink" title="Mutation必须是同步函数"></a>Mutation必须是同步函数</h2><p>一条重要的原则就是要记住<code>mutation</code>必须是同步函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">  someMutation (state) &#123;</span><br><span class="line">    api.<span class="title function_">callAsyncMethod</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在想象，我们正在debug一个app并且观察<code>devtool</code>中的<code>mutation</code>日志。每一条<code>mutation</code>被记录，<code>devtools</code>都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中<code>mutation</code>中的异步函数中的回调让这不可能完成：因为当<code>mutation</code>触发的时候，回调函数还没有被调用，<code>devtools</code>不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>
<h2 id="在组件中提交Mutation"><a href="#在组件中提交Mutation" class="headerlink" title="在组件中提交Mutation"></a>在组件中提交Mutation</h2><p>你可以在组件中使用<code>this.$store.commit(&#39;xxx&#39;)</code>提交<code>mutation</code>，或者使用<code>mapMutations</code>辅助函数将组件中的<code>methods</code>映射为<code>store.commit</code>调用（需要在根节点注入<code>store</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapMutations</span>([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>在<code>mutation</code>中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的<code>mutation</code>来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在Vuex中，<code>mutation</code>都是同步事务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"><span class="comment">// 任何由 &quot;increment&quot; 导致的状态变更都应该在此刻完成。</span></span><br></pre></td></tr></table></figure>
<h1 id="Action-1"><a href="#Action-1" class="headerlink" title="Action"></a>Action</h1><p>Action类似于<code>mutation</code>，不同在于：</p>
<ul>
<li>Action提交的是<code>mutation</code>，而不是直接变更状态。</li>
<li>Action可以包含任意异步操作。</li>
</ul>
<p>让我们来注册一个简单的 action：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Action函数接受一个与<code>store</code>实例具有相同方法和属性的<code>context</code>对象，因此你可以调用 <code>context.commit</code> 提交一个<code>mutation</code>，或者通过<code>context.state</code>和<code>context.getters</code>来获取 <code>state</code>和<code>getters</code>。<br>实践中，我们会经常用到ES2015的参数解构来简化代码（特别是我们需要调用<code>commit</code>很多次的时候）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  increment (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分发Action"><a href="#分发Action" class="headerlink" title="分发Action"></a>分发Action</h2><p>Action通过<code>store.dispatch</code>方法触发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>乍一眼看上去感觉多此一举，我们直接分发<code>mutation</code>岂不更方便？实际上并非如此，还记得<code>mutation</code>必须同步执行这个限制么？Action就不受约束！我们可以在<code>action</code>内部执行异步操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actions支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;incrementAsync&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来看一个更加实际的购物车示例，涉及到调用异步API和分发多重<code>mutation</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  checkout (&#123; commit, state &#125;, products) &#123;</span><br><span class="line">    <span class="comment">// 把当前购物车的物品备份起来</span></span><br><span class="line">    <span class="keyword">const</span> savedCartItems = [...state.<span class="property">cart</span>.<span class="property">added</span>]</span><br><span class="line">    <span class="comment">// 发出结账请求，然后乐观地清空购物车</span></span><br><span class="line">    <span class="title function_">commit</span>(types.<span class="property">CHECKOUT_REQUEST</span>)</span><br><span class="line">    <span class="comment">// 购物 API 接受一个成功回调和一个失败回调</span></span><br><span class="line">    shop.<span class="title function_">buyProducts</span>(</span><br><span class="line">      products,</span><br><span class="line">      <span class="comment">// 成功操作</span></span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">commit</span>(types.<span class="property">CHECKOUT_SUCCESS</span>),</span><br><span class="line">      <span class="comment">// 失败操作</span></span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">commit</span>(types.<span class="property">CHECKOUT_FAILURE</span>, savedCartItems)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们正在进行一系列的异步操作，并且通过提交<code>mutation</code>来记录<code>action</code>产生的副作用（即状态变更）。</p>
<h2 id="在组件中分发Action"><a href="#在组件中分发Action" class="headerlink" title="在组件中分发Action"></a>在组件中分发Action</h2><p>你在组件中使用<code>this.$store.dispatch(&#39;xxx&#39;)</code>分发<code>action</code>，或者使用<code>mapActions</code>辅助函数将组件的<code>methods</code>映射为<code>store.dispatch</code> 调用（需要先在根节点注入<code>store</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapActions</span>([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;</span><br><span class="line">      <span class="attr">add</span>: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合Action"><a href="#组合Action" class="headerlink" title="组合Action"></a>组合Action</h2><p>Action通常是异步的，那么如何知道<code>action</code>什么时候结束呢？更重要的是，我们如何才能组合多个<code>action</code>，以处理更加复杂的异步流程？<br>首先，你需要明白<code>store.dispatch</code>可以处理被触发的<code>action</code>的处理函数返回的<code>Promise</code>，并且<code>store.dispatch</code>仍旧返回<code>Promise</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在另外一个<code>action</code>中也可以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;someOtherMutation&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果我们利用<code>async / await</code>，我们可以如下组合<code>action</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;gotData&#x27;</span>, <span class="keyword">await</span> <span class="title function_">getData</span>())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">dispatch</span>(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&#x27;gotOtherData&#x27;</span>, <span class="keyword">await</span> <span class="title function_">getOtherData</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个<code>action</code>函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
</blockquote>
<h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，<code>store</code>对象就有可能变得相当臃肿。<br>为了解决以上问题，Vuex允许我们将<code>store</code>分割成模块。每个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getter</code>、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.<span class="property">state</span>.<span class="property">a</span> <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.<span class="property">state</span>.<span class="property">b</span> <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>
<h2 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h2><p>对于模块内部的<code>mutation</code>和<code>getter</code>，接收的第一个参数是模块的局部状态对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，对于模块内部的<code>action</code>，局部状态通过<code>context.state</code>暴露出来，根节点状态则为<code>context.rootState</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.<span class="property">count</span> + rootState.<span class="property">count</span>) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于模块内部的<code>getter</code>，根节点状态会作为第三个参数暴露出来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> + rootState.<span class="property">count</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>默认情况下，模块内部的<code>action</code>、<code>mutation</code>和<code>getter</code>是注册在全局命名空间的——这样使得多个模块能够对同一<code>mutation</code>或<code>action</code>作出响应。<br>如果希望你的模块具有更高的封装度和复用性，你可以通过添加<code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有<code>getter</code>、<code>action</code>及<code>mutation</code>都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">account</span>: &#123;</span><br><span class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      <span class="attr">state</span>: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      <span class="attr">getters</span>: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">actions</span>: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">mutations</span>: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      <span class="attr">modules</span>: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        <span class="attr">myPage</span>: &#123;</span><br><span class="line">          <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">          <span class="attr">getters</span>: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/profile&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        <span class="attr">posts</span>: &#123;</span><br><span class="line">          <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">          <span class="attr">getters</span>: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>启用了命名空间的<code>getter</code>和<code>action</code>会收到局部化的<code>getter</code>，<code>dispatch</code>和<code>commit</code>。换言之，你在使用模块内容时不需要在同一模块内额外添加空间名前缀。更改<code>namespaced</code>属性后不需要修改模块内的代码。</p>
<h2 id="在带命名空间的模块内访问全局内容（Global-Assets）"><a href="#在带命名空间的模块内访问全局内容（Global-Assets）" class="headerlink" title="在带命名空间的模块内访问全局内容（Global Assets）"></a>在带命名空间的模块内访问全局内容（Global Assets）</h2><p>如果你希望使用全局<code>state</code>和<code>getter</code>，<code>rootState</code>和<code>rootGetter</code>会作为第三和第四参数传入<code>getter</code>，也会通过<code>context</code>对象的属性传入<code>action</code>。<br>若需要在全局命名空间内分发<code>action</code>或提交<code>mutation</code>，将<code>&#123; root: true &#125;</code>作为第三参数传给<code>dispatch</code>或<code>commit</code>即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">modules</span>: &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中，`getters` 被局部化了</span></span><br><span class="line">      <span class="comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span></span><br><span class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.<span class="property">someOtherGetter</span> <span class="comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span></span><br><span class="line">        rootGetters.<span class="property">someOtherGetter</span> <span class="comment">// -&gt; &#x27;someOtherGetter&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">someOtherGetter</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        getters.<span class="property">someGetter</span> <span class="comment">// -&gt; &#x27;foo/someGetter&#x27;</span></span><br><span class="line">        rootGetters.<span class="property">someGetter</span> <span class="comment">// -&gt; &#x27;someGetter&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="string">&#x27;someOtherAction&#x27;</span>) <span class="comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span></span><br><span class="line">        <span class="title function_">dispatch</span>(<span class="string">&#x27;someOtherAction&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; &#x27;someOtherAction&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;someMutation&#x27;</span>) <span class="comment">// -&gt; &#x27;foo/someMutation&#x27;</span></span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;someMutation&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; &#x27;someMutation&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在带命名空间的模块注册全局action"><a href="#在带命名空间的模块注册全局action" class="headerlink" title="在带命名空间的模块注册全局action"></a>在带命名空间的模块注册全局action</h2><p>若需要在带命名空间的模块注册全局<code>action</code>，你可添加<code>root: true</code>，并将这个<code>action</code>的定义放在函数<code>handler</code>中。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    someOtherAction (&#123;dispatch&#125;) &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(<span class="string">&#x27;someAction&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="attr">someAction</span>: &#123;</span><br><span class="line">          <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">          handler (namespacedContext, payload) &#123; ... &#125; <span class="comment">// -&gt; &#x27;someAction&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带命名空间的绑定函数"><a href="#带命名空间的绑定函数" class="headerlink" title="带命名空间的绑定函数"></a>带命名空间的绑定函数</h2><p>当使用<code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code>和<code>mapMutations</code>这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">some</span>.<span class="property">nested</span>.<span class="property">module</span>.<span class="property">a</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">some</span>.<span class="property">nested</span>.<span class="property">module</span>.<span class="property">b</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapActions</span>([</span><br><span class="line">    <span class="string">&#x27;some/nested/module/foo&#x27;</span>, <span class="comment">// -&gt; this[&#x27;some/nested/module/foo&#x27;]()</span></span><br><span class="line">    <span class="string">&#x27;some/nested/module/bar&#x27;</span> <span class="comment">// -&gt; this[&#x27;some/nested/module/bar&#x27;]()</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapState</span>(<span class="string">&#x27;some/nested/module&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">a</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">b</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  ...<span class="title function_">mapActions</span>(<span class="string">&#x27;some/nested/module&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;foo&#x27;</span>, <span class="comment">// -&gt; this.foo()</span></span><br><span class="line">    <span class="string">&#x27;bar&#x27;</span> <span class="comment">// -&gt; this.bar()</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且，你可以通过使用<code>createNamespacedHelpers</code>创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = <span class="title function_">createNamespacedHelpers</span>(<span class="string">&#x27;some/nested/module&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...<span class="title function_">mapState</span>(&#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">a</span>,</span><br><span class="line">      <span class="attr">b</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">b</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 在 `some/nested/module` 中查找</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([</span><br><span class="line">      <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模块动态注册"><a href="#模块动态注册" class="headerlink" title="模块动态注册"></a>模块动态注册</h4><p>在<code>store</code>创建之后，你可以使用<code>store.registerModule</code>方法注册模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册模块 `myModule`</span></span><br><span class="line">store.<span class="title function_">registerModule</span>(<span class="string">&#x27;myModule&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册嵌套模块 `nested/myModule`</span></span><br><span class="line">store.<span class="title function_">registerModule</span>([<span class="string">&#x27;nested&#x27;</span>, <span class="string">&#x27;myModule&#x27;</span>], &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>之后就可以通过<code>store.state.myModule</code>和<code>store.state.nested.myModule</code>访问模块的状态。<br>模块动态注册功能使得其他Vue插件可以通过在<code>store</code>中附加新模块的方式来使用Vuex管理状态。例如，<code>vuex-router-sync</code>插件就是通过动态注册模块将<code>vue-router</code>和<code>vuex</code>结合在一起，实现应用的路由状态管理。<br>你也可以使用<code>store.unregisterModule(moduleName)</code>来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建<code>store</code>时声明的模块）。<br>在注册一个新<code>module</code>时，你很有可能想保留过去的<code>state</code>，例如从一个服务端渲染的应用保留 state。你可以通过<code>preserveState</code>选项将其归档：<code>store.registerModule(&#39;a&#39;, module, &#123; preserveState: true &#125;)</code>。</p>
<h4 id="模块重用"><a href="#模块重用" class="headerlink" title="模块重用"></a>模块重用</h4><p>有时我们可能需要创建一个模块的多个实例，例如：</p>
<ul>
<li>创建多个<code>store</code>，他们公用同一个模块 (例如当<code>runInNewContext</code>选项是<code>false</code>或<code>&#39;once&#39;</code>时，为了在服务端渲染中避免有状态的单例)</li>
<li>在一个<code>store</code>中多次注册同一个模块</li>
</ul>
<p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时<code>store</code>或模块间数据互相污染的问题。</p>
<p>实际上这和Vue组件内的<code>data</code>是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyReusableModule</span> = &#123;</span><br><span class="line">  state () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// mutation, action 和 getter 等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/28/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><a class="page-number" href="/page/31/">31</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/30/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>