<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Shell/Bash 变量"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/02/Shell/Bash%20%E5%8F%98%E9%87%8F/"
    >Bash 变量</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/02/Shell/Bash%20%E5%8F%98%E9%87%8F/" class="article-date">
  <time datetime="2023-07-02T09:42:56.000Z" itemprop="datePublished">2023-07-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Bash 变量分成环境变量和自定义变量两类。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。</p>
<p><code>env</code>命令或<code>printenv</code>命令，可以显示所有环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">env</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ <span class="built_in">printenv</span></span><br></pre></td></tr></table></figure>
<p>常见的环境变量：</p>
<ul>
<li><code>BASHPID</code>：Bash 进程的进程 ID。</li>
<li><code>BASHOPTS</code>：当前 Shell 的参数，可以用<code>shopt</code>命令修改。</li>
<li><code>DISPLAY</code>：图形环境的显示器名字，通常是<code>:0</code>，表示 X Server 的第一个显示器。</li>
<li><code>EDITOR</code>：默认的文本编辑器。</li>
<li><code>HOME</code>：用户的主目录。</li>
<li><code>HOST</code>：当前主机的名称。</li>
<li><code>IFS</code>：词与词之间的分隔符，默认为空格。</li>
<li><code>LANG</code>：字符集以及语言编码，比如<code>zh_CN.UTF-8</code>。</li>
<li><code>PATH</code>：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PS1</code>：Shell 提示符。</li>
<li><code>PS2</code>： 输入多行命令时，次要的 Shell 提示符。</li>
<li><code>PWD</code>：当前工作目录。</li>
<li><code>RANDOM</code>：返回一个 0 到 32767 之间的随机数。</li>
<li><code>SHELL</code>：Shell 的名字。</li>
<li><code>SHELLOPTS</code>：启动当前 Shell 的<code>set</code>命令的参数。</li>
<li><code>TERM</code>：终端类型名，即终端仿真器所用的协议。</li>
<li><code>UID</code>：当前用户的 ID 编号。</li>
<li><code>USER</code>：当前用户的用户名。</li>
</ul>
<p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p>
<blockquote>
<p>注意，Bash 变量名区分大小写，<code>HOME</code>和<code>home</code>是两个不同的变量。</p>
</blockquote>
<p>查看单个环境变量的值，可以使用<code>printenv</code>命令或<code>echo</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">printenv</span> PATH</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>printenv</code>命令后面的变量名，不用加前缀<code>$</code>。</p>
<h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p>自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p>
<p><code>set</code>命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。</p>
<h1 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h1><p>用户创建变量的时候，变量名必须遵守下面的规则：</p>
<ul>
<li>字母、数字和下划线字符组成。</li>
<li>第一个字符必须是一个字母或一个下划线，不能是数字。</li>
<li>不能使用 Shell 里的关键字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br><span class="line">variable=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">variable=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，等号左边是变量名，右边是变量。</p>
<blockquote>
<p>注意，等号两边不能有空格。</p>
</blockquote>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myvar=<span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>Bash 没有数据类型的概念，所有的变量值都是字符串。</p>
<p>下面是一些自定义变量的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=z                     <span class="comment"># 变量 a 赋值为字符串 z</span></span><br><span class="line">b=<span class="string">&quot;a string&quot;</span>            <span class="comment"># 变量值包含空格，就必须放在引号里面</span></span><br><span class="line">c=<span class="string">&quot;a string and <span class="variable">$b</span>&quot;</span>     <span class="comment"># 变量值可以引用其他变量的值</span></span><br><span class="line">d=<span class="string">&quot;\t\ta string\n&quot;</span>      <span class="comment"># 变量值可以使用转义字符</span></span><br><span class="line">e=$(<span class="built_in">ls</span> -l foo.txt)      <span class="comment"># 变量值可以是命令的执行结果</span></span><br><span class="line">f=$((<span class="number">5</span> * <span class="number">7</span>))            <span class="comment"># 变量值可以是数学运算的结果</span></span><br></pre></td></tr></table></figure>
<p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ foo=1</span><br><span class="line">$ foo=2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>如果同一行定义多个变量，必须使用分号<code>;</code>分隔。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ foo=1;bar=2</span><br></pre></td></tr></table></figure>
<h1 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h1><p>读取变量的时候，直接在变量名前加上<code>$</code>就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ foo=bar</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>每当 Shell 看到以<code>$</code>开头的单词时，就会尝试读取这个变量名对应的值。</p>
<p>如果变量不存在，Bash 不会报错，而会输出空字符。</p>
<p>由于<code>$</code>在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> The total is <span class="variable">$100</span>.00</span><br><span class="line">The total is 00.00</span><br></pre></td></tr></table></figure>
<p>上面命令的原意是输入<code>$100</code>，但是 Bash 将<code>$1</code>解释成了变量，该变量为空，因此输入就变成了 00.00。所以，如果要使用<code>$</code>的原义，需要在<code>$</code>前面放上反斜杠，进行转义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> The total is \<span class="variable">$100</span>.00</span><br><span class="line">The total is <span class="variable">$100</span>.00</span><br></pre></td></tr></table></figure>
<p>读取变量的时候，变量名也可以使用花括号<code>&#123;&#125;</code>包围，比如<code>$a</code>也可以写成<code>$&#123;a&#125;</code>。这种写法可以用于变量名与其他字符连用的情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ a=foo</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$a_file</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;a&#125;</span>_file</span><br><span class="line">foo_file</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量名<code>a_file</code>不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分<code>$a</code>，Bash 才能正确解读。</p>
<p>事实上，读取变量的语法<code>$foo</code>，可以看作是<code>$&#123;foo&#125;</code>的简写形式。</p>
<p>如果变量的值本身也是变量，可以使用<code>$&#123;!varname&#125;</code>的语法，读取最终的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ myvar=USER</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;!myvar&#125;</span></span><br><span class="line">ruanyf</span><br></pre></td></tr></table></figure>
<p>上面的例子中，变量<code>myvar</code>的值是<code>USER</code>，<code>$&#123;!myvar&#125;</code>的写法将其展开成最终的值。</p>
<p>如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ a=<span class="string">&quot;1 2  3&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">1 2 3</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span>&quot;</span></span><br><span class="line">1 2  3</span><br></pre></td></tr></table></figure>
<p>上面示例中，变量<code>a</code>的值包含两个连续空格。如果直接读取，Shell 会将连续空格合并成一个。只有放在双引号里面读取，才能保持原来的格式。</p>
<h1 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h1><p><code>unset</code>命令用来删除一个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset NAME</span><br></pre></td></tr></table></figure>
<p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使<code>unset</code>命令删除了变量，还是可以读取这个变量，值为空字符串。</p>
<p>所以，删除一个变量，也可以将这个变量设成空字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ foo=<span class="string">&#x27;&#x27;</span></span><br><span class="line">$ foo=</span><br></pre></td></tr></table></figure>
<p>上面两种写法，都是删除了变量<code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p>
<h1 id="输出变量，export-命令"><a href="#输出变量，export-命令" class="headerlink" title="输出变量，export 命令"></a>输出变量，export 命令</h1><p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用<code>export</code>命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p>
<p><code>export</code>命令用来向子 Shell 输出变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME=foo</span><br><span class="line"><span class="built_in">export</span> NAME</span><br></pre></td></tr></table></figure>
<p>上面命令输出了变量<code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NAME=value</span><br></pre></td></tr></table></figure>
<p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量<code>$NAME</code>。</p>
<p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出变量 $foo</span></span><br><span class="line">$ <span class="built_in">export</span> foo=bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建子 Shell</span></span><br><span class="line">$ bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 $foo</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改继承的变量</span></span><br><span class="line">$ foo=baz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出子 Shell</span></span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 $foo</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>上面例子中，子 Shell 修改了继承的变量<code>$foo</code>，对父 Shell 没有影响。</p>
<h1 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h1><p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p>
<h2 id=""><a href="#" class="headerlink" title="$?"></a>$?</h2><p><code>$?</code>为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是 0，表示上一个命令执行成功；如果不是零，表示上一个命令执行失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> doesnotexist</span><br><span class="line"><span class="built_in">ls</span>: doesnotexist: No such file or directory</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>ls</code>命令查看一个不存在的文件，导致报错。<code>$?</code>为 1，表示上一个命令执行失败。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="$$"></a>$$</h2><p><code>$$</code>为当前 Shell 的进程 ID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $$</span><br><span class="line">10662</span><br></pre></td></tr></table></figure>
<p>这个特殊变量可以用来命名临时文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGFILE=/tmp/output_log.$$</span><br></pre></td></tr></table></figure>
<h2 id="-2"><a href="#-2" class="headerlink" title="$_"></a>$_</h2><p><code>$_</code>为上一个命令的最后一个参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep dictionary /usr/share/dict/words</span><br><span class="line">dictionary</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$_</span></span><br><span class="line">/usr/share/dict/words</span><br></pre></td></tr></table></figure>
<h2 id="-3"><a href="#-3" class="headerlink" title="$!"></a>$!</h2><p><code>$!</code>为最近一个后台执行的异步命令的进程 ID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ firefox &amp;</span><br><span class="line">[1] 11064</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $!</span><br><span class="line">11064</span><br></pre></td></tr></table></figure>
<p>上面例子中，firefox 是后台运行的命令，<code>$!</code>返回该命令的进程 ID。</p>
<h2 id="0"><a href="#0" class="headerlink" title="$0"></a>$0</h2><p><code>$0</code>为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">bash</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>$0</code>返回当前运行的是 Bash。</p>
<h2 id="-4"><a href="#-4" class="headerlink" title="$-"></a>$-</h2><p><code>$-</code>为当前 Shell 的启动参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> $-</span><br><span class="line">himBHs</span><br></pre></td></tr></table></figure>
<h2 id="和"><a href="#和" class="headerlink" title="$@和$#"></a>$@和$#</h2><p><code>$#</code>表示脚本的参数数量，<code>$@</code>表示脚本的参数值。</p>
<h1 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="变量的默认值"></a>变量的默认值</h1><p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;varname:-word&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则返回<code>word</code>。它的目的是返回一个默认值，比如<code>$&#123;count:-0&#125;</code>表示变量<code>count</code>不存在时返回 0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;varname:=word&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则将它设为<code>word</code>，并且返回<code>word</code>。它的目的是设置变量的默认值，比如<code>$&#123;count:=0&#125;</code>表示变量<code>count</code>不存在时返回 0，且将count设为0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;varname:+word&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面语法的含义是，如果变量名存在且不为空，则返回<code>word</code>，否则返回空值。它的目的是测试变量是否存在，比如<code>$&#123;count:+1&#125;</code>表示变量<code>count</code>存在时返回 1（表示<code>true</code>），否则返回空值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;varname:?message&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面语法的含义是，如果变量<code>varname</code>存在且不为空，则返回它的值，否则打印出<code>varname: message</code>，并中断脚本的执行。如果省略了<code>message</code>，则输出默认的信息<code>“parameter null or not set.”</code>。它的目的是防止变量未定义，比如<code>$&#123;count:?&quot;undefined!&quot;&#125;</code>表示变量<code>count</code>未定义时就中断执行，抛出错误，返回给定的报错信息<code>undefined!</code>。</p>
<p>上面四种语法如果用在脚本中，变量名的部分可以用数字 1 到 9，表示脚本的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=<span class="variable">$&#123;1:?&quot;filename missing.&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码出现在脚本中，1 表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p>
<h1 id="declare-命令"><a href="#declare-命令" class="headerlink" title="declare 命令"></a>declare 命令</h1><p><code>declare</code>命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p>
<p>它的语法形式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare OPTION VARIABLE=value</span><br></pre></td></tr></table></figure>
<p><code>declare</code>命令的主要参数（<code>OPTION</code>）如下。</p>
<ul>
<li><code>-a</code>：声明数组变量。</li>
<li><code>-f</code>：输出所有函数定义。</li>
<li><code>-F</code>：输出所有函数名。</li>
<li><code>-i</code>：声明整数变量。</li>
<li><code>-l</code>：声明变量为小写字母。</li>
<li><code>-p</code>：查看变量信息。</li>
<li><code>-r</code>：声明只读变量。</li>
<li><code>-u</code>：声明变量为大写字母。</li>
<li><code>-x</code>：该变量输出为环境变量。</li>
</ul>
<p><code>declare</code>命令如果用在函数中，声明的变量只在函数内部有效，等同于<code>local</code>命令。</p>
<p>不带任何参数时，<code>declare</code>命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的<code>set</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ declare</span><br></pre></td></tr></table></figure>
<h2 id="i-参数"><a href="#i-参数" class="headerlink" title="-i 参数"></a>-i 参数</h2><p><code>-i</code>参数声明整数变量以后，可以直接进行数学运算。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -i val1=12 val2=5</span><br><span class="line">$ <span class="built_in">declare</span> -i result</span><br><span class="line">$ result=val1*val2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">60</span><br></pre></td></tr></table></figure>
<p>上面例子中，如果变量<code>result</code>不声明为整数，<code>val1*val2</code>会被当作字面量，不会进行整数运算。另外，<code>val1</code>和<code>val2</code>其实不需要声明为整数，因为只要<code>result</code>声明为整数，它的赋值就会自动解释为整数运算。</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -i var=12</span><br><span class="line">$ var=foo</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>上面例子中，变量<code>var</code>声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出 0，也可能输出的是 3。</p>
<h2 id="x-参数"><a href="#x-参数" class="headerlink" title="-x 参数"></a>-x 参数</h2><p><code>-x</code>参数等同于<code>export</code>命令，可以输出一个变量为子 Shell 的环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -x foo</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ <span class="built_in">export</span> foo</span><br></pre></td></tr></table></figure>
<h2 id="r-参数"><a href="#r-参数" class="headerlink" title="-r 参数"></a>-r 参数</h2><p><code>-r</code>参数可以声明只读变量，无法改变变量值，也不能<code>unset</code>变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -r bar=1</span><br><span class="line"></span><br><span class="line">$ bar=2</span><br><span class="line">bash: bar：只读变量</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">unset</span> bar</span><br><span class="line">bash: bar：只读变量</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>上面例子中，后两个赋值语句都会报错，命令执行失败。</p>
<h2 id="u-参数"><a href="#u-参数" class="headerlink" title="-u 参数"></a>-u 参数</h2><p><code>-u</code>参数声明变量为大写字母，可以自动把变量值转成大写字母。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -u foo</span><br><span class="line">$ foo=upper</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">UPPER</span><br></pre></td></tr></table></figure>
<h2 id="l-参数"><a href="#l-参数" class="headerlink" title="-l 参数"></a>-l 参数</h2><p><code>-l</code>参数声明变量为小写字母，可以自动把变量值转成小写字母。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -l bar</span><br><span class="line">$ bar=LOWER</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$bar</span></span><br><span class="line">lower</span><br></pre></td></tr></table></figure>
<h2 id="p-参数"><a href="#p-参数" class="headerlink" title="-p 参数"></a>-p 参数</h2><p><code>-p</code>参数输出变量信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ foo=hello</span><br><span class="line">$ <span class="built_in">declare</span> -p foo</span><br><span class="line"><span class="built_in">declare</span> -- foo=<span class="string">&quot;hello&quot;</span></span><br><span class="line">$ <span class="built_in">declare</span> -p bar</span><br><span class="line">bar：未找到</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>declare -p</code>可以输出已定义变量的值，对于未定义的变量，会提示找不到。</p>
<p>如果不提供变量名，<code>declare -p</code>输出所有变量的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -p</span><br></pre></td></tr></table></figure>
<h2 id="f-参数"><a href="#f-参数" class="headerlink" title="-f 参数"></a>-f 参数</h2><p><code>-f</code>参数输出当前环境的所有函数，包括它的定义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -f</span><br></pre></td></tr></table></figure>
<h2 id="F参数"><a href="#F参数" class="headerlink" title="-F参数"></a>-F参数</h2><p><code>-F</code>参数输出当前环境的所有函数名，不包含函数定义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">declare</span> -F</span><br></pre></td></tr></table></figure>
<h1 id="readonly-命令"><a href="#readonly-命令" class="headerlink" title="readonly 命令"></a>readonly 命令</h1><p><code>readonly</code>命令等同于<code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能<code>unset</code>变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">readonly</span> foo=1</span><br><span class="line">$ foo=2</span><br><span class="line">bash: foo：只读变量</span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>上面例子中，更改只读变量<code>foo</code>会报错，命令执行失败。</p>
<p><code>readonly</code>命令有三个参数：</p>
<ul>
<li><code>-f</code>：声明的变量为函数名。</li>
<li><code>-p</code>：打印出所有的只读变量。</li>
<li><code>-a</code>：声明的变量为数组。</li>
</ul>
<h1 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h1><p><code>let</code>命令声明变量时，可以直接执行算术表达式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">let</span> foo=1+2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>let</code>命令可以直接计算<code>1 + 2</code>。</p>
<p><code>let</code>命令的参数表达式如果包含空格，就需要使用引号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">let</span> <span class="string">&quot;foo = 1 + 2&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>let</code>可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">let</span> <span class="string">&quot;v1 = 1&quot;</span> <span class="string">&quot;v2 = v1++&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$v1</span>,<span class="variable">$v2</span></span><br><span class="line">2,1</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>let</code>声明了两个变量<code>v1</code>和<code>v2</code>，其中<code>v2</code>等于<code>v1++</code>，表示先返回<code>v1</code>的值，然后<code>v1</code>自增。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bash/" rel="tag">Bash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-Shell/Bash 基本语法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/02/Shell/Bash%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"
    >Bash 基本语法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/02/Shell/Bash%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2023-07-02T09:42:56.000Z" itemprop="datePublished">2023-07-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Bash-的基本语法"><a href="#Bash-的基本语法" class="headerlink" title="Bash 的基本语法"></a>Bash 的基本语法</h1><h2 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h2><p><code>echo</code>命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>echo</code>的参数是<code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;&lt;HTML&gt;</span></span></span><br><span class="line">  &lt;HEAD&gt;</span><br><span class="line">    &lt;TITLE&gt;Page Title&lt;/TITLE&gt;</span><br><span class="line">  &lt;/HEAD&gt;</span><br><span class="line">  &lt;BODY&gt;</span><br><span class="line">    Page body.</span><br><span class="line">  &lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="n-参数"><a href="#n-参数" class="headerlink" title="-n 参数"></a>-n 参数</h4><p>默认情况下，<code>echo</code>输出的文本末尾会有一个回车符。<code>-n</code>参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n hello world</span><br><span class="line">hello world$</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>world</code>后面直接就是下一行的提示符<code>$</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a;<span class="built_in">echo</span> b</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -n a;<span class="built_in">echo</span> b</span><br><span class="line">ab</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>-n</code>参数可以让两个<code>echo</code>命令的输出连在一起，出现在同一行。</p>
<h4 id="e-参数"><a href="#e-参数" class="headerlink" title="-e 参数"></a>-e 参数</h4><p><code>-e</code>参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符<code>\n</code>）。如果不使用<code>-e</code>参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code>不解释它们，原样输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello\nWorld&quot;</span></span><br><span class="line">Hello\nWorld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号的情况</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;Hello\nWorld&quot;</span></span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单引号的情况</span></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&#x27;Hello\nWorld&#x27;</span></span><br><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>-e</code>参数使得<code>\n</code>解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> [ arg1 ... [ argN ]]</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>command</code>是具体的命令或者一个可执行文件，<code>arg1 ... argN</code>是传递给命令的参数，它们是可选的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>
<p>上面这个命令中，<code>ls</code>是命令，<code>-l</code>是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的<code>-l</code>。同一个配置项往往有长和短两种形式，比如<code>-l</code>是短形式，<code>--list</code>是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 短形式</span></span><br><span class="line">$ <span class="built_in">ls</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长形式</span></span><br><span class="line">$ <span class="built_in">ls</span> --reverse</span><br></pre></td></tr></table></figure>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> foo bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ <span class="built_in">echo</span> foo \</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>Bash 使用空格（或 Tab 键）区分不同的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> foo bar</span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>foo</code>和<code>bar</code>之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> this is a     <span class="built_in">test</span></span><br><span class="line">this is a <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>a</code>和<code>test</code>之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>分号（<code>;</code>）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clear; <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，Bash 先执行<code>clear</code>命令，执行完成后，再执行<code>ls</code>命令。</p>
<blockquote>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
</blockquote>
<h2 id="命令的组合符-amp-amp-和"><a href="#命令的组合符-amp-amp-和" class="headerlink" title="命令的组合符&amp;&amp;和||"></a>命令的组合符&amp;&amp;和||</h2><p>除了分号，Bash 还提供两个命令组合符<code>&amp;&amp;</code>和<code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command1 &amp;&amp; Command2</span><br></pre></td></tr></table></figure>
<p>上面命令的意思是，如果<code>Command1</code>命令运行成功，则继续运行<code>Command2</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command1 || Command2</span><br></pre></td></tr></table></figure>
<p>上面命令的意思是，如果<code>Command1</code>命令运行失败，则继续运行<code>Command2</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> filelist.txt ; <span class="built_in">ls</span> -l filelist.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，只要<code>cat</code>命令执行结束，不管成功或失败，都会继续执行<code>ls</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> filelist.txt &amp;&amp; <span class="built_in">ls</span> -l filelist.txt</span><br></pre></td></tr></table></figure>
<p>上面例子中，只有<code>cat</code>命令执行成功，才会继续执行<code>ls</code>命令。如果<code>cat</code>执行失败（比如不存在文件<code>flielist.txt</code>），那么<code>ls</code>命令就不会执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> foo || <span class="built_in">mkdir</span> bar</span><br></pre></td></tr></table></figure>
<p>上面例子中，只有<code>mkdir foo</code>命令执行失败（比如<code>foo</code>目录已经存在），才会继续执行<code>mkdir bar</code>命令。如果<code>mkdir foo</code>命令执行成功，就不会创建<code>bar</code>目录了。</p>
<h2 id="type-命令"><a href="#type-命令" class="headerlink" title="type 命令"></a>type 命令</h2><p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢？</p>
<p><code>type</code>命令用来判断命令的来源。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">$ <span class="built_in">type</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> is hashed (/bin/ls)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>type</code>命令告诉我们，<code>echo</code>是内部命令，<code>ls</code>是外部程序（<code>/bin/ls</code>）。</p>
<p><code>type</code>命令本身也是内置命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> <span class="built_in">type</span></span><br><span class="line"><span class="built_in">type</span> is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure>
<p>如果要查看一个命令的所有定义，可以使用<code>type</code>命令的<code>-a</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> -a <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> is shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">echo</span> is /usr/bin/echo</span><br><span class="line"><span class="built_in">echo</span> is /bin/echo</span><br></pre></td></tr></table></figure>
<p>上面代码表示，<code>echo</code>命令既是内置命令，也有对应的外部程序。</p>
<p><code>type</code>命令的<code>-t</code>参数，可以返回一个命令的类型：别名（<code>alias</code>），关键词（<code>keyword</code>），函数（<code>function</code>），内置命令（<code>builtin</code>）和文件（<code>file</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> -t bash</span><br><span class="line">file</span><br><span class="line">$ <span class="built_in">type</span> -t <span class="keyword">if</span></span><br><span class="line">keyword</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>bash</code>是文件，<code>if</code>是关键词。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键。</p>
<ul>
<li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>：中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>：向上滚动。</li>
<li><code>Shift + PageDown</code>：向下滚动。</li>
<li><code>Ctrl + U</code>：从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>：从光标位置删除到行尾。</li>
<li><code>Ctrl + W</code>：删除光标位置前一个单词。</li>
<li><code>Ctrl + D</code>：关闭 Shell 会话。</li>
<li><code>↑，↓</code>：浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入<code>tou</code>，然后按一下 Tab 键，Bash 会自动补上<code>ch</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让你选择。</p>
<h1 id="引号和转义"><a href="#引号和转义" class="headerlink" title="引号和转义"></a>引号和转义</h1><p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>某些字符在 Bash 里面有特殊含义（比如<code>$、&amp;、*</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$date</span></span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>上面例子中，输出<code>$date</code>不会有任何结果，因为<code>$</code>是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \<span class="variable">$date</span></span><br><span class="line"><span class="variable">$date</span></span><br></pre></td></tr></table></figure>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线（<code>\\</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \\</span><br><span class="line">\</span><br></pre></td></tr></table></figure>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>：响铃</li>
<li><code>\b</code>：退格</li>
<li><code>\n</code>：换行</li>
<li><code>\r</code>：回车</li>
<li><code>\t</code>：制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用<code>echo</code>命令的<code>-e</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> a\tb</span><br><span class="line">atb</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">&quot;a\tb&quot;</span></span><br><span class="line">a        b</span><br></pre></td></tr></table></figure>
<p>上面例子中，命令行直接输出不可打印字符<code>\t</code>，Bash 不能正确解释。必须把它们放在引号之中，然后使用echo命令的-e参数。</p>
<p>换行符是一个特殊字符，表示命令的结束，Bash 收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash 会将其当作长度为0的空字符处理，从而可以将一行命令写成多行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> \</span><br><span class="line">/path/to/foo \</span><br><span class="line">/path/to/bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ <span class="built_in">mv</span> /path/to/foo /path/to/bar</span><br></pre></td></tr></table></figure>
<p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h2><p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（*）、美元符号（$）、反斜杠（\）等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;$USER&#x27;</span></span><br><span class="line"><span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;$((2+2))&#x27;</span></span><br><span class="line">$((<span class="number">2</span>+<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;$(echo foo)&#x27;</span></span><br><span class="line">$(<span class="built_in">echo</span> foo)</span><br></pre></td></tr></table></figure>
<p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（$），然后再对里层的单引号转义。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不正确</span></span><br><span class="line">$ <span class="built_in">echo</span> it<span class="string">&#x27;s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 不正确</span></span><br><span class="line"><span class="string">$ echo &#x27;</span>it\<span class="string">&#x27;s&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">$ <span class="built_in">echo</span> $<span class="string">&#x27;it\&#x27;</span>s<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;it&#x27;s&quot;</span></span><br><span class="line">it<span class="string">&#x27;s</span></span><br></pre></td></tr></table></figure>
<h2 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h2><p>双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">*</span><br></pre></td></tr></table></figure>
<p>上面例子中，通配符*是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，双引号里面不会进行文件名扩展。</p>
<p>但是，三个特殊字符除外：美元符号（<code>$</code>）、反引号（<code>\``）和反斜杠（</code>`）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span></span><br><span class="line">/bin/bash</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;`date`&quot;</span></span><br><span class="line">Mon Jan 27 13:33:18 CST 2020</span><br></pre></td></tr></table></figure>
<p>上面例子中，美元符号（$）和反引号（&#96;）在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;I&#x27;d say: \&quot;hello!\&quot;&quot;</span></span><br><span class="line">I<span class="string">&#x27;d say: &quot;hello!&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ echo &quot;\\&quot;</span></span><br><span class="line"><span class="string">\</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>换行符在双引号之中，会失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;hello</span></span><br><span class="line"><span class="string">world&quot;</span></span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就失去了这种特殊作用，只用来换行，所以可以输入多行。<code>echo</code>命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号（或单引号），将文件名放在里面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> <span class="string">&quot;two words.txt&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面命令中，<code>two words.txt</code>是一个包含空格的文件名，如果不放在双引号里面，就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;this is a     test&quot;</span></span><br><span class="line">this is a     <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行输出</span></span><br><span class="line">$ <span class="built_in">echo</span> $(cal)</span><br><span class="line">一月 2020 日 一 二 三 四 五 六 1 2 3 ... 31</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始格式输出</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(cal)</span>&quot;</span></span><br><span class="line">      一月 2020</span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">          1  2  3  4</span><br><span class="line"> 5  6  7  8  9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29 30 31</span><br></pre></td></tr></table></figure>
<p>上面例子中，如果<code>$(cal)</code>不放在双引号之中，<code>echo</code>就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="Here-文档"><a href="#Here-文档" class="headerlink" title="Here 文档"></a>Here 文档</h2><p>Here 文档是一种输入多行字符串的方法，格式如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt; <span class="string">token</span></span><br><span class="line"><span class="string">text</span></span><br><span class="line"><span class="string">token</span></span><br></pre></td></tr></table></figure>
<p>它的格式分成开始标记（<code>&lt;&lt; token</code>）和结束标记（<code>token</code>）。开始标记是两个小于号<code>+ Here</code>文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt;&lt; <span class="string">_EOF_</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;</span></span><br><span class="line"><span class="string">    The title of your page</span></span><br><span class="line"><span class="string">    &lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    Your page content goes here.</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">_EOF_</span></span><br></pre></td></tr></table></figure>
<p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ foo=<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">$ <span class="built_in">cat</span> &lt;&lt; <span class="string">_example_</span></span><br><span class="line"><span class="string">$foo</span></span><br><span class="line"><span class="string">&quot;$foo&quot;</span></span><br><span class="line"><span class="string">&#x27;$foo&#x27;</span></span><br><span class="line"><span class="string">_example_</span></span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，变量<code>$foo</code>发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ foo=<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">$ <span class="built_in">cat</span> &lt;&lt; <span class="string">&#x27;_example_&#x27;</span></span><br><span class="line"><span class="variable">$foo</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;$foo&#x27;</span></span><br><span class="line">_example_</span><br><span class="line"></span><br><span class="line"><span class="variable">$foo</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line"><span class="string">&#x27;$foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，Here 文档的开始标记（<code>_example_</code>）放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了<code>echo</code>命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &lt;&lt; <span class="string">token</span></span><br><span class="line"><span class="string">  string</span></span><br><span class="line"><span class="string">token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> string | <span class="built_in">command</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Here 文档相当于<code>echo</code>命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如<code>echo</code>命令就不能用 Here 文档作为参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &lt;&lt; <span class="string">_example_</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">_example_</span></span><br></pre></td></tr></table></figure>
<p>上面例子不会有任何输出，因为 Here 文档对于<code>echo</code>命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="Here-字符串"><a href="#Here-字符串" class="headerlink" title="Here 字符串"></a>Here 字符串</h2><p>Here 文档还有一个变体，叫做 Here 字符串，使用三个小于号（<code>&lt;&lt;&lt;</code>）表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt; string</span><br></pre></td></tr></table></figure>
<p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如cat命令只接受标准输入传入的字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &lt;&lt;&lt; <span class="string">&#x27;hi there&#x27;</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;hi there&#x27;</span> | <span class="built_in">cat</span></span><br></pre></td></tr></table></figure>
<p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">md5sum</span> &lt;&lt;&lt; <span class="string">&#x27;ddd&#x27;</span></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;ddd&#x27;</span> | <span class="built_in">md5sum</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>md5sum</code>命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即<code>md5sum ddd</code>里面的<code>ddd</code>会被解释成文件名。这时就可以用 Here 字符串，将字符串传给<code>md5sum</code>命令。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bash/" rel="tag">Bash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/OSPF实战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/" class="article-date">
  <time datetime="2023-05-11T09:24:30.447Z" itemprop="datePublished">2023-05-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="OSPF-基础命令"><a href="#OSPF-基础命令" class="headerlink" title="OSPF 基础命令"></a>OSPF 基础命令</h1><p>掌握三条命令，就能玩转 OSPF：</p>
<ul>
<li>创建 OSPF 进程，进入配置视图</li>
<li>创建 OSPF 区域</li>
<li>接口激活 OSPF</li>
</ul>
<h2 id="创建-OSPF-进程"><a href="#创建-OSPF-进程" class="headerlink" title="创建 OSPF 进程"></a>创建 OSPF 进程</h2><p>在系统视图下，使用 OSPF 命令，创建 OSPF 进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Router]ospf 1 Router-id 1.1.1.1</span><br></pre></td></tr></table></figure>
<p>上面的命令，是在<code>Router</code>上创建<code>Process-ID</code>为 1 的 OSPF 进程，并进入配置视图。使用的<code>Router-ID</code>是<code>1.1.1.1</code>。</p>
<p><code>Process-ID</code>是可选参数，表示 OSPF 进程的编号，只在设备本身生效，也就是说，两台设备建立 OSPF 邻居时，不要求双方的<code>Process-ID</code>一样。如果不指定<code>Process-ID</code>，会分配一个默认值作为<code>Process-ID</code>。</p>
<p><code>router-id</code>也是可选参数，用来指定设备的<code>Router-ID</code>。通常，手动配置<code>Router-ID</code>，不会使用默认值。</p>
<h2 id="创建-OSPF-区域"><a href="#创建-OSPF-区域" class="headerlink" title="创建 OSPF 区域"></a>创建 OSPF 区域</h2><p>创建完 OSPF 进程后，就需要创建 OSPF 区域。在配置视图下，使用<code>area</code>命令创建区域，并指定区域 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Router]ospf 1 Router-id 1.1.1.1</span><br><span class="line">[Router-ospf-1]area 1</span><br></pre></td></tr></table></figure>
<p>在 OSPF 进程 1 中，创建<code>Area1</code>。</p>
<h2 id="接口激活-OSPF"><a href="#接口激活-OSPF" class="headerlink" title="接口激活 OSPF"></a>接口激活 OSPF</h2><p>默认状态下，所有接口都没有激活 OSPF，要在接口激活 OSPF，有两种方法：</p>
<h3 id="在区域视图激活-OSPF"><a href="#在区域视图激活-OSPF" class="headerlink" title="在区域视图激活 OSPF"></a>在区域视图激活 OSPF</h3><p>在区域视图下，使用<code>network</code>命令，再加上 IP 地址和通配符掩码，满足条件的接口激活 OSPF。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Router]ospf 1 Router-id 1.1.1.1</span><br><span class="line">[Router-ospf-1]area 0</span><br><span class="line">[Router-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255</span><br></pre></td></tr></table></figure>
<p>举个栗子：<code>network 192.168.1.0 0.0.0.255</code>，IP 地址是<code>192.168.1.0</code>，通配符掩码是<code>0.0.0.255</code>。通配符掩码中，比特位为 0 的需要匹配，比特位为 1 的不需要匹配。命令中匹配的 IP 地址是<code>192.168.1.0</code>至<code>192.168.1.255</code>。</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/1.png" class="">

<p>计算方法是，把<code>192.168.1.0</code>用二进制表示，把通配符掩码<code>0.0.0.255</code>也换算成二进制，每个比特位对应。前 24 位全为 0，后 8 位全为 1。匹配的 IP 地址，以<code>192.168.1</code>开头，后面是 0 至 255 的任意值。接口 IP 地址在这个范围内，且 IP 地址掩码长度大于或等于<code>network</code>命令的 0 比特位数，就在接口上激活 OSPF。</p>
<p>有两个特殊的<code>network</code>命令，一个是<code>network x.x.x.x 0.0.0.0</code>，比如<code>network 192.168.1.1 0.0.0.0</code>，IP 地址是<code>192.168.1.1</code>的接口激活 OSPF，无论网络掩码长度多少。另一个是<code>network 0.0.0.0 255.255.255.255</code>，匹配任意 IP 地址，所有配置了 IP 地址的接口，都会激活 OSPF。</p>
<h3 id="在指定接口激活-OSPF"><a href="#在指定接口激活-OSPF" class="headerlink" title="在指定接口激活 OSPF"></a>在指定接口激活 OSPF</h3><p>上面的方法，可以使用一条命令，在多个接口激活 OSPF。另一个方法就是在指定接口激活 OSPF。先创建 OSPF 进程和区域，然后进入接口视图，使用<code>ospf enable</code>命令激活。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Router]ospf 1 Router-<span class="built_in">id</span> 1.1.1.1 <span class="comment">#创建OSPF进程</span></span><br><span class="line">[Router-ospf-1]area 0 <span class="comment">#创建Area0</span></span><br><span class="line">[Router-ospf-1-area-0.0.0.0]quit</span><br><span class="line">[Router-ospf-1]quit</span><br><span class="line">[Router]interface GigabitEthernet 0/0 <span class="comment">#进入GE0/0接口视图</span></span><br><span class="line">[Router-GigabitEthernet0/0]ospf <span class="built_in">enable</span> 1 area 0 <span class="comment">#激活OSPF</span></span><br></pre></td></tr></table></figure>
<h1 id="OSPF-单区域实验"><a href="#OSPF-单区域实验" class="headerlink" title="OSPF 单区域实验"></a>OSPF 单区域实验</h1><img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/2.png" class="">

<p>路由器 RT1 的两个接口分别连接<code>172.16.1.0/24</code>和<code>172.16.2.0/24</code>网段，另一个接口连接路由器 RT2。RT2 创建 Loopback 接口，配置 IP 地址<code>172.16.255.2/24</code>，模拟 RT2 的直连网段。在 RT1 和 RT2 上运行 OSPF，让 PC 可以访问全部网段。</p>
<p>RT1 配置如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[RT1]ospf 1 router-id 1.1.1.1</span><br><span class="line">[RT1-ospf-1]area 0</span><br><span class="line">[RT1-ospf-1-area-0.0.0.0]network 172.16.1.0 0.0.0.255</span><br><span class="line">[RT1-ospf-1-area-0.0.0.0]network172.16.2.0 0.0.0.255</span><br><span class="line">[RT1-ospf-1-area-0.0.0.0]network 172.16.12.0 0.0.0.3</span><br></pre></td></tr></table></figure>
<p>RT2 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[RT2]ospf 1 router-id 2.2.2.2</span><br><span class="line">[RT2-ospf-1]area 0</span><br><span class="line">[RT2-ospf-1-area-0.0.0.0]network 172.16.12.0 0.0.0.3</span><br><span class="line">[RT2-ospf-1-area-0.0.0.]network 172.16.255.0 0.0.0.255</span><br></pre></td></tr></table></figure>
<p>配置完成后，RT1 和 RT2 建立邻接关系，交换 LSA。查看 RT1 的邻居表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/3.png" class="">

<p>邻接表中，RT1 在<code>Area0</code>发现邻居，<code>Router-ID</code>是<code>2.2.2.2</code>，接口 IP 地址是<code>172.16.12.2</code>，邻居状态是<code>Full</code>，对端是<code>Master</code>。</p>
<p>再看 RT1 的 OSPF 路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/4.png" class="">

<p>命令<code>display ospf routing</code>，是查看 OSPF 路由表，并不是路由器的全局路由器。这些 OSPF 路由表能否加载到全局路由表，还要看路由表优先级等因素。这里发现 R2 的 Loopback0 接口路由，是一条主机路由，实际上，Loopback0 接口的掩码长度是 24，而不是 32。这是因为 OSPF 把 Loopback 接口作为末梢网络，无论实际掩码是多少，Type-1 LSA 中，都以<code>255.255.255.255</code>进行通告。</p>
<p>查看 RT2 的 Type-1 LSA ：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/5.png" class="">

<p>如果希望 RT2 的 Type-1 LSA 描述 Loopback 接口的实际掩码信息，可以把接口的网络类型改成 Broadcast 或 NBMA，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[RT2]interface LoopBack 0</span><br><span class="line">[RT2-LoopBack0]ospf network-type broadcast</span><br></pre></td></tr></table></figure>
<p>再看 RT2 的 Type-1 LSA：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/6.png" class="">

<p>RT2 以实际掩码信息通告<code>Loopback0</code>接口。现在看下 RT1 的路由表中 OSPF 路由：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/7.png" class="">

<p>RT1 把<code>172.16.255.0/24</code>网段加载到路由表。同时，RT2 也获得到达<code>172.16.1.0/24</code>和<code>172.16.2.0/24</code>的路由。这样 PC 就能访问网络中的各个网段。</p>
<h1 id="Silent-Interface"><a href="#Silent-Interface" class="headerlink" title="Silent-Interface"></a>Silent-Interface</h1><img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/8.png" class="">

<p>上个实验的拓扑图中，RT1 的<code>GE0/0/0</code>和<code>GE0/0/1</code>接口连接终端网段，只有终端 PC，没有 OSPF 路由器。然而，接口已经激活了 OSPF，会周期性的发送<code>Hello</code>报文，但是 PC 无法识别、也不需要识别<code>Hello</code>报文。这时，可以把 RT1 的<code>GE0/0/0</code>和<code>GE0/0/1</code>配置成静默接口（<code>Silent-Interface</code>），接口就会禁止收发<code>Hello</code>报文。</p>
<p>R1 的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[RT1]ospf 1</span><br><span class="line">[RT1-ospf-1]silent-interface GigabitEthernet 0/0/0</span><br><span class="line">[RT1-ospf-1]silent-interface GigabitEthernet 0/0/1</span><br></pre></td></tr></table></figure>
<p>虽然两个接口指定为<code>Silent-Interface</code>，但是已经使用 network 命令激活 OSPF，因此 RT2 还是能通过 OSPF 学习到这两个接口网段的路由。</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/9.png" class="">

<h1 id="OSPF-多区域实验"><a href="#OSPF-多区域实验" class="headerlink" title="OSPF 多区域实验"></a>OSPF 多区域实验</h1><img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/10.png" class="">

<p>RT1 和 RT2 是两台汇聚交换机，各自下挂两个终端网段，同时上连核心交换机 RT3 。在三台路由器上部署 OSPF ，使用多区域 OSPF 的设计，实现全网各个网段的数据互通。</p>
<p>RT1 的配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[RT1]ospf 1 router-id 1.1.1.1</span><br><span class="line">[RT1-ospf-1]area 1</span><br><span class="line">[RT1-ospf-1-area-0.0.0.1]network 172.16.1.0 0.0.0.255</span><br><span class="line">[RT1-ospf-1-area-0.0.0.1]network 172.16.2.0 0.0.0.255</span><br><span class="line">[RT1-ospf-area-0.0.0.1]quit</span><br><span class="line">[RT1-ospf-1]area 0</span><br><span class="line">[RT1-ospf-1-area-0.0.0.o]network 172.16.0.0 0.0.0.3</span><br></pre></td></tr></table></figure>
<p>RT2 的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[RT2]ospf 1 router-id 2.2.2.2</span><br><span class="line">[RT2-ospf-1]area 2</span><br><span class="line">[RT2-ospf-1-area-0.0.0.2]network 172.16.9.0 0.0.0.255</span><br><span class="line">[RT2-ospf-1-area-0.0.0.2]network 172.16.10.0 0.0.0.255</span><br><span class="line">[RT2-ospf-1-area-0.0.0.2]quit</span><br><span class="line">[RT2-ospf-1]area 0</span><br><span class="line">[RT2-ospf-1-area-0.0.0.o]network 172.16.0.4 0.0.0.3</span><br></pre></td></tr></table></figure>
<p>RT3 的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[RT3]ospf 1 router-id 3.3.3.3</span><br><span class="line">[RT3-ospf-1]area 0</span><br><span class="line">[RT3-ospf-1-area-0.0.0.0]network 172.16.0.0 0.0.0.3</span><br><span class="line">[RT3-ospf-1-area-0.0.0.0]network 172.16.0.4 0.0.0.3</span><br></pre></td></tr></table></figure>
<p>查看 RT3 的 OSPF 邻居表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/11.png" class="">

<p>RT3 和 RT1、RT2 建立的 FULL 的邻接关系，我们再看看 RT3 的路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/12.png" class="">

<p><code>Area0</code>的路由器 RT3，已经学到了 RT1 和 RT2 下连的终端网段路由。这些路由都是区域间路由，根据 RT1 和 RT2 在<code>Area0</code>泛洪的 Type-3 LSA 计算得出，而 RT3 要计算到达<code>Area1</code>和<code>Area2</code>的区域间路由，除了这些网段的 Type-3 LSA，还需要指定 ABR 的位置。作为 ABR，RT1 和 RT2 在泛洪 Type-1 LSA 时，会把 B 比特位设置为 1。因此，通过 Area0 内泛洪的<code>Type-1</code>、<code>Type-2</code>LSA ，RT3 能计算到达 ABR 的最佳路径。使用<code>display ospf abr-asbr</code>命令查看 ABR 和 ASBR 信息：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/13.png" class="">

<p>在 RT1 和 RT2 上查看路由表，看到两台路由器都学到了全网的路由，RT1 和 RT2 下挂的 PC 就可以到达全网各个网段。</p>
<h1 id="OSPF-Cost-值"><a href="#OSPF-Cost-值" class="headerlink" title="OSPF Cost 值"></a>OSPF Cost 值</h1><img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/14.png" class="">

<p>R1 和 R2 连接到相同的一个网段：<code>192.168.100.0/24</code>，同时下连 R3。R1、R2、R3 都激活 OSPF，在相同的 Area 中，接口的 Cost 又是默认值，这时 R3 的路由表中，到达<code>192.168.100.0/24</code>会有两条等价路由：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/15.png" class="">

<p>如果两条链路以主备方式工作，该如何实现呢？一个最简单的方法就是调整接口 Cost 值。比如把 R3 的<code>G0/0/2</code>接口 Cost 值调大，到达<code>192.168.100.0/24</code>的报文会转发给 R1，当 R1 故障时，R3 自动把流量切到 R2。</p>
<p>R3 的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R3]interface GigabitEthernet 0/0/2</span><br><span class="line">[R3-GigabitEthernet0/0/2]ospf cost 100</span><br></pre></td></tr></table></figure>
<p>查看接口参数：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/16.png" class="">

<p>在查看 R3 的路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/17.png" class="">

<p>配置生效。</p>
<h1 id="OSPF-特殊区域"><a href="#OSPF-特殊区域" class="headerlink" title="OSPF 特殊区域"></a>OSPF 特殊区域</h1><img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/18.png" class="">

<p>R1 、R2 、R3 运行 OSPF，R3 把自己的静态路由引入 OSPF，让域内的路由器学习到外部路由。</p>
<h2 id="1、基本配置"><a href="#1、基本配置" class="headerlink" title="1、基本配置"></a>1、基本配置</h2><p>R1 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Rl]ospf i router-id 1.1.1.1</span><br><span class="line">[R1-ospf-l]area 1</span><br><span class="line">[R1-ospf-1-area-0.0.0.l]network 10.1.12.0 0.0.0.255</span><br></pre></td></tr></table></figure>
<p>R2 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[R2]ospf  router-id 2.2.2.2</span><br><span class="line">[R2-ospf-l]area 1</span><br><span class="line">[R2-ospf-1-area-0.0.0.]network 10.1.12.0 0.0.0.255</span><br><span class="line">[R2-ospf-1-area-0.0.0.1]quit</span><br><span class="line">[R2-ospf-1]area 0</span><br><span class="line">[R2-ospf-1-area-0.0.0.0]network 10.1.23.0 0.0.0.255</span><br></pre></td></tr></table></figure>
<p>R3 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[R3]ip route-static 10.3.1.0 24 NULL 0</span><br><span class="line">[R3]ip route-static 10.3.2.0 24 NULL O</span><br><span class="line">[R3]ospf 1 router-id 3.3.3.3</span><br><span class="line">[R3-ospf-1]area 0</span><br><span class="line">[R3-ospf-1-area-0.0.0.o]network 10.1.23.0 0.0.0.255</span><br><span class="line">[R3-ospf-1-area-0.0.0.0]quit</span><br><span class="line">[R3-ospf-1]import-route static</span><br></pre></td></tr></table></figure>
<p>观察 R1 的路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/19.png" class="">

<p>R1 学习到了区域间路由和外部路由，外部路由标记位 O_ASE（ OSPF AS External ）。再看看 R1 的 LSDB：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/20.png" class="">

<p>R1 的 LSDB，有 Type-1、Type-2、Type-3、Type-4、Type-5 LSA。Type-3 LSA 描述到达<code>10.1.23.0/24</code>的区域间路由。Type-4 LSA 描述到达 ASBR，也就是 R3 的路由，是由 ABR R2 产生。Type-5 LSA 描述外部路由<code>10.3.1.0/24</code>和<code>10.3.2.0/24</code>，并在整个 OSPF 域内泛洪，这时 R1 有到达各个网段的路由。</p>
<h2 id="2、Area1-配置为-Stub-区域"><a href="#2、Area1-配置为-Stub-区域" class="headerlink" title="2、Area1 配置为 Stub 区域"></a>2、Area1 配置为 Stub 区域</h2><p>先把 Area1 配置为 Stub 区域，R1 和 R2 的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Rl]ospf 1</span><br><span class="line">[R1-ospf-l]area 1</span><br><span class="line">[R1-ospf-1-area-0.0.0.1]stub</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R2]ospf 1</span><br><span class="line">[R2-ospf-l]area 1</span><br><span class="line">[R2-ospf-1-area-0.0.0.1]stub</span><br></pre></td></tr></table></figure>
<p>某个区域为 Stub 区域，区域内的路由器都要配置成 Stub 区域，否则无法正确建立邻居关系。Stub 区域的 ABR，即 R2，会阻挡 Type-4 、Type-5 LSA 进入区域内，减少 LSA 泛洪的数量，从而减小路由表规模，降低设备负担。</p>
<p>现在 R1 无法学到 OSPF 外部路由，同时 R2 会下发一条用 Type-3 LSA 描述的外部路由，让 Area1 内的路由器访问域外的网络。观察 R1 的路由表和 LSDB：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/21.png" class="">
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/22.png" class="">

<p>R1 的路由表减少，不再有 Type-4 和 Type-5 LSA ，只有 Type-1、Type-2、Type-3 LSA。</p>
<h2 id="3、Area1-配置为-Totally-Stub-区域"><a href="#3、Area1-配置为-Totally-Stub-区域" class="headerlink" title="3、Area1 配置为 Totally-Stub 区域"></a>3、Area1 配置为 Totally-Stub 区域</h2><p>如果要进一步减少 LSA 泛洪，可以把区域间的路由也阻挡。在上个实验的基础上，R2 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R2]ospf 1</span><br><span class="line">[R2-ospf-l]area 1</span><br><span class="line">[R2-ospf-1-area-0.0.0.1]stub no-summary</span><br></pre></td></tr></table></figure>
<p>这时，R2 阻挡 Type-3、Type-4、Type-5 LSA 进入 Area1，同时自动下发一条默认路由，使用 Type-3 LSA 描述。这样当 R1 访问区域外的网络时，就使用默认路由转发数据。</p>
<p>查看 R1 路由表和 LSDB：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/23.png" class="">
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/24.png" class="">

<p>R1 路由表只有一条 0.0.0.0&#x2F;0 的默认路由，极大简化了路由表。同时，R1 的 LSDB 也非常简洁。</p>
<h2 id="4、Area1-配置为-NSSA"><a href="#4、Area1-配置为-NSSA" class="headerlink" title="4、Area1 配置为 NSSA"></a>4、Area1 配置为 NSSA</h2><img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/25.png" class="">

<p>网络发生变化，Area1 的 R1 连着一个外部路由，需要引入 OSPF，让域内路由器获得外部路由，但又希望保持 Stub 区域特性，那么可以把 Area1 配置为 NSSA。在上个实验的基础上，R1 配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[R1]ip route-static 10.1.1.0 24 NULL 0 <span class="comment">#模拟外部路由</span></span><br><span class="line">[R1]ospf 1</span><br><span class="line">[Rl-ospf-l]area 1</span><br><span class="line">[R1-ospf-1-area-0.0.0.1]undo stub</span><br><span class="line">[R1-ospf-1-area-0.0.0.]nssa</span><br><span class="line">[R1-ospf-1-area-0.0.0.1]quit</span><br><span class="line">[R1-ospf-1]import-route static</span><br></pre></td></tr></table></figure>
<p>在 R1 创建静态路由，模拟成外部路由，先取消 Stub 配置，然后配置 NSSA，再把外部路由引入 OSPF。</p>
<p>R2 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[R2]ospf 1</span><br><span class="line">[R2-ospf-l]area 1</span><br><span class="line">[R2-ospf-1-area-0.0.0.]undo stub</span><br><span class="line">[R2-ospf-1-area-0.0.0.1]nssa</span><br></pre></td></tr></table></figure>
<p>某个区域配置为 NSSA，则区域内的所有路由器都要进行相应配置，否则建立邻居关系会出现问题。Area1 区域成为 NSSA 后，会阻挡 Type-4、Type-5 LSA 进入区域。但是 ABR R2 会下发一条 Type-7 LSA 的默认路由，让区域内的路由器，通过默认路由到达域外网络。同时，会向 Area0 通告 Type-5 LSA 描述<code>10.1.1.0/24</code>路由，让 OSPF 其它区域的路由器都学习到这条路由。</p>
<p>查看 R1 的 LSDB ：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/26.png" class="">

<p>R1 的 LSDB 中，有 Type-1、Type-2、Type-3、Type-7 LSA，其中两条 Type-7 LSA，一条是 R1 生成的，描述引入的外部路由<code>10.1.1.0/24</code>，另一条是 R2 生成的，是一条默认路由。再看看 R1 的路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/27.png" class="">

<p>再看看 R3 的 LSDB:</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/28.png" class="">

<p>R3 有三条 Type-5 LSA，其中两条是自己生成的，描述外部路由<code>10.3.1.0/24</code>和<code>10.3.2.0/24</code>，另一条是 R2 生成的，描述外部路由<code>10.1.1.0/24</code>。R2 把从 Area1 收到的 Type-7 LSA 转换成 Type-5 LSA，并通告到 Area0 中。查看 R3 路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/29.png" class="">

<h2 id="5、Area1-配置为-Totally-NSSA"><a href="#5、Area1-配置为-Totally-NSSA" class="headerlink" title="5、Area1 配置为 Totally NSSA"></a>5、Area1 配置为 Totally NSSA</h2><p>为了进一步减少 Area1 的 LSA，把 Area1 配置成 Totally NSSA 实现。在上个实验的基础上，R2 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R2]ospf 1</span><br><span class="line">[R2-ospf-l]area 1</span><br><span class="line">[R2-ospf-1-area-0.0.0.1]nssa no-summary</span><br></pre></td></tr></table></figure>
<p>这样 Area1 内不会有 Type-3 LSA 泛洪，R1 也学不到区域间路由。</p>
<p>看下 R1 的 LSDB：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/30.png" class="">

<p>R1 的 LSDB 中，只有 Type-1、Type-2、Type-7 LSA 和一条描述的默认路由 Type-3 LSA。当 NSSA 内同时存在 Type-3 LSA 和 Type-7 LSA 描述的默认路由时，路由器优先使用 Type-3 LSA 的默认路由，忽略 Type-7 LSA 的默认路由。</p>
<h1 id="Virtual-Link"><a href="#Virtual-Link" class="headerlink" title="Virtual Link"></a>Virtual Link</h1><img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/31.png" class="">

<p>R1、R2、R3 运行 OSPF，规划两个区域<code>Area0</code>和<code>Area23</code>。R3 有两条路由到达<code>192.168.2.0/24</code>网段，因为 R3 不能使用非 0 区域的 Type-3 LSA 来计算区域间路由，因此无论路径的 Cost 如何，R3 都会选择 R1 到达目的网段。查看 R3 的 OSPF 路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/32.png" class="">

<p>如果向让 R3 从 R2 到达<code>192.168.2.0/24</code>，即使用高带宽链路转发，一个简单的方法是，在 R2 和 R3 之间跨越<code>Area23</code>建立一条<code>Virtual Link</code>，通过这条<code>Virtual Link</code>，R2 直接把 Type-1 LSA 发送给 R3。</p>
<p>R2 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R2]ospf 1</span><br><span class="line">[R2-ospf-l]area 23</span><br><span class="line">[R2-ospf-1-area-0.0.0.23]vlink-peer 3.3.3.3</span><br></pre></td></tr></table></figure>
<p>R3 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R3]ospf 1</span><br><span class="line">[R3-ospf-l]area 23</span><br><span class="line">[R3-ospf-1-area-0.0.0.23]vlink-peer 2.2.2.2</span><br></pre></td></tr></table></figure>
<p>配置完成后，R2 和 R3 建立一条<code>Virtual Link</code>，<code>Virtual Link</code>穿过 Area23，在 R3 查看<code>Virtual Link</code>信息：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/33.png" class="">

<p><code>Virtual Link</code>建立完成后，状态为<code>Full</code>，Cost 为 1，再看下 R3 的 OSPF 路由表：</p>
<img src="/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E5%AE%9E%E6%88%98/34.png" class="">

<p><code>192.168.2.0/24</code>路由的下一跳变成了<code>192.168.23.2</code>，说明到达这个网段的下一跳切换到了 R2，达到预期目标。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/STP详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/STP%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2023-05-08T06:37:12.277Z" itemprop="datePublished">2023-05-08</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="网络环路"><a href="#网络环路" class="headerlink" title="网络环路"></a>网络环路</h1><p>现在我们的生活已经离不开网络，如果我家断网，我会抱怨这什么破网络，影响我刷抖音、打游戏；如果公司断网，那老板估计会骂娘，因为会影响到公司正常运转，直接造成经济损失。网络通信中，通常是以一条链路能够正常工作为前提，如果链路断开或节点故障，那么互联的设备就无法正常通信了，这类网络问题叫做单点故障。没有备份的链路或节点，出现故障会直接断网。</p>
<img src="/2023/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/STP%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>如果要提供 7×24 小时不间断的服务，那就需要在网络中提前部署冗余。避免出现单点故障，合理的做法是在网络中的关键设备和关键链路添加冗余。在冗余的网络环境中，任意一条链路发生故障断开，都不会影响网络，直接使用其它链路继续转发数据，解决单点故障的隐患。</p>
<img src="/2023/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/STP%E8%AF%A6%E8%A7%A3/2.png" class="">

<p>但同时也带来了另外的网络问题。这种组网会构成二层环路，会引发广播风暴、重复帧、MAC 地址漂移等问题，严重时会占满链路带宽，或打爆设备 CPU，导致设备无法正常工作，最终造成网络瘫痪。当然，在实际的网络中，不少二层环路是由于人为的错误操作导致的，比如接错了网线。</p>
<img src="/2023/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/STP%E8%AF%A6%E8%A7%A3/3.png" class="">

<p>举个栗子：</p>
<p>大刘的主机想要与小美的主机进行通信，现在只知道小美主机的 IP 地址，不知道 MAC 地址。有 IP 地址，就可以通过 ARP 协议来获取小美主机的 MAC 地址。我们来看看有冗余的网络中数据交换的过程：</p>
<img src="/2023/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/STP%E8%AF%A6%E8%A7%A3/4.png" class="">

<ol>
<li>大刘主机向交换机 A 发送 ARP 广播帧，来解析小美主机的 MAC 地址；  </li>
<li>交换机 A 收到广播帧后，查看自己的 MAC 地址表，没找到相应的表项，就向所有端口（除接收端口之外）泛洪这个广播帧。也就是向 G0&#x2F;1 和 G0&#x2F;2 两个端口泛洪广播帧；  </li>
<li>交换机 B 和交换机 C 收到广播帧后，没有对应 MAC 地址表项，也将广播帧所有端口（除接收端口之外）泛洪出去；  </li>
<li>小美主机终于收到了大刘发送的 ARP 广播帧，发现是查询自己的 MAC 地址后，小美主机将会通过单播帧返回自己的 MAC 地址；  </li>
<li>这个过程看似正常，大刘主机发送的 ARP 广播帧顺利到达小美主机，小美主机也进行了响应，但是网络中广播帧的传输还没有结束。在第 3 步中，交换机 C 也把 ARP 广播帧泛洪到交换机 B 。这时交换机 B 就收到了两个相同的 ARP 广播帧，分别来自交换机 A 和交换机 C ，收到的广播帧都会泛洪出去。那么，小美主机也会收到两个相同的 ARP 广播帧，也就是重复帧。出现这种现象说明网络中存在不合理的冗余链路；  </li>
<li>接下来我们看下交换机 C ，交换机 C 收到从交换机 A 发过来的广播帧，同时交换机 C 的 MAC 地址表添加一条表项，记录大刘主机 MAC 地址和端口 G0&#x2F;0 的映射关系。交换机 C 又从交换机 B 收到相同的广播帧，大刘主机 MAC 地址的映射端口从 G0&#x2F;0 变成 G0&#x2F;1 。从不同的端口收到相同的数据帧，导致 MAC 地址表项发生变化的现象，就叫做 MAC 地址漂移，这种现象说明网络中可能存在环路。这样一来，交换机 C 就无法确定大刘主机到底位于自己的哪个端口；  </li>
<li>主机收到广播帧，会进行解封装，查看上层的 IP 地址是否是发送给自己的，再进行下一步处理。交换机（只指二层交换机）收到广播帧，会直接进行泛洪。大刘主机发出的广播帧，经过交换机 A 后，从交换机 A 的 G0&#x2F;1 口泛洪的广播帧，交换机 B 收到后再从 G0&#x2F;2 口进行泛洪，交换机 C 收到广播帧后，又从 G0&#x2F;0 口泛洪出去，结果广播帧回到了交换机 A ，交换机 A 再从 G0&#x2F;1 进行泛洪，最终这个广播帧会一直逆时针、永无止境的进行泛洪；同理，交换机 A 从 G0&#x2F;2 口进行泛洪的广播帧，也会按顺时针、无休止的在三台交换机上进行泛洪。这种广播帧不停泛洪的现象，叫做广播风暴。广播风暴不仅会大量消耗网络设备的带宽和 CPU 使用率，也会影响到主机。主机收到一个广播帧后，会解封装上送网络层去处理，大量的广播帧泛洪，很可能导致主机瘫痪。  </li>
</ol>
<p>通过这个简单的演示，我们看到了冗余链路带来的风险。重复帧、MAC 地址漂移和广播风暴，都是由一个广播帧引起的，可是网络中不可避免出现广播帧，也不能因为二层环路问题而忽略冗余链路增加网络可靠性的好处。</p>
<p>那么如何在保证网络冗余的情况下，消除二层环路呢？实际上交换机的二层环路是一个典型问题，解决方案也有不少。其中的一个解决方案就是 STP（生成树协议），能够阻断冗余链路来消除可能存在的环路，并且在网络故障时激活被阻断的冗余备份链路，恢复网络的连通性，保障业务的不间断服务。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/WLAN"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/" class="article-date">
  <time datetime="2023-05-06T12:06:17.460Z" itemprop="datePublished">2023-05-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CSMA-x2F-CA"><a href="#CSMA-x2F-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h1><p>以太网用 CSMA&#x2F;CD 进行传输控制，而 IEEE 802.11 的 WLAN 采用的是 CSMA&#x2F;CA。</p>
<p>CSMA&#x2F;CD ，全称<code>Carrier Sense Multiple Access with Collision Detection</code>，即 载波侦听多路访问&#x2F;冲突检测协议。</p>
<p>载波侦听（<code>Carrier Sense</code>），是指网络中的各个设备在发送数据前，都要确认确认线路上有没有数据传输。如果有数据传输，就不发送数据；如果没有数据传输，马上发送数据。</p>
<p>多路访问（<code>Multiple Access</code>），是指网络上所有设备收发数据，共同使用同一条线路，而且发送的数据是广播型。</p>
<p>冲突检测（<code>Collision Detection</code>），是指设备在发送数据帧的同时，还必须监听线路情况，判断是否发生冲突。也就是说，同一时刻，有没有其它设备也在发送数据帧。</p>
<p>以太网的冲突域是指数据发送时，检测出冲突，当发生冲突时等待一段随机时间再次发送。而在 WLAN 中，如果遇到其它设备正在发送数据，那么就在设备发送完成后，再等待一段随机时间，采继续发送数据。这就是冲突避免（<code>CA ，Collision Avoidance</code>）。因为在对方设备发送完后直接发送数据，也有可能会造成无线传输冲突。</p>
<p>以太网中，传输介质是网线或光纤，能够通过电气信号检测冲突的发生。但由于无线网络不会产生电气信号，因此需要使用 CSMA&#x2F;CA 来替代 CSMA&#x2F;CD。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">以太网</th>
<th align="center">WLAN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">标准</td>
<td align="center">IEEE802.3</td>
<td align="center">IEEE802.11</td>
</tr>
<tr>
<td align="center">地址</td>
<td align="center">MAC 地址</td>
<td align="center">MAC 地址</td>
</tr>
<tr>
<td align="center">传输介质</td>
<td align="center">线缆</td>
<td align="center">无线电波</td>
</tr>
<tr>
<td align="center">接入控制</td>
<td align="center">CSMA&#x2F;CD</td>
<td align="center">CSMA&#x2F;CA</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">半双工&#x2F;全双工</td>
<td align="center">半双工</td>
</tr>
</tbody></table>
<h1 id="WLAN-的架构"><a href="#WLAN-的架构" class="headerlink" title="WLAN 的架构"></a>WLAN 的架构</h1><p>STA ，全称<code>Station</code>，即工作站，是指配有无线网卡的无线终端，比如：手机、电脑等。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/1.png" class="">

<p>AP，全称<code>Wireless Access Point</code>，即无线 AP，用来连接 STA 和有线网络的网络设备。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/2.png" class="">

<p>IBSS，全称<code>Independent Basic Service Set</code>，即独立基本服务集，包含一个及以上 STA 的无线网络，也叫做 ad-hoc 无线网络，无法访问 DS 时使用的模式。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/3.png" class="">

<p>BSS，全称<code>Basic Service Set</code>，即基本服务集，由一个 AP 和一个及以上 STA 组成的无线网络。BSS 内所有的 STA 通信都是通过 AP 完成，AP 不仅能连接有线网络，还可以在 STA 和 其它 STA 或 DS 节点之间进行桥接。</p>
<p>ESS，全称<code>Extended Service Set</code>，即扩展服务集，同一有线网络连接的、两个及以上的 AP 组成，和一个子网概念类似。</p>
<p>DS，全称<code>Distribution System</code>，即分发系统，让不同 BSS 内的 AP 通过 DS 互连，STA 可以从一个 BSS 移动到另一个 BSS。AP 之间可以是无线互连，也可以是有线互连，通常是使用有线互连。DS 是 BSS 之间进行逻辑连接的基础，让 STA 在 BSS 之间能够实现漫游。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/4.png" class="">

<h1 id="WLAN-的拓扑结构"><a href="#WLAN-的拓扑结构" class="headerlink" title="WLAN 的拓扑结构"></a>WLAN 的拓扑结构</h1><p>WLAN 的拓扑结构分为两种，一种是终端之间直接互连的<code>ad-hoc</code>模式，另一种是通过 AP 连接有线网络的基础设施模式。</p>
<p><code>ad-hoc</code>模式，全称<code>ad-hoc mode</code>，即 IEEE 802.11 无线网络的 BSS，在两台 STA 之间直接进行无线通信，而组成的网络，也叫做点对点的网络模式。通常是笔记本电脑和打印机进行无线连接或多台游戏机进行联机对战时使用。终端一般配置了无线网卡。这个模式下，终端是不能连接到互联网上的。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/5.png" class="">

<p>基础设施模式，全称<code>Infrastructure Mode</code>，是指 802.11 无线网络的 BSS 形式组网，通常是通过 AP 连接到互联网时使用。在这个模式下，除了有 STA 外，还需要有 AP 才能连接到互联网。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/6.png" class="">

<h2 id="WLAN-的接入点"><a href="#WLAN-的接入点" class="headerlink" title="WLAN 的接入点"></a>WLAN 的接入点</h2><p>有线网络通过有线线缆把终端和交换机连接起来，组成网络。而无线网络的基础设施模式中，是通过一种叫做 AP 的设备，把多台终端连接到有线网络中。AP 也叫做接入点，接入点通常有 RJ-45 网络接口，用来连接到交换机或路由器上，从而让无线网络的终端能够访问有线网络或互联网。</p>
<h1 id="WLAN-标准"><a href="#WLAN-标准" class="headerlink" title="WLAN 标准"></a>WLAN 标准</h1><p>和以太网一样，WLAN 的标准也是有 IEEE 组织制定的。以太网标准统称为 IEEE 802.3，而 WLAN 标准统称为 802.11。</p>
<p>和 IEEE 802.3 一样，IEEE 802.11 在物理层和数据链路层之间也定义了 MAC 子层。定义了 WLAN 采用哪种频带和调制方式，传输速率达到多大等传输标准，还定义了安全性、QoS 、管理等相关内容。</p>
<table>
<thead>
<tr>
<th align="center">IEEE 标准</th>
<th align="center">名称</th>
<th align="center">年份</th>
<th align="center">频带</th>
<th align="center">最大传输速率</th>
<th align="center">调制方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">802.11</td>
<td align="center">WiFi0</td>
<td align="center">1997年</td>
<td align="center">2.4GHz</td>
<td align="center">2Mbit&#x2F;s</td>
<td align="center">DSSS</td>
</tr>
<tr>
<td align="center">802.11b</td>
<td align="center">WiFi1</td>
<td align="center">1999年</td>
<td align="center">2.4GHz</td>
<td align="center">11Mbit&#x2F;s</td>
<td align="center">DSSS</td>
</tr>
<tr>
<td align="center">802.11a</td>
<td align="center">WiFi2</td>
<td align="center">1999年</td>
<td align="center">5GHz</td>
<td align="center">54Mbit&#x2F;s</td>
<td align="center">OFDM</td>
</tr>
<tr>
<td align="center">802.11g</td>
<td align="center">WiFi3</td>
<td align="center">2003年</td>
<td align="center">2.4GHz</td>
<td align="center">54Mbit&#x2F;s</td>
<td align="center">OFDM</td>
</tr>
<tr>
<td align="center">802.11n</td>
<td align="center">WiFi4</td>
<td align="center">2009年</td>
<td align="center">2.4GHz&#x2F;5GHz</td>
<td align="center">600Mbit&#x2F;s</td>
<td align="center">OFDM</td>
</tr>
<tr>
<td align="center">802.11ac Wave 1</td>
<td align="center">WiFi5</td>
<td align="center">2013年</td>
<td align="center">5GHz</td>
<td align="center">3.46Gbit&#x2F;s</td>
<td align="center">OFDM</td>
</tr>
<tr>
<td align="center">802.11ac Wave 2</td>
<td align="center">WiFi5</td>
<td align="center">2016年</td>
<td align="center">5GHz</td>
<td align="center">6.96Gbit&#x2F;s</td>
<td align="center">OFDM</td>
</tr>
<tr>
<td align="center">802.11ax</td>
<td align="center">WiFi6</td>
<td align="center">2018年</td>
<td align="center">2.4GHz&#x2F;5GHz</td>
<td align="center">9.6Gbit&#x2F;s</td>
<td align="center">OFDMA</td>
</tr>
</tbody></table>
<h2 id="IEEE-802-11n"><a href="#IEEE-802-11n" class="headerlink" title="IEEE 802.11n"></a>IEEE 802.11n</h2><p><code>IEEE 802.11n</code>之前的标准已经不多见了。<code>IEEE 802.11n</code>，又叫做 WiFi 4，标准在 2009 年制定完成，最大传输速率是<code>600 Mbit/s</code>，使用 MIMO 多通道技术让传输速率大幅提升。也能向下兼容<code>IEEE 802.11a、IEEE 802.11b、IEEE 802.11g</code>。</p>
<h2 id="IEEE-802-11ac"><a href="#IEEE-802-11ac" class="headerlink" title="IEEE 802.11ac"></a>IEEE 802.11ac</h2><p><code>IEEE 802.11ac</code>，又叫做 WiFi 5，有两个版本，分别是：Wave 1、Wave 2。区别是 Wave 1 使用 80 Mhz 频宽和 SU-MIMO 技术，最大传输速率是<code>3.46 Gbit/s</code>。而 Wave 2 是使用 160 Mhz 频宽和 DL MU-MIMO 技术，最大传输速率是<code>6.93 Gbit/s</code>。频带和调制方式等都相同。</p>
<h2 id="IEEE-802-11ax"><a href="#IEEE-802-11ax" class="headerlink" title="IEEE 802.11ax"></a>IEEE 802.11ax</h2><p><code>IEEE 802.11ax</code>，又叫做 WiFi 6，标准在 2018 年制定完成，最大传输速率是<code>9.6 Gbit/s</code>。WiFi 6 同时支持 2.4G 和 5G 频段，完整涵盖低速与高速设备，覆盖范围更远。支持 WPA 3 安全协议，无线网络更安全。支持 TWT 技术，能够更省电。简单的说，就是速度更快、延时更低、容量更低、更安全、更省电。</p>
<h2 id="什么是-WiFi"><a href="#什么是-WiFi" class="headerlink" title="什么是 WiFi"></a>什么是 WiFi</h2><p>WiFi 是基于<code>IEEE 802.11</code>标准的、不同厂家为产品的品牌认证。既然有<code>IEEE 802.11</code>标准了，为什么还要有 WiFi 认证？这是因为<code>IEEE 802.11</code>正式标准推出的时间周期长，而无线网络发展迅猛，各个厂家等不及正式标准，自己组成了 WiFi 联盟，并完成互联互通的认证。</p>
<p>实际上，并不是每个<code>IEEE 802.11</code>产品都申请了 WiFi 联盟的认证，那么缺少 WiFi 认证的产品，并不一定兼容 WiFi 设备。但是经过 WiFi 认证的 STA 或 AP 都能无障碍的互联互通。</p>
<p>在酒店或公共场所中，经常看到“免费 WiFi 上网”的标识，这就表示这里的 AP 已经通过了 WiFi 认证。除了电脑和手机，家电和游戏机也可以完成 WiFi 认证。</p>
<p>WiFi 还定义了类似 WPA 这种无线加密的相关标准。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/7.png" class="">

<h1 id="WLAN-的功能"><a href="#WLAN-的功能" class="headerlink" title="WLAN 的功能"></a>WLAN 的功能</h1><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>使用 WLAN 的终端要通过 AP 完成无线连接，才能连接到互联网或有线网络。</p>
<p>无线终端连接 AP 的过程叫做关联（<code>Association</code>）。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/8.png" class="">

<p>STA 可以和连接不同的 AP，但是同一时刻，只能连接在一个 AP 上。AP 会定期发送<code>beacon</code>帧，STA 根据<code>beacon</code>帧的内容，获取 AP 的 SSID 信息、支持的无线传输速率，以及无线信道等信息。</p>
<p>STA 在关联过程中，会向 AP 发送关联请求数据帧，AP 收到请求后，就向 STA 返回带有状态码的关联响应数据帧。</p>
<p>STA 会确认 AP 发过来的状态码，如果是<code>successful</code>，表示关联成功，如果返回其它信息，表示关联失败。STA 在收到<code>successful</code>的同时，还会分配一个 Association ID（AID）的识别号。</p>
<p>WLAN 认证的过程，是在关联过程之前发生的。</p>
<h2 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h2><img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/9.png" class="">

<p>IEEE 802.11 的 MAC 数据帧的字段信息如下：</p>
<ul>
<li><code>Protocol Version</code>：协议版本，表示 IEEE 802.11 协议的版本。</li>
<li><code>Type</code>：类型，表示数据帧的功能，有控制帧、管理帧、数据帧三种。</li>
<li><code>Subtype</code>：子类型，每种数据帧都有多个子类型，实现特定的功能。</li>
<li><code>To DS</code>和<code>From DS</code>：DS 是指分布式系统，用与 AP 和关联的 STA 之间传送的数据帧类型。值为 1 时，表示发送源是 AP，值为 0 时，表示发送源是 STA。</li>
<li><code>More Frag</code>：把上层分组进行分片后，进行发送时使用。值为 1 时，表示后续存在分片数据帧。值为 0 时，表示当前数据帧是最后的分片，或不存在分片数据帧。</li>
<li><code>Retry</code>：表示是否重发数据帧。值为 1 时，表示再次发送数据帧。值为 0 时，表示不再发送这个数据帧。</li>
<li><code>More Data</code>：表示是否存在后续发送的分组。值为 1 时，表示存在后续分组。</li>
<li><code>WEP</code>：表示是否进行 WEP 加密。值为 1 时，表示进行加密。</li>
<li><code>Order</code>：值为 1 时，表示数据帧严格按照 strictly ordered（发送接收顺无法替换）的标准进行发送。</li>
</ul>
<p>IEEE 802.11 的数据帧可分为三类：</p>
<ul>
<li>管理帧<br>1、广播无线信号的<code>beacon</code>帧，默认情况下，每 100 毫秒 AP 广播一次。<br>2、认证使用认证帧：AP 和 STA 进行信息交互时，使用的关联帧。</li>
<li>控制帧</li>
<li>数据帧</li>
</ul>
<p>通常数据帧的 Address 1 表示目的地址，Address 2 表示源地址，Address 3 表示 BSSID 信息。</p>
<h1 id="接入点的接入控制"><a href="#接入点的接入控制" class="headerlink" title="接入点的接入控制"></a>接入点的接入控制</h1><p>由于无线电波是看不见的，会出现陌生用户在未经允许时，擅自接入 AP 使用的情况发生。只要在无线信号能够到达的范围内，并知道 SSID，STA 就能够和 AP 进行关联。为了防止未知的人使用，可以使用 ESSID 隐藏功能和 MAC 地址过滤功能。</p>
<h2 id="ESSID-隐藏"><a href="#ESSID-隐藏" class="headerlink" title="ESSID 隐藏"></a>ESSID 隐藏</h2><p>SSID 信息是由 AP 的 beacon 帧定期进行广播发送的。STA 通过 beacon 帧来确认和那个 SSID 进行连接。但是，只有是无线信号能够到达的地方，任何人都可以通过 beacon 帧，使用 STA 搜索到 SSID 信息并连接。</p>
<p>为了防范这类风险，可以使用不发出 beacon 帧的 ESSID 隐藏功能。STA 需要通过其它途径获得 SSID 信息，并在 STA 进行相应配置，从而隐藏网络连接。</p>
<p>但是，由于 SSID 在无线网络的传播中，没有加密，当有 STA 使用这个隐藏的 SSID 连接 AP 时，可以通过无线监控工具获取这个无线网络的 SSID，所以 ESSI 隐藏功能不是很安全的对策。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/10.png" class="">

<h2 id="MAC-地址过滤"><a href="#MAC-地址过滤" class="headerlink" title="MAC 地址过滤"></a>MAC 地址过滤</h2><p>在 AP 中设置允许关联的 MAC 地址列表，只有在列表里面的 STA 才能连上无线网络，防止以外的 STA 接入 AP，这个方法叫做 MAC 地址过滤或 MAC 地址认证。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/11.png" class="">

<p>除了在 AP 上设置外，还可以通过 RADIUS 服务器设置允许接入的 MAC 地址信息，在认证的同时完成 MAC 地址过滤。但是，MAC 地址也能通过工具伪装和冒充，可以对接入 WLAN 的 MAC 地址进行监听，获得具体的 MAC 地址信息，所以这也不是完善的安全策略。</p>
<h1 id="接入点的认证"><a href="#接入点的认证" class="headerlink" title="接入点的认证"></a>接入点的认证</h1><p>在 AP 上使用 ESSID 隐藏和 MAC 地址过滤功能，都不能完全阻止恶意访问，为了彻底防止恶意用户访问无线网络，需要进行认证。</p>
<p>IEEE 802.11 最开始有两种认证方式：开放系统认证、共享密钥认证。</p>
<p>开放系统认证<br>开发系统认证（<code>Open System Authentication</code>）不用 STA 输入用户名和密码等认证信息，就可以向 AP 发出认证请求。AP 能够接收所有接入认证请求，也就是说，无论是谁都可以和 AP 关联上。通常用于公共 WiFi ，结合 Portal 认证或 VPN 来完成用户访问网络的权限控制。</p>
<p>共享密钥认证<br>共享密钥认证（<code>Shared Key Authentication</code>）用于 AP 和 STA 进行无线加密通信。使用 WEP 或 WPA 加密标准时，AP 和 STA 预先配置相同的口令，通过这个口令就可以建立无线通信链路。这个口令叫做预共享密钥（<code>pre-shared key</code>），不知道预共享密钥的 STA，是无法和 AP 进行关联的。</p>
<p>IEEE 802.1X<br>IEEE 802.1X 是用户认证和访问控制协议，是从有线网络中引用过来的。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/12.png" class="">

<p>IEEE 802.1X 认证是由认证客户端、接入设备、认证服务器三部分组成。请求认证的终端叫做认证客户端，和终端连接的 AP、交换机及其它网络设备叫做接入设备。认证方式使用 EAP，客户端发起认证请求，接入设备会把收到的 EAP 消息封装成 RADIUS 数据帧，转发给认证服务器，当认证服务器完成认证后，接入设备会通知客户端并把客户端作为认证成功的客户端，之后客户端发送的数据帧都会转发到局域网或互联网上。</p>
<p>认证信息是使用用户名、口令、数字证书等其中一种方式即可，对应的认证协议有 EAP-MD5、EAP-TLS、EAP-TTLS 等各种类型。</p>
<h1 id="WLAN-通信的加密"><a href="#WLAN-通信的加密" class="headerlink" title="WLAN 通信的加密"></a>WLAN 通信的加密</h1><p>空气中传输的无线电波，只要是在覆盖范围内，就能被任何人收到，再加上 WLAN 数据解析工具，恶意用户就能够窃听无线网络的通信内容。</p>
<p>为了防止无线通信被窃听和篡改，要在无线通信过程中，对信息进行加密。WLAN 加密有 WEP、WPA、WPA2、WPA3 等标准。</p>
<h2 id="WEP"><a href="#WEP" class="headerlink" title="WEP"></a>WEP</h2><p>WEP，全称<code>Wired Equivalent Privacy</code>，即有线等效保密。WEP 加密是最早在无线加密中使用的技术，基于 RC4 算法的密钥对数据进行加密，这个密钥叫做 WEP key。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/13.png" class="">

<p>WEP 一共有三种加密方式：40 bit 长度的密钥和 24 bit 长度的初始向量值组成 64 bit 长的加密方式，104 bit 长度的密钥和 24 bit 长度的初始向量值组成 128 bit 长的加密方式，128 bit 长度的密钥和 24 bit 长度的初始向量值组成 152 bit 长的加密方式。密钥长度越短，破解时间也越短，现在已经不怎么使用了。</p>
<h2 id="WPA"><a href="#WPA" class="headerlink" title="WPA"></a>WPA</h2><p>WEP 实在太脆弱了，于是就制定了 WPA，全称<code>WiFi Protected Access</code>，即 WiFi 保护接入。</p>
<p>WPA 把 SSID 和 WEP 密钥一起加密，并且能定期自动更新用户认证功能和密钥的 TKIP。</p>
<p>WPA 有两种模式：个人模式和企业模式。</p>
<ul>
<li>个人模式的 WPA 主要是家庭和个人使用，也叫做 WPA-PSK，AP 和 STA 使用相同的预共享密钥（PSK）。</li>
<li>企业模式的 WPA 主要用于企业，增加了 IEEE 802.1X 认证服务器，不同的用户使用不同的用户名和密码连接无线网络。</li>
</ul>
<h2 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h2><p>WPA2 是新一代 WPA 标准，采用 AES 加密算法。AES 常用于 IPsec 和 SSL 等协议中，比 RC4 的安全性更高。AES 支持长度是 128 bit 、196 bit 、256 bit 的密钥，WPA2 使用其中的 128 bit 长度类型。WPA2 兼容上一代 WPA，支持 WPA2 的设备和只支持 WPA 的设备也能通信。AES 采用了类似 TKIP 的协议 CCMP，其中 CBC-MAC 是密码段连接&#x2F;消息认证码的意思。</p>
<p>AP 的加密设置可以选择 WPA-PSK（TKIP）、WPA-PSK（AES）、WPA2-PSK（TKIP）或 WPA2-PSK（AES）。</p>
<h2 id="WPA3"><a href="#WPA3" class="headerlink" title="WPA3"></a>WPA3</h2><p>2017 年 10 月，802.11 协议中沿用 13 年的 WPA2 加密被完全破解。2018 年 6 月 26 日，WiFi 联盟宣布 WPA3 协议已最终完成，这是 WiFi 连接的新标准。</p>
<p>WPA3 在 WPA2 的基础上增加了新的功能，以简化 WiFi 安全保障方法、实现更可靠的身份验证，提高数据加密强度。所有的 WPA3 网络都必须进行管理帧保护 PMF，保证数据的安全性。</p>
<p>根据 WiFi 网络的用途和安全需求的不同，WPA3 又分为 WPA3 个人版、WPA3 企业版，即 WPA3-SAE 和 WPA3-802.1X。WPA3 为不同网络提供了额外功能：WPA3 个人版增强了对密码安全的保护，而 WPA3 企业版的用户可以选择更高级的安全协议，保护敏感数据。</p>
<p>WPA3 个人版<br>对比 WPA2 个人版，WPA3 个人版能提供更可靠的基于密码的身份验证。这是由于 WPA3 个人版使用了更安全的协议：对等实体同时验证 SAE（<code>Simultaneous Authentication of Equals</code>）。SAE 取代了 WPA2 个人版的 PSK 认证方式，可以有效地抵御离线字典攻击，增加暴力破解的难度。SAE 能够提供前向保密，即使攻击者知道了网络中的密码，也不能解密获取到的流量，大大提升了 WPA3 个人网络的安全。WPA3 个人版只支持 AES 加密方式。</p>
<p>SAE 在 WPA&#x2F;WPA2-PSK 原有的四次握手前增加了 SAE 握手，实质上是为了动态协商成对主密钥 PMK。WPA&#x2F;WPA2-PSK 的 PMK 只与 SSID 和预共享密钥有关，而 SAE 引入了动态随机变量，每次协商的 PMK 都是不同的，提升了安全性。</p>
<p>WPA3 企业版</p>
<p>企业、政府和金融机构为了更高的安全性可以采用 WPA3 企业版。WPA3 企业版基于 WPA2 企业版，提供一种可选模式：WPA3-Enterprise 192bit ，这个模式的优点有：</p>
<p>数据保护：使用 192 位的 Suite-B 安全套件，增加密钥的长度。</p>
<p>密钥保护：使用 HMAC-SHA-384 在 4 次握手阶段导出密钥。</p>
<p>流量保护：使用伽罗瓦计数器模式协议 GCMP-256（ Galois Counter Mode Protocol ）保护用户上线后的无线流量。</p>
<p>管理帧保护：使用 GMAC-256（ GCMP 的伽罗瓦消息认证码，Galois Message Authentication Code ）保护组播管理帧。</p>
<p>WPA2 企业版支持多种 EAP 方式的身份验证，但是 WPA3 企业版仅支持 EAP-TLS 的方式。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/14.png" class="">

<h1 id="WLAN-的桥接"><a href="#WLAN-的桥接" class="headerlink" title="WLAN 的桥接"></a>WLAN 的桥接</h1><p>在无法布线的楼宇之间、在物理位置较远的站点之间，可以通过无线桥接进行无线连接。无线桥接是通过无线上连，有线下连的方式组网。</p>
<p>在通信距离较长时，需要使用定向天线来增强某个特定方向的电波强度。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/15.png" class="">

<h1 id="什么是无线中继？"><a href="#什么是无线中继？" class="headerlink" title="什么是无线中继？"></a>什么是无线中继？</h1><p>AP 上连无线接口当做 STA，连接其它 AP 释放的 SSID。AP 下连无线接口释放相同的 SSID，让 STA 接入，这就是无线中继。通过连接中继器，将 STA 收到的数据转发给拥有相同 SSID 的 AP，就能扩大无线网络的范围。一级中继器连接后，网络吞吐率会减半。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/16.png" class="">

<h1 id="无线网络的最大速率"><a href="#无线网络的最大速率" class="headerlink" title="无线网络的最大速率"></a>无线网络的最大速率</h1><p>无线网络和有线网络都是有理论的最大速率，比如：常见的以太网的 10Gbit&#x2F;s 和 WiFi 6 的 9.6Gbit&#x2F;s，这些是说在进行数据通信时，传输的极限速率。</p>
<p>由于无线网络中使用了 CSMA&#x2F;CA 的冲突回避协议，数据在发送时有等待的时间。因此，WiFi 6 的最大理论速率是 9.6Gbit&#x2F;s，实际使用时最大速度可能不到 80%。</p>
<h1 id="无线网络的速率跟距离有关吗？"><a href="#无线网络的速率跟距离有关吗？" class="headerlink" title="无线网络的速率跟距离有关吗？"></a>无线网络的速率跟距离有关吗？</h1><p>STA 能够进行通信的最大距离半径叫做覆盖范围。根据 STA 和 AP 的距离不同，最大速率也会不同，离 AP 越远，通信延迟越大，数据传输速率也越低。在没有障碍物时，无线网络的覆盖范围是同心圆的形状分布。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/17.png" class="">

<h1 id="WiFi-5"><a href="#WiFi-5" class="headerlink" title="WiFi 5"></a>WiFi 5</h1><p>WiFi 5 ，也就是 802.11ac 标准。对比 802.11n ，WiFi 5 主要有四个方面的提升：更宽的频宽绑定、更多的空间流、更先进的调制技术、更灵活的 MIMO 机制。</p>
<p>信道绑定：802.11n 引入了信道绑定技术，是把两个 20MHz 的信道捆绑在一起。而 WiFi 5 能够支持 160MHz 的信道，也就是绑定了 8 个信道。如果 802.11a&#x2F;b&#x2F;g 是单车道的话，而 802.11n 就是双车道，到来 WiFi 5 就达到八车道。</p>



<h1 id="WiFi-6"><a href="#WiFi-6" class="headerlink" title="WiFi 6"></a>WiFi 6</h1><p>WiFi 6，其实就是<code>802.11ax</code>标准。对比 WiFi 5，WiFi 6 的提升是更完整的频带覆盖、更高阶的调制方式、更全面的 MU-MIMO、引入 OFDMA 技术、新增 TWT 机制。</p>
<p>同时支持<code>2.4GHz</code>和<code>5GHz</code>频段：WiFi5 只支持 5G 频段，虽然 5G 的频段资源丰富，但穿透力差，在信号覆盖较弱。而 WiFi 6 同时支持<code>2.4GHz</code>和<code>5GHz</code>频段，<code>2.4G</code>信号覆盖效果更好，完整涵盖低速与高速设备。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/24.png" class="">

<p>高阶调试方式：WiFi 6 支持 1024-QAM，高于 WiFi 5 的 256-QAM，单载波承载的数据量可以达到 10bit，意味着更高的数据传输速率。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/25.png" class="">

<p>完整 MU-MIMO：WiFi 5 引入 MU-MIMO 功能，但是支持数据下载，上传数据时还是走得 SU-MIMO。而 WiFi6 是完整版的 MU-MIMO 功能，支持数据上行和下行。8 × 8 MU-MIMO，表示最多可以同时支持八个终端传输数据。虽然 AP 可以接入多个终端，但是没使用 MU-MIMO 技术之前，都是一个接着一个收发数据的，AP 每次只能和一个终端传输数据，只是时间间隔是毫秒级，我们无法感知而已。WiFi 6 就是真正意义上的八个终端同时传输数据了，适用于高密的无线网络场景。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/26.png" class="">

<p>OFDMA 技术：WiFi6 在在 OFDM 的基础上加入多址（即多用户）技术，从而演进成 OFDMA。实际上 OFDMA 将帧结构重新设计，细分成若干资源单元，为多个用户服务。</p>
<p>以 20MHz 信道为例，在 OFDM 方案（即 WiFi 4&#x2F;WiFi 5）里每一帧由 52 个数据子载波组成，但由于这一帧只为一个终端服务。传输的数据包太小时（像聊天记录）。空载的子载波也无法分配给其他终端。</p>
<p>而在 OFDMA 方案（即 WiFi 6）里每一帧由 234 个数据子载波组成，每 26 个子载波定义为一个 RU（资源单元），每个 RU 可以为一个终端服务，简单除一下，每一帧就可以被分成 9 份，最多可以同时为 9 个用户服务。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/27.png" class="">

<p>用卡车来货来解释这个技术最方便直观了。OFDM 技术是为每一个客户发一次货车。不管货物多少，来一单发一趟，这样不免就有货车空载的现象。而 OFDMA 技术会将多个订单合在一起发货，让卡车尽量满载上路，使得运输效率大大提升。</p>
<p>不但如此，WiFi6 下 OFDMA 和 MU-MIMO 的效果可以叠加。两者呈现出一种互补关系，OFDMA 适用于小数据包的并行传输提高信道利用率和传输效率。而 MU-MIMO 则适用于大数据包的并行传输，提高单用户的有效带宽，同样能减少时延。</p>
<p>TWT机制：WiFi 6 加入了 TWT 机制（<code>Target Wake Time</code>）。TWT 机制是专门针对类似智能家居这样的低速设备而设置的。例如配置 2.4GHz 频段、20MHz 频带的 WiFi 终端。AP 会自动生成一个数据交换用的唤醒时间，在网络数据传输不高的时段，依次唤醒这些低速设备进行数据交换，比如下载最新数据库、上传生成数据等操作。这样慢速设备不再长时间占用带宽，可以有效避免网络拥堵。这也是一种优化网络带宽利用率的技术手段。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/28.png" class="">

<p>WiFi 6 计算最大速率时，使用 160MHz 模式、1024-QAM 调制方式、800ns 的保护间隔时长，WiFi 6 单条流速率可达 1.2 Gbit&#x2F;s，八条流速率高达 9.6Gbit&#x2F;s。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/29.png" class="">
<h1 id="WLAN-的信道"><a href="#WLAN-的信道" class="headerlink" title="WLAN 的信道"></a>WLAN 的信道</h1><p>WLAN 标准中，使用<code>2.4GHz</code>和<code>5GHz</code>频带，各个频带都有多条信道。在设置 AP 时，为了防止干扰，需要把相同信道的 AP 隔离开来。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/30.png" class="">

<h2 id="2-4G-信道"><a href="#2-4G-信道" class="headerlink" title="2.4G 信道"></a>2.4G 信道</h2><p>WLAN 的 2.4G 信道频宽是<code>83.5MHz</code>，频率范围是<code>2.4~2.4835 GHz</code>，实际一共划分了 14 个信道，中国是使用前面的 13 个信道，信道编号是<code>1~13</code>。每个信道的有效宽度是<code>20 MHz</code>，另外还有<code>2MHz</code>的强制隔离频带，类似公路上的隔离带。对于中心频率是<code>2412MHz</code>的信道 1，频率范围是<code>2401~2423 MHz</code>。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/31.png" class="">

<p>但并不是说，只要选择数字不同的信道，就一定不会发生干扰。信道 1 使用的频率和 信道<code>2~5</code>是有一部分的重合，因此还是会发生干扰。这样看来，肯定不会发生干扰的信道组合是 1、6、11。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/32.png" class="">
<h2 id="5G-信道"><a href="#5G-信道" class="headerlink" title="5G 信道"></a>5G 信道</h2><p>WLAN 的 5G 信道频宽资源就丰富些，一共是<code>700MHz</code>的频宽，频率范围是<code>5.15~5.85 GHz</code>，中国一共有 13 个<code>20MHz</code>信道，信道编号是 36、40、44、48、52、56、60、64、149、153、157、161、165，并且所有信道都是互不干扰的，可以直接使用。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/33.png" class="">

<p>从<code>802.11n</code>开始，可以同时使用相邻的信道，组成<code>40MHz、80MHz、160MHz</code>的频宽进行数据传输。</p>
<img src="/2023/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/WLAN/34.png" class="">

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/HTTPS"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/" class="article-date">
  <time datetime="2023-05-04T01:16:01.958Z" itemprop="datePublished">2023-05-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h1><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</li>
<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h2 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li>篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/1.png" class="">

<p>HTTPS 在 HTTP 与 TCP 层之间加入了 TLS 协议，可以很好的解决了上述的风险：</p>
<ul>
<li>信息加密： HTTP 交互信息是被加密的，第三方就无法被窃取；</li>
<li>校验机制：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；</li>
<li>身份证书：证明淘宝是真的淘宝网；</li>
</ul>
<p>可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么在进行 HTTP 通信前，需要先进行 TLS 握手。</p>
<p>TLS 的握手过程，如下图：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/2.png" class="">

<p>上图简要概述了 TLS 的握手过程，其中每一个「框」都是一个记录（record），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p>
<p>所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p>
<p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p>
<p>因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</p>
<p>接下来，我们就以最简单的 RSA 密钥交换算法，来看看它的 TLS 握手过程。</p>
<h1 id="RSA-握手过程"><a href="#RSA-握手过程" class="headerlink" title="RSA 握手过程"></a>RSA 握手过程</h1><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p>
<p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>
<p>我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/3.png" class="">

<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/4.png" class="">

<h2 id="TLS-第一次握手"><a href="#TLS-第一次握手" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h2><p>客户端首先会发一个<code>Client Hello</code>消息，字面意思我们也能理解到，这是跟服务器「打招呼」。</p>


<p>消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（<code>Client Random</code>），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p>
<h2 id="TLS-第二次握手"><a href="#TLS-第二次握手" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h2><p>当服务端收到客户端的<code>Client Hello</code>消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（<code>Server Random</code>）。</p>
<p>接着，返回<code>Server Hello</code>消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（<code>Server Random</code>），然后从客户端的密码套件列表选择了一个合适的密码套件。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/6.png" class="">

<p>可以看到，服务端选择的密码套件是<code>Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256</code>。</p>
<p>这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：</p>
<ul>
<li>由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；</li>
<li>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</li>
<li>摘要算法 SHA256 用于消息认证和产生随机数；</li>
</ul>
<p>就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。</p>
<p>那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。</p>
<p>然后，服务端为了证明自己的身份，会发送<code>Server Certificate</code>给客户端，这个消息里含有数字证书。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/7.png" class="">

<p>随后，服务端发了<code>Server Hello Done</code>消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/8.png" class="">

<h2 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h2><p>在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？</p>
<h3 id="数字证书和-CA-机构"><a href="#数字证书和-CA-机构" class="headerlink" title="数字证书和 CA 机构"></a>数字证书和 CA 机构</h3><p>在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：</p>
<ul>
<li>公钥；</li>
<li>持有者信息；</li>
<li>证书认证机构（CA）的信息；</li>
<li>CA 对这份文件的数字签名及使用的算法；</li>
<li>证书有效期；</li>
<li>还有一些其他额外信息；</li>
</ul>
<p>那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。</p>
<p>我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？</p>
<p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA（<code>Certificate Authority</code>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p>
<p>之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。</p>
<h3 id="数字证书签发和验证流程"><a href="#数字证书签发和验证流程" class="headerlink" title="数字证书签发和验证流程"></a>数字证书签发和验证流程</h3><p>如下图图所示，为数字证书签发和验证流程：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/9.png" class="">

<p>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成<code>Certificate Signature</code>，也就是 CA 对证书做了签名；</li>
<li>最后将<code>Certificate Signature</code>添加在文件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密<code>Certificate Signature</code>内容，得到一个 Hash 值 H2；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
<h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><p>但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/10.png" class="">

<p>对于这种三级层级关系的证书的验证过程如下：</p>
<ul>
<li>客户端收到<code>baidu.com</code>的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据<code>baidu.com</code>证书中的签发者，找到该证书的颁发机构是<code>GlobalSign Organization Validation CA - SHA256 - G2</code>，然后向 CA 请求该中间证书。</li>
<li>请求到证书后发现<code>GlobalSign Organization Validation CA - SHA256 - G2</code>证书是由<code>GlobalSign Root CA</code>签发的，由于<code>GlobalSign Root CA</code>没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证<code>GlobalSign Organization Validation CA - SHA256 - G2</code>证书，如果发现验证通过，就认为该中间证书是可信的。</li>
<li><code>GlobalSign Organization Validation CA - SHA256 - G2</code>证书被信任后，可以使用<code>GlobalSign Organization Validation CA - SHA256 - G2</code>证书中的公钥去验证<code>baidu.com</code>证书的可信性，如果验证通过，就可以信任<code>baidu.com</code>证书。</li>
</ul>
<p>在这四个步骤中，最开始客户端只信任根证书<code>GlobalSign Root CA</code>证书的，然后<code>GlobalSign Root CA</code>证书信任<code>GlobalSign Organization Validation CA - SHA256 - G2</code>证书，而<code>GlobalSign Organization Validation CA - SHA256 - G2</code>证书又信任<code>baidu.com</code>证书，于是客户端也信任<code>baidu.com</code>证书。</p>
<p>总括来说，由于用户信任<code>GlobalSign</code>，所以由<code>GlobalSign</code>所担保的<code>baidu.com</code>可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的<code>GlobalSign</code>都可被信任。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/11.png" class="">

<p>这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/12.png" class="">

<h2 id="TLS-第三次握手"><a href="#TLS-第三次握手" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h2><p>客户端验证完证书后，认为可信则继续往下走。</p>
<p>接着，客户端就会生成一个新的随机数 (<code>pre-master</code>)，用服务器的 RSA 公钥加密该随机数，通过<code>Client Key Exchange</code>消息传给服务端。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/13.png" class="">

<p>服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (<code>pre-master</code>)。</p>
<p>至此，客户端和服务端双方都共享了三个随机数，分别是<code>Client Random、Server Random、pre-master</code>。</p>
<p>于是，双方根据已经得到的三个随机数，生成会话密钥（Master Secret），它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p>
<p>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/14.png" class="">

<p>然后，客户端再发一个<code>Encrypted Handshake Message（Finishd）</code>消息，把之前所有发送的数据做个摘要，再用会话密钥加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/15.png" class="">

<p>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p>
<h2 id="TLS-第四次握手"><a href="#TLS-第四次握手" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h2><p>服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p>
<p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p>
<h2 id="RSA-算法的缺陷"><a href="#RSA-算法的缺陷" class="headerlink" title="RSA 算法的缺陷"></a>RSA 算法的缺陷</h2><p>使用 RSA 密钥协商算法的最大问题是不支持前向保密。</p>
<p>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p>
<p>为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。</p>
<h1 id="ECDHE-握手解析"><a href="#ECDHE-握手解析" class="headerlink" title="ECDHE 握手解析"></a>ECDHE 握手解析</h1><h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><p>ECDHE 密钥协商算法是 DH 算法演进过来的，所以我们先从 DH 算法说起。</p>
<p>DH 算法是非对称加密算法， 因此它可以用于密钥交换，该算法的核心数学思想是离散对数。</p>
<p>离散对数是「离散 + 对数」的两个数学概念的组合，所以我们先来复习一遍对数。</p>
<p>要说起对数，必然要说指数，因为它们是互为反函数，指数就是幂运算，对数是指数的逆运算。</p>
<p>举个栗子，如果以 2 作为底数，那么指数和对数运算公式，如下图所示：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/16.png" class="">

<p>那么对于底数为 2 的时候， 32 的对数是 5，64 的对数是 6，计算过程如下：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/17.png" class="">

<p>对数运算的取值是可以连续的，而离散对数的取值是不能连续的，因此也以「离散」得名，</p>
<p>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，对应编程语言的操作符是「%」，也可以用 mod 表示。离散对数的概念如下图：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/18.png" class="">

<p>上图的，底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。</p>
<p>特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。</p>
<h2 id="DH-算法"><a href="#DH-算法" class="headerlink" title="DH 算法"></a>DH 算法</h2><p>认识了离散对数，我们来看看 DH 算法是如何密钥交换的。</p>
<p>现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。</p>
<p>然后小红和小明各自生成一个随机整数作为私钥，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。</p>
<p>现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出公钥：</p>
<p>小红的公钥记作 A，A &#x3D; G ^ a ( mod P )；<br>小明的公钥记作 B，B &#x3D; G ^ b ( mod P )；</p>
<p>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。</p>
<p>双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。</p>
<p>然后小红执行运算： B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： A ^ b ( mod P )，得到的结果也是 K。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/19.png" class="">

<p>这个 K 就是小红和小明之间用的对称加密密钥，可以作为会话密钥使用。</p>
<p>可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。</p>
<p>前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。</p>
<h2 id="DHE-算法"><a href="#DHE-算法" class="headerlink" title="DHE 算法"></a>DHE 算法</h2><p>根据私钥生成的方式，DH 算法分为两种实现：</p>
<ul>
<li>static DH 算法，这个是已经被废弃了；</li>
<li>DHE 算法，现在常用的；</li>
</ul>
<p>static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。</p>
<p>于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 static DH 算法不具备前向安全性。</p>
<p>既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。</p>
<p>所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」。</p>
<h2 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h2><p>DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— ECDHE 算法。</p>
<p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p>
<p>小红和小明使用 ECDHE 密钥交换算法的过程：</p>
<p>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；<br>双方各自随机生成一个随机数作为私钥d，并与基点 G相乘得到公钥Q（Q &#x3D; dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；<br>双方交换各自的公钥，最后小红计算点<code>(x1，y1) = d1Q2</code>，小明计算点<code>(x2，y2) = d2Q1</code>，由于椭圆曲线上是可以满足乘法交换和结合律，所以<code>d1Q2 = d1d2G = d2d1G = d2Q1</code>，因此双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥。<br>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p>
<h2 id="ECDHE-握手过程"><a href="#ECDHE-握手过程" class="headerlink" title="ECDHE 握手过程"></a>ECDHE 握手过程</h2><p>知道了 ECDHE 算法基本原理后，我们就结合实际的情况来看看。</p>
<p>我用 Wireshark 工具抓了用 ECDHE 密钥协商算法的 TSL 握手过程，可以看到是四次握手：</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/20.png" class="">

<p>细心的小伙伴应该发现了，使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。</p>
<p>所以，ECDHE 相比 RSA 握手过程省去了一个消息往返的时间，这个有点「抢跑」的意思，它被称为是「TLS False Start」，跟「TCP Fast Open」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。</p>
<p>接下来，分析每一个 ECDHE 握手过程。</p>
<h3 id="TLS-第一次握手-1"><a href="#TLS-第一次握手-1" class="headerlink" title="TLS 第一次握手"></a>TLS 第一次握手</h3><p>客户端首先会发一个「Client Hello」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random）。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/21.png" class="">

<h3 id="TLS-第二次握手-1"><a href="#TLS-第二次握手-1" class="headerlink" title="TLS 第二次握手"></a>TLS 第二次握手</h3><p>服务端收到客户端的「打招呼」，同样也要回礼，会返回「Server Hello」消息，消息面有服务器确认的 TLS 版本号，也给出了一个随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/22.png" class="">

<p>不过，这次选择的密码套件就和 RSA 不一样了，我们来分析一下这次的密码套件的意思。</p>
<p>「 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384」</p>
<p>密钥协商算法使用 ECDHE；<br>签名算法使用 RSA；<br>握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM；<br>摘要算法使用 SHA384；<br>接着，服务端为了证明自己的身份，发送「Certificate」消息，会把证书也发给客户端。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/23.png" class="">

<p>这一步就和 RSA 握手过程有很大的区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「Server Key Exchange」消息。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/24.png" class="">

<p>这个过程服务器做了三件事：</p>
<p>选择了名为 x25519 的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；<br>生成随机数作为服务端椭圆曲线的私钥，保留到本地；<br>根据基点 G 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端。<br>为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。</p>
<p>随后，就是「Server Hello Done」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/25.png" class="">

<p>至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：<code>Client Random、Server Random</code>、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥，这几个信息很重要，是后续生成会话密钥的材料。</p>
<h3 id="TLS-第三次握手-1"><a href="#TLS-第三次握手-1" class="headerlink" title="TLS 第三次握手"></a>TLS 第三次握手</h3><p>客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。</p>
<p>客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「Client Key Exchange」消息发给服务端。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/26.png" class="">

<p>至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，但实际应用中，x 还不是最终的会话密钥。</p>
<p>还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？</p>
<p>最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的。</p>
<p>之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算不出最终的会话密钥，安全性更高。</p>
<p>算好会话密钥后，客户端会发一个「Change Cipher Spec」消息，告诉服务端后续改用对称算法加密通信。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/27.png" class="">

<p>接着，客户端会发「Encrypted Handshake Message」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。</p>
<img src="/2023/05/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/28.png" class="">

<h3 id="TLS-第四次握手-1"><a href="#TLS-第四次握手-1" class="headerlink" title="TLS 第四次握手"></a>TLS 第四次握手</h3><p>最后，服务端也会有一个同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RSA 和 ECDHE 握手过程的区别：<br>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；<br>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；<br>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/RIP实战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP%E5%AE%9E%E6%88%98/" class="article-date">
  <time datetime="2023-04-26T10:27:59.589Z" itemprop="datePublished">2023-04-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="RIPv2-基础配置"><a href="#RIPv2-基础配置" class="headerlink" title="RIPv2 基础配置"></a>RIPv2 基础配置</h1><p>下面的拓扑图中有三台路由器，我们在路由器上部署 RIPv2 ，让网络中的各个网段能够实现互通。</p>
<img src="/2023/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP%E5%AE%9E%E6%88%98/1.png" class="">

<p>RT1 配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;Huawei&gt;system-view</span><br><span class="line">[Huawei]sysname RT1</span><br><span class="line">[RT1]interface GigabitEthernet 0/0/0</span><br><span class="line">[RT1-GigabitEthernet0/0/0]ip address 192.168.1.1 30</span><br><span class="line">[RT1-GigabitEthernet0/0/0]quit</span><br><span class="line">[RT1]interface GigabitEthernet 0/0/1</span><br><span class="line">[RT1-GigabitEthernet0/0/1]ip address 172.16.1.254 24</span><br><span class="line">[RT1-GigabitEthernet0/0/1]quit</span><br><span class="line">[RT1]</span><br><span class="line">[RT1]rip 1</span><br><span class="line">[RT1-rip-1]version 2</span><br><span class="line">[RT1-rip-1]network 192.168.1.0</span><br><span class="line">[RT1-rip-1]network 172.16.0.0</span><br></pre></td></tr></table></figure>
<p>配置说明：</p>
<ul>
<li><code>rip 1</code>：数字 1 表示 RIP 的进程 ID。如果不配置，系统会自动生成一个。一个设备运行不同 RIP 进程，使用进程 ID 区分，且相互独立。</li>
<li><code>version 2</code>：配置 RIP 的版本，这里配置的是 RIPv2。</li>
<li><code>network 192.168.1.0</code>：<code>network</code>命令用于网段的激活。</li>
<li><code>network 172.16.0.0</code>：需要注意的是<code>network</code>命令指定的必须是主类网络地址，而不是子网地址。如果使用<code>network 172.16.1.0</code>命令，那么系统会报错，因为<code>172.16.1.0</code>是一个子网地址，而不是主类地址。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/三层交换机"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/"
    >三层交换机</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/" class="article-date">
  <time datetime="2023-04-15T12:46:11.000Z" itemprop="datePublished">2023-04-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>三层交换机是在二层交换机的基础上，增加了路由选择功能的网络设备，能够基于 ASIC 和 FPGA 实现网络功能和转发分组。</p>
<p>二层交换机能够基于数据链路层的 MAC 地址，进行数据帧或 VLAN 的传输功能。三层交换机能够基于网络层的 IP 地址，实现路由选择以及分组过滤等功能。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/1.png" class="">

<p>二层交换机通过使用 VLAN 分隔广播域，位于同一个 VLAN 下的终端才能进行数据帧交互。对于不同 VLAN 的终端有通信需求时，就必须使用路由功能，也就是需要额外添加路由器。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/2.png" class="">

<p>二层交换机和路由器组合使用，才能完成跨 VLAN 的通信，但使用三层交换机就不需要其它网络设备，能够直接完成不同 VLAN 之间的通信。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/3.png" class="">

<p>现在，内部网络核心交换机都是使用三层交换机。三层交换机用于由以太网构成的 Intranet 内部转发分组，而路由器作为连接互联网和 Intranet 内网之间的网关来使用。</p>
<h1 id="三层交换机和路由器的不同"><a href="#三层交换机和路由器的不同" class="headerlink" title="三层交换机和路由器的不同"></a>三层交换机和路由器的不同</h1><p>三层交换机一般只支持以太网的数据链路层协议和 IP 网络的网络层协议。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">三层交换机</th>
<th align="center">路由器</th>
</tr>
</thead>
<tbody><tr>
<td align="center">硬件</td>
<td align="center">箱式、框式</td>
<td align="center">桌面式、箱式、框式</td>
</tr>
<tr>
<td align="center">数据帧处理</td>
<td align="center">基于ASCI的硬件处理</td>
<td align="center">基于CPU的软件处理</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">线速处理</td>
<td align="center">比三层交换机慢</td>
</tr>
<tr>
<td align="center">接口</td>
<td align="center">以太网（RJ-45、光收发器）</td>
<td align="center">以太网（RJ-45、光收发器）、串口、ISDN、ATM、SDH等</td>
</tr>
<tr>
<td align="center">不支持的协议、功能</td>
<td align="center">拨号接入（PPP、PPoE）高QoS、NAT、VPN、状态检测、高安全功能、VoIP等</td>
<td align="center">STP&#x2F;RSTP、LAN tranking、私有VLAN等</td>
</tr>
</tbody></table>
<p>路由器的物理层和数据链路层除了 IEEE 802 标准以外，还支持其它各种协议，包括 ATM、SDH、串口等。网络层和传输层也一样，支持 TCP&#x2F;IP 协议簇以外的协议簇，比如 IPX 、AppleTalk 等。这些功能都是由运行在 CPU 上的软件来完成，对比三层交换机，速度会慢不少，但是也有很多功能必须由路由器 CPU 来处理，比如远程接入、安全功能等。</p>
<h1 id="三层交换机的架构"><a href="#三层交换机的架构" class="headerlink" title="三层交换机的架构"></a>三层交换机的架构</h1><p>三层交换机的构成要素有：控制平面、数据平面、背板和物理接口。高端路由器和防火墙也是同样的架构。三层交换机把硬件设备内部分成两个区域，即以路由选择、管理功能为主的控制平面和以数据转发功能为主的数据平面，从而实现高速转发分组的系统架构。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/4.png" class="">

<table>
<thead>
<tr>
<th align="center">硬件构成</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">控制平面</td>
<td align="center">通过基于CPU的软件处理进行硬件整体控制。负责操作系统管理、管理员用户界面、路由选择协议处理等工作</td>
</tr>
<tr>
<td align="center">数据平面</td>
<td align="center">通过基于ASIC、FPGA、网络处理器的硬件处理来进行实际的数据传输。在二层上完成MAC数据帧传输、在三层上完成IP分组传输。在传输时也会进行必要的访问控制列表和QoS相关的处理</td>
</tr>
<tr>
<td align="center">背板</td>
<td align="center">完成物理接口之间的数据传输。背板有三种方式：共享总线方式、共享内存方式、纵横通路方式。</td>
</tr>
<tr>
<td align="center">物理接口</td>
<td align="center">与其它硬件之间进行数据帧收发。在三层交换机中使用RJ-45或光收发器接头。</td>
</tr>
</tbody></table>
<p>当硬件内部结构分为控制平面和数据平面时，分组的传输需要使用 FIB（转发信息库）和邻接表的信息。这种利用 FIB 和邻接表信息的 IP 分组传输方式叫做特快转发。</p>
<table>
<thead>
<tr>
<th align="center">表项</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FIB<br>Forwarding Information Base</td>
<td align="center">基于控制面板上路由选择表的信息在数据平面上生成的、由当前有效的目的地址子网、下一跳、输出接口的组合等信息构成的表项</td>
</tr>
<tr>
<td align="center">邻接表<br>adjacency table</td>
<td align="center">基于控制面板上 ARP 表的信息在数据平面上生成的、由当前有效目的地主机和输出接口对等信息构成的表项</td>
</tr>
</tbody></table>
<p>路由器使用 CPU 完成分组转发，而三层交换机使用 ASCI 代替 CPU，分组的转发更快。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/6.png" class="">
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/7.png" class="">

<p>三层交换机将 FIB 和邻接表合并成一个表项，这个表项叫做 FDB（转发数据库），注册在内存中并通过硬件处理完成高速检索。</p>
<h1 id="多层交换"><a href="#多层交换" class="headerlink" title="多层交换"></a>多层交换</h1><p>除了二层交换机之外，三层以上功能的交换机统称为多层交换机。</p>
<p>拥有 IP 路由选择等网络功能、能够通过访问控制列表来对传输层的 TCP 端口编号进行访问控制的三层交换机，也叫做四层交换机。</p>
<p>能够支持到 TCP 层级访问控制的交换机叫做四层交换机。能够基于 HTTP 和 HTTPS 这类应用层参数进行负载均衡等操作，这类交换机叫做七层交换机。</p>
<p>有些厂家将处理到应用层的网络设备和路由器区分开来，作为不同类型的产品。但所谓的多层交换机，也就是基于 ASIC 和 FPGA 的硬件处理，高速进行各层业务处理的网络设备。</p>
<h2 id="负载均衡设备"><a href="#负载均衡设备" class="headerlink" title="负载均衡设备"></a>负载均衡设备</h2><p>多个客户端同时连接一台服务器，可能导致服务器的处理能力超过负载。如果使用多台提供相同服务的服务器，通过使用负载均衡设备，就可以将客户端的请求分散到各个服务器进行处理。</p>
<p>负载均衡设备可以是专用设备，也可以是在服务器上运行的应用程序。专用设备会有以太网接口，可以说是多层交换机的一种。也存在拥有负载均衡功能的路由器。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/8.png" class="">

<p>负载均衡设备一般会分配虚拟 IP 地址，所有客户端的请求是通过虚拟 IP 地址完成的，通过负载均衡算法将客户端的请求转发到服务器的实际 IP 地址上。</p>
<h3 id="负载均衡设备作用"><a href="#负载均衡设备作用" class="headerlink" title="负载均衡设备作用"></a>负载均衡设备作用</h3><p>使用负载均衡设备可以提高扩展性和可靠性。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">提高扩展性</td>
<td align="center">在服务器群处理能力不足时，负载均衡设备能够随时添加一台物理服务器，提高虚拟服务器的性能</td>
</tr>
<tr>
<td align="center">提高可靠性</td>
<td align="center">即使服务器群（即虚拟服务器）中某台服务器发生故障，虚拟服务器也会继续提供服务，因为客户端访问的是虚拟 IP 地址，其它物理服务器能够继续处理业务，确保服务不间断</td>
</tr>
</tbody></table>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/9.png" class="">

<p>负载均衡设备不仅适用于服务器，防火墙或代理服务器这种安全设备也可以使用负载均衡设备。</p>
<h3 id="负载均衡算法类型"><a href="#负载均衡算法类型" class="headerlink" title="负载均衡算法类型"></a>负载均衡算法类型</h3><img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/10.png" class="">

<h3 id="SSL-加速"><a href="#SSL-加速" class="headerlink" title="SSL 加速"></a>SSL 加速</h3><p>SSL 加速是负载均衡专用设备的一项功能，执行这个功能的内部装置叫做 SSL 加速器。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/11.png" class="">

<p>在服务器进行 SSL 通信时，对传输的数据进行加密解密操作需要执行相当复杂的计算，这会导致服务器 CPU 的处理负载进一步加大。与不执行加密解密的 HTTP 通信对比，HTTPS 的处理负载是 HTTP 的 10 倍。</p>
<p>这时，通过使用 SSL 加速器对客户端的 HTTPS 请求进行解密，并转换成 HTTP 请求后再转发到实际的服务器上，这样就可以降低服务器 CPU 的处理负载。</p>
<p>这样一来，整个系统在提高服务器响应速度的同时，还能减少服务器的数量，在单位时间内能够转发更多 Web 服务内容。</p>
<h1 id="三层交换机分类"><a href="#三层交换机分类" class="headerlink" title="三层交换机分类"></a>三层交换机分类</h1><h2 id="根据形状和用途分类"><a href="#根据形状和用途分类" class="headerlink" title="根据形状和用途分类"></a>根据形状和用途分类</h2><p>和二层交换机的分类一样。</p>
<h2 id="根据性能分类"><a href="#根据性能分类" class="headerlink" title="根据性能分类"></a>根据性能分类</h2><p>根据三层交换机的背板容量，可分为高端交换机、中端交换机和低端交换机。</p>
<h3 id="高端三层交换机"><a href="#高端三层交换机" class="headerlink" title="高端三层交换机"></a>高端三层交换机</h3><p>框式三层交换机由路由引擎、交换结构、线卡模块、风扇模块和电源模块组成，一般作为企业的核心交换机用在数据中心。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/12.png" class="">

<p>为了提高交换机的可靠性，除了线卡模块之外，其余模块都提供了冗余结构。电源或风扇模块通常采用 1+N 或 N+N 冗余结构，路由引擎通常采用 1+1 的冗余结构。三层交换机一般通过多台设备堆叠构成三层冗余结构，来提高整个系统的可用性。</p>
<h3 id="中端三层交换机"><a href="#中端三层交换机" class="headerlink" title="中端三层交换机"></a>中端三层交换机</h3><p>中端三层交换机一般是箱式交换机或最大插槽数为 4 的框式交换机，用于企业核心交换机和接入交换机进行汇聚交换。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/13.png" class="">

<h3 id="低端三层交换机"><a href="#低端三层交换机" class="headerlink" title="低端三层交换机"></a>低端三层交换机</h3><p>低端三层交换机一般为箱式交换机或桌面式交换机，作为企业的接入交换机使用，设备通常有 24 端口或 48 端口。有些作为 IP 电话或无线 LAN 的访问接入点，还能直接使用以太网的电源供电（PoE）。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/14.png" class="">

<h1 id="三层交换机功能"><a href="#三层交换机功能" class="headerlink" title="三层交换机功能"></a>三层交换机功能</h1><p>尽管各个厂家的三层交换机提供的功能不同，但是这些功能大致有几个类别：认证类、管理类、路由选择协议、QoS、IP 隧道、VLAN、STP 等。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/15.png" class="">

<p>在三层交换机中，对分组进行管理的功能是由 CPU（软件）直接处理的。用户直接的通信，是由 ASIC（硬件）处理实现分组的高速转发的。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/16.png" class="">

<h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><p>由一台或几台集线器组成的一个广播域可以称为是一个扁平网络。相互连接的终端会接收网络发来的所有广播帧。随着连接终端数量的增加，广播数量也会增加，网络状况也就越混杂。</p>
<p>这种情况下，需要采用 VLAN（<code>Virtual Lan</code>）技术把整个扁平网络进行逻辑分段。一个 VLAN 对应一个广播域，不同 VLAN 的广播域互相隔离，因此能够控制广播域内的广播通信规模。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/17.png" class="">

<p>交换机通过设置，可以轻易的修改物理端口的属性，让这个物理端口加入到某一个 VLAN 之中，而不需要改变对应的物理线路。</p>
<p>VLAN 之间的通信需要使用路由选择，不借助路由器或三层交换机就无法与不同 VLAN 的终端进行通信，因此安全性也有了保障。</p>
<h2 id="基于端口的-VLAN"><a href="#基于端口的-VLAN" class="headerlink" title="基于端口的 VLAN"></a>基于端口的 VLAN</h2><p>基于端口的 VLAN 是在交换机的端口上设置 VLAN ID，拥有相同 VLAN ID 的多个端口构成一个 VLAN。通常交换机在初始状态下，所有端口默认 VLAN ID &#x3D; 1（即 VLAN 1），可以对任意一个端口的 VLAN ID 进行设置。比如把修改某一个端口配置为 VLAN ID &#x3D; 2，那这个端口就属于 VLAN 2。</p>
<h2 id="标签-VLAN"><a href="#标签-VLAN" class="headerlink" title="标签 VLAN"></a>标签 VLAN</h2><p>当 VLAN 需要跨越多个交换机时，会使用中继端口（<code>trunk port</code>）的标签 VLAN（<code>tag VLAN</code>）。tag VLAN 通过中继端口完成数据帧的接收和发送，其中数据帧需要添加 4 字节 IEEE 802.1Q 定义的头部信息（即 VLAN 标签信息）。为数据帧添加标签的过程叫做<code>tagging</code>。当<code>tagging</code>完成后，数据帧的最大长度从 1518 字节变成 1522 字节，其中有<code>12bit</code>的 VLAN ID 信息，也就是说，最多支持的 VLAN 数是 4096 个。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/18.png" class="">
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/19.png" class="">

<p>在以太网中，数据帧中 TPID 的值是<code>0x8100</code>。如果源地址后面的值不是<code>0x8100</code>，那么就不是 TPID 信息，而是识别成“长度&#x2F;类型”。当“长度&#x2F;类型”的值为<code>0x05DC</code>(十进制数为 1500) 以下时，表示数据帧的长度；在<code>0x0600</code>以上时，表示数据帧的类型。数据帧类型的值分别是：IPv4 是<code>0x0800</code>，ARP 是<code>0x0806</code>、IPv6 是<code>0x86DD</code>等。</p>
<p>不支持 IEEE 802.1Q 的交换机，由于无法识别 TPID，会将<code>0x8100</code>视为数据帧类型，但是不存在<code>0x8100</code>类型的数据帧，交换机会作为错误帧直接丢弃。</p>
<p>IEEE 802.1Q 还定义了一个字段：TCI，TCI 可以分为 3 个子数据域：PCP、CFI 和 VID。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/20.png" class="">
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/21.png" class="">

<h2 id="本征-VLAN"><a href="#本征-VLAN" class="headerlink" title="本征 VLAN"></a>本征 VLAN</h2><p>本征 VLAN（<code>native VLAN</code>）用于中继端口（<code>trunk port</code>）。如果数据帧在进入<code>trunk port</code>前，是没有标记的，那么<code>trunk port</code>会给它打上<code>native VLAN</code>的标记，这个数据帧就以<code>native VLAN</code>的身份传输。如果数据帧在进入<code>trunk</code>前，已经打上标记了，且<code>trunk port</code>允许这个 VLAN ID 通过，这个数据帧就通过。<code>trunk port</code>不允许通过的 VLAN 数据帧会直接丢弃。交换机默认使用 VLAN ID 为 1 的 VLAN 作为<code>native VLAN</code>。<code>native VLAN</code>是可以自定义的，通常是使用 VLAN 1 以外的 VLAN 作为本征<code>native VLAN</code>，作为管理 VLAN。</p>
<h2 id="中继端口"><a href="#中继端口" class="headerlink" title="中继端口"></a>中继端口</h2><p>使用标签 VLAN（<code>tag VLAN</code>）向其它交换机传递 VLAN ID 时，首先设置中继端口（<code>trunk port</code>）。<code>trunk port</code>能够属于多个 VLAN，与其它交换机进行多个 VLAN 的数据帧收发通信。两台交换机<code>trunk port</code>之间的链路叫做中继链路（<code>trunk link</code>）。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/22.png" class="">

<p>与<code>trunk port</code>和<code>trunk link</code>对应的，是接入端口（<code>access port</code>）和接入链路（<code>access link</code>）这两个概念。<code>access port</code>只属于一个 VLAN，<code>access link</code>也仅传输一个 VLAN 数据帧。</p>
<h2 id="私有-VLAN"><a href="#私有-VLAN" class="headerlink" title="私有 VLAN"></a>私有 VLAN</h2><p>私有 VLAN（<code>Private VLAN</code>）也叫做 PVLAN，是指在 VLAN 内部再构建一层 VLAN 的功能，也叫做多层 VLAN。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/23.png" class="">

<p>PVLAN 能够进一步分割广播域，削减 VLAN 内部的广播流量并保障通信的安全性。酒店、公寓等场所使用这个功能，能够控制服务器或网关与终端的连接，让不同终端之间无法相互通信。</p>
<p>PVLAN 由主 VLAN（<code>Primary VLAN</code>）和从 VLAN（<code>Secondary VLAN</code>）组成，从 VLAN 与 1 个主 VLAN 关联。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/24.png" class="">

<p>使用 PVLAN 的物理端口模式：</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/25.png" class="">

<h2 id="静态-VLAN-和动态-VLAN"><a href="#静态-VLAN-和动态-VLAN" class="headerlink" title="静态 VLAN 和动态 VLAN"></a>静态 VLAN 和动态 VLAN</h2><p>通过输入交换机命令，将一个交换机端口固定分配给某个 VLAN，这种 VLAN 划分方式叫做静态 VLAN。</p>
<p>相对的，根据连接端口的终端或用户信息自动分配某个 VLAN 的方式叫做动态 VLAN。具体来说，就是交换机根据终端的 MAC 地址来分配，或者基于 802.1X 的认证来决定端口属于哪个 VLAN。在动态 VLAN 中，无论终端与哪台交换机连接，都会获取固定的同一个 VLAN。</p>
<p>通过交换机内部的数据库，可以实现基于 MAC 地址的认证，但大部分情况下，动态 VLAN 的实现都是使用 RADIUS 服务器。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/26.png" class="">

<h2 id="VLAN-之间的互通"><a href="#VLAN-之间的互通" class="headerlink" title="VLAN 之间的互通"></a>VLAN 之间的互通</h2><h3 id="二层交换机"><a href="#二层交换机" class="headerlink" title="二层交换机"></a>二层交换机</h3><p>在二层交换机上设置多个 VLAN 后，单台交换机内，数据帧只能在相同 VLAN 内转发，不能在不同 VLAN 之间转发。</p>
<p>当需要在多个 VLAN 之间转发数据时，一般会使用<code>trunk link</code>连接路由器，通过路由器进行 VLAN 之间的路由选择。</p>
<img src="/2023/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA/27.png" class="">

<h3 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h3><p>三层交换机能够在交换机内部直接完成 VLAN 之间的路由选择。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS 代码片段(String)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%20%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(String)/" class="article-date">
  <time datetime="2023-04-13T06:25:51.432Z" itemprop="datePublished">2023-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 1-全大写 2-全小写 3-首字母大写</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">turnCase</span> = (<span class="params">str, type</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">toLowerCase</span>()</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> str[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + str.<span class="title function_">substring</span>(<span class="number">1</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">turnCase</span>(<span class="string">&#x27;vue&#x27;</span>, <span class="number">1</span>) <span class="comment">// VUE</span></span><br><span class="line"><span class="title function_">turnCase</span>(<span class="string">&#x27;REACT&#x27;</span>, <span class="number">2</span>) <span class="comment">// react</span></span><br><span class="line"><span class="title function_">turnCase</span>(<span class="string">&#x27;vue&#x27;</span>, <span class="number">3</span>) <span class="comment">// Vue</span></span><br></pre></td></tr></table></figure>
<h2 id="getURLParameters"><a href="#getURLParameters" class="headerlink" title="getURLParameters"></a>getURLParameters</h2><p>返回包含当前 URL 参数的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getURLParameters</span> = url =&gt;</span><br><span class="line">  (url.<span class="title function_">match</span>(<span class="regexp">/([^?=&amp;]+)(=([^&amp;]*))/g</span>) || []).<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">a, v</span>) =&gt;</span> ((a[v.<span class="title function_">slice</span>(<span class="number">0</span>, v.<span class="title function_">indexOf</span>(<span class="string">&#x27;=&#x27;</span>))] = v.<span class="title function_">slice</span>(v.<span class="title function_">indexOf</span>(<span class="string">&#x27;=&#x27;</span>) + <span class="number">1</span>)), a),</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="title function_">getURLParameters</span>(<span class="string">&#x27;http://url.com/page?name=Adam&amp;surname=Smith&#x27;</span>); <span class="comment">// &#123;name: &#x27;Adam&#x27;, surname: &#x27;Smith&#x27;&#125;</span></span><br><span class="line"><span class="title function_">getURLParameters</span>(<span class="string">&#x27;google.com&#x27;</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS 代码片段(Browser)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2023/04/13/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%20%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(Browser)/" class="article-date">
  <time datetime="2023-04-13T06:25:51.431Z" itemprop="datePublished">2023-04-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="开启全屏"><a href="#开启全屏" class="headerlink" title="开启全屏"></a>开启全屏</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">launchFullscreen</span> = (<span class="params">element</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (element.<span class="property">requestFullscreen</span>) &#123;</span><br><span class="line">    element.<span class="title function_">requestFullscreen</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">mozRequestFullScreen</span>) &#123;</span><br><span class="line">    element.<span class="title function_">mozRequestFullScreen</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">msRequestFullscreen</span>) &#123;</span><br><span class="line">    element.<span class="title function_">msRequestFullscreen</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.<span class="property">webkitRequestFullscreen</span>) &#123;</span><br><span class="line">    element.<span class="title function_">webkitRequestFullScreen</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭全屏"><a href="#关闭全屏" class="headerlink" title="关闭全屏"></a>关闭全屏</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">exitFullscreen</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">exitFullscreen</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">exitFullscreen</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">msExitFullscreen</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">msExitFullscreen</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">mozCancelFullScreen</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">mozCancelFullScreen</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">webkitExitFullscreen</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">webkitExitFullscreen</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解析URL参数"><a href="#解析URL参数" class="headerlink" title="解析URL参数"></a>解析URL参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getSearchParams</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> searchPar = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>)</span><br><span class="line">  <span class="keyword">const</span> paramsObj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> searchPar.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    paramsObj[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> paramsObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设目前位于 https://****com/index?id=154513&amp;age=18;</span></span><br><span class="line"><span class="title function_">getSearchParams</span>(); <span class="comment">// &#123;id: &quot;154513&quot;, age: &quot;18&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="滚动到页面顶部"><a href="#滚动到页面顶部" class="headerlink" title="滚动到页面顶部"></a>滚动到页面顶部</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">scrollToTop</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> height = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span><br><span class="line">  <span class="keyword">if</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(scrollToTop);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, height - height / <span class="number">8</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滚动到元素位置"><a href="#滚动到元素位置" class="headerlink" title="滚动到元素位置"></a>滚动到元素位置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">smoothScroll</span> = element =&gt;&#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(element).<span class="title function_">scrollIntoView</span>(&#123;</span><br><span class="line">    <span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="parseCookie"><a href="#parseCookie" class="headerlink" title="parseCookie"></a>parseCookie</h2><p>解析<code>Cookie</code>标头字符串并返回所有<code>cookie</code>的<code>name-value</code>对的对象。</p>
<ul>
<li>使用<code>String.split(&#39;;&#39;)</code>将键值对彼此分开。</li>
<li>使用<code>Array.map()</code>和<code>String.split(&#39;=&#39;)</code>将键与每对中的值分开。</li>
<li>使用<code>Array.reduce()</code>和<code>decodeURIComponent()</code>创建一个包含所有键值对的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">parseCookie</span> = str =&gt;</span><br><span class="line">  str</span><br><span class="line">    .<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>))</span><br><span class="line">    .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, v</span>) =&gt;</span> &#123;</span><br><span class="line">      acc[<span class="built_in">decodeURIComponent</span>(v[<span class="number">0</span>].<span class="title function_">trim</span>())] = <span class="built_in">decodeURIComponent</span>(v[<span class="number">1</span>].<span class="title function_">trim</span>());</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">parseCookie</span>(<span class="string">&#x27;foo=bar; equation=E%3Dmc%5E2&#x27;</span>); <span class="comment">// &#123; foo: &#x27;bar&#x27;, equation: &#x27;E=mc^2&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="获取选择的文本"><a href="#获取选择的文本" class="headerlink" title="获取选择的文本"></a>获取选择的文本</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSelectedText</span> = (<span class="params"></span>) =&gt; <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSelectedText</span>(); <span class="comment">// &#x27;Lorem ipsum&#x27;</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>