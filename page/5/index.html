<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-python/Python类和对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/15/python/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"
    >Python类和对象</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/15/python/Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2022-12-15T05:38:43.000Z" itemprop="datePublished">2022-12-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="class：定义类"><a href="#class：定义类" class="headerlink" title="class：定义类"></a>class：定义类</h1><p>定义一个类使用<code>class</code>关键字实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名：</span><br><span class="line">  多个（≥0）类属性...</span><br><span class="line">  多个（≥0）类方法...</span><br></pre></td></tr></table></figure>
<p>无论是类属性还是类方法，对于类来说，它们都不是必需的。另外，类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。</p>
<p>类属性指的就是包含在类中的变量；类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。</p>
<p>Python 类是由类头（<code>class</code>类名）和类体（统一缩进的变量和函数）构成。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheFirstDemo</span>:</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个类属性</span></span><br><span class="line">  add = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置，如上面程序中第二行的字符串，就是<code>TheFirstDemo</code>这个类的说明文档。</p>
<p>另外分析上面的代码可以看到，我们创建了一个名为<code>TheFirstDemo</code>的类，其包含了一个名为<code>add</code>的类属性。注意，根据定义属性位置的不同，在各个类方法之外定义的变量称为类属性或类变量（如<code>add</code>属性）。</p>
<p>同时，<code>TheFirstDemo</code>类中还包含一个<code>say()</code>类方法，该方法包含两个参数，分别是<code>self</code>和<code>content</code>。<code>content</code>参数就只是一个普通参数，没有特殊含义，但<code>self</code>比较特殊，并不是普通的参数。</p>
<p>更确切地说，<code>say()</code>是一个实例方法，除此之外，Python 类中还可以定义类方法和静态方法。</p>
<p>事实上，我们完全可以创建一个没有任何类属性和类方法的类，换句话说，Python 允许创建空类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以看到，如果一个类没有任何类属性和类方法，那么可以直接用<code>pass</code>关键字作为类体即可。</p>
<h1 id="init-类构造方法"><a href="#init-类构造方法" class="headerlink" title="init()类构造方法"></a><strong>init</strong>()类构造方法</h1><p>在创建类时，我们可以手动添加一个<code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p>
<p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,...):</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure>
<p>另外，<code>__init__()</code>方法可以包含多个参数，但必须包含一个名为<code>self</code>的参数，且必须作为第一个参数。也就是说，类的构造方法最少也要有一个<code>self</code>参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TheFirstDemo</span>:</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">#构造方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用构造方法&quot;</span>)</span><br><span class="line">  <span class="comment"># 下面定义了一个类属性</span></span><br><span class="line">  add = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>注意，即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含<code>self</code>参数的构造方法。</p>
<p>仅包含<code>self</code>参数的<code>__init__()</code>构造方法，又称为类的默认构造方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan = TheFirstDemo()</span><br></pre></td></tr></table></figure>
<p>这行代码的含义是创建一个名为<code>zhangsan</code>的<code>TheFirstDemo</code>类对象。运行代码可看到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用构造方法</span><br></pre></td></tr></table></figure>
<p>显然，在创建<code>zhangsan</code>这个对象时，隐式调用了我们手动创建的<code>__init__()</code>构造方法。</p>
<p>在<code>__init__()</code>构造方法中，除了<code>self</code>参数外，还可以自定义一些参数，参数之间使用逗号进行分割。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;这是一个学习Python定义的一个类&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, add</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&quot;的英文名为:&quot;</span>, add)</span><br><span class="line"><span class="comment">#创建 add 对象，并传递参数给构造函数</span></span><br><span class="line">add = CLanguage(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然构造方法中有<code>self、name、add</code>3 个参数，但实际需要传参的仅有<code>name</code>和<code>add</code>，也就是说，<code>self</code>不需要手动传递参数。</p>
<h1 id="类对象的创建和使用"><a href="#类对象的创建和使用" class="headerlink" title="类对象的创建和使用"></a>类对象的创建和使用</h1><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><p>对已定义好的类进行实例化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名(参数)</span><br></pre></td></tr></table></figure>
<p>定义类时，如果没有手动添加<code>__init__()</code>构造方法，又或者添加的<code>__init__()</code>中仅有一个<code>self</code>参数，则创建类对象时的参数可以省略不写。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="comment"># 下面定义了2个类变量</span></span><br><span class="line">  name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">  add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, add</span>):</span><br><span class="line">    <span class="comment">#下面定义 2 个实例变量</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.add = add</span><br><span class="line">    <span class="built_in">print</span>(name,<span class="string">&quot;的英文名为：&quot;</span>,add)</span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"><span class="comment"># 将该CLanguage对象赋给clanguage变量</span></span><br><span class="line">clanguage = CLanguage(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，由于构造方法除<code>self</code>参数外，还包含 2 个参数，且这 2 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的<code>name</code>值和<code>add</code>值（<code>self</code>参数是特殊参数，不需要手动传值，Python 会自动传给它值）。</p>
<p>类变量和实例变量，简单地理解，定义在各个类方法之外（包含在类中）的变量为类变量（或者类属性），定义在类方法中的变量为实例变量（或者实例属性）。</p>
<h2 id="类对象的使用"><a href="#类对象的使用" class="headerlink" title="类对象的使用"></a>类对象的使用</h2><p>定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：</p>
<ul>
<li>访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；</li>
<li>调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。</li>
</ul>
<h4 id="类对象访问变量或方法"><a href="#类对象访问变量或方法" class="headerlink" title="类对象访问变量或方法"></a>类对象访问变量或方法</h4><p>使用已创建好的类对象访问类中实例变量的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类对象名.变量名</span><br></pre></td></tr></table></figure>
<p>使用类对象调用类中方法的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(参数)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输出name和add实例变量的值</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.name,clanguage.add)</span><br><span class="line"><span class="comment">#修改实例变量的值</span></span><br><span class="line">clanguage.name=<span class="string">&quot;小红&quot;</span></span><br><span class="line">clanguage.add=<span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment">#调用clanguage的say()方法</span></span><br><span class="line">clanguage.say(<span class="string">&quot;人生苦短，我用Python&quot;</span>)</span><br><span class="line"><span class="comment">#再次输出name和add的值</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.name,clanguage.add)</span><br></pre></td></tr></table></figure>
<h4 id="给类对象动态添加-x2F-删除变量"><a href="#给类对象动态添加-x2F-删除变量" class="headerlink" title="给类对象动态添加&#x2F;删除变量"></a>给类对象动态添加&#x2F;删除变量</h4><p>Python 支持为已创建好的对象动态增加实例变量：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为clanguage对象增加一个money实例变量</span></span><br><span class="line">clanguage.money= <span class="number">159.9</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.money) <span class="comment"># 159.9</span></span><br></pre></td></tr></table></figure>
<p>动态删除使用<code>del</code>语句即可实现：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除新添加的 money 实例变量</span></span><br><span class="line"><span class="keyword">del</span> clanguage.money</span><br><span class="line"><span class="comment">#再次尝试输出 money，此时会报错</span></span><br><span class="line"><span class="built_in">print</span>(clanguage.money)</span><br></pre></td></tr></table></figure>
<p>运行程序会发现，结果显示<code>AttributeError</code>错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:/Users/mengma/Desktop/1.py&quot;, line 29, in &lt;module&gt;</span><br><span class="line">    print(clanguage.money)</span><br><span class="line">AttributeError: &#x27;CLanguage&#x27; object has no attribute &#x27;money&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="给类对象动态添加方法"><a href="#给类对象动态添加方法" class="headerlink" title="给类对象动态添加方法"></a>给类对象动态添加方法</h4><p>Python 也允许为对象动态增加方法。以<code>Clanguage</code>类为例，由于其内部只包含一个<code>say()</code>方法，因此该类实例化出的<code>clanguage</code>对象也只包含一个<code>say()</code>方法。但其实，我们还可以为<code>clanguage</code>对象动态添加其它方法。</p>
<p>需要注意的一点是，为<code>clanguage</code>对象动态增加的方法，Python 不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为<code>self</code>也没用）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;---info函数---&quot;</span>, self)</span><br><span class="line"><span class="comment"># 使用info对clanguage的foo方法赋值（动态绑定方法）</span></span><br><span class="line">clanguage.foo = info</span><br><span class="line"><span class="comment"># Python不会自动将调用者绑定到第一个参数，</span></span><br><span class="line"><span class="comment"># 因此程序需要手动将调用者绑定为第一个参数</span></span><br><span class="line">clanguage.foo(clanguage)  <span class="comment"># ①</span></span><br><span class="line"><span class="comment"># 使用lambda表达式为clanguage对象的bar方法赋值（动态绑定方法）</span></span><br><span class="line">clanguage.bar = <span class="keyword">lambda</span> self: <span class="built_in">print</span>(<span class="string">&#x27;--lambda表达式--&#x27;</span>, self)</span><br><span class="line">clanguage.bar(clanguage) <span class="comment"># ②</span></span><br></pre></td></tr></table></figure>
<p>上面的第 8 行和第 10 行代码分别使用函数、lambda 表达式为<code>clanguage</code>对象动态增加了方法，但对于动态增加的方法，Python 不会自动将方法调用者绑定到它们的第一个参数，因此程序必须手动为第一个参数传入参数值，如上面程序中 ① 号、② 号代码所示。</p>
<p>有没有不用手动给<code>self</code>传值的方法呢？通过借助<code>types</code>模块下的<code>MethodType</code>可以实现：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self,content</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小明的英文名为：%s&quot;</span> % content)</span><br><span class="line"><span class="comment"># 导入MethodType</span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">clanguage.info = MethodType(info, clanguage)</span><br><span class="line"><span class="comment"># 第一个参数已经绑定了，无需传入</span></span><br><span class="line">clanguage.info(<span class="string">&quot;xiaoming&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，由于使用<code>MethodType</code>包装<code>info()</code>函数时，已经将该函数的<code>self</code>参数绑定为<code>clanguage</code>，因此后续再使用<code>info()</code>函数时，就不用再给<code>self</code>参数绑定值了。</p>
<h1 id="self用法"><a href="#self用法" class="headerlink" title="self用法"></a>self用法</h1><p>在定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将<code>self</code>参数作为方法的第一个参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在执行构造方法&quot;</span>)</span><br><span class="line">  <span class="comment"># 定义一个study()实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self,name</span>):</span><br><span class="line">    <span class="built_in">print</span>(name,<span class="string">&quot;正在学Python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>事实上，Python 只是规定，无论是构造方法还是实例方法，最少要包含一个参数，并没有规定该参数的具体名称。之所以将其命名为<code>self</code>，只是程序员之间约定俗成的一种习惯（大家一看到<code>self</code>，就知道它的作用）。</p>
<p>那么，<code>self</code>参数的具体作用是什么呢？打个比方，如果把类比作造房子的图纸，那么类实例化后的对象是真正可以住的房子。根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？</p>
<p>当然是通过<code>self</code>参数，它就相当于每个房子的门钥匙，可以保证每个房子的主人仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。</p>
<p>其实 Python 类方法中的<code>self</code>参数就相当于 C++ 中的<code>this</code>指针。</p>
<p>也就是说，同一个类可以产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，换句话说，Python 会自动绑定类方法的第一个参数指向调用该方法的对象。如此，Python 解释器就能知道到底要操作哪个对象的方法了。</p>
<p>因此，程序在调用实例方法和构造方法时，不需要手动为第一个参数传值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在执行构造方法&quot;</span>)</span><br><span class="line">  <span class="comment"># 定义一个study()实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self, <span class="string">&quot;正在学Python&quot;</span>)</span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.study()</span><br><span class="line">lisi = Person()</span><br><span class="line">lisi.study()</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>study()</code>中的<code>self</code>代表该方法的调用者，即谁调用该方法，那么<code>self</code>就代表谁。因此，该程序的运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在执行构造方法</span><br><span class="line">&lt;__main__.Person object at 0x0000021ADD7D21D0&gt; 正在学Python</span><br><span class="line">正在执行构造方法</span><br><span class="line">&lt;__main__.Person object at 0x0000021ADD7D2E48&gt; 正在学Python</span><br></pre></td></tr></table></figure>
<p>另外，对于构造函数中的<code>self</code>参数，其代表的是当前正在初始化的类对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name=name</span><br><span class="line">zhangsan = Person(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(zhangsan.name) <span class="comment"># zhangsan</span></span><br><span class="line">lisi = Person(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lisi.name) <span class="comment"># lisi</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>zhangsan</code>在进行初始化时，调用的构造函数中<code>self</code>代表的是<code>zhangsan</code>；而<code>lisi</code>在进行初始化时，调用的构造函数中<code>self</code>代表的是<code>lisi</code>。</p>
<p>值得一提的是，除了类对象可以直接调用类方法，还有一种函数调用的方式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">who</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self)</span><br><span class="line">zhangsan = Person()</span><br><span class="line"><span class="comment">#第一种方式</span></span><br><span class="line">zhangsan.who()</span><br><span class="line"><span class="comment">#第二种方式</span></span><br><span class="line">who = zhangsan.who</span><br><span class="line">who()<span class="comment">#通过 who 变量调用zhangsan对象中的 who() 方法</span></span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Person object at 0x0000025C26F021D0&gt;</span><br><span class="line">&lt;__main__.Person object at 0x0000025C26F021D0&gt;</span><br></pre></td></tr></table></figure>
<p>显然，无论采用哪种方法，<code>self</code>所表示的都是实际调用该方法的对象。</p>
<p>总之，无论是类中的构造函数还是普通的类方法，实际调用它们的谁，则第一个参数<code>self</code>就代表谁。</p>
<h1 id="类属性和实例属性"><a href="#类属性和实例属性" class="headerlink" title="类属性和实例属性"></a>类属性和实例属性</h1><p>无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。</p>
<p>在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：</p>
<ul>
<li>类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；</li>
<li>类体中，所有函数内部：以<code>self.变量名</code>的方式定义的变量，称为实例属性或实例变量；</li>
<li>类体中，所有函数内部：以“变量名&#x3D;变量值”的方式定义的变量，称为局部变量。</li>
</ul>
<p>类方法也可细分为实例方法、静态方法和类方法。</p>
<h2 id="类变量（类属性）"><a href="#类变量（类属性）" class="headerlink" title="类变量（类属性）"></a>类变量（类属性）</h2><p>类变量指的是在类中，但在各个类方法外定义的变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="comment"># 下面定义了2个类变量</span></span><br><span class="line">  name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">  add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure>
<p>上面程序中，<code>name</code>和<code>add</code>就属于类变量。</p>
<p>类变量的特点是，所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。类变量的调用方式有 2 种，既可以使用类名直接调用，也可以使用类的实例化对象调用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用类名直接调用</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="comment">#修改类变量的值</span></span><br><span class="line">CLanguage.name = <span class="string">&quot;小红&quot;</span></span><br><span class="line">CLanguage.add = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaohong</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过类名不仅可以调用类变量，也可以修改它的值。</p>
<p>当然，也可以使用类对象来调用所属类中的类变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br><span class="line"><span class="built_in">print</span>(clang.add)</span><br></pre></td></tr></table></figure>
<p>注意，因为类变量为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前，各类对象中类变量的值：&quot;</span>)</span><br><span class="line">clang1 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang1.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang1.add) <span class="comment"># xiaoming</span></span><br><span class="line">clang2 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后，各类对象中类变量的值：&quot;</span>)</span><br><span class="line">CLanguage.name = <span class="string">&quot;小红&quot;</span></span><br><span class="line">CLanguage.add = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang1.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang1.add) <span class="comment"># xiaohong</span></span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaohong</span></span><br></pre></td></tr></table></figure>
<p>显然，通过类名修改类变量，会作用到所有的实例化对象（例如这里的<code>clang1</code>和<code>clang2</code>）。</p>
<p>注意，通过类对象是无法修改类变量的。通过类对象对类变量赋值，其本质将不再是修改类变量的值，而是在给该对象定义新的实例变量。</p>
<p>值得一提的是，除了可以通过类名访问类变量之外，还可以动态地为类和对象添加类变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">CLanguage.catalog = <span class="number">13</span></span><br><span class="line"><span class="built_in">print</span>(clang.catalog) <span class="comment"># 13</span></span><br></pre></td></tr></table></figure>
<h2 id="实例变量（实例属性）"><a href="#实例变量（实例属性）" class="headerlink" title="实例变量（实例属性）"></a>实例变量（实例属性）</h2><p>实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。另外，实例变量只能通过对象名访问，无法通过类名访问。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">    <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    self.catalog = <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>此<code>CLanguage</code>类中，<code>name、add</code>以及<code>catalog</code>都是实例变量。其中，由于<code>__init__()</code>函数在创建类对象时会自动调用，而<code>say()</code>方法需要类对象手动调用。因此，<code>CLanguage</code>类的类对象都会包含<code>name</code>和<code>add</code>实例变量，而只有调用了<code>say()</code>方法的类对象，才包含<code>catalog</code>实例变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="comment">#由于 clang 对象未调用 say() 方法，因此其没有 catalog 变量，下面这行代码会报错</span></span><br><span class="line"><span class="comment">#print(clang.catalog)</span></span><br><span class="line">clang2 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaoming</span></span><br><span class="line"><span class="comment">#只有调用 say()，才会拥有 catalog 实例变量</span></span><br><span class="line">clang2.say()</span><br><span class="line"><span class="built_in">print</span>(clang2.catalog) <span class="comment"># 13</span></span><br></pre></td></tr></table></figure>
<p>通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的实例变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#clang访问类变量</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaoming</span></span><br><span class="line">clang.name = <span class="string">&quot;小红&quot;</span></span><br><span class="line">clang.add = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment">#clang实例变量的值</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaohong</span></span><br><span class="line"><span class="comment">#类变量的值</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaoming</span></span><br></pre></td></tr></table></figure>
<p>显然，通过类对象是无法修改类变量的值的，本质其实是给<code>clang</code>对象新添加<code>name</code>和<code>add</code>这 2 个实例变量。</p>
<p>类中，实例变量和类变量可以同名，但这种情况下使用类对象将无法调用类变量，它会首选实例变量，这也是不推荐“类变量使用对象名调用”的原因。</p>
<p>另外，和类变量不同，通过某个对象修改实例变量的值，不会影响类的其它实例化对象，更不会影响同名的类变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  name = <span class="string">&quot;小明&quot;</span>  <span class="comment">#类变量</span></span><br><span class="line">  add = <span class="string">&quot;xiaoming&quot;</span>  <span class="comment">#类变量</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小红&quot;</span>   <span class="comment">#实例变量</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaohong&quot;</span>   <span class="comment">#实例变量</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    self.catalog = <span class="number">13</span>  <span class="comment">#实例变量</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#修改 clang 对象的实例变量</span></span><br><span class="line">clang.name = <span class="string">&quot;小李&quot;</span></span><br><span class="line">clang.add = <span class="string">&quot;xiaoli&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 小李</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># xiaoli</span></span><br><span class="line">clang2 = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clang2.name) <span class="comment"># 小红</span></span><br><span class="line"><span class="built_in">print</span>(clang2.add) <span class="comment"># xiaohong</span></span><br><span class="line"><span class="comment">#输出类变量的值</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.name) <span class="comment"># 小明</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.add) <span class="comment"># xiaoming</span></span><br></pre></td></tr></table></figure>
<p>不仅如此，Python 只支持为特定的对象添加实例变量。例如，在之前代码的基础上，为<code>clang</code>对象添加<code>money</code>实例变量：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang.money = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(clang.money)</span><br></pre></td></tr></table></figure>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>除了实例变量，类方法中还可以定义局部变量。局部变量直接以“变量名&#x3D;值”的方式进行定义：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self,money</span>):</span><br><span class="line">    sale = <span class="number">0.8</span>*money</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优惠后的价格为：&quot;</span>,sale)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.count(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>通常情况下，定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。</p>
<h1 id="实例方法、静态方法和类方法"><a href="#实例方法、静态方法和类方法" class="headerlink" title="实例方法、静态方法和类方法"></a>实例方法、静态方法和类方法</h1><p>类方法可分为类方法、实例方法和静态方法。采用<code>@classmethod</code>修饰的方法为类方法；采用<code>@staticmethod</code>修饰的方法为静态方法；不用任何修饰的方法为实例方法。</p>
<h2 id="类实例方法"><a href="#类实例方法" class="headerlink" title="类实例方法"></a>类实例方法</h2><p>通常情况下，在类中定义的方法默认都是实例方法。类的构造方法理论上也属于实例方法，只不过它比较特殊。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#类构造方法，也属于实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="comment"># 下面定义了一个say实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用 say() 实例方法&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>实例方法最大的特点就是，它最少也要包含一个<code>self</code>参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。实例方法通常会用类对象直接调用：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">clang.say() <span class="comment"># 正在调用 say() 实例方法</span></span><br></pre></td></tr></table></figure>
<p>当然，Python 也支持使用类名调用实例方法，但此方式需要手动给<code>self</code>参数传值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类名调用实例方法，需手动给 self 参数传值</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line">CLanguage.say(clang) <span class="comment"># 正在调用 say() 实例方法</span></span><br></pre></td></tr></table></figure>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为<code>cls</code>，Python 会自动将类本身绑定给<code>cls</code>参数（注意，绑定的不是类对象）。也就是说，我们在调用类方法时，无需显式为<code>cls</code>参数传参。</p>
<p>和<code>self</code>一样，<code>cls</code>参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。</p>
<p>和实例方法最大的不同在于，类方法需要使用<code>@classmethod</code>修饰符进行修饰：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#类构造方法，也属于实例方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="comment">#下面定义了一个类方法</span></span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用类方法&quot;</span>, cls)</span><br></pre></td></tr></table></figure>
<p>如果没有<code>＠classmethod</code>，则 Python 解释器会将<code>info()</code>方法认定为实例方法，而不是类方法。</p>
<p>类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用类名直接调用类方法</span></span><br><span class="line">CLanguage.info()</span><br><span class="line"><span class="comment">#使用类对象调用类方法</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.info()</span><br></pre></td></tr></table></figure>
<h2 id="类静态方法"><a href="#类静态方法" class="headerlink" title="类静态方法"></a>类静态方法</h2><p>静态方法，其实就是函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。</p>
<p>静态方法没有类似<code>self、cls</code>这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</p>
<p>静态方法需要使用<code>@staticmethod</code>修饰：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line"><span class="meta">  @staticmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">name, add</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, add)</span><br></pre></td></tr></table></figure>
<p>静态方法的调用，既可以使用类名，也可以使用类对象：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用类名直接调用静态方法</span></span><br><span class="line">CLanguage.info(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="comment">#使用类对象调用静态方法</span></span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.info(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;xiaohong&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。</p>
<h1 id="类调用实例方法"><a href="#类调用实例方法" class="headerlink" title="类调用实例方法"></a>类调用实例方法</h1><p>实例方法的调用方式有 2 种，既可以采用类对象调用，也可以直接通过类名调用。</p>
<p>通常情况下，我们习惯使用类对象调用类中的实例方法。但如果想用类调用实例方法，不能像如下这样：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我正在学 Python&quot;</span>)</span><br><span class="line"><span class="comment">#通过类名直接调用实例方法</span></span><br><span class="line">CLanguage.info()</span><br></pre></td></tr></table></figure>
<p>运行上面代码，程序会报出如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\demo.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    CLanguage.info()</span><br><span class="line">TypeError: info() missing 1 required positional argument: &#x27;self&#x27;</span><br></pre></td></tr></table></figure>
<p>其中，最后一行报错信息提示我们，调用<code>info()</code>类方式时缺少给<code>self</code>参数传参。这意味着，和使用类对象调用实例方法不同，通过类名直接调用实例方法时，Python 并不会自动给<code>self</code>参数传值。</p>
<p><code>self</code>参数需要的是方法的实际调用者（是类对象），而这里只提供了类名，当然无法自动传值。</p>
<p>因此，如果想通过类名直接调用实例方法，就必须手动为<code>self</code>参数传值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我正在学 Python&quot;</span>)</span><br><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#通过类名直接调用实例方法</span></span><br><span class="line">CLanguage.info(clang)</span><br></pre></td></tr></table></figure>
<p>可以看到，通过手动将<code>clang</code>这个类对象传给了<code>self</code>参数，使得程序得以正确执行。实际上，这里调用实例方法的形式完全是等价于<code>clang.info()</code>。</p>
<p>值得一提的是，上面的报错信息只是让我们手动为<code>self</code>参数传值，但并没有规定必须传一个该类的对象，其实完全可以任意传入一个参数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self,<span class="string">&quot;正在学 Python&quot;</span>)</span><br><span class="line"><span class="comment">#通过类名直接调用实例方法</span></span><br><span class="line">CLanguage.info(<span class="string">&quot;zhangsan&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 正在学 Python</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>&quot;zhangsan&quot;</code>这个字符串传给了<code>info()</code>方法的<code>self</code>参数。显然，无论是<code>info()</code>方法中使用<code>self</code>参数调用其它类方法，还是使用<code>self</code>参数定义新的实例变量，胡乱的给<code>self</code>参数传参都将会导致程序运行崩溃。</p>
<p>总的来说，Python 中允许使用类名直接调用实例方法，但必须手动为该方法的第一个<code>self</code>参数传递参数，这种调用方法的方式被称为“非绑定方法”。</p>
<p>用类的实例对象访问类成员的方式称为绑定方法，而用类名调用类成员的方式称为非绑定方法。</p>
<h1 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h1><p>通过使用描述符，可以让程序员在引用一个对象属性时自定义要完成的工作。</p>
<p>本质上看，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。</p>
<p>描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 property、方法、类方法、静态方法和<code>super</code>类型。</p>
<p>描述符类基于以下 3 个特殊方法，换句话说，这 3 个方法组成了描述符协议：</p>
<ul>
<li><code>__set__(self, obj, type=None)</code>：在设置属性时将调用这一方法；</li>
<li><code>__get__(self, obj, value)</code>：在读取属性时将调用这一方法；</li>
<li><code>__delete__(self, obj)</code>：对属性调用<code>del</code>时将调用这一方法。</li>
</ul>
<p>其中，实现了<code>setter</code>和<code>getter</code>方法的描述符类被称为数据描述符；反之，如果只实现了<code>getter</code>方法，则称为非数据描述符。</p>
<p>实际上，在每次查找属性时，描述符协议中的方法都由类对象的特殊方法<code>__getattribute__()</code>调用（注意不要和<code>__getattr__()</code>弄混）。也就是说，每次使用类对象.属性（或者<code>getattr(类对象，属性值)</code>）的调用方式时，都会隐式地调用<code>__getattribute__()</code>，它会按照下列顺序查找该属性：</p>
<ul>
<li>验证该属性是否为类实例对象的数据描述符；</li>
<li>如果不是，就查看该属性是否能在类实例对象的<code>__dict__</code>中找到；</li>
<li>最后，查看该属性是否为类实例对象的非数据描述符。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#描述符类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">revealAccess</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, initval = <span class="literal">None</span>, name = <span class="string">&#x27;var&#x27;</span></span>):</span><br><span class="line">    self.val = initval</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, objtype</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Retrieving&quot;</span>,self.name)</span><br><span class="line">    <span class="keyword">return</span> self.val</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, val</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;updating&quot;</span>,self.name)</span><br><span class="line">    self.val = val</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myClass</span>:</span><br><span class="line">  x = revealAccess(<span class="number">10</span>,<span class="string">&#x27;var &quot;x&quot;&#x27;</span>)</span><br><span class="line">  y = <span class="number">5</span></span><br><span class="line">m = myClass()</span><br><span class="line"><span class="built_in">print</span>(m.x)</span><br><span class="line">m.x = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(m.x)</span><br><span class="line"><span class="built_in">print</span>(m.y)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrieving var &quot;x&quot;</span><br><span class="line">10</span><br><span class="line">updating var &quot;x&quot;</span><br><span class="line">Retrieving var &quot;x&quot;</span><br><span class="line">20</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>从这个例子可以看到，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的<code>__get__()</code>方法，并返回它的值；同样，每次在对该属性赋值时，也会调用<code>__set__()</code>方法。</p>
<p>注意，虽然上面例子中没有使用<code>__del__()</code>方法，但也很容易理解，当每次使用<code>del</code>类对象.属性（或者 delattr(类对象，属性)）语句时，都会调用该方法。</p>
<h1 id="property-函数"><a href="#property-函数" class="headerlink" title="property()函数"></a>property()函数</h1><p>我们一直在用“类对象.属性”的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。正常情况下，类包含的属性应该是隐藏的，只允许通过类提供的方法来间接实现对类属性的访问和操作。</p>
<p>因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个<code>getter</code>（或<code>setter</code>）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#构造函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name </span><br><span class="line">  <span class="comment">#设置 name 属性值的函数 </span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="comment">#访问nema属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.name</span><br><span class="line">  <span class="comment">#删除name属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">delname</span>(<span class="params">self</span>):</span><br><span class="line">    self.name=<span class="string">&quot;xxx&quot;</span></span><br><span class="line">clang = CLanguage(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="comment">#获取name属性值</span></span><br><span class="line"><span class="built_in">print</span>(clang.getname()) <span class="comment"># 小明</span></span><br><span class="line"><span class="comment">#设置name属性值</span></span><br><span class="line">clang.setname(<span class="string">&quot;Python教程&quot;</span>) <span class="comment"># Python教程</span></span><br><span class="line"><span class="built_in">print</span>(clang.getname())</span><br><span class="line"><span class="comment">#删除name属性值</span></span><br><span class="line">clang.delname()</span><br><span class="line"><span class="built_in">print</span>(clang.getname()) <span class="comment"># xxx</span></span><br></pre></td></tr></table></figure>
<p>Python 中提供了<code>property()</code>函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性名=property(fget=None, fset=None, fdel=None, doc=None)</span><br></pre></td></tr></table></figure>
<p>其中，<code>fget</code>参数用于指定获取该属性值的类方法，<code>fset</code>参数用于指定设置该属性值的方法，<code>fdel</code>参数用于指定删除该属性值的方法，最后的<code>doc</code>是一个文档字符串，用于说明此函数的作用。</p>
<p>注意，在使用<code>property()</code>函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，<code>property()</code>函数中参数的指定并不是完全随意的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment">#构造函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n</span>):</span><br><span class="line">    self.__name = n</span><br><span class="line">  <span class="comment">#设置 name 属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self,n</span>):</span><br><span class="line">    self.__name = n</span><br><span class="line">  <span class="comment">#访问nema属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__name</span><br><span class="line">  <span class="comment">#删除name属性值的函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">delname</span>(<span class="params">self</span>):</span><br><span class="line">    self.__name=<span class="string">&quot;xxx&quot;</span></span><br><span class="line">  <span class="comment">#为name 属性配置 property() 函数</span></span><br><span class="line">  name = <span class="built_in">property</span>(getname, setname, delname, <span class="string">&#x27;指明出处&#x27;</span>)</span><br><span class="line"><span class="comment">#调取说明文档的 2 种方式</span></span><br><span class="line"><span class="comment">#print(CLanguage.name.__doc__)</span></span><br><span class="line"><span class="built_in">help</span>(CLanguage.name)</span><br><span class="line">clang = CLanguage(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="comment">#调用 getname() 方法</span></span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br><span class="line"><span class="comment">#调用 setname() 方法</span></span><br><span class="line">clang.name=<span class="string">&quot;Python教程&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br><span class="line"><span class="comment">#调用 delname() 方法</span></span><br><span class="line"><span class="keyword">del</span> clang.name</span><br><span class="line"><span class="built_in">print</span>(clang.name)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Help on property:</span><br><span class="line"></span><br><span class="line">    指明出处</span><br><span class="line"></span><br><span class="line">小明</span><br><span class="line">Python教程</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure>
<p>注意，在此程序中，由于<code>getname()</code>方法中需要返回<code>name</code>属性，如果使用<code>self.name</code>的话，其本身又被调用<code>getname()</code>，这将会先入无限死循环。为了避免这种情况的出现，程序中的<code>name</code>属性必须设置为私有属性，即使用<code>__name</code>（前面有 2 个下划线）。</p>
<p>当然，<code>property()</code>函数也可以少传入几个参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">property</span>(getname, setname)</span><br></pre></td></tr></table></figure>
<p>这意味着，<code>name</code>是一个可读写的属性，但不能删除，因为<code>property()</code>函数中并没有为<code>name</code>配置用于函数该属性的方法。也就是说，即便<code>CLanguage</code>类中设计有<code>delname()</code>函数，这种情况下也不能用来删除<code>name</code>属性。 </p>
<p>同理，还可以像如下这样使用<code>property()</code>函数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">property</span>(getname) <span class="comment"># name 属性可读，不可写，也不能删除</span></span><br><span class="line">name = <span class="built_in">property</span>(getname, setname,delname) <span class="comment"># name属性可读、可写、也可删除，就是没有说明文档</span></span><br></pre></td></tr></table></figure>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>简单的理解封装，即在设计类时，刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以“类对象.属性名”（或者“类对象.方法名(参数)”）的形式调用这些属性（或方法），而只能用未隐藏的类方法间接操作这些隐藏的属性和方法。</p>
<p>封装机制保证了类内部数据结构的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。</p>
<p>除此之外，对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，我们只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松实现用户对类中属性或方法的不合理操作。</p>
<h2 id="Python-类如何进行封装"><a href="#Python-类如何进行封装" class="headerlink" title="Python 类如何进行封装"></a>Python 类如何进行封装</h2><p>Python 类中的变量和函数，不是公有的（类似<code>public</code>属性），就是私有的（类似<code>private</code>）。</p>
<p>但是，Python 并没有提供<code>public、private</code>这些修饰符。为了实现类的封装，Python 采取了下面的方法：</p>
<ul>
<li>默认情况下，Python 类中的变量和方法都是公有的，它们的名称前都没有下划线（<code>_</code>）；</li>
<li>如果类中的变量和函数，其名称以双下划线<code>__</code>开头，则该变量（函数）为私有变量（私有函数）。</li>
</ul>
<p>除此之外，还可以定义以单下划线<code>_</code>开头的类属性或者类方法（例如<code>_name、_display(self)</code>），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法。</p>
<blockquote>
<p>注意，Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数<code>__init__(self)</code>），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span> :</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setname</span>(<span class="params">self, name</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name) &lt; <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&#x27;名称长度必须大于1！&#x27;</span>)</span><br><span class="line">    self.__name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__name</span><br><span class="line">  <span class="comment">#为 name 配置 setter 和 getter 方法</span></span><br><span class="line">  name = <span class="built_in">property</span>(getname, setname)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">setadd</span>(<span class="params">self, add</span>):</span><br><span class="line">    <span class="keyword">if</span> add.startswith(<span class="string">&quot;http://&quot;</span>):</span><br><span class="line">      self.__add = add</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&#x27;地址必须以 http:// 开头&#x27;</span>) </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getadd</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.__add</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#为 add 配置 setter 和 getter 方法</span></span><br><span class="line">  add = <span class="built_in">property</span>(getadd, setadd)</span><br><span class="line">  <span class="comment">#定义个私有方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self.__name,self.__add)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = <span class="string">&quot;百度&quot;</span></span><br><span class="line">clang.add = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clang.name) <span class="comment"># 百度</span></span><br><span class="line"><span class="built_in">print</span>(clang.add) <span class="comment"># http://www.baidu.com</span></span><br></pre></td></tr></table></figure>
<p>上面程序中，<code>CLanguage</code>将<code>name</code>和<code>add</code>属性都隐藏了起来，但同时也提供了可操作它们的“窗口”，也就是各自的<code>setter</code>和<code>getter</code>方法，这些方法都是公有的。</p>
<p>不仅如此，以<code>add</code>属性的<code>setadd()</code>方法为例，通过在该方法内部添加控制逻辑，即通过调用<code>startswith()</code>方法，控制用户输入的地址必须以<code>http://</code>开头，否则程序将会执行<code>raise</code>语句抛出<code>ValueError</code>异常。</p>
<p>通过此程序的运行逻辑不难看出，通过对<code>CLanguage</code>类进行良好的封装，使得用户仅能通过暴露的<code>setter()</code>和<code>getter()</code>方法操作<code>name</code>和<code>add</code>属性，而通过对<code>setname()</code>和<code>setadd()</code>方法进行适当的设计，可以避免用户对类中属性的不合理操作，从而提高了类的可维护性和安全性。</p>
<p><code>CLanguage</code>类中还有一个<code>__display()</code>方法，由于该类方法为私有（<code>private</code>）方法，且该类没有提供操作该私有方法的“窗口”，因此我们无法在类的外部使用它。换句话说，如下调用<code>__display()</code>方法是不可行的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#尝试调用私有的 display() 方法</span></span><br><span class="line">clang.__display()</span><br></pre></td></tr></table></figure>
<p>这会导致如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\1.py&quot;, line 33, in &lt;module&gt;</span><br><span class="line">    clang.__display()</span><br><span class="line">AttributeError: &#x27;CLanguage&#x27; object has no attribute &#x27;__display&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用。</p>
<p>举个例子，假设现有一个<code>Shape</code>类，该类的<code>draw()</code>方法可以在屏幕上画出指定的形状，现在需要创建一个<code>Form</code>类，要求此类不但可以在屏幕上画出指定的形状，还可以计算出所画形状的面积。要创建这样的类，笨方法是将<code>draw()</code>方法直接复制到新类中，并添加计算面积的方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;画&quot;</span>,content)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;画&quot;</span>,content)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#....</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;此图形的面积为...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当然还有更简单的方法，就是使用类的继承机制。实现方法为：让<code>Form</code>类继承<code>Shape</code>类，这样当<code>Form</code>类对象调用<code>draw()</code>方法时，Python 解释器会先去 Form 中找以<code>draw</code>为名的方法，如果找不到，它还会自动去<code>Shape</code>类中找。如此，我们只需在<code>Form</code>类中添加计算面积的方法即可：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;画&quot;</span>,content)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#....</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;此图形的面积为...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>class Form(Shape)</code>就表示<code>Form</code>继承<code>Shape</code>。</p>
<p>Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。因此在上面这个样例中，<code>Form</code>是子类，<code>Shape</code>是父类。</p>
<p>子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>, 父类<span class="number">2</span>, ...)：</span><br><span class="line">  <span class="comment">#类定义部分</span></span><br></pre></td></tr></table></figure>
<p>注意，如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即一个子类可以同时拥有多个直接父类。</p>
<p>“派生”和继承是一个意思，只是观察角度不同而已。换句话说，继承是相对子类来说的，即子类继承自父类；而派生是相对于父类来说的，即父类派生出子类。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是一个人，名字是：&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;人也是高级动物&quot;</span>)</span><br><span class="line"><span class="comment">#同时继承 People 和 Animal 类</span></span><br><span class="line"><span class="comment">#其同时拥有 name 属性、say() 和 display() 方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">zhangsan.say()</span><br><span class="line">zhangsan.display()</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是一个人，名字是： 张三</span><br><span class="line">人也是高级动物</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然 Person 类为空类，但由于其继承自 People 和 Animal 这 2 个类，因此实际上 Person 并不空，它同时拥有这 2 个类所有的属性和方法。<br>没错，子类拥有父类所有的属性和方法，即便该属性或方法是私有（private）的。</p>
<h2 id="关于Python的多继承"><a href="#关于Python的多继承" class="headerlink" title="关于Python的多继承"></a>关于Python的多继承</h2><p>事实上，大部分面向对象的编程语言，都只支持单继承，即子类有且只能有一个父类。而 Python 却支持多继承（C++也支持多继承）。<br>和单继承相比，多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承。</p>
<p>使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = People</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;People类&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = Animal</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Animal类&quot;</span>,self.name)</span><br><span class="line"><span class="comment">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">zhangsan.say()</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">People类 张三</span><br></pre></td></tr></table></figure>
<p>可以看到，当<code>Person</code>同时继承<code>People</code>类和<code>Animal</code>类时，<code>People</code>类在前，因此如果<code>People</code>和<code>Animal</code>拥有同名的类方法，实际调用的是<code>People</code>类中的。</p>
<h1 id="父类方法重写"><a href="#父类方法重写" class="headerlink" title="父类方法重写"></a>父类方法重写</h1><p>在 Python 中，子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。</p>
<p>但凡事都有例外，我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。</p>
<p>举个例子，鸟通常是有翅膀的，也会飞，因此我们可以像如下这样定义个和鸟相关的类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">  <span class="comment">#鸟有翅膀</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isWing</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟有翅膀&quot;</span>)</span><br><span class="line">  <span class="comment">#鸟会飞</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟会飞&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>但是，对于鸵鸟来说，它虽然也属于鸟类，也有翅膀，但是它只会奔跑，并不会飞。针对这种情况，可以这样定义鸵鸟类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">  <span class="comment"># 重写Bird类的fly()方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸵鸟不会飞&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，因为<code>Ostrich</code>继承自<code>Bird</code>，因此<code>Ostrich</code>类拥有<code>Bird</code>类的<code>isWing()</code>和<code>fly()</code>方法。其中，<code>isWing()</code>方法同样适合<code>Ostrich</code>，但<code>fly()</code>明显不适合，因此我们在<code>Ostrich</code>类中对<code>fly()</code>方法进行重写。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">  <span class="comment">#鸟有翅膀</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isWing</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟有翅膀&quot;</span>)</span><br><span class="line">  <span class="comment">#鸟会飞</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟会飞&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">  <span class="comment"># 重写Bird类的fly()方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸵鸟不会飞&quot;</span>)</span><br><span class="line"><span class="comment"># 创建Ostrich对象</span></span><br><span class="line">ostrich = Ostrich()</span><br><span class="line"><span class="comment">#调用 Ostrich 类中重写的 fly() 类方法</span></span><br><span class="line">ostrich.fly()</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鸵鸟不会飞</span><br></pre></td></tr></table></figure>
<p>显然，<code>ostrich</code>调用的是重写之后的<code>fly()</code>类方法。</p>
<h2 id="如何调用被重写的方法"><a href="#如何调用被重写的方法" class="headerlink" title="如何调用被重写的方法"></a>如何调用被重写的方法</h2><p>事实上，如果我们在子类中重写了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。</p>
<p>这就产生一个新的问题，即如果想调用父类中被重写的这个方法，该怎么办呢？</p>
<p>Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间中，调用类空间中的函数，只需要在调用该函数时备注类名即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>:</span><br><span class="line">  <span class="comment">#鸟有翅膀</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">isWing</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟有翅膀&quot;</span>)</span><br><span class="line">  <span class="comment">#鸟会飞</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸟会飞&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ostrich</span>(<span class="title class_ inherited__">Bird</span>):</span><br><span class="line">  <span class="comment"># 重写Bird类的fly()方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fly</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鸵鸟不会飞&quot;</span>)</span><br><span class="line"><span class="comment"># 创建Ostrich对象</span></span><br><span class="line">ostrich = Ostrich()</span><br><span class="line"><span class="comment">#调用 Bird 类中的 fly() 方法</span></span><br><span class="line">Bird.fly(ostrich)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">鸟会飞</span><br></pre></td></tr></table></figure>
<p>此程序中，需要大家注意的一点是，使用类名调用其类方法，Python 不会为该方法的第一个<code>self</code>参数自定绑定值，因此采用这种调用方法，需要手动为<code>self</code>参数赋值。</p>
<p>通过类名调用实例方法的这种方式，又被称为未绑定方法。</p>
<h1 id="super-函数"><a href="#super-函数" class="headerlink" title="super()函数"></a>super()函数</h1><p>Python 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。</p>
<p>但我们知道，Python 支持多继承，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法。显然，构造方法也是如此。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是人，名字为：&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,food</span>):</span><br><span class="line">    self.food = food</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是动物,我吃&quot;</span>,self.food)</span><br><span class="line"><span class="comment">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">per = Person(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">per.say()</span><br><span class="line"><span class="comment">#per.display()</span></span><br></pre></td></tr></table></figure>
<p>运行结果，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是人，名字为： zhangsan</span><br></pre></td></tr></table></figure>
<p>上面程序中，Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 per 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 per 对象的同时，还要给 name 属性进行赋值。</p>
<p>但如果去掉最后一行的注释，运行此行代码，Python 解释器会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\Demo.py&quot;, line 18, in &lt;module&gt;</span><br><span class="line">    per.display()</span><br><span class="line">  File &quot;D:\python3.6\Demo.py&quot;, line 11, in display</span><br><span class="line">    print(&quot;我是动物,我吃&quot;,self.food)</span><br><span class="line">AttributeError: &#x27;Person&#x27; object has no attribute &#x27;food&#x27;</span><br></pre></td></tr></table></figure>
<p>这是因为，从 Animal 类中继承的 display() 方法中，需要用到 food 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 per 对象时，Animal 类的构造方法未得到执行，所以程序出错。</p>
<p>反过来也是如此，如果将第 13 行代码改为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(Animal, People)</span><br></pre></td></tr></table></figure>
<p>则在创建 per 对象时，会给 food 属性传值。这意味着，per.display() 能顺序执行，但 per.say() 将会报错。</p>
<p>针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。但需要注意，如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。</p>
<p>在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：</p>
<ul>
<li>类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；</li>
<li>使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。</li>
</ul>
<p>也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种，而调用其它父类构造方法的方式只能使用未绑定方法。</p>
<p>在 Python 3.x 中，<code>super()</code>函数的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super().__init__(...)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是人，名字为：&quot;</span>,self.name)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,food</span>):</span><br><span class="line">    self.food = food</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是动物,我吃&quot;</span>,self.food)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(People, Animal):</span><br><span class="line">  <span class="comment">#自定义构造方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,food</span>):</span><br><span class="line">    <span class="comment">#调用 People 类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>().__init__(name)</span><br><span class="line">    <span class="comment">#super(Person,self).__init__(name) #执行效果和上一行相同</span></span><br><span class="line">    <span class="comment">#People.__init__(self,name)#使用未绑定方法调用 People 类构造方法</span></span><br><span class="line">    <span class="comment">#调用其它父类的构造方法，需手动给 self 传值</span></span><br><span class="line">    Animal.__init__(self,food)    </span><br><span class="line">per = Person(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;熟食&quot;</span>)</span><br><span class="line">per.say() <span class="comment"># 我是人，名字为： zhangsan</span></span><br><span class="line">per.display() <span class="comment"># 我是动物,我吃 熟食</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Person</code>类自定义的构造方法中，调用<code>People</code>类构造方法，可以使用<code>super()</code>函数，也可以使用未绑定方法。但是调用<code>Animal</code>类的构造方法，只能使用未绑定方法。</p>
<h1 id="slots-：限制类实例动态添加属性和方法"><a href="#slots-：限制类实例动态添加属性和方法" class="headerlink" title="__slots__：限制类实例动态添加属性和方法"></a>__slots__：限制类实例动态添加属性和方法</h1><p>了解了如何动态的为单个实例对象添加属性，甚至如果必要的话，还可以为所有的类实例对象统一添加属性（通过给类添加属性）。</p>
<p>那么，Python 是否也允许动态地为类或实例对象添加方法呢？答案是肯定的。我们知道，类方法又可细分为实例方法、静态方法和类方法，Python 语言允许为类动态地添加这 3 种方法；但对于实例对象，则只允许动态地添加实例方法，不能添加类方法和静态方法。</p>
<p>为单个实例对象添加方法，不会影响该类的其它实例对象；而如果为类动态地添加方法，则所有的实例对象都可以使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#下面定义了一个实例方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>)</span><br><span class="line"><span class="comment">#下面定义了一个类方法</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info2</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用类方法&quot;</span>)</span><br><span class="line"><span class="comment">#下面定义个静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info3</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用静态方法&quot;</span>)</span><br><span class="line"><span class="comment">#类可以动态添加以上 3 种方法，会影响所有实例对象</span></span><br><span class="line">CLanguage.info = info</span><br><span class="line">CLanguage.info2 = info2</span><br><span class="line">CLanguage.info3 = info3</span><br><span class="line">clang = CLanguage()</span><br><span class="line"><span class="comment">#如今，clang 具有以上 3 种方法</span></span><br><span class="line">clang.info()</span><br><span class="line">clang.info2()</span><br><span class="line">clang.info3()</span><br><span class="line"><span class="comment">#类实例对象只能动态添加实例方法，不会影响其它实例对象</span></span><br><span class="line">clang1 = CLanguage()</span><br><span class="line">clang1.info = info</span><br><span class="line"><span class="comment">#必须手动为 self 传值</span></span><br><span class="line">clang1.info(clang1)</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：<br>正在调用实例方法<br>正在调用类方法<br>正在调用静态方法<br>正在调用实例方法</p>
<p>显然，动态给类或者实例对象添加属性或方法，是非常灵活的。但与此同时，如果胡乱地使用，也会给程序带来一定的隐患，即程序中已经定义好的类，如果不做任何限制，是可以做动态的修改的。</p>
<p>庆幸的是，Python 提供了<code>__slots__</code>属性，通过它可以避免用户频繁的给实例对象动态地添加属性或方法。</p>
<p>再次声明，<code>__slots__</code>只能限制为实例对象动态添加属性和方法，而无法限制动态地为类添加属性和方法。</p>
<p><code>__slots__</code>属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    __slots__ = (&#x27;name&#x27;,&#x27;add&#x27;,&#x27;info&#x27;)</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>CLanguage</code>类中指定了<code>__slots__</code>属性，这意味着，该类的实例对象仅限于动态添加<code>name、add、info</code>这 3 个属性以及<code>name()、add()</code>和<code>info()</code>这 3 个方法。</p>
<p>注意，对于动态添加的方法，<code>__slots__</code>限制的是其方法名，并不限制参数的个数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self,name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>,self.name)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="comment">#为 clang 对象动态添加 info 实例方法</span></span><br><span class="line">clang.info = info</span><br><span class="line">clang.info(clang,<span class="string">&quot;Python教程&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在调用实例方法 小明</span><br></pre></td></tr></table></figure>
<p>还是在<code>CLanguage</code>类的基础上，添加如下代码并运行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self,name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>,self.name)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">clang.say = info</span><br><span class="line">clang.say(clang,<span class="string">&quot;Python教程&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行程序，显示如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\1.py&quot;, line 9, in &lt;module&gt;</span><br><span class="line">    clang.say = info</span><br><span class="line">AttributeError: &#x27;CLanguage&#x27; object has no attribute &#x27;say&#x27;</span><br></pre></td></tr></table></figure>
<p>显然，根据<code>__slots__</code>属性的设置，<code>CLanguage</code>类的实例对象是不能动态添加以 say 为名称的方法的。</p>
<p><code>__slots__</code>属性限制的对象是类的实例对象，而不是类，因此下面的代码是合法的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>)</span><br><span class="line">CLanguage.say = info</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.say()</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在调用实例方法</span><br></pre></td></tr></table></figure>
<p>当然，还可以为类动态添加类方法和静态方法，这里不再给出具体实例，读者可自行编写代码尝试。</p>
<p>此外，<code>__slots__</code>属性对由该类派生出来的子类，也是不起作用的。例如如下代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  __slots__ = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line"><span class="comment">#Clanguage 的空子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLangs</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#定义的实例方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;正在调用实例方法&quot;</span>)</span><br><span class="line">clang = CLangs()</span><br><span class="line"><span class="comment">#为子类对象动态添加 say() 方法</span></span><br><span class="line">clang.say = info</span><br><span class="line">clang.say(clang)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正在调用实例方法</span><br></pre></td></tr></table></figure>
<p>显然，<code>__slots__</code>属性只对当前所在的类起限制作用。</p>
<p>因此，如果子类也要限制外界为其实例对象动态地添加属性和方法，必须在子类中设置<code>__slots__</code>属性。</p>
<p>注意，如果为子类也设置有<code>__slots__</code>属性，那么子类实例对象允许动态添加的属性和方法，是子类中<code>__slots__</code>属性和父类<code>__slots__</code>属性的和。</p>
<h1 id="type-函数：动态创建类"><a href="#type-函数：动态创建类" class="headerlink" title="type()函数：动态创建类"></a>type()函数：动态创建类</h1><p>我们知道，<code>type()</code>函数属于 Python 内置函数，通常用来查看某个变量的具体类型。其实，<code>type()</code>函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。</p>
<p>type() 函数的语法格式有 2 种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type(obj) </span><br><span class="line">type(name, bases, dict)</span><br></pre></td></tr></table></figure>
<p>以上这 2 种语法格式，各参数的含义及功能分别是：</p>
<ul>
<li>第一种语法格式用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。</li>
<li>第二种语法格式用来创建类，其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看 3.4 的类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">3.4</span>))</span><br><span class="line"><span class="comment">#查看类对象的类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(clangs))</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&lt;class &#x27;__main__.CLanguage&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p><code>type()</code>函数的另一种用法，即创建一个新类，先来分析一个样例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个实例方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我要学 Python！&quot;</span>)</span><br><span class="line"><span class="comment">#使用 type() 函数创建类</span></span><br><span class="line">CLanguage = <span class="built_in">type</span>(<span class="string">&quot;CLanguage&quot;</span>,(<span class="built_in">object</span>,),<span class="built_in">dict</span>(say = say, name = <span class="string">&quot;C语言中文网&quot;</span>))</span><br><span class="line"><span class="comment">#创建一个 CLanguage 实例对象</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="comment">#调用 say() 方法和 name 属性</span></span><br><span class="line">clangs.say()</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br></pre></td></tr></table></figure>
<p>注意，Python 元组语法规定，当<code>(object,)</code>元组中只有一个元素时，最后的逗号（,）不能省略。</p>
<p>可以看到，此程序中通过<code>type()</code>创建了类，其类名为<code>CLanguage</code>，继承自<code>objects</code>类，且该类中还包含一个<code>say()</code>方法和一个<code>name</code>属性。</p>
<p>运行上面的程序，其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我要学 Python！</span><br><span class="line">C语言中文网</span><br></pre></td></tr></table></figure>
<p>可以看到，使用<code>type()</code>函数创建的类，和直接使用<code>class</code>定义的类并无差别。事实上，我们在使用<code>class</code>定义类时，Python 解释器底层依然是用<code>type()</code>来创建这个类。</p>
<h1 id="MetaClass元类"><a href="#MetaClass元类" class="headerlink" title="MetaClass元类"></a>MetaClass元类</h1><p><code>MetaClass</code>元类，本质也是一个类，但和普通类的用法不同，它可以对类内部的定义（包括类属性和类方法）进行动态的修改。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。</p>
<p>不要从字面上去理解元类的含义，事实上<code>MetaClass</code>中的<code>Meta</code>这个词根，起源于希腊语词汇 meta，包含“超越”和“改变”的意思。</p>
<p>举个例子，根据实际场景的需要，我们要为多个类添加一个 name 属性和一个 say() 方法。显然有多种方法可以实现，但其中一种方法就是使用 MetaClass 元类。</p>
<p>如果在创建类时，想用<code>MetaClass</code>元类动态地修改内部的属性或者方法，则类的创建过程将变得复杂：先创建 MetaClass 元类，然后用元类去创建类，最后使用该类的实例化对象实现功能。</p>
<p>如果想把一个类设计成<code>MetaClass</code>元类，其必须符合以下条件：</p>
<ul>
<li>必须显式继承自<code>type</code>类；</li>
<li>类中需要定义并实现<code>__new__()</code>方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该<code>__new__()</code>方法会自动被执行，用来修改新建的类。</li>
</ul>
<p>我们先尝试定义一个<code>MetaClass</code>元类：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="comment"># cls代表动态修改的类</span></span><br><span class="line">    <span class="comment"># name代表动态修改的类名</span></span><br><span class="line">    <span class="comment"># bases代表被动态修改的类的所有父类</span></span><br><span class="line">    <span class="comment"># attr代表被动态修改的类的所有属性、方法组成的字典</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="comment"># 动态为该类添加一个name属性</span></span><br><span class="line">        attrs[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;C语言中文网&quot;</span></span><br><span class="line">        attrs[<span class="string">&#x27;say&#x27;</span>] = <span class="keyword">lambda</span> self: <span class="built_in">print</span>(<span class="string">&quot;调用 say() 实例方法&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,name,bases,attrs)</span><br></pre></td></tr></table></figure>
<p>此程序中，首先可以断定 FirstMetaClass 是一个类。其次，由于该类继承自 type 类，并且内部实现了 <strong>new</strong>() 方法，因此可以断定 FirstMetaCLass 是一个元类。</p>
<p>可以看到，在这个元类的<code>__new__()</code>方法中，手动添加了一个 name 属性和 say() 方法。这意味着，通过 FirstMetaClass 元类创建的类，会额外添加 name 属性和 say() 方法。通过如下代码，可以验证这个结论：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义类时，指定元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>(<span class="built_in">object</span>,metaclass=FirstMetaClass):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br><span class="line">clangs.say()</span><br></pre></td></tr></table></figure>
<p>可以看到，在创建类时，通过在标注父类的同时指定元类（格式为metaclass&#x3D;元类名），则当 Python 解释器在创建这该类时，FirstMetaClass 元类中的 <strong>new</strong> 方法就会被调用，从而实现动态修改类属性或者类方法的目的。</p>
<p>运行上面的程序，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网</span><br><span class="line">调用 say() 实例方法</span><br></pre></td></tr></table></figure>
<p>显然，<code>FirstMetaClass</code>元类的<code>__new__()</code>方法动态地为<code>Clanguage</code>类添加了<code>name</code>属性和<code>say()</code>方法，因此，即便该类在定义时是空类，它也依然有<code>name</code>属性和<code>say()</code>方法。</p>
<p>对于<code>MetaClass</code>元类，它多用于创建 API，因此我们几乎不会使用到它。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>我们都知道，Python 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赋值的是 CLanguage 类的实例对象&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPython</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赋值的是 CPython 类的实例对象&quot;</span>)</span><br><span class="line">a = CLanguage()</span><br><span class="line">a.say()</span><br><span class="line">a = CPython()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">赋值的是 CLanguage 类的实例对象</span><br><span class="line">赋值的是 CPython 类的实例对象</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>a</code>可以被先后赋值为<code>CLanguage</code>类和<code>CPython</code>类的对象，但这并不是多态。类的多态特性，还要满足以下 2 个前提条件：</p>
<ul>
<li>继承：多态一定是发生在子类和父类之间；</li>
<li>重写：子类重写了父类的方法。</li>
</ul>
<p>下面程序是对上面代码的改写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 Clanguage 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPython</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CPython 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLinux</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CLinux 类的say方法&quot;</span>)</span><br><span class="line">a = CLanguage()</span><br><span class="line">a.say()</span><br><span class="line">a = CPython()</span><br><span class="line">a.say()</span><br><span class="line">a = CLinux()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用的是 Clanguage 类的say方法</span><br><span class="line">调用的是 CPython 类的say方法</span><br><span class="line">调用的是 CLinux 类的say方法</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>CPython</code>和<code>CLinux</code>都继承自<code>CLanguage</code>类，且各自都重写了父类的<code>say()</code>方法。从运行结果可以看出，同一变量<code>a</code>在执行同一个<code>say()</code>方法时，由于<code>a</code>实际表示不同的类实例对象，因此<code>a.say()</code>调用的并不是同一个类中的<code>say()</code>方法，这就是多态。</p>
<p>其实，Python 在多态的基础上，衍生出了一种更灵活的编程机制。继续对上面的程序进行改写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WhoSay</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self,who</span>):</span><br><span class="line">    who.say()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 Clanguage 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPython</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CPython 类的say方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLinux</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用的是 CLinux 类的say方法&quot;</span>)</span><br><span class="line">a = WhoSay()</span><br><span class="line"><span class="comment">#调用 CLanguage 类的 say() 方法</span></span><br><span class="line">a.say(CLanguage())</span><br><span class="line"><span class="comment">#调用 CPython 类的 say() 方法</span></span><br><span class="line">a.say(CPython())</span><br><span class="line"><span class="comment">#调用 CLinux 类的 say() 方法</span></span><br><span class="line">a.say(CLinux())</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用的是 Clanguage 类的say方法</span><br><span class="line">调用的是 CPython 类的say方法</span><br><span class="line">调用的是 CLinux 类的say方法</span><br></pre></td></tr></table></figure>
<p>此程序中，通过给<code>WhoSay</code>类中的<code>say()</code>函数添加一个<code>who</code>参数，其内部利用传入的<code>who</code>调用<code>say()</code>方法。这意味着，当调用<code>WhoSay</code>类中的<code>say()</code>方法时，我们传给<code>who</code>参数的是哪个类的实例对象，它就会调用那个类中的<code>say()</code>方法。</p>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个。对于这些实例化对象个数固定的类，可以用枚举类来定义。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">  <span class="comment"># 为序列值指定value值</span></span><br><span class="line">  red = <span class="number">1</span></span><br><span class="line">  green = <span class="number">2</span></span><br><span class="line">  blue = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>如果想将一个类定义为枚举类，只需要令其继承自<code>enum</code>模块中的<code>Enum</code>类即可。例如在上面程序中，<code>Color</code>类继承自<code>Enum</code>类，则证明这是一个枚举类。</p>
<p>在<code>Color</code>枚举类中，<code>red、green、blue</code>都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为<code>name</code>和<code>value</code>，其中<code>name</code>属性值为该枚举值的变量名（如<code>red</code>），<code>value</code>代表该枚举值的序号（序号通常从 1 开始）。</p>
<p>和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调用枚举成员的 3 种方式</span></span><br><span class="line"><span class="built_in">print</span>(Color.red)</span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;red&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(Color(<span class="number">1</span>))</span><br><span class="line"><span class="comment">#调取枚举成员中的 value 和 name</span></span><br><span class="line"><span class="built_in">print</span>(Color.red.value)</span><br><span class="line"><span class="built_in">print</span>(Color.red.name)</span><br><span class="line"><span class="comment">#遍历枚举类中所有成员的 2 种方式</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> Color:</span><br><span class="line">  <span class="built_in">print</span>(color)</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">1</span><br><span class="line">red</span><br><span class="line">Color.red</span><br><span class="line">Color.green</span><br><span class="line">Color.blue</span><br></pre></td></tr></table></figure>
<p>枚举类成员之间不能比较大小，但可以用<code>==</code>或者<code>is</code>进行比较是否相等：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Color.red == Color.green) <span class="comment"># Flase</span></span><br><span class="line"><span class="built_in">print</span>(Color.red.name <span class="keyword">is</span> Color.green.name) <span class="comment"># Flase</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.red = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>除此之外，该枚举类还提供了一个<code>__members__</code>属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,member <span class="keyword">in</span> Color.__members__.items():</span><br><span class="line">  <span class="built_in">print</span>(name,<span class="string">&quot;-&gt;&quot;</span>,member)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red -&gt; Color.red</span><br><span class="line">green -&gt; Color.green</span><br><span class="line">blue -&gt; Color.blue</span><br></pre></td></tr></table></figure>
<p>值得一提的是，Python 枚举类中各个成员必须保证<code>name</code>互不相同，但<code>value</code>可以相同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">  <span class="comment"># 为序列值指定value值</span></span><br><span class="line">  red = <span class="number">1</span></span><br><span class="line">  green = <span class="number">1</span></span><br><span class="line">  blue = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;green&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color.red</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Color</code>枚举类中<code>red</code>和<code>green</code>具有相同的值（都是 1），Python 允许这种情况的发生，它会将<code>green</code>当做是<code>red</code>的别名，因此当访问<code>green</code>成员时，最终输出的是<code>red</code>。</p>
<p>在实际编程过程中，如果想避免发生这种情况，可以借助<code>@unique</code>装饰器，这样当枚举类中出现相同值的成员时，程序会报<code>ValueError</code>错误。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入 unique</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum,unique</span><br><span class="line"><span class="comment">#添加 unique 装饰器</span></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">  <span class="comment"># 为序列值指定value值</span></span><br><span class="line">  red = <span class="number">1</span></span><br><span class="line">  green = <span class="number">1</span></span><br><span class="line">  blue = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;green&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>运行程序会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\demo.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    class Color(Enum):</span><br><span class="line">  File &quot;D:\python3.6\lib\enum.py&quot;, line 834, in unique</span><br><span class="line">    (enumeration, alias_details))</span><br><span class="line">ValueError: duplicate values found in &lt;enum &#x27;Color&#x27;&gt;: green -&gt; red</span><br></pre></td></tr></table></figure>
<p>除了通过继承<code>Enum</code>类的方法创建枚举类，还可以使用<code>Enum()</code>函数创建枚举类。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="comment">#创建一个枚举类</span></span><br><span class="line">Color = Enum(<span class="string">&quot;Color&quot;</span>,(<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>))</span><br><span class="line"><span class="comment">#调用枚举成员的 3 种方式</span></span><br><span class="line"><span class="built_in">print</span>(Color.red)</span><br><span class="line"><span class="built_in">print</span>(Color[<span class="string">&#x27;red&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(Color(<span class="number">1</span>))</span><br><span class="line"><span class="comment">#调取枚举成员中的 value 和 name</span></span><br><span class="line"><span class="built_in">print</span>(Color.red.value)</span><br><span class="line"><span class="built_in">print</span>(Color.red.name)</span><br><span class="line"><span class="comment">#遍历枚举类中所有成员的 2 种方式</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> Color:</span><br><span class="line">  <span class="built_in">print</span>(color)</span><br></pre></td></tr></table></figure>
<p><code>Enum()</code>函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。</p>
<p>如上所示，仅通过一行代码，即创建了一个和前面的<code>Color</code>类相同的枚举类。运行程序，其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">Color.red</span><br><span class="line">1</span><br><span class="line">red</span><br><span class="line">Color.red</span><br><span class="line">Color.green</span><br><span class="line">Color.blue</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python模块和包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/12/14/python/Python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/" class="article-date">
  <time datetime="2022-12-14T04:08:50.780Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><p><code>import</code>的用法主要有以下两种：<br><code>import 模块名1 [as 别名1], 模块名2 [as 别名2]，…</code>：使用这种语法格式的<code>import</code>语句，会导入指定模块中的所有成员（包括变量、函数、类等）。不仅如此，当需要使用模块中的成员时，需用该模块名（或别名）作为前缀，否则 Python 解释器会报错。<br><code>from 模块名 import 成员名1 [as 别名1]，成员名2 [as 别名2]，…</code>：使用这种语法格式的<code>import</code>语句，只会导入模块中指定的成员，而不是全部成员。同时，当程序中使用该成员时，无需附加任何前缀，直接使用成员名（或别名）即可。</p>
<p>注意，用<code>[]</code>括起来的部分，可以使用，也可以省略。</p>
<p>其中，第二种<code>import</code>语句也可以导入指定模块中的所有成员，即使用<code>form</code>模块名<code>import ＊</code>，但此方式不推荐使用。</p>
<h2 id="import-模块名-as-别名"><a href="#import-模块名-as-别名" class="headerlink" title="import 模块名 as 别名"></a>import 模块名 as 别名</h2><p>下面程序使用导入整个模块的最简单语法来导入指定模块：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys整个模块</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 使用sys模块名作为前缀来访问模块中的成员</span></span><br><span class="line"><span class="built_in">print</span>(sys.argv[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>上面第 2 行代码使用最简单的方式导入了<code>sys</code>模块，因此在程序中使用<code>sys</code>模块内的成员时，必须添加模块名作为前缀。</p>
<p>运行上面程序，可以看到如下输出结果（<code>sys</code>模块下的<code>argv</code>变量用于获取运行 Python 程序的命令行参数，其中<code>argv[0]</code>用于获取当前 Python 程序的存储路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mengma\Desktop\hello.py</span><br></pre></td></tr></table></figure>
<p>导入整个模块时，也可以为模块指定别名。例如如下程序：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys整个模块，并指定别名为s</span></span><br><span class="line"><span class="keyword">import</span> sys <span class="keyword">as</span> s</span><br><span class="line"><span class="comment"># 使用s模块别名作为前缀来访问模块中的成员</span></span><br><span class="line"><span class="built_in">print</span>(s.argv[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>第 2 行代码在导入<code>sys</code>模块时才指定了别名<code>s</code>，因此在程序中使用<code>sys</code>模块内的成员时，必须添加模块别名<code>s</code>作为前缀。运行该程序，可以看到如下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mengma\Desktop\hello.py</span><br></pre></td></tr></table></figure>
<p>也可以一次导入多个模块，多个模块之间用逗号隔开。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys、os两个模块</span></span><br><span class="line"><span class="keyword">import</span> sys,os</span><br><span class="line"><span class="comment"># 使用模块名作为前缀来访问模块中的成员</span></span><br><span class="line"><span class="built_in">print</span>(sys.argv[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># os模块的sep变量代表平台上的路径分隔符</span></span><br><span class="line"><span class="built_in">print</span>(os.sep)</span><br></pre></td></tr></table></figure>
<p>上面第 2 行代码一次导入了 sys 和 os 两个模块，因此程序要使用 sys、os 两个模块内的成员，只要分别使用 sys、os 模块名作为前缀即可。在 Windows 平台上运行该程序，可以看到如下输出结果（os 模块的 sep 变量代表平台上的路径分隔符）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mengma\Desktop\hello.py</span><br><span class="line">\</span><br></pre></td></tr></table></figure>
<p>在导入多个模块的同时，也可以为模块指定别名：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys、os两个模块，并为sys指定别名s，为os指定别名o</span></span><br><span class="line"><span class="keyword">import</span> sys <span class="keyword">as</span> s,os <span class="keyword">as</span> o</span><br><span class="line"><span class="comment"># 使用模块别名作为前缀来访问模块中的成员</span></span><br><span class="line"><span class="built_in">print</span>(s.argv[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(o.sep)</span><br></pre></td></tr></table></figure>
<p>上面第 2 行代码一次导入了sys 和 os 两个模块，并分别为它们指定别名为 s、o，因此程序可以通过 s、o 两个前缀来使用 sys、os 两个模块内的成员。在 Windows 平台上运行该程序，可以看到如下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mengma\Desktop\hello.py</span><br><span class="line">\</span><br></pre></td></tr></table></figure>
<h2 id="from-模块名-import-成员名-as-别名"><a href="#from-模块名-import-成员名-as-别名" class="headerlink" title="from 模块名 import 成员名 as 别名"></a>from 模块名 import 成员名 as 别名</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys模块的argv成员</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"><span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br><span class="line"><span class="built_in">print</span>(argv[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>第 2 行代码导入了<code>sys</code>模块中的<code>argv</code>成员，这样即可在程序中直接使用 argv 成员，无须使用任何前缀。</p>
<p>导入模块成员时，也可以为成员指定别名，例如如下程序：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys模块的argv成员，并为其指定别名v</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv <span class="keyword">as</span> v</span><br><span class="line"><span class="comment"># 使用导入成员（并指定别名）的语法，直接使用成员的别名访问</span></span><br><span class="line"><span class="built_in">print</span>(v[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>第 2 行代码导入了<code>sys</code>模块中的<code>argv</code>成员，并为该成员指定别名<code>v</code>，这样即可在程序中通过别名<code>v</code>使用<code>argv</code>成员，无须使用任何前缀。</p>
<p><code>form...import</code>导入模块成员时，支持一次导入多个成员：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys模块的argv,winver成员</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv, winver</span><br><span class="line"><span class="comment"># 使用导入成员的语法，直接使用成员名访问</span></span><br><span class="line"><span class="built_in">print</span>(argv[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(winver)</span><br></pre></td></tr></table></figure>
<p>上面第 2 行代码导入了<code>sys</code>模块中的<code>argv、 winver</code>成员，这样即可在程序中直接使用<code>argv、winver</code>两个成员，无须使用任何前缀。运行该程序，可以看到如下输出结果（<code>sys</code>的<code>winver</code>成员记录了该 Python 的版本号）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mengma\Desktop\hello.py</span><br><span class="line">3.11</span><br></pre></td></tr></table></figure>
<p>一次导入多个模块成员时，也可指定别名，同样使用<code>as</code>关键字为成员指定别名：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sys模块的argv,winver成员，并为其指定别名v、wv</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv <span class="keyword">as</span> v, winver <span class="keyword">as</span> wv</span><br><span class="line"><span class="comment"># 使用导入成员（并指定别名）的语法，直接使用成员的别名访问</span></span><br><span class="line"><span class="built_in">print</span>(v[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(wv)</span><br></pre></td></tr></table></figure>
<p>上面第 2 行代码导入了 sys 模块中的 argv、winver 成员，并分别为它们指定了别名 v、wv，这样即可在程序中通过 v 和 wv 两个别名使用 argv、winver 成员，无须使用任何前缀。</p>
<h2 id="不推荐使用-from-import-导入模块所有成员"><a href="#不推荐使用-from-import-导入模块所有成员" class="headerlink" title="不推荐使用 from import 导入模块所有成员"></a>不推荐使用 from import 导入模块所有成员</h2><p>在使用<code>from...import</code>语法时，可以一次导入指定模块内的所有成员（此方式不推荐）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入sys 棋块内的所有成员</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#使用导入成员的语法，直接使用成员的别名访问</span></span><br><span class="line"><span class="built_in">print</span>(argv[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(winver)</span><br></pre></td></tr></table></figure>
<p>上面代码一次导入了<code>sys</code>模块中的所有成员，这样程序即可通过成员名来使用该模块内的所有成员。该程序的输出结果和前面程序的输出结果完全相同。</p>
<p>需要说明的是，一般不推荐使用“from 模块 import”这种语法导入指定模块内的所有成员，因为它存在潜在的风险。比如同时导入<code>module1</code>和<code>module2</code>内的所有成员，假如这两个模块内都有一个<code>foo()</code>函数，那么当在程序中执行如下代码时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo()</span><br></pre></td></tr></table></figure>
<p>上面调用的这个<code>foo()</code>函数到底是<code>module1</code>模块中的还是<code>module2</code>模块中的？因此，这种导入指定模块内所有成员的用法是有风险的。</p>
<p>但如果换成如下两种导入方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import module1</span><br><span class="line">import module2 as m2</span><br></pre></td></tr></table></figure>
<p>接下来要分别调用这两个模块中的<code>foo()</code>函数就非常清晰。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用模块module1 的模块名作为前缀调用foo()函数</span></span><br><span class="line">module1.foo()</span><br><span class="line"><span class="comment">#使用module2 的模块别名作为前缀调用foo()函数</span></span><br><span class="line">m2.foo()</span><br><span class="line">或者使用 <span class="keyword">from</span>...<span class="keyword">import</span> 语句也是可以的：</span><br><span class="line"><span class="comment">#导入module1 中的foo 成员，并指定其别名为foo1</span></span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo <span class="keyword">as</span> fool</span><br><span class="line"><span class="comment">#导入module2 中的foo 成员，并指定其别名为foo2</span></span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo <span class="keyword">as</span> foo2</span><br></pre></td></tr></table></figure>
<p>此时通过别名将 module1 和 module2 两个模块中的 foo 函数很好地进行了区分，接下来分别调用两个模块中 foo() 函数就很清晰：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo1() #调用module1 中的foo()函数</span><br><span class="line">foo2() #调用module2 中的foo()函数</span><br></pre></td></tr></table></figure>
<h1 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h1><p>Python 模块就是 Python 程序，换句话说，只要是 Python 程序，都可以作为模块导入。例如，下面定义了一个简单的模块（编写在 demo.py 文件中）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name,add)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;人生苦短，我学Python！&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,add</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.add = add</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name,self.add)</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在 demo.py 文件中放置了变量（name 和 add）、函数（ say() ）以及一个 Clanguage 类，该文件就可以作为一个模板。</p>
<p>但通常情况下，为了检验模板中代码的正确性，我们往往需要为其设计一段测试代码，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">say()</span><br><span class="line">clangs = CLanguage(&quot;小红&quot;,&quot;xiaohong&quot;)</span><br><span class="line">clangs.say()</span><br><span class="line">运行 demo.py 文件，其执行结果为：</span><br><span class="line">小明 xiaoming</span><br><span class="line">人生苦短，我学Python！</span><br><span class="line">小红 xiaohong</span><br></pre></td></tr></table></figure>
<p>通过观察模板中程序的执行结果可以断定，模板文件中包含的函数以及类，是可以正常工作的。</p>
<p>在此基础上，我们可以新建一个 test.py 文件，并在该文件中使用 demo.py 模板文件，即使用 import 语句导入 demo.py：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import demo</span><br></pre></td></tr></table></figure>
<p>注意，虽然 demo 模板文件的全称为 demo.py，但在使用 import 语句导入时，只需要使用该模板文件的名称即可。</p>
<p>此时，如果直接运行 test.py 文件，其执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明 xiaoming</span><br><span class="line">人生苦短，我学Python！</span><br><span class="line">小红 xiaohong</span><br></pre></td></tr></table></figure>
<p>可以看到，当执行 test.py 文件时，它同样会执行 demo.py 中用来测试的程序，这显然不是我们想要的效果。正常的效果应该是，只有直接运行模板文件时，测试代码才会被执行；反之，如果是其它程序以引入的方式执行模板文件，则测试代码不应该被执行。</p>
<p>要实现这个效果，可以借助 Python 内置的<code>__name__</code>变量。当直接运行一个模块时，<code>name</code>变量的值为<code>__main__</code>；而将模块被导入其他程序中并运行该程序时，处于模块中的<code>__name__</code>变量的值就变成了模块名。因此，如果希望测试函数只有在直接运行模块文件时才执行，则可在调用测试函数时增加判断，即只有当<code>__name__ ==&#39;__main__&#39;</code>时才调用测试函数。</p>
<p>因此，我们可以修改 demo.py 模板文件中的测试代码为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  say()</span><br><span class="line">  clangs = CLanguage(<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line">  clangs.say()</span><br></pre></td></tr></table></figure>
<p>显然，这里执行的仅是模板文件中的输出语句，测试代码并未执行。</p>
<h2 id="自定义模块编写说明文档"><a href="#自定义模块编写说明文档" class="headerlink" title="自定义模块编写说明文档"></a>自定义模块编写说明文档</h2><p>我们知道，在定义函数或者类时，可以为其添加说明文档，以方便用户清楚的知道该函数或者类的功能。自定义模块也不例外。</p>
<p>为自定义模块添加说明文档，和函数或类的添加方法相同，即只需在模块开头的位置定义一个字符串即可。例如，为 demo.py 模板文件添加一个说明文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">demo 模块中包含以下内容：</span><br><span class="line">name 字符串变量：初始值为“Python教程”</span><br><span class="line">add    字符串变量：初始值为“http://c.biancheng.net/python”</span><br><span class="line">say() 函数</span><br><span class="line">CLanguage类：包含 name 和 add 属性和 say() 方法。</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<p>在此基础上，我们可以通过模板的 <strong>doc</strong> 属性，来访问模板的说明文档。例如，在 test.py 文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import demo</span><br><span class="line">print(demo.__doc__)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：<br>Python教程 <a target="_blank" rel="noopener" href="http://c.biancheng.net/python">http://c.biancheng.net/python</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">demo 模块中包含以下内容：</span><br><span class="line">name 字符串变量：初始值为“Python教程”</span><br><span class="line">add    字符串变量：初始值为“http://c.biancheng.net/python”</span><br><span class="line">say() 函数</span><br><span class="line">CLanguage类：包含 name 和 add 属性和 say() 方法。</span><br></pre></td></tr></table></figure>
<h1 id="导入模块的3种方式"><a href="#导入模块的3种方式" class="headerlink" title="导入模块的3种方式"></a>导入模块的3种方式</h1><p>即自定义 Python 模板后，在其它文件中用 import（或 from…import） 语句引入该文件时，Python 解释器同时如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named &#x27;模块名&#x27;</span><br></pre></td></tr></table></figure>
<p>意思是 Python 找不到这个模块名，这是什么原因导致的呢？要想解决这个问题，读者要先搞清楚 Python 解释器查找模块文件的过程。</p>
<p>通常情况下，当使用 import 语句导入模块后，Python 会按照以下顺序查找指定的模块文件：<br>在当前目录，即当前执行的程序文件所在目录下查找；<br>到 PYTHONPATH（环境变量）下的每个目录中查找；<br>到 Python 默认的安装目录下查找。</p>
<p>以上所有涉及到的目录，都保存在标准模块 sys 的 sys.path 变量中，通过此变量我们可以看到指定程序文件支持查找的所有目录。换句话说，如果要导入的模块没有存储在 sys.path 显示的目录中，那么导入该模块并运行程序时，Python 解释器就会抛出 ModuleNotFoundError（未找到模块）异常。</p>
<p>解决“Python找不到指定模块”的方法有 3 种，分别是：</p>
<ul>
<li>向 sys.path 中临时添加模块文件存储位置的完整路径；</li>
<li>将模块放在 sys.path 变量中已包含的模块加载路径中；</li>
<li>设置 path 系统环境变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#hello.py</span><br><span class="line">def say ():</span><br><span class="line">    print(&quot;Hello,World!&quot;)</span><br><span class="line">#say.py</span><br><span class="line">import hello</span><br><span class="line">hello.say()</span><br></pre></td></tr></table></figure>
<p>显然，hello.py 文件和 say.py 文件并不在同一目录，此时运行 say.py 文件，其运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\say.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    import hello</span><br><span class="line">ModuleNotFoundError: No module named &#x27;hello&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到，Python 解释器抛出了 ModuleNotFoundError 异常。接下来，分别用以上 3 种方法解决这个问题。</p>
<h2 id="导入模块方式一：临时添加模块完整路径"><a href="#导入模块方式一：临时添加模块完整路径" class="headerlink" title="导入模块方式一：临时添加模块完整路径"></a>导入模块方式一：临时添加模块完整路径</h2><p>模块文件的存储位置，可以临时添加到 sys.path 变量中，即向 sys.path 中添加 D:\python_module（hello.py 所在目录），在 say.py 中的开头位置添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&#x27;D:\\python_module&#x27;)</span><br></pre></td></tr></table></figure>
<p>注意：在添加完整路径中，路径中的 ‘&#39; 需要使用 \ 进行转义，否则会导致语法错误。再次运行 say.py 文件，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure>
<p>可以看到，程序成功运行。在此基础上，我们在 say.py 文件中输出 sys.path 变量的值，会得到以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;C:\\Users\\mengma\\Desktop&#x27;, &#x27;D:\\python3.6\\Lib\\idlelib&#x27;, &#x27;D:\\python3.6\\python36.zip&#x27;, &#x27;D:\\python3.6\\DLLs&#x27;, &#x27;D:\\python3.6\\lib&#x27;, &#x27;D:\\python3.6&#x27;, &#x27;C:\\Users\\mengma\\AppData\\Roaming\\Python\\Python36\\site-packages&#x27;, &#x27;D:\\python3.6\\lib\\site-packages&#x27;, &#x27;D:\\python3.6\\lib\\site-packages\\win32&#x27;, &#x27;D:\\python3.6\\lib\\site-packages\\win32\\lib&#x27;, &#x27;D:\\python3.6\\lib\\site-packages\\Pythonwin&#x27;, &#x27;D:\\python_module&#x27;]</span><br></pre></td></tr></table></figure>
<p>该输出信息中，红色部分就是临时添加进去的存储路径。需要注意的是，通过该方法添加的目录，只能在执行当前文件的窗口中有效，窗口关闭后即失效。</p>
<h2 id="导入模块方式二：将模块保存到指定位置"><a href="#导入模块方式二：将模块保存到指定位置" class="headerlink" title="导入模块方式二：将模块保存到指定位置"></a>导入模块方式二：将模块保存到指定位置</h2><p>如果要安装某些通用性模块，比如复数功能支持的模块、矩阵计算支持的模块、图形界面支持的模块等，这些都属于对 Python 本身进行扩展的模块，这种模块应该直接安装在 Python 内部，以便被所有程序共享，此时就可借助于 Python 默认的模块加载路径。</p>
<p>Python 程序默认的模块加载路径保存在 sys.path 变量中，因此，我们可以在 say.py 程序文件中先看看 sys.path 中保存的默认加载路径，向 say.py 文件中输出 sys.path 的值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;C:\\Users\\mengma\\Desktop&#x27;, &#x27;D:\\python3.6\\Lib\\idlelib&#x27;, &#x27;D:\\python3.6\\python36.zip&#x27;, &#x27;D:\\python3.6\\DLLs&#x27;, &#x27;D:\\python3.6\\lib&#x27;, &#x27;D:\\python3.6&#x27;, &#x27;C:\\Users\\mengma\\AppData\\Roaming\\Python\\Python36\\site-packages&#x27;, &#x27;D:\\python3.6\\lib\\site-packages&#x27;, &#x27;D:\\python3.6\\lib\\site-packages\\win32&#x27;, &#x27;D:\\python3.6\\lib\\site-packages\\win32\\lib&#x27;, &#x27;D:\\python3.6\\lib\\site-packages\\Pythonwin&#x27;]</span><br></pre></td></tr></table></figure>
<p>上面的运行结果中，列出的所有路径都是 Python 默认的模块加载路径，但通常来说，我们默认将 Python 的扩展模块添加在 lib\site-packages 路径下，它专门用于存放 Python 的扩展模块和包。</p>
<p>所以，我们可以直接将我们已编写好的 hello.py 文件添加到  lib\site-packages 路径下，就相当于为 Python 扩展了一个 hello 模块，这样任何 Python 程序都可使用该模块。</p>
<p>移动工作完成之后，再次运行 say.py 文件，可以看到成功运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure>
<h2 id="导入模块方式三：设置环境变量"><a href="#导入模块方式三：设置环境变量" class="headerlink" title="导入模块方式三：设置环境变量"></a>导入模块方式三：设置环境变量</h2><p>PYTHONPATH 环境变量（简称 path 变量）的值是很多路径组成的集合，Python 解释器会按照 path 包含的路径进行一次搜索，直到找到指定要加载的模块。当然，如果最终依旧没有找到，则 Python 就报 ModuleNotFoundError 异常。</p>
<p>在 Windows 平台上设置环境变量<br>首先，找到桌面上的“计算机”（或者我的电脑），并点击鼠标右键，单击“属性”。此时会显示“控制面板\所有控制面板项\系统”窗口，单击该窗口左边栏中的“高级系统设置”菜单，出现“系统属性”对话框，如图 1 所示。</p>
<p>图 1 系统属性对话框</p>
<p>如图 1 所示，点击“环境变量”按钮，此时将弹出图 2 所示的对话框：</p>
<p>图 2 环境变量对话框</p>
<p>如图 2 所示，通过该对话框，就可以完成 path 环境变量的设置。需要注意的是，该对话框分为上下 2 部分，其中上面的“用户变量”部分用于设置当前用户的环境变量，下面的“系统变量”部分用于设置整个系统的环境变量。</p>
<p>通常情况下，建议大家设置设置用户的 path 变量即可，因为此设置仅对当前登陆系统的用户有效，而如果修改系统的 path 变量，则对所有用户有效。<br>对于普通用户来说，设置用户 path 变量和系统 path 变量的效果是相同的，但 Python 在使用 path 变量时，会先按照系统 path 变量的路径去查找，然后再按照用户 path 变量的路径去查找。</p>
<p>这里我们选择设置当前用户的 path 变量。单击用户变量中的“新建”按钮， 系统会弹出如图 3 所示的对话框。</p>
<p>图 3 新建PYTHONPATH环境变量</p>
<p>其中，在“变量名”文本框内输入 PYTHONPATH，表明将要建立名为 PYTHONPATH 的环境变量；在“变量值”文本框内输入 .;d:\python_ module。注意，这里其实包含了两条路径（以分号 ；作为分隔符）：<br>第一条路径为一个点（.），表示当前路径，当运行 Python 程序时，Python 将可以从当前路径加载模块；<br>第二条路径为 d:\python_ module，当运行 Python 程序时，Python 将可以从 d:\python_ module 中加载模块。</p>
<p>然后点击“确定”，即成功设置 path 环境变量。此时，我们只需要将模块文件移动到和引入该模块的文件相同的目录，或者移动到 d:\python_ module 路径下，该模块就能被成功加载。<br>在 Linux 上设置环境变量<br>启动 Linux 的终端窗口，进入当前用户的 home 路径下，然后在 home 路径下输入如下命令：<br>ls - a</p>
<p>该命令将列出当前路径下所有的文件，包括隐藏文件。Linux 平台的环境变量是通过 .bash_profile 文件来设置的，使用无格式编辑器打开该文件，在该文件中添加 PYTHONPATH 环境变量。也就是为该文件增加如下一行：<br>#设置PYTHON PATH 环境变量<br>PYTHONPATH&#x3D;.:&#x2F;home&#x2F;mengma&#x2F;python_module</p>
<p>Linux 与 Windows 平台不一样，多个路径之间以冒号（:）作为分隔符，因此上面一行同样设置了两条路径，点（.）代表当前路径，还有一条路径是 &#x2F;home&#x2F;mengma&#x2F;python_module（mengma 是在 Linux 系统的登录名）。</p>
<p>在完成了 PYTHONPATH 变量值的设置后，在 .bash_profile 文件的最后添加导出 PYTHONPATH 变量的语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#导出PYTHONPATH 环境变量</span><br><span class="line">export PYTHONPATH</span><br></pre></td></tr></table></figure>
<p>重新登录 Linux 平台，或者执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.bash_profile</span><br></pre></td></tr></table></figure>
<p>这两种方式都是为了运行该文件，使在文件中设置的 PYTHONPATH 变量值生效。</p>
<p>在成功设置了上面的环境变量之后，接下来只要把前面定义的模块（Python 程序）放在与当前所运行 Python 程序相同的路径中（或放在 &#x2F;home&#x2F;mengma&#x2F;python_module 路径下），该模块就能被成功加载了。<br>在Mac OS X 上设置环境变量<br>在 Mac OS X 上设置环境变量与 Linux 大致相同（因为 Mac OS X 本身也是类 UNIX 系统）。启动 Mac OS X 的终端窗口（命令行界面），进入当前用户的 home 路径下，然后在 home 路径下输入如下命令：<br>ls -a</p>
<p>该命令将列出当前路径下所有的文件，包括隐藏文件。Mac OS X 平台的环境变量也可通过，bash_profile 文件来设置，使用无格式编辑器打开该文件，在该文件中添加 PYTHONPATH 环境变量。也就是为该文件增加如下一行：<br>#设置PYTHON PATH 环境变盘<br>PYTHONPATH&#x3D;.:&#x2F;Users&#x2F;mengma&#x2F;python_module</p>
<p>Mac OS X 的多个路径之间同样以冒号（:）作为分隔符，因此上面一行同样设置了两条路径：点（.）代表当前路径，还有一条路径是 &#x2F;Users&#x2F;mengma&#x2F;python_module。</p>
<p>在完成了 PYTHONPATH 变量值的设置后，在 .bash_profile 文件的最后添加导出 PYTHONPATH 变量的语句。<br>#导出PYTHON PATH 环境变量<br>export PYTHONPATH</p>
<p>重新登录 Mac OS X 系统，或者执行如下命令：<br>source.bash_profile</p>
<p>这两种方式都是为了运行该文件，使在文件中设置的 PYTHONPATH 变量值生效。</p>
<p>在成功设置了上面的环境变量之后，接下来只要把前面定义的模块（Python 程序）放在与当前所运行 Python 程序相同的路径中（或放在 Users&#x2F;mengma&#x2F;python_module 路径下），该模块就能被成功加载了。</p>
<h1 id="all-变量"><a href="#all-变量" class="headerlink" title="__all__变量"></a>__all__变量</h1><p>事实上，当我们向文件导入某个模块时，导入的是该模块中那些名称不以下划线（单下划线“_”或者双下划线“__”）开头的变量、函数和类。因此，如果我们不想模块文件中的某个成员被引入到其它文件中使用，可以在其名称前添加下划线。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;人生苦短，我学Python！&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CLanguage</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">disPython</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小红&quot;</span>)</span><br><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">from</span> demo <span class="keyword">import</span> *</span><br><span class="line">say()</span><br><span class="line">CLanguage()</span><br><span class="line">disPython()</span><br></pre></td></tr></table></figure>
<p>在此基础上，如果<code>demo.py</code>模块中的<code>disPython()</code>函数不想让其它文件引入，则只需将其名称改为<code>_disPython()</code>或者<code>__disPython()</code>。修改之后，再次执行<code>test.py</code>，其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">人生苦短，我学Python！</span><br><span class="line">小明：xiaoming</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:/Users/mengma/Desktop/2.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    disPython()</span><br><span class="line">NameError: name &#x27;disPython&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>显然，<code>test.py</code>文件中无法使用未引入的<code>disPython()</code>函数。</p>
<h2 id="Python模块-all-变量"><a href="#Python模块-all-变量" class="headerlink" title="Python模块__all__变量"></a>Python模块__all__变量</h2><p>除此之外，还可以借助模块提供的<code>__all__</code>变量，该变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。通过在模块文件中设置<code>__all__</code>变量，当其它文件以<code>from 模块名 import *</code>的形式导入该模块时，该文件中只能使用<code>__all__</code>列表中指定的成员。<br>也就是说，只有以<code>from 模块名 import *</code>形式导入的模块，当该模块设有<code>__all__</code>变量时，只能导入该变量指定的成员，未指定的成员是无法导入的。</p>
<p>举个例子，修改 demo.py 模块文件中的代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;人生苦短，我学Python！&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CLanguage</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">disPython</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小红&quot;</span>)</span><br><span class="line">__all__ = [<span class="string">&quot;say&quot;</span>,<span class="string">&quot;CLanguage&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>可见，<code>__all__</code>变量只包含<code>say()</code>和<code>CLanguage()</code>的函数名，不包含<code>disPython()</code>函数的名称。此时直接执行<code>test.py</code>文件，其执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">人生苦短，我学Python！</span><br><span class="line">小明</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:/Users/mengma/Desktop/2.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    disPython()</span><br><span class="line">NameError: name &#x27;disPython&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>显然，对于 test.py 文件来说，demo.py 模块中的 disPython() 函数是未引入，这样调用是非法的。</p>
<p>再次声明，<code>__all__</code>变量仅限于在其它文件中以“from 模块名 import *”的方式引入。也就是说，如果使用以下 2 种方式引入模块，则<code>__all__</code>变量的设置是无效的。</p>
<ol>
<li><p>以“import 模块名”的形式导入模块。通过该方式导入模块后，总可以通过模块名前缀（如果为模块指定了别名，则可以使用模快的别名作为前缀）来调用模块内的所有成员（除了以下划线开头命名的成员）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;人生苦短，我学Python！&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CLanguage</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">disPython</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小红&quot;</span>)</span><br><span class="line">__all__ = [<span class="string">&quot;say&quot;</span>]</span><br><span class="line"><span class="comment">#test.py</span></span><br><span class="line"><span class="keyword">import</span> demo</span><br><span class="line">demo.say()</span><br><span class="line">demo.CLanguage()</span><br><span class="line">demo.disPython()</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然 demo.py 模块文件中设置有<code>__all__</code>变量，但是当以<code>import demo</code>的方式引入后，<code>__all__</code>变量将不起作用。</p>
</li>
<li><p>以<code>from 模块名 import 成员</code>的形式直接导入指定成员。使用此方式导入的模块，<code>__all__</code>变量即便设置，也形同虚设。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> demo <span class="keyword">import</span> say</span><br><span class="line"><span class="keyword">from</span> demo <span class="keyword">import</span> CLanguage</span><br><span class="line"><span class="keyword">from</span> demo <span class="keyword">import</span> disPython</span><br><span class="line">say()</span><br><span class="line">CLanguage()</span><br><span class="line">disPython()</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>实际开发中，一个大型的项目往往需要使用成百上千的 Python 模块，如果将这些模块都堆放在一起，势必不好管理。而且，使用模块可以有效避免变量名或函数名重名引发的冲突，但是如果模块名重复怎么办呢？因此，Python提出了包（Package）的概念。</p>
<p>简单理解，包就是文件夹，只不过在该文件夹下必须存在一个名为<code>__init__.py</code>的文件。</p>
<p>注意，这是 Python 2.x 的规定，而在 Python 3.x 中，<code>__init__.py</code>对包来说，并不是必须的。</p>
<p>每个包的目录下都必须建立一个<code>__init__.py</code>的模块，可以是一个空模块，可以写一些初始化代码，其作用就是告诉 Python 要将该目录当成包来处理。</p>
<p>注意，<code>__init__.py</code>不同于其他模块文件，此模块的模块名不是<code>__init__</code>，而是它所在的包名。例如，在<code>settings</code>包中的<code>__init__.py</code>文件，其模块名就是<code>settings</code>。</p>
<p>包是一个包含多个模块的文件夹，它的本质依然是模块，因此包中也可以包含包。</p>
<p>Python 库：相比模块和包，库是一个更大的概念，例如在 Python 标准库中的每个库都有好多个包，而每个包中都有若干个模块。</p>
<h1 id="创建包，导入包"><a href="#创建包，导入包" class="headerlink" title="创建包，导入包"></a>创建包，导入包</h1><p>包其实就是文件夹，更确切的说，是一个包含<code>__init__.py</code>文件的文件夹。因此，如果我们想手动创建一个包，只需进行以下 2 步操作：</p>
<ul>
<li>新建一个文件夹，文件夹的名称就是新建包的包名；</li>
<li>在该文件夹中，创建一个<code>__init__.py</code>文件（前后各有 2 个下划线‘_’），该文件中可以不编写任何代码。当然，也可以编写一些 Python 初始化代码，则当有其它程序文件导入包时，会自动执行该文件中的代码。</li>
</ul>
<p>例如，现在我们创建一个非常简单的包，该包的名称为<code>my_package</code>，可以仿照以上 2 步进行：</p>
<ul>
<li>创建一个文件夹，其名称设置为<code>my_package</code>；</li>
<li>在该文件夹中添加一个<code>__init__.py</code>文件，此文件中可以不编写任何代码。不过，这里向该文件编写如下代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">创建第一个 Python 包</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">print(&#x27;python&#x27;)</span><br></pre></td></tr></table></figure>
可以看到，<code>__init__.py</code>文件中，包含了 2 部分信息，分别是此包的说明信息和一条<code>print</code>输出语句。</li>
</ul>
<p>由此，我们就成功创建好了一个 Python 包。</p>
<p>创建好包之后，我们就可以向包中添加模块（也可以添加包）。这里给<code>my_package</code>包添加 2 个模块，分别是<code>module1.py、module2.py</code>，各自包含的代码分别如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#module1.py模块文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">arc</span>):</span><br><span class="line">  <span class="built_in">print</span>(arc)</span><br><span class="line"><span class="comment">#module2.py 模块文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>现在，我们就创建好了一个具有如下文件结构的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_package</span><br><span class="line">     ┠── __init__.py</span><br><span class="line">     ┠── module1.py</span><br><span class="line">     ┗━━  module2.py</span><br></pre></td></tr></table></figure>
<h2 id="Python包的导入"><a href="#Python包的导入" class="headerlink" title="Python包的导入"></a>Python包的导入</h2><p>包其实本质上还是模块，因此导入模块的语法同样也适用于导入包。无论导入我们自定义的包，还是导入从他处下载的第三方包，导入方法可归结为以下 3 种：</p>
<ul>
<li><code>import 包名[.模块名 [as 别名]]</code></li>
<li><code>from 包名 import 模块名 [as 别名]</code></li>
<li><code>from 包名.模块名 import 成员名 [as 别名]</code></li>
</ul>
<p>用<code>[]</code>括起来的部分，是可选部分，即可以使用，也可以直接忽略。</p>
<p>注意，导入包的同时，会在包目录下生成一个含有<code>__init__.cpython-36.pyc</code>文件的<code>__pycache__</code>文件夹。</p>
<h4 id="1-import-包名-模块名-as-别名"><a href="#1-import-包名-模块名-as-别名" class="headerlink" title="1) import 包名[.模块名 [as 别名]]"></a>1) import 包名[.模块名 [as 别名]]</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package.module1</span><br><span class="line">my_package.module1.display(<span class="string">&quot;java&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，通过此语法格式导入包中的指定模块后，在使用该模块中的成员（变量、函数、类）时，需添加“包名.模块名”为前缀。当然，如果使用<code>as</code>给包名.模块名”起一个别名的话，就使用直接使用这个别名作为前缀使用该模块中的方法了：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package.module1 <span class="keyword">as</span> module</span><br><span class="line">module.display(<span class="string">&quot;python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>另外，当直接导入指定包时，程序会自动执行该包所对应文件夹下的<code>__init__.py</code>文件中的代码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line">my_package.module1.display(<span class="string">&quot;linux&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>直接导入包名，并不会将包中所有模块全部导入到程序中，它的作用仅仅是导入并执行包下的<code>__init__.py</code>文件，因此，运行该程序，在执行<code>__init__.py</code>文件中代码的同时，还会抛出<code>AttributeError</code>异常（访问的对象不存在）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\demo.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    my_package.module1.display(&quot;linux&quot;)</span><br><span class="line">AttributeError: module &#x27;my_package&#x27; has no attribute &#x27;module1&#x27;</span><br></pre></td></tr></table></figure>
<p>我们知道，包的本质就是模块，导入模块时，当前程序中会包含一个和模块名同名且类型为<code>module</code>的变量，导入包也是如此：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"><span class="built_in">print</span>(my_package)</span><br><span class="line"><span class="built_in">print</span>(my_package.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(my_package))</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">&lt;module &#x27;my_package&#x27; from &#x27;C:\\Users\\mengma\\Desktop\\my_package\\__init__.py&#x27;&gt;</span><br><span class="line"></span><br><span class="line">创建第一个 Python 包</span><br><span class="line"></span><br><span class="line">&lt;class &#x27;module&#x27;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-from-包名-import-模块名-as-别名"><a href="#2-from-包名-import-模块名-as-别名" class="headerlink" title="2) from 包名 import 模块名 [as 别名]"></a>2) from 包名 import 模块名 [as 别名]</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module1</span><br><span class="line">module1.display(<span class="string">&quot;golang&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">golang</span><br></pre></td></tr></table></figure>
<p>可以看到，使用此语法格式导入包中模块后，在使用其成员时不需要带包名前缀，但需要带模块名前缀。</p>
<p>当然，我们也可以使用<code>as</code>为导入的指定模块定义别名：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package <span class="keyword">import</span> module1 <span class="keyword">as</span> module</span><br><span class="line">module.display(<span class="string">&quot;golang&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>同样，既然包也是模块，那么这种语法格式自然也支持<code>from 包名 import *</code>这种写法，它和<code>import</code>包名 的作用一样，都只是将该包的<code>__init__.py</code>文件导入并执行。</p>
<h4 id="3-from-包名-模块名-import-成员名-as-别名"><a href="#3-from-包名-模块名-import-成员名-as-别名" class="headerlink" title="3) from 包名.模块名 import 成员名 [as 别名]"></a>3) from 包名.模块名 import 成员名 [as 别名]</h4><p>此语法格式用于向程序中导入“包.模块”中的指定成员（变量、函数或类）。通过该方式导入的变量（函数、类），在使用时可以直接使用变量名（函数名、类名）调用：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.module1 <span class="keyword">import</span> display</span><br><span class="line">display(<span class="string">&quot;shell&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">shell</span><br></pre></td></tr></table></figure>
<p>当然，也可以使用<code>as</code>为导入的成员起一个别名：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.module1 <span class="keyword">import</span> display <span class="keyword">as</span> dis</span><br><span class="line">dis(<span class="string">&quot;shell&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>该程序的运行结果和上面相同。</p>
<p>另外，在使用此种语法格式加载指定包的指定模块时，可以使用 * 代替成员名，表示加载该模块下的所有成员。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_package.module1 <span class="keyword">import</span> *</span><br><span class="line">display(<span class="string">&quot;python&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="查看模块"><a href="#查看模块" class="headerlink" title="查看模块"></a>查看模块</h1><h2 id="查看模块成员：dir-函数"><a href="#查看模块成员：dir-函数" class="headerlink" title="查看模块成员：dir()函数"></a>查看模块成员：dir()函数</h2><p>通过<code>dir()</code>函数，我们可以查看某指定模块包含的全部成员（包括变量、函数和类）。注意这里所指的全部成员，不仅包含可供我们调用的模块成员，还包含所有名称以双下划线“__”开头和结尾的成员，而这些“特殊”命名的成员，是为了在本模块中使用的，并不希望被其它文件调用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(string))</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;Formatter&#x27;, &#x27;Template&#x27;, &#x27;_ChainMap&#x27;, &#x27;_TemplateMetaclass&#x27;, &#x27;__all__&#x27;, &#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;_re&#x27;, &#x27;_string&#x27;, &#x27;ascii_letters&#x27;, &#x27;ascii_lowercase&#x27;, &#x27;ascii_uppercase&#x27;, &#x27;capwords&#x27;, &#x27;digits&#x27;, &#x27;hexdigits&#x27;, &#x27;octdigits&#x27;, &#x27;printable&#x27;, &#x27;punctuation&#x27;, &#x27;whitespace&#x27;]</span><br></pre></td></tr></table></figure>
<p>可以看到，通过<code>dir()</code>函数获取到的模块成员，不仅包含供外部文件使用的成员，还包含很多“特殊”（名称以 2 个下划线开头和结束）的成员，列出这些成员，对我们并没有实际意义。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>([e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">dir</span>(string) <span class="keyword">if</span> <span class="keyword">not</span> e.startswith(<span class="string">&#x27;_&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;Formatter&#x27;, &#x27;Template&#x27;, &#x27;ascii_letters&#x27;, &#x27;ascii_lowercase&#x27;, &#x27;ascii_uppercase&#x27;, &#x27;capwords&#x27;, &#x27;digits&#x27;, &#x27;hexdigits&#x27;, &#x27;octdigits&#x27;, &#x27;printable&#x27;, &#x27;punctuation&#x27;, &#x27;whitespace&#x27;]</span><br></pre></td></tr></table></figure>
<p>显然通过列表推导式，可在<code>dir()</code>函数输出结果的基础上，筛选出对我们有用的成员并显示出来。</p>
<h2 id="查看模块成员：-all-变量"><a href="#查看模块成员：-all-变量" class="headerlink" title="查看模块成员：__all__变量"></a>查看模块成员：__all__变量</h2><p><code>__all__</code>变量也可以查看模块（包）内包含的所有成员。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string.__all__)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;ascii_letters&#x27;, &#x27;ascii_lowercase&#x27;, &#x27;ascii_uppercase&#x27;, &#x27;capwords&#x27;, &#x27;digits&#x27;, &#x27;hexdigits&#x27;, &#x27;octdigits&#x27;, &#x27;printable&#x27;, &#x27;punctuation&#x27;, &#x27;whitespace&#x27;, &#x27;Formatter&#x27;, &#x27;Template&#x27;]</span><br></pre></td></tr></table></figure>
<p>和<code>dir()</code>函数相比，<code>__all__</code>变量在查看指定模块成员时，它不会显示模块中的特殊成员，同时还会根据成员的名称进行排序显示。</p>
<p>不过需要注意的是，并非所有的模块都支持使用<code>__all__</code>变量，因此对于获取有些模块的成员，就只能使用<code>dir()</code>函数。</p>
<h1 id="doc-属性：查看文档"><a href="#doc-属性：查看文档" class="headerlink" title="__doc__属性：查看文档"></a>__doc__属性：查看文档</h1><p>在使用<code>dir()</code>函数和<code>__all__</code>变量的基础上，虽然我们能知晓指定模块（或包）中所有可用的成员（变量、函数和类）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string.__all__)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;ascii_letters&#x27;, &#x27;ascii_lowercase&#x27;, &#x27;ascii_uppercase&#x27;, &#x27;capwords&#x27;, &#x27;digits&#x27;, &#x27;hexdigits&#x27;, &#x27;octdigits&#x27;, &#x27;printable&#x27;, &#x27;punctuation&#x27;, &#x27;whitespace&#x27;, &#x27;Formatter&#x27;, &#x27;Template&#x27;]</span><br></pre></td></tr></table></figure>
<p>但对于以上的输出结果，对于不熟悉<code>string</code>模块的用户，还是不清楚这些名称分别表示的是什么意思，更不清楚各个成员有什么功能。</p>
<p>针对这种情况，我们可以使用<code>help()</code>函数来获取指定成员（甚至是该模块）的帮助信息。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#***__init__.py 文件中的内容***</span></span><br><span class="line"><span class="keyword">from</span> my_package.module1 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> my_package.module2 <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#***module1.py 中的内容***</span></span><br><span class="line"><span class="comment">#module1.py模块文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">arc</span>):</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  直接输出指定的参数</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(arc)</span><br><span class="line"><span class="comment">#***module2.py中的内容***</span></span><br><span class="line"><span class="comment">#module2.py 模块文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  CLanguage是一个类，其包含：</span></span><br><span class="line"><span class="string">  display() 方法</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">display</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>现在，我们先借助<code>dir()</code>函数，查看<code>my_package</code>包中有多少可供我们调用的成员：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"><span class="built_in">print</span>([e <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">dir</span>(my_package) <span class="keyword">if</span> <span class="keyword">not</span> e.startswith(<span class="string">&#x27;_&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;CLanguage&#x27;, &#x27;display&#x27;, &#x27;module1&#x27;, &#x27;module2&#x27;]</span><br></pre></td></tr></table></figure>
<p>通过此输出结果可以得知，在<code>my_package</code>包中，有以上 4 个成员可供我们使用。接下来，我们使用<code>help()</code>函数来查看这些成员的具体含义（以 module1 为例）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"><span class="built_in">help</span>(my_package.module1)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Help on module my_package.module1 in my_package:</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    my_package.module1 - #module1.py模块文件</span><br><span class="line"></span><br><span class="line">FUNCTIONS</span><br><span class="line">    display(arc)</span><br><span class="line">        直接输出指定的参数</span><br><span class="line"></span><br><span class="line">FILE</span><br><span class="line">    c:\users\mengma\desktop\my_package\module1.py</span><br></pre></td></tr></table></figure>
<p>通过输出结果可以得知，<code>module1</code>实际上是一个模块文件，其包含<code>display()</code>函数，该函数的功能是直接输出指定的<code>arc</code>参数。同时，还显示出了该模块具体的存储位置。</p>
<p>值得一提的是，之所以我们可以使用<code>help()</code>函数查看具体成员的信息，是因为该成员本身就包含表示自身身份的说明文档（本质是字符串，位于该成员内部开头的位置）。无论是函数还是类，都可以使用<code>__doc__</code>属性获取它们的说明文档，模块也不例外。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"><span class="built_in">print</span>(my_package.module1.display.__doc__)</span><br></pre></td></tr></table></figure>
<p>其实，<code>help()</code>函数底层也是借助<code>__doc__</code>属性实现的。</p>
<p>如果使用<code>help()</code>函数或者<code>__doc__</code>属性，仍然无法满足我们的需求，还可以调用<code>__file__</code>属性，查看该模块或者包文件的具体存储位置，直接查看其源代码。</p>
<h1 id="file-属性：查看模块的源文件路径"><a href="#file-属性：查看模块的源文件路径" class="headerlink" title="__file__属性：查看模块的源文件路径"></a>__file__属性：查看模块的源文件路径</h1><p>当指定模块（或包）没有说明文档时，仅通过<code>help()</code>函数或者<code>__doc__</code>属性，无法有效帮助我们理解该模块（包）的具体功能。在这种情况下，我们可以通过<code>__file__</code>属性查找该模块（或包）文件所在的具体存储位置，直接查看其源代码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_package</span><br><span class="line"><span class="built_in">print</span>(my_package.__file__) <span class="comment"># C:\Users\mengma\Desktop\my_package\__init__.py</span></span><br></pre></td></tr></table></figure>
<p>注意，因为当引入<code>my_package</code>包时，其实际上执行的是<code>__init__.py</code>文件，因此这里查看<code>my_package</code>包的存储路径，输出的<code>__init__.py</code>文件的存储路径。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="built_in">print</span>(string.__file__) <span class="comment"># D:\python3.6\lib\string.py</span></span><br></pre></td></tr></table></figure>
<p>注意，并不是所有模块都提供<code>__file__</code>属性，因为并不是所有模块的实现都采用 Python 语言，有些模块采用的是其它编程语言。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python文件操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2022/12/14/python/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2022-12-14T04:08:50.777Z" itemprop="datePublished">2022-12-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>当程序运行时，变量是保存数据的好方法，但变量、序列以及对象中存储的数据是暂时的，程序结束后就会丢失，如果希望程序结束后数据仍然保持，就需要将数据保存到文件中。Python 提供了内置的文件对象，以及对文件、目录进行操作的内置模块，通过这些技术可以很方便地将数据保存到文件（如文本文件等）中。</p>
<p>关于文件，它有两个关键属性，分别是“文件名”和“路径”。</p>
<p>在 Windows 上，路径书写使用反斜杠 “&quot; 作为文件夹之间的分隔符。但在 OS X 和 Linux 上，使用正斜杠 “&#x2F;“ 作为它们的路径分隔符。如果想要程序运行在所有操作系统上，在编写 Python 脚本时，就必须处理这两种情况。</p>
<p>好在，用<code>os.path.join()</code>函数来做这件事很简单。如果将单个文件和路径上的文件夹名称的字符串传递给它，<code>os.path.join()</code>就会返回一个文件路径的字符串，包含正确的路径分隔符。在交互式环境中输入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.path.join(&#x27;demo&#x27;, &#x27;exercise&#x27;)</span><br><span class="line">&#x27;demo\\exercise&#x27;</span><br></pre></td></tr></table></figure>
<p>因为此程序是在 Windows 上运行的，所以<code>os.path.join(&#39;demo&#39;, &#39;exercise&#39;)</code>返回<code>&#39;demo\\exercise&#39;</code>（请注意，反斜杠有两个，因为每个反斜杠需要由另一个反斜杠字符来转义）。如果在 OS X 或 Linux 上调用这个函数，该字符串就会是<code>&#39;demo/exercise&#39;</code>。</p>
<p>不仅如此，如果需要创建带有文件名称的文件存储路径，os.path.join() 函数同样很有用。例如，下面的例子将一个文件名列表中的名称，添加到文件夹名称的末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">myFiles = [&#x27;accounts.txt&#x27;, &#x27;details.csv&#x27;, &#x27;invite.docx&#x27;]</span><br><span class="line">for filename in myFiles:</span><br><span class="line">    print(os.path.join(&#x27;C:\\demo\\exercise&#x27;, filename))</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\demo\exercise\accounts.txt</span><br><span class="line">C:\demo\exercise\details.csv</span><br><span class="line">C:\demo\exercise\invite.docx</span><br></pre></td></tr></table></figure>
<h1 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h1><h2 id="什么是当前工作目录"><a href="#什么是当前工作目录" class="headerlink" title="什么是当前工作目录"></a>什么是当前工作目录</h2><p>每个运行在计算机上的程序，都有一个“当前工作目录”（或<code>cwd</code>）。所有没有从根文件夹开始的文件名或路径，都假定在当前工作目录下。</p>
<p>在 Python 中，利用<code>os.getcwd()</code>函数可以取得当前工作路径的字符串，还可以利用<code>os.chdir()</code>改变它。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br><span class="line"><span class="string">&#x27;C:\\Users\\mengma\\Desktop&#x27;</span></span><br><span class="line">os.chdir(<span class="string">&#x27;C:\\Windows\\System32&#x27;</span>)</span><br><span class="line">os.getcwd()</span><br><span class="line"><span class="string">&#x27;C:\\Windows\\System32&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，原本当前工作路径为<code>&#39;C:\\Users\\mengma\\Desktop&#39;</code>（也就是桌面），通过<code>os.chdir()</code>函数，将其改成了<code>&#39;C:\\Windows\\System32&#39;</code>。</p>
<p>需要注意的是，如果使用<code>os.chdir()</code>修改的工作目录不存在，Python 解释器会报错：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">&#x27;C:\\error&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#6&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    os.chdir(<span class="string">&#x27;C:\\error&#x27;</span>)</span><br><span class="line">FileNotFoundError: [WinError <span class="number">2</span>] 系统找不到指定的文件。: <span class="string">&#x27;C:\\error&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="什么是绝对路径与相对路径"><a href="#什么是绝对路径与相对路径" class="headerlink" title="什么是绝对路径与相对路径"></a>什么是绝对路径与相对路径</h2><p>明确一个文件所在的路径，有 2 种表示方式，分别是：</p>
<ul>
<li>绝对路径：总是从根文件夹开始，Window 系统中以盘符（C：、D：）作为根文件夹，而 OS X 或者 Linux 系统中以<code>/</code>作为根文件夹。</li>
<li>相对路径：指的是文件相对于当前工作目录所在的位置。例如，当前工作目录为<code>&quot;C:\Windows\System32&quot;</code>，若文件<code>demo.txt</code>就位于这个 System32 文件夹下，则<code>demo.txt</code>的相对路径表示为<code>&quot;.\demo.txt&quot;</code>（其中<code>.\</code>就表示当前所在目录）。</li>
</ul>
<p>在使用相对路径表示某文件所在的位置时，除了经常使用<code>.\</code>表示当前所在目录之外，还会用到<code>..\</code>表示当前所在目录的父目录。</p>
<h2 id="Python处理绝对路径和相对路径"><a href="#Python处理绝对路径和相对路径" class="headerlink" title="Python处理绝对路径和相对路径"></a>Python处理绝对路径和相对路径</h2><p>Python <code>os.path</code>模块提供了一些函数，可以实现绝对路径和相对路径之间的转换，以及检查给定的路径是否为绝对路径，比如说：</p>
<ul>
<li>调用<code>os.path.abspath(path)</code>将返回 path 参数的绝对路径的字符串，这是将相对路径转换为绝对路径的简便方法。</li>
<li>调用<code>os.path.isabs(path)</code>，如果参数是一个绝对路径，就返回<code>True</code>，如果参数是一个相对路径，就返回<code>False</code>。</li>
<li>调用<code>os.path.relpath(path, start)</code>将返回从<code>start</code>路径到<code>path</code>的相对路径的字符串。如果没有提供<code>start</code>，就使用当前工作目录作为开始路径。</li>
<li>调用<code>os.path.dirname(path)</code>将返回一个字符串，它包含<code>path</code>参数中最后一个斜杠之前的所有内容；调用<code>os.path.basename(path)</code>将返回一个字符串，它包含<code>path</code>参数中最后一个斜杠之后的所有内容。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.getcwd()</span><br><span class="line"><span class="string">&#x27;C:\\Windows\\System32&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;C:\\Windows\\System32&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="string">&#x27;.\\Scripts&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;C:\\Windows\\System32\\Scripts&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isabs(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isabs(os.path.abspath(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.relpath(<span class="string">&#x27;C:\\Windows&#x27;</span>, <span class="string">&#x27;C:\\&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Windows&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.relpath(<span class="string">&#x27;C:\\Windows&#x27;</span>, <span class="string">&#x27;C:\\spam\\eggs&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;..\\..\\Windows&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">&#x27;C:\\Windows\\System32\\calc.exe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.basename(path)</span><br><span class="line"><span class="string">&#x27;calc.exe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.dirname(path)</span><br><span class="line"><span class="string">&#x27;C:\\Windows\\System32&#x27;</span></span><br></pre></td></tr></table></figure>
<p>除此之外，如果同时需要一个路径的目录名称和基本名称，就可以调用<code>os.path.split()</code>获得这两个字符串的元组：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>path = <span class="string">&#x27;C:\\Windows\\System32\\calc.exe&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(path)</span><br><span class="line">(<span class="string">&#x27;C:\\Windows\\System32&#x27;</span>, <span class="string">&#x27;calc.exe&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意，可以调用<code>os.path.dirname()</code>和<code>os.path.basename()</code>，将它们的返回值放在一个元组中，从而得到同样的元组。但使用<code>os.path.split()</code>无疑是很好的快捷方式。</p>
<p>同时，如果提供的路径不存在，许多 Python 函数就会崩溃并报错，但好在<code>os.path</code>模块提供了以下函数用于检测给定的路径是否存在，以及它是文件还是文件夹：</p>
<ul>
<li>如果<code>path</code>参数所指的文件或文件夹存在，调用<code>os.path.exists(path)</code>将返回<code>True</code>，否则返回<code>False</code>。</li>
<li>如果<code>path</code>参数存在，并且是一个文件，调用<code>os.path.isfile(path)</code>将返回<code>True</code>，否则返回<code>False</code>。</li>
<li>如果<code>path</code>参数存在，并且是一个文件夹，调用<code>os.path.isdir(path)</code>将返回<code>True</code>，否则返回<code>False</code>。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">&#x27;C:\\Windows&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">&#x27;C:\\some_made_up_folder&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">&#x27;C:\\Windows\\System32&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">&#x27;C:\\Windows\\System32&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">&#x27;C:\\Windows\\System32\\calc.exe&#x27;</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">&#x27;C:\\Windows\\System32\\calc.exe&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h1 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h1><p>对文件的常见的操作包括创建、删除、修改权限、读取、写入等，这些操作可大致分为以下 2 类：</p>
<ul>
<li>删除、修改权限：作用于文件本身，属于系统级操作。</li>
<li>写入、读取：是文件最常用的操作，作用于文件的内容，属于应用级操作。</li>
</ul>
<p>其中，对文件的系统级操作可以借助 Python 中的专用模块（<code>os、sys</code>等），并调用模块中的指定函数来实现。例如，假设如下代码文件的同级目录中有一个文件<code>a.txt</code>，通过调用<code>os</code>模块中的<code>remove</code>函数，可以将该文件删除：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(<span class="string">&quot;a.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>文件的应用级操作可以分为以下 3 步，每一步都需要借助对应的函数实现：</p>
<ul>
<li>打开文件：使用<code>open()</code>函数，该函数会返回一个文件对象；</li>
<li>对已打开文件做读&#x2F;写操作：读取文件内容可使用<code>read()、readline()</code>以及<code>readlines()</code>函数；向文件中写入内容，可以使用<code>write()</code>函数。</li>
<li>关闭文件：完成对文件的读&#x2F;写操作之后，最后需要关闭文件，可以使用<code>close()</code>函数。</li>
</ul>
<p>一个文件，必须在打开之后才能对其进行操作，并且在操作结束之后，还应该将其关闭，这 3 步的顺序不能打乱。</p>
<h1 id="open-函数：打开指定文件"><a href="#open-函数：打开指定文件" class="headerlink" title="open()函数：打开指定文件"></a>open()函数：打开指定文件</h1><p>如果想要操作文件，首先需要创建或者打开指定的文件，并创建一个文件对象，可以通过内置的<code>open()</code>函数实现。</p>
<p><code>open()</code>函数用于创建或打开指定文件：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(file_name [, mode=<span class="string">&#x27;r&#x27;</span> [ , buffering=-<span class="number">1</span> [ , encoding = <span class="literal">None</span> ]]])</span><br></pre></td></tr></table></figure>
<p>此格式中，用<code>[]</code>括起来的部分为可选参数，即可以使用也可以省略。其中，各参数含义：</p>
<ul>
<li><code>file</code>：表示要创建的文件对象。</li>
<li><code>file_name</code>：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。</li>
<li><code>mode</code>：可选参数，用于指定文件的打开模式。如果不写，则默认以只读（<code>r</code>）模式打开文件。</li>
<li><code>buffering</code>：可选参数，用于指定对文件做读写操作时，是否使用缓冲区。</li>
<li><code>encoding</code>：手动设定打开文件时所使用的编码格式，不同平台的<code>ecoding</code>参数值也不同，Windows 默认为 cp936（实际上就是 GBK 编码）。</li>
</ul>
<p><code>open</code>函数支持的文件打开模式：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">意义</th>
<th align="center">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">只读模式打开文件，读文件内容的指针会放在文件的开头。</td>
<td align="center">操作的文件必须存在。</td>
</tr>
<tr>
<td align="center">rb</td>
<td align="center">以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。</td>
<td align="center">操作的文件必须存在。</td>
</tr>
<tr>
<td align="center">r+</td>
<td align="center">打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。</td>
<td align="center">操作的文件必须存在。</td>
</tr>
<tr>
<td align="center">rb+</td>
<td align="center">以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。</td>
<td align="center">操作的文件必须存在。</td>
</tr>
<tr>
<td align="center">w</td>
<td align="center">以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。	若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">wb</td>
<td align="center">以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件）</td>
<td align="center">若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。</td>
</tr>
<tr>
<td align="center">w+</td>
<td align="center">打开文件后，会对原有内容进行清空，并对该文件有读写权限。</td>
<td align="center">若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。</td>
</tr>
<tr>
<td align="center">wb+</td>
<td align="center">以二进制格式、读写模式打开文件，一般用于非文本文件</td>
<td align="center">若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ab</td>
<td align="center">以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">a+</td>
<td align="center">以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ab+</td>
<td align="center">以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>文件打开模式，直接决定了后续可以对文件做哪些操作。例如，使用<code>r</code>模式打开的文件，后续编写的代码只能读取文件，而无法修改文件内容。</p>
<p>不同文件打开模式的功能：</p>
<img src="/2022/12/14/python/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/1.gif" class="">

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#当前程序文件同目录下没有 a.txt 文件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(file)</span><br></pre></td></tr></table></figure>
<p>当以默认模式打开文件时，默认使用<code>r</code>权限，由于该权限要求打开的文件必须存在，因此运行此代码会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\demo.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    file = open(&quot;a.txt&quot;)</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &#x27;a.txt&#x27;</span><br></pre></td></tr></table></figure>
<p>现在，在程序文件同目录下，手动创建一个<code>a.txt</code>文件，并再次运行该程序，其运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;_io.TextIOWrapper name=&#x27;a.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，当前输出结果中，输出了<code>file</code>文件对象的相关信息，包括打开文件的名称、打开模式、打开文件时所使用的编码格式。</p>
<p>使用<code>open()</code>打开文件时，默认采用 GBK 编码。但当要打开的文件不是 GBK 编码格式时，可以在使用<code>open()</code>函数时，手动指定打开文件的编码格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意，手动修改<code>encoding</code>参数的值，仅限于文件以文本的形式打开，也就是说，以二进制格式打开时，不能对<code>encoding</code>参数的值做任何修改，否则程序会抛出<code>ValueError</code>异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: binary mode doesn&#x27;t take an encoding argument</span><br></pre></td></tr></table></figure>
<h2 id="open-是否需要缓冲区"><a href="#open-是否需要缓冲区" class="headerlink" title="open()是否需要缓冲区"></a>open()是否需要缓冲区</h2><p>通常情况下、建议在使用<code>open()</code>函数时打开缓冲区，即不需要修改<code>buffing</code>参数的值。</p>
<p>如果<code>buffing</code>参数的值为 0（或者<code>False</code>），则表示在打开指定文件时不使用缓冲区；如果<code>buffing</code>参数值为大于 1 的整数，该整数用于指定缓冲区的大小（单位是字节）；如果<code>buffing</code>参数的值为负数，则代表使用默认的缓冲区大小。</p>
<p>目前为止计算机内存的 I&#x2F;O 速度仍远远高于计算机外设（例如键盘、鼠标、硬盘等）的 I&#x2F;O 速度，如果不使用缓冲区，则程序在执行 I&#x2F;O 操作时，内存和外设就必须进行同步读写操作，也就是说，内存必须等待外设输入（输出）一个字节之后，才能再次输出（输入）一个字节。这意味着，内存中的程序大部分时间都处于等待状态。</p>
<p>而如果使用缓冲区，则程序在执行输出操作时，会先将所有数据都输出到缓冲区中，然后继续执行其它操作，缓冲区中的数据会有外设自行读取处理；同样，当程序执行输入操作时，会先等外设将数据读入缓冲区中，无需同外设做同步读写操作。</p>
<h2 id="open-文件对象常用的属性"><a href="#open-文件对象常用的属性" class="headerlink" title="open()文件对象常用的属性"></a>open()文件对象常用的属性</h2><p>成功打开文件之后，可以调用文件对象本身拥有的属性获取当前文件的部分信息，其常见的属性为：</p>
<ul>
<li><code>file.name</code>：返回文件的名称；</li>
<li><code>file.mode</code>：返回打开文件时，采用的文件打开模式；</li>
<li><code>file.encoding</code>：返回打开文件时使用的编码格式；</li>
<li><code>file.closed</code>：判断文件是否己经关闭。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以默认方式打开文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;my_file.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出文件是否已经关闭</span></span><br><span class="line"><span class="built_in">print</span>(f.closed) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 输出访问模式</span></span><br><span class="line"><span class="built_in">print</span>(f.mode) <span class="comment"># r</span></span><br><span class="line"><span class="comment">#输出编码格式</span></span><br><span class="line"><span class="built_in">print</span>(f.encoding) <span class="comment"># cp936</span></span><br><span class="line"><span class="comment"># 输出文件名</span></span><br><span class="line"><span class="built_in">print</span>(f.name) <span class="comment"># my_file.txt</span></span><br></pre></td></tr></table></figure>
<p>注意，使用<code>open()</code>函数打开的文件对象，必须手动进行关闭，Python 垃圾回收机制无法自动回收打开文件所占用的资源。</p>
<h1 id="read-函数：按字节（字符）读取文件"><a href="#read-函数：按字节（字符）读取文件" class="headerlink" title="read()函数：按字节（字符）读取文件"></a>read()函数：按字节（字符）读取文件</h1><p>Python 提供了如下 3 种函数，它们都可以帮我们实现读取文件中数据的操作：</p>
<ul>
<li><code>read()</code>函数：逐个字节或者字符读取文件中的内容；</li>
<li><code>readline()</code>函数：逐行读取文件中的内容；</li>
<li><code>readlines()</code>函数：一次性读取文件中多行内容。</li>
</ul>
<h2 id="read-函数"><a href="#read-函数" class="headerlink" title="read()函数"></a>read()函数</h2><p>对于借助<code>open()</code>函数，并以可读模式（包括<code>r、r+、rb、rb+</code>）打开的文件，可以调用<code>read()</code>函数逐个字节（或者逐个字符）读取文件中的内容。</p>
<p>如果文件是以文本模式（非二进制模式）打开的，则<code>read()</code>函数会逐个字符进行读取；反之，如果文件以二进制模式打开，则<code>read()</code>函数会逐个字节进行读取。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.read([size])</span><br></pre></td></tr></table></figure>
<p>其中，<code>file</code>表示已打开的文件对象；<code>size</code>作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以 utf-8 的编码格式打开指定文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment">#输出读取到的数据</span></span><br><span class="line"><span class="built_in">print</span>(f.read()) <span class="comment"># hello world!</span></span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以通过使用<code>size</code>参数，指定<code>read()</code>每次可读取的最大字符（或者字节）数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以 utf-8 的编码格式打开指定文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment">#输出读取到的数据</span></span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">6</span>)) <span class="comment"># hello </span></span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>显然，该程序中的<code>read()</code>函数只读取了<code>my_file</code>文件开头的 6 个字符。</p>
<p>再次强调，<code>size</code>表示的是一次最多可读取的字符（或字节）数，因此，即便设置的<code>size</code>大于文件中存储的字符（字节）数，<code>read()</code>函数也不会报错，它只会读取文件中所有的数据。</p>
<p>除此之外，对于以二进制格式打开的文件，<code>read()</code>函数会逐个字节读取文件中的内容。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以二进制形式打开指定文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,<span class="string">&#x27;rb+&#x27;</span>)</span><br><span class="line"><span class="comment">#输出读取到的数据</span></span><br><span class="line"><span class="built_in">print</span>(f.read()) <span class="comment"># b&#x27;Python\xe6\x95\x99\xe7\xa8\x8b\r\n&#x27;</span></span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>可以看到，输出的数据为<code>bytes</code>字节串。我们可以调用<code>decode()</code>方法，将其转换成我们认识的字符串。</p>
<p>另外需要注意的一点是，想使用<code>read()</code>函数成功读取文件内容，除了严格遵守<code>read()</code>的语法外，其还要求<code>open()</code>函数必须以可读默认（包括<code>r、r+、rb、rb+</code>）打开文件。举个例子，将上面程序中<code>open()</code>的打开模式改为<code>w</code>，程序会抛出<code>io.UnsupportedOperation</code>异常，提示文件没有读取权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\file.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    print(f.read())</span><br><span class="line">io.UnsupportedOperation: not readable</span><br></pre></td></tr></table></figure>
<h2 id="read-函数抛出UnicodeDecodeError异常的解决方法"><a href="#read-函数抛出UnicodeDecodeError异常的解决方法" class="headerlink" title="read()函数抛出UnicodeDecodeError异常的解决方法"></a>read()函数抛出UnicodeDecodeError异常的解决方法</h2><p>在使用<code>read()</code>函数时，如果 Python 解释器提示<code>UnicodeDecodeError</code>异常，其原因在于，目标文件使用的编码格式和<code>open()</code>函数打开该文件时使用的编码格式不匹配。</p>
<p>举个例子，如果目标文件的编码格式为 GBK 编码，而我们在使用<code>open()</code>函数并以文本模式打开该文件时，手动指定<code>encoding</code>参数为 UTF-8。这种情况下，由于编码格式不匹配，当我们使用<code>read()</code>函数读取目标文件中的数据时，Python 解释器就会提示<code>UnicodeDecodeError</code>异常。</p>
<p>要解决这个问题，要么将<code>open()</code>函数中的<code>encoding</code>参数值修改为和目标文件相同的编码格式，要么重新生成目标文件（即将该文件的编码格式改为和<code>open()</code>函数中的<code>encoding</code>参数相同）。</p>
<p>除此之外，还有一种方法：先使用二进制模式读取文件，然后调用<code>bytes</code>的<code>decode()</code>方法，使用目标文件的编码格式，将读取到的字节串转换成认识的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#以二进制形式打开指定文件，该文件编码格式为 utf-8</span><br><span class="line">f = open(&quot;my_file.txt&quot;,&#x27;rb+&#x27;)</span><br><span class="line">byt = f.read()</span><br><span class="line">print(byt)</span><br><span class="line">print(&quot;\n转换后：&quot;)</span><br><span class="line">print(byt.decode(&#x27;utf-8&#x27;))</span><br><span class="line">#关闭文件</span><br><span class="line">f.close()</span><br><span class="line">程序执行结果为：</span><br><span class="line">b&#x27;Python\xe6\x95\x99\xe7\xa8\x8b\r\n&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="readline-和readlines-函数：按行读取文件"><a href="#readline-和readlines-函数：按行读取文件" class="headerlink" title="readline()和readlines()函数：按行读取文件"></a>readline()和readlines()函数：按行读取文件</h1><p>和 read() 函数不同，这 2 个函数都以“行”作为读取单位，即每次都读取目标文件中的一行。对于读取以文本格式打开的文件，读取一行很好理解；对于读取以二进制格式打开的文件，它们会以“\n”作为读取一行的标志。</p>
<h2 id="readline-函数"><a href="#readline-函数" class="headerlink" title="readline()函数"></a>readline()函数</h2><p><code>readline()</code>函数用于读取文件中的一行，包含最后的换行符<code>\n</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.readline([size])</span><br></pre></td></tr></table></figure>
<p>其中，file 为打开的文件对象；size 为可选参数，用于指定读取每一行时，一次最多读取的字符（字节）数。<br>和 read() 函数一样，此函数成功读取文件数据的前提是，使用 open() 函数指定打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>)</span><br><span class="line"><span class="comment"># 读取一行数据</span></span><br><span class="line">byt = f.readline()</span><br><span class="line"><span class="built_in">print</span>(byt)</span><br></pre></td></tr></table></figure>
<p>由于<code>readline()</code>函数在读取文件中一行的内容时，会读取最后的换行符<code>\n</code>，再加上<code>print()</code>函数输出内容时默认会换行，所以输出结果中会看到多出了一个空行。</p>
<p>不仅如此，在逐行读取时，还可以限制最多可以读取的字符（字节）数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以二进制形式打开指定文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">byt = f.readline(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(byt)</span><br></pre></td></tr></table></figure>
<p>和上一个例子的输出结果相比，由于这里没有完整读取一行的数据，因此不会读取到换行符。</p>
<h2 id="readlines-函数"><a href="#readlines-函数" class="headerlink" title="readlines()函数"></a>readlines()函数</h2><p><code>readlines()</code>函数用于读取文件中的所有行，它和调用不指定<code>size</code>参数的<code>read()</code>函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。</p>
<p>和<code>readline()</code>函数一样，<code>readlines()</code>函数在读取每一行时，会连同行尾的换行符一块读取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.readlines()</span><br></pre></td></tr></table></figure>
<p>其中，<code>file</code>为打开的文件对象。和<code>read()、readline()</code>函数一样，它要求打开文件的模式必须为可读模式（包括<code>r、rb、r+、rb+</code>4 种）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">byt = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(byt)</span><br><span class="line">运行结果为：</span><br><span class="line">[<span class="string">b&#x27;Python\xbd\xcc\xb3\xcc\r\n&#x27;</span>, <span class="string">b&#x27;http://www.baidu.com&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h1 id="write-和writelines-：向文件中写入数据"><a href="#write-和writelines-：向文件中写入数据" class="headerlink" title="write()和writelines()：向文件中写入数据"></a>write()和writelines()：向文件中写入数据</h1><p>Python 中的文件对象提供了<code>write()</code>函数，可以向文件中写入指定内容。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.write(string)</span><br></pre></td></tr></table></figure>
<p>其中，<code>file</code>表示已经打开的文件对象；<code>string</code>表示要写入文件的字符串（或字节串，仅适用写入二进制文件中）。</p>
<p>注意，在使用<code>write()</code>向文件中写入数据，需保证使用<code>open()</code>函数是以<code>r+、w、w+、a</code>或<code>a+</code>的模式打开文件，否则执行<code>write()</code>函数会抛出<code>io.UnsupportedOperation</code>错误。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&quot;写入一行新数据&quot;</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>如果打开文件模式中包含<code>w</code>（写入），那么向文件中写入内容时，会先清空原文件中的内容，然后再写入新的内容。因此运行上面程序，再次打开<code>a.txt</code>文件，只会看到新写入的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写入一行新数据</span><br></pre></td></tr></table></figure>
<p>而如果打开文件模式中包含<code>a</code>（追加），则不会清空原有内容，而是将新写入的内容会添加到原内容后边。</p>
<p>因此，采用不同的文件打开模式，会直接影响<code>write()</code>函数向文件中写入数据的效果。</p>
<p>另外，在写入文件完成后，一定要调用<code>close()</code>函数将打开的文件关闭，否则写入的内容不会保存到文件中。例如，将上面程序中最后一行<code>f.close()</code>删掉，再次运行此程序并打开<code>a.txt</code>，你会发现该文件是空的。这是因为，当我们在写入文件内容时，操作系统不会立刻把数据写入磁盘，而是先缓存起来，只有调用<code>close()</code>函数时，操作系统才会保证把没有写入的数据全部写入磁盘文件中。</p>
<p>除此之外，如果向文件写入数据后，不想马上关闭文件，也可以调用文件对象提供的<code>flush()</code>函数，它可以实现将缓冲区的数据写入文件中。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&quot;写入一行新数据&quot;</span>)</span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure>
<p>打开<code>a.txt</code>文件，可以看到写入的新内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写入一行新数据</span><br></pre></td></tr></table></figure>
<p>通过设置<code>open()</code>函数的<code>buffering</code>参数可以关闭缓冲区，这样数据不就可以直接写入文件中了？对于以二进制格式打开的文件，可以不使用缓冲区，写入的数据会直接进入磁盘文件；但对于以文本格式打开的文件，必须使用缓冲区，否则 Python 解释器会<code>ValueError</code>错误。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>,buffering = <span class="number">0</span>)</span><br><span class="line">f.write(<span class="string">&quot;写入一行新数据&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\demo.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    f = open(&quot;a.txt&quot;, &#x27;w&#x27;,buffering = 0)</span><br><span class="line">ValueError: can&#x27;t have unbuffered text I/O</span><br></pre></td></tr></table></figure>
<h1 id="writelines-函数"><a href="#writelines-函数" class="headerlink" title="writelines()函数"></a>writelines()函数</h1><p><code>writelines()</code>函数可以实现将字符串列表写入文件中。</p>
<p>注意，写入函数只有<code>write()</code>和<code>writelines()</code>函数，而没有名为<code>writeline</code>的函数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">n = <span class="built_in">open</span>(<span class="string">&#x27;b.txt&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>)</span><br><span class="line">n.writelines(f.readlines())</span><br><span class="line">n.close()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>执行此代码，在<code>a.txt</code>文件同级目录下会生成一个<code>b.txt</code>文件，且该文件中包含的数据和<code>a.txt</code>完全一样。</p>
<p>需要注意的是，使用<code>writelines()</code>函数向文件中写入多行数据时，不会自动给各行添加换行符。上面例子中，之所以<code>b.txt</code>文件中会逐行显示数据，是因为<code>readlines()</code>函数在读取各行数据时，读入了行尾的换行符。</p>
<h1 id="close-函数：关闭文件"><a href="#close-函数：关闭文件" class="headerlink" title="close()函数：关闭文件"></a>close()函数：关闭文件</h1><p><code>close()</code>函数是专门用来关闭已打开文件的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p>其中，<code>file</code>表示已打开的文件对象。</p>
<p>即使用<code>open()</code>函数打开的文件，在操作完成之后，一定要调用<code>close()</code>函数将其关闭，否则程序的运行可能出现问题。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">os.remove(<span class="string">&quot;my_file.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>remove()</code>函数的功能是删除指定的文件。但是，如果运行此程序，Python 解释器会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\demo.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    os.remove(&quot;my_file.txt&quot;)</span><br><span class="line">PermissionError: [WinError 32] 另一个程序正在使用此文件，进程无法访问。: &#x27;my_file.txt&#x27;</span><br></pre></td></tr></table></figure>
<p>显然，由于我们使用了<code>open()</code>函数打开了<code>my_file.txt</code>文件，但没有及时关闭，直接导致后续的<code>remove()</code>函数运行出现错误。因此，正确的程序应该是这样的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">os.remove(<span class="string">&quot;my_file.txt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当确定<code>my_file.txt</code>文件可以被删除时，再次运行程序，可以发现该文件已经被成功删除了。</p>
<p>再举个例子，如果我们不调用<code>close()</code>函数关闭已打开的文件，确定不影响读取文件的操作，但会导致<code>write()</code>或者<code>writeline()</code>函数向文件中写数据时，写入失败。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行后，虽然 Python 解释器不报错，但打开<code>my_file.txt</code>文件会发现，根本没有写入成功。这是因为，在向以文本格式（而不是二进制格式）打开的文件中写入数据时，Python 出于效率的考虑，会先将数据临时存储到缓冲区中，只有使用<code>close()</code>函数关闭文件时，才会将缓冲区中的数据真正写入文件中。</p>
<p>因此，在上面程序的最后添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>再次运行程序，就会看到<code>&quot;hello world&quot;</code>成功写入到了<code>a.txt</code>文件。</p>
<p>当然在某些实际场景中，我们可能需要在将数据成功写入到文件中，但并不想关闭文件。这也是可以实现的，调用<code>flush()</code>函数即可：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;my_file.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure>
<p>打开<code>my_file.txt</code>文件，会发现已经向文件中成功写入了字符串<code>hello world</code>。</p>
<h1 id="seek-和tell-函数"><a href="#seek-和tell-函数" class="headerlink" title="seek()和tell()函数"></a>seek()和tell()函数</h1><p>使用 open() 函数打开文件并读取文件中的内容时，总是会从文件的第一个字符（字节）开始读起。那么，有没有办法可以自定指定读取的起始位置呢？答案是肯定，这就需要移动文件指针的位置。</p>
<p>文件指针用于标明文件读写的起始位置。假如把文件看成一个水流，文件中每个数据（以 b 模式打开，每个数据就是一个字节；以普通模式打开，每个数据就是一个字符）就相当于一个水滴，而文件指针就标明了文件将要从文件的哪个位置开始读起。图 1 简单示意了文件指针的概念。</p>
<p>文件指针概念示意图<br>图 1 文件指针概念示意图</p>
<p>可以看到，通过移动文件指针的位置，再借助 read() 和 write() 函数，就可以轻松实现，读取文件中指定位置的数据（或者向文件中的指定位置写入数据）。</p>
<p>注意，当向文件中写入数据时，如果不是文件的尾部，写入位置的原有数据不会自行向后移动，新写入的数据会将文件中处于该位置的数据直接覆盖掉。</p>
<p>实现对文件指针的移动，文件对象提供了 tell() 函数和 seek() 函数。tell() 函数用于判断文件指针当前所处的位置，而 seek() 函数用于移动文件指针到文件的指定位置。</p>
<h2 id="tell-函数"><a href="#tell-函数" class="headerlink" title="tell() 函数"></a>tell() 函数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.tell()</span><br></pre></td></tr></table></figure>
<p>其中，file 表示文件对象。</p>
<p>例如，在同一目录下，编写如下程序对 a.txt 文件做读取操作，a.txt 文件中内容为：<br><a target="_blank" rel="noopener" href="http://c.biancheng.net/">http://c.biancheng.net</a></p>
<p>读取 a.txt 的代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(f.tell())</span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(f.tell())</span><br><span class="line">运行结果为：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">htt</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当使用 open() 函数打开文件时，文件指针的起始位置为 0，表示位于文件的开头处，当使用 read() 函数从文件中读取 3 个字符之后，文件指针同时向后移动了 3 个字符的位置。这就表明，当程序使用文件对象读写数据时，文件指针会自动向后移动：读写了多少个数据，文件指针就自动向后移动多少个位置。</p>
<h2 id="seek-函数"><a href="#seek-函数" class="headerlink" title="seek()函数"></a>seek()函数</h2><p>seek() 函数用于将文件指针移动至指定位置，该函数的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.seek(offset[, whence])</span><br></pre></td></tr></table></figure>
<p>其中，各个参数的含义如下：<br>file：表示文件对象；<br>whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。<br>offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当whence &#x3D;&#x3D; 0 &amp;&amp;offset &#x3D;&#x3D; 3（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当whence &#x3D;&#x3D; 1 &amp;&amp;offset &#x3D;&#x3D; 5（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。<br>注意，当 offset 值非 0 时，Python 要求文件必须要以二进制格式打开，否则会抛出 io.UnsupportedOperation 错误。</p>
<p>下面程序示范了文件指针操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">f = open(&#x27;a.txt&#x27;, &#x27;rb&#x27;)</span><br><span class="line"># 判断文件指针的位置</span><br><span class="line">print(f.tell())</span><br><span class="line"># 读取一个字节，文件指针自动后移1个数据</span><br><span class="line">print(f.read(1))</span><br><span class="line">print(f.tell())</span><br><span class="line"># 将文件指针从文件开头，向后移动到 5 个字符的位置</span><br><span class="line">f.seek(5)</span><br><span class="line">print(f.tell())</span><br><span class="line">print(f.read(1))</span><br><span class="line"># 将文件指针从当前位置，向后移动到 5 个字符的位置</span><br><span class="line">f.seek(5, 1)</span><br><span class="line">print(f.tell())</span><br><span class="line">print(f.read(1))</span><br><span class="line"># 将文件指针从文件结尾，向前移动到距离 2 个字符的位置</span><br><span class="line">f.seek(-1, 2)</span><br><span class="line">print(f.tell())</span><br><span class="line">print(f.read(1))</span><br><span class="line">运行结果为：</span><br><span class="line">0</span><br><span class="line">b&#x27;h&#x27;</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">b&#x27;/&#x27;</span><br><span class="line">11</span><br><span class="line">b&#x27;a&#x27;</span><br><span class="line">21</span><br><span class="line">b&#x27;t&#x27;</span><br></pre></td></tr></table></figure>
<p>注意：由于程序中使用 seek() 时，使用了非 0 的偏移量，因此文件的打开方式中必须包含 b，否则就会报  io.UnsupportedOperation 错误，有兴趣的读者可自定尝试。</p>
<p>上面程序示范了使用 seek() 方法来移动文件指针，包括从文件开头、指针当前位置、文件结尾处开始计算。运行上面程序，结合程序输出结果可以体会文件指针移动的效果。<br>#　with as<br>任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，严重时会使系统崩溃。</p>
<p>例如，前面在介绍文件操作时，一直强调打开的文件最后一定要关闭，否则会程序的运行造成意想不到的隐患。但是，即便使用 close() 做好了关闭文件的操作，如果在打开文件或文件操作过程中抛出了异常，还是无法及时关闭文件。</p>
<p>为了更好地避免此类问题，不同的编程语言都引入了不同的机制。在 Python 中，对应的解决方式是使用 with as 语句操作上下文管理器（context manager），它能够帮助我们自动分配并且释放资源。<br>简单的理解，同时包含 <strong>enter</strong>() 和 <strong>exit</strong>() 方法的对象就是上下文管理器。常见构建上下文管理器的方式有 2 种，分别是基于类实现和基于生成器实现。</p>
<p>例如，使用 with as 操作已经打开的文件对象（本身就是上下文管理器），无论期间是否抛出异常，都能保证 with as 语句执行完毕后自动关闭已经打开的文件。</p>
<p>with as 语句的基本语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with 表达式 [as target]：</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>
<p>此格式中，用 [] 括起来的部分可以使用，也可以省略。其中，target 参数用于指定一个变量，该语句会将 expression 指定的结果保存到该变量中。with as 语句中的代码块如果不想执行任何语句，可以直接使用 pass 语句代替。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;\nPython教程&quot;</span>)</span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">Python教程</span><br></pre></td></tr></table></figure>
<p>可以看到，通过使用<code>with as</code>语句，即便最终没有关闭文件，修改文件内容的操作也能成功。<br>#　pickle模块：实现Python对象的持久化存储<br>Python 中有个序列化过程叫作 pickle，它能够实现任意对象与文本之间的相互转化，也可以实现任意对象与二进制之间的相互转化。也就是说，pickle 可以实现 Python 对象的存储及恢复。</p>
<p>值得一提的是，pickle 是 python 语言的一个标准模块，安装 python 的同时就已经安装了 pickle 库，因此它不需要再单独安装，使用 import 将其导入到程序中，就可以直接使用。</p>
<p>pickle 模块提供了以下 4 个函数供我们使用：</p>
<ul>
<li><code>dumps()</code>：将 Python 中的对象序列化成二进制对象，并返回；</li>
<li><code>loads()</code>：读取给定的二进制对象数据，并将其转换为 Python 对象；</li>
<li><code>dump()</code>：将 Python 中的对象序列化成二进制对象，并写入文件；</li>
<li><code>load()</code>：读取指定的序列化数据文件，并返回对象。</li>
</ul>
<p>以上这 4 个函数可以分成两类，其中 dumps 和 loads 实现基于内存的 Python 对象与二进制互转；dump 和 load 实现基于文件的 Python 对象与二进制互转。</p>
<h2 id="pickle-dumps-函数"><a href="#pickle-dumps-函数" class="headerlink" title="pickle.dumps()函数"></a>pickle.dumps()函数</h2><p>此函数用于将 Python 对象转为二进制对象，其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumps(obj, protocol=None, *, fix_imports=True)</span><br></pre></td></tr></table></figure>
<p>此格式中各个参数的含义为：<br>obj：要转换的 Python 对象；<br>protocol：pickle 的转码协议，取值为 0、1、2、3、4，其中 0、1、2 对应 Python 早期的版本，3 和 4 则对应 Python 3.x 版本及之后的版本。未指定情况下，默认为 3。<br>其它参数：为了兼容 Python 2.x 版本而保留的参数，Python 3.x 中可以忽略。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tup1 = (<span class="string">&#x27;I love Python&#x27;</span>, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="literal">None</span>)</span><br><span class="line"><span class="comment">#使用 dumps() 函数将 tup1 转成 p1</span></span><br><span class="line">p1 = pickle.dumps(tup1)</span><br><span class="line"><span class="built_in">print</span>(p1)</span><br><span class="line">输出结果为：</span><br><span class="line"><span class="string">b&#x27;\x80\x03X\r\x00\x00\x00I love Pythonq\x00cbuiltins\nset\nq\x01]q\x02(K\x01K\x02K\x03e\x85q\x03Rq\x04N\x87q\x05.&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="pickle-loads-函数"><a href="#pickle-loads-函数" class="headerlink" title="pickle.loads()函数"></a>pickle.loads()函数</h2><p>此函数用于将二进制对象转换成 Python 对象：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loads(data, *, fix_imports=<span class="literal">True</span>, encoding=<span class="string">&#x27;ASCII&#x27;</span>, errors=<span class="string">&#x27;strict&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其中，data 参数表示要转换的二进制对象，其它参数只是为了兼容 Python 2.x 版本而保留的，可以忽略。</p>
<p>【例 2】在例 1 的基础上，将 p1 对象反序列化为 Python 对象。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tup1 = (<span class="string">&#x27;I love Python&#x27;</span>, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="literal">None</span>)</span><br><span class="line">p1 = pickle.dumps(tup1)</span><br><span class="line"><span class="comment">#使用 loads() 函数将 p1 转成 Python 对象</span></span><br><span class="line">t2 = pickle.loads(p1)</span><br><span class="line"><span class="built_in">print</span>(t2)</span><br><span class="line">运行结果为：</span><br><span class="line">(<span class="string">&#x27;I love Python&#x27;</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>注意，在使用 loads() 函数将二进制对象反序列化成 Python 对象时，会自动识别转码协议，所以不需要将转码协议当作参数传入。并且，当待转换的二进制对象的字节数超过 pickle 的 Python 对象时，多余的字节将被忽略。</p>
<h2 id="pickle-dump-函数"><a href="#pickle-dump-函数" class="headerlink" title="pickle.dump()函数"></a>pickle.dump()函数</h2><p>此函数用于将 Python 对象转换成二进制文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dump (obj, file,protocol=None, *, fix mports=True)</span><br></pre></td></tr></table></figure>
<p>其中各个参数的具体含义如下：<br>obj：要转换的 Python 对象。<br>file：转换到指定的二进制文件中，要求该文件必须是以”wb”的打开方式进行操作。<br>protocol：和 dumps() 函数中 protocol 参数的含义完全相同，因此这里不再重复描述。<br>其他参数：为了兼容以前 Python 2.x版本而保留的参数，可以忽略。</p>
<p>【例 3】将 tup1 元组转换成二进制对象文件。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">tup1 = (<span class="string">&#x27;I love Python&#x27;</span>, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="literal">None</span>)</span><br><span class="line"><span class="comment">#使用 dumps() 函数将 tup1 转成 p1</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;a.txt&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f: <span class="comment">#打开文件</span></span><br><span class="line">    pickle.dump(tup1, f) <span class="comment">#用 dump 函数将 Python 对象转成二进制对象文件</span></span><br></pre></td></tr></table></figure>
<p>运行完此程序后，会在该程序文件同级目录中，生成 a.txt 文件，但由于其内容为二进制数据，因此直接打开会看到乱码。</p>
<h2 id="pickle-load-函数"><a href="#pickle-load-函数" class="headerlink" title="pickle.load()函数"></a>pickle.load()函数</h2><p>此函数和 dump() 函数相对应，用于将二进制对象文件转换成 Python 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load(file, *, fix_imports=True, encoding=&#x27;ASCII&#x27;, errors=&#x27;strict&#x27;)</span><br></pre></td></tr></table></figure>
<p>其中，file 参数表示要转换的二进制对象文件（必须以 “rb” 的打开方式操作文件），其它参数只是为了兼容 Python 2.x 版本而保留的参数，可以忽略。</p>
<p>【例 4】将例 3 转换的 a.txt 二进制文件对象转换为 Python 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">tup1 = (&#x27;I love Python&#x27;, &#123;1,2,3&#125;, None)</span><br><span class="line">#使用 dumps() 函数将 tup1 转成 p1</span><br><span class="line">with open (&quot;a.txt&quot;, &#x27;wb&#x27;) as f: #打开文件</span><br><span class="line">    pickle.dump(tup1, f) #用 dump 函数将 Python 对象转成二进制对象文件</span><br><span class="line">with open (&quot;a.txt&quot;, &#x27;rb&#x27;) as f: #打开文件</span><br><span class="line">    t3 = pickle.load(f) #将二进制文件对象转换成 Python 对象</span><br><span class="line">    print(t3)</span><br><span class="line">运行结果为：</span><br><span class="line">(&#x27;I love Python&#x27;, &#123;1, 2, 3&#125;, None)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看似强大的 pickle 模块，其实也有它的短板，即 pickle 不支持并发地访问持久性对象，在复杂的系统环境下，尤其是读取海量数据时，使用 pickle 会使整个系统的I&#x2F;O读取性能成为瓶颈。这种情况下，可以使用 ZODB。</p>
<p>ZODB 是一个健壮的、多用户的和面向对象的数据库系统，专门用于存储 Python 语言中的对象数据，它能够存储和管理任意复杂的 Python 对象，并支持事务操作和并发控制。并且，ZODB 也是在 Python 的序列化操作基础之上实现的，因此要想有效地使用 ZODB，必须先学好 pickle。</p>
<h1 id="fileinput模块：逐行读取多个文件"><a href="#fileinput模块：逐行读取多个文件" class="headerlink" title="fileinput模块：逐行读取多个文件"></a>fileinput模块：逐行读取多个文件</h1><p>我们学会了使用<code>open()</code>和<code>read()</code>（或者<code>readline()、readlines()</code>）组合，来读取单个文件中的数据。但在某些场景中，可能需要读取多个文件的数据，这种情况下，再使用这个组合，显然就不合适了。</p>
<p>庆幸的是，Python 提供了<code>fileinput</code>模块，通过该模块中的<code>input()</code>函数，我们能同时打开指定的多个文件，还可以逐个读取这些文件中的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileinput.input（files=&quot;filename1, filename2, ...&quot;, inplace=False, backup=&#x27;&#x27;, bufsize=0, mode=&#x27;r&#x27;, openhook=None）</span><br></pre></td></tr></table></figure>
<p>此函数会返回一个 FileInput 对象，它可以理解为是将多个指定文件合并之后的文件对象。其中，各个参数的含义如下：<br>files：多个文件的路径列表；<br>inplace：用于指定是否将标准输出的结果写回到文件，此参数默认值为 False；<br>backup：用于指定备份文件的扩展名；<br>bufsize：指定缓冲区的大小，默认为 0；<br>mode：打开文件的格式，默认为 r（只读格式）；<br>openhook：控制文件的打开方式，例如编码格式等。<br>注意，和 open() 函数不同，input() 函数不能指定打开文件的编码格式，这意味着使用该函数读取的所有文件，除非以二进制方式进行读取，否则该文件编码格式都必须和当前操作系统默认的编码格式相同，不然 Python 解释器可能会提示 UnicodeDecodeError 错误。</p>
<p>和 open() 函数返回单个的文件对象不同，fileinput 对象无需调用类似 read()、readline()、readlines() 这样的函数，直接通过 for 循环即可按次序读取多个文件中的数据。</p>
<p>值得一提的是，fileinput 模块还提供了很多使用的函数（如表 1 所示），通过调用这些函数，可以帮我们更快地实现想要的功能。</p>
<p>表 1 fileinput 模块常用函数<br>函数名	功能描述<br>fileinput.filename()	返回当前正在读取的文件名称。<br>fileinput.fileno()	返回当前正在读取文件的文件描述符。<br>fileinput.lineno()	返回当前读取了多少行。<br>fileinput.filelineno()	返回当前正在读取的内容位于当前文件中的行号。<br>fileinput.isfirstline()	判断当前读取的内容在当前文件中是否位于第 1 行。<br>fileinput.nextfile()	关闭当前正在读取的文件，并开始读取下一个文件。<br>fileinput.close()	关闭 FileInput 对象。<br>文件描述符是一个文件的代号，其值为一个整数。后续章节将会介绍关于文件描述符的操作。</p>
<p>假设使用 input() 读取 2 个文件，分别为 my_file.txt 和 file.txt，它们位于同一目录，且各自包含的内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#file.txt</span><br><span class="line">Python教程</span><br><span class="line">http://c.biancheng.net/python/</span><br><span class="line"></span><br><span class="line">#my_file.txt</span><br><span class="line">Linux教程</span><br><span class="line">http://c.biancheng.net/linux_tutorial/</span><br></pre></td></tr></table></figure>
<p>下面程序演示了如何使用 input() 函数依次读取这 2 个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import fileinput</span><br><span class="line">#使用for循环遍历 fileinput 对象</span><br><span class="line">for line in fileinput.input(files=(&#x27;my_file.txt&#x27;, &#x27;file.txt&#x27;)):</span><br><span class="line">    # 输出读取到的内容</span><br><span class="line">    print(line)</span><br><span class="line"># 关闭文件流</span><br><span class="line">fileinput.close()</span><br></pre></td></tr></table></figure>
<p>在使用 fileinput 模块中的 input() 函数之前，一定要先引入 fileinput 模块。</p>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Linux教程</span><br><span class="line"></span><br><span class="line">http://c.biancheng.net/linux_tutorial/</span><br><span class="line">Python教程</span><br><span class="line"></span><br><span class="line">http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure>
<p>显然，读取文件内容的次序，取决于 input() 函数中文件名的先后次序。</p>
<h1 id="linecache模块用法：随机读取文件指定行"><a href="#linecache模块用法：随机读取文件指定行" class="headerlink" title="linecache模块用法：随机读取文件指定行"></a>linecache模块用法：随机读取文件指定行</h1><p>除了可以借助<code>fileinput</code>模块实现读取文件外，Python 还提供了<code>linecache</code>模块。和前者不同，<code>linecache</code>模块擅长读取指定文件中的指定行。换句话说，如果我们想读取某个文件中指定行包含的数据，就可以使用<code>linecache</code>模块。</p>
<p>值得一提的是，<code>linecache</code>模块常用来读取 Python 源文件中的代码，它使用的是 UTF-8 编码格式来读取文件内容。这意味着，使用该模块读取的文件，其编码格式也必须为 UTF-8，否则要么读取出来的数据是乱码，要么直接读取失败（Python 解释器会报 SyntaxError 异常）。</p>
<p>要使用<code>linecache</code>模块，就必须知道其包含了哪些函数。linecache 模块中常用的函数及其功能如表 1 所示。</p>
<p>表 1 linecache模块常用函数及功能<br>函数基本格式	功能<br>linecache.getline(filename, lineno, module_globals&#x3D;None)	读取指定模块中指定文件的指定行（仅读取指定文件时，无需指定模块）。其中，filename 参数用来指定文件名，lineno 用来指定行号，module_globals 参数用来指定要读取的具体模块名。注意，当指定文件以相对路径的方式传给 filename 参数时，该函数以按照 sys.path 规定的路径查找该文件。<br>linecache.clearcache()	如果程序某处，不再需要之前使用 getline() 函数读取的数据，则可以使用该函数清空缓存。<br>linecache.checkcache(filename&#x3D;None)	检查缓存的有效性，即如果使用 getline() 函数读取的数据，其实在本地已经被修改，而我们需要的是新的数据，此时就可以使用该函数检查缓存的是否为新的数据。注意，如果省略文件名，该函数将检车所有缓存数据的有效性。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> linecache</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment">#读取string模块中第 3 行的数据</span></span><br><span class="line"><span class="built_in">print</span>(linecache.getline(string.__file__, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 读取普通文件的第2行</span></span><br><span class="line"><span class="built_in">print</span>(linecache.getline(<span class="string">&#x27;my_file.txt&#x27;</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>在执行该程序之前，需保证 my_file.txt 文件是以 UTF-8 编码格式保存的（Python 提供的模块，通常编码格式为 UTF-8）。在此基础上，执行该程序，其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Public module variables:</span><br><span class="line"></span><br><span class="line">http://c.biancheng.net/linux_tutorial/</span><br></pre></td></tr></table></figure>
<h1 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h1><p><code>pathlib</code>模块中包含的是一些类，它们的继承关系如图 1 所示。</p>
<p>图 1 pathlib模块中类的组织结构<br>图 1 中，箭头连接的是有继承关系的两个类，以 PurePosixPath 和 PurePath 类为例，PurePosizPath 继承自 PurePath，即前者是后者的子类。</p>
<p>pathlib 模块的操作对象是各种操作系统中使用的路径（例如指定文件位置的路径，包括绝对路径和相对路径）。这里简单介绍一下图 1 中包含的几个类的具体功能：<br>PurePath 类会将路径看做是一个普通的字符串，它可以实现将多个指定的字符串拼接成适用于当前操作系统的路径格式，同时还可以判断任意两个路径是否相等。注意，使用 PurePath 操作的路径，它并不会关心该路径是否真实有效。<br>PurePosixPath 和 PureWindowsPath 是 PurePath 的子类，前者用于操作 UNIX（包括 Mac OS X）风格的路径，后者用于操作 Windows 风格的路径。<br>Path 类和以上 3 个类不同，它操作的路径一定是真实有效的。Path 类提供了判断路径是否真实存在的方法。<br>PosixPath 和 WindowPath 是 Path 的子类，分别用于操作 Unix（Mac OS X）风格的路径和 Windows 风格的路径。<br>注意，UNIX 操作系统和 Windows 操作系统上，路径的格式是完全不同的，主要区别在于根路径和路径分隔符，UNIX 系统的根路径是斜杠（&#x2F;），而 Windows 系统的根路径是盘符（C:）；UNIX 系统路径使用的分隔符是斜杠（&#x2F;），而 Windows 使用的是反斜杠（\）。</p>
<h1 id="PurePath-类的用法"><a href="#PurePath-类的用法" class="headerlink" title="PurePath 类的用法"></a>PurePath 类的用法</h1><p><code>PurePath</code>类（以及<code>PurePosixPath</code>类和<code>PureWindowsPath</code>类）都提供了大量的构造方法、实例方法以及类实例属性，供我们使用。</p>
<h2 id="PurePath类构造方法"><a href="#PurePath类构造方法" class="headerlink" title="PurePath类构造方法"></a>PurePath类构造方法</h2><p>需要注意的是，在使用<code>PurePath</code>类时，考虑到操作系统的不同，如果在 UNIX 或 Mac OS X 系统上使用 PurePath 创建对象，该类的构造方法实际返回的是<code>PurePosixPath</code>对象；反之，如果在 Windows 系统上使用 PurePath 创建对象，该类的构造方法返回的是 PureWindowsPath 对象。<br>当然，我们完全可以直接使用<code>PurePosixPath</code>类或者<code>PureWindowsPath</code>类创建指定操作系统使用的类对象。</p>
<p>例如，在 Windows 系统上执行如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pathlib import *</span><br><span class="line"># 创建PurePath，实际上使用PureWindowsPath</span><br><span class="line">path = PurePath(&#x27;my_file.txt&#x27;)</span><br><span class="line">print(type(path))</span><br><span class="line">程序执行结果为：</span><br><span class="line">&lt;class &#x27;pathlib.PureWindowsPath&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>显然，在 Windows 操作系统上，使用 PurePath 类构造函数创建的是 PureWindowsPath 类对象。</p>
<p>除此之外，PurePath 在创建对象时，也支持传入多个路径字符串，它们会被拼接成一个路径格式的字符串。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pathlib import *</span><br><span class="line"># 创建PurePath，实际上使用PureWindowsPath</span><br><span class="line">path = PurePath(&#x27;http:&#x27;,&#x27;c.biancheng.net&#x27;,&#x27;python&#x27;)</span><br><span class="line">print(path)</span><br><span class="line">程序执行结果为：</span><br><span class="line">http:\c.biancheng.net\python</span><br></pre></td></tr></table></figure>
<p>可以看到，由于本机为 Windows 系统，因此这里输出的是适用于 Windows 平台的路径。如果想在 Windows 系统上输出 UNIX 风格的路径字符串，就需要使用 PurePosixPath 类。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pathlib import *</span><br><span class="line">path = PurePosixPath(&#x27;http:&#x27;,&#x27;c.biancheng.net&#x27;,&#x27;python&#x27;)</span><br><span class="line">print(path)</span><br><span class="line">程序执行结果为：</span><br><span class="line">http:/c.biancheng.net/python</span><br></pre></td></tr></table></figure>
<p>值的一提的是，如果在使用 PurePath 类构造方法时，不传入任何参数，则等同于传入点‘.’（表示当前路径）作为参数。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> *</span><br><span class="line">path = PurePath()</span><br><span class="line"><span class="built_in">print</span>(path) <span class="comment"># .</span></span><br><span class="line">path = PurePath(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(path) <span class="comment"># .</span></span><br></pre></td></tr></table></figure>
<p>另外，如果传入 PurePath 构造方法中的多个参数中，包含多个根路径，则只会有最后一个根路径及后面的子路径生效。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> *</span><br><span class="line">path = PurePath(<span class="string">&#x27;C://&#x27;</span>,<span class="string">&#x27;D://&#x27;</span>,<span class="string">&#x27;my_file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(path) <span class="comment"># D:\my_file.txt</span></span><br></pre></td></tr></table></figure>
<p>注意，对于 Windows 风格的路径，只有盘符（如 C、D等）才能算根路径。</p>
<p>需要注意的是，如果传给<code>PurePath</code>构造方法的参数中包含有多余的斜杠或者点（<code>.</code>，表示当前路径），会直接被忽略（<code>..</code>不会被忽略）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> *</span><br><span class="line">path = PurePath(<span class="string">&#x27;C://./my_file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(path) <span class="comment"># C:\my_file.txt</span></span><br></pre></td></tr></table></figure>
<p><code>PurePath</code>类还重载各种比较运算符，多余同种风格的路径字符串来说，可以判断是否相等，也可以比较大小（实际上就是比较字符串的大小）；对于不同种风格的路径字符串之间，只能判断是否相等（显然，不可能相等），但不能比较大小。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># Unix风格的路径区分大小写</span></span><br><span class="line"><span class="built_in">print</span>(PurePosixPath(<span class="string">&#x27;C://my_file.txt&#x27;</span>) == PurePosixPath(<span class="string">&#x27;c://my_file.txt&#x27;</span>))</span><br><span class="line"><span class="comment"># Windows风格的路径不区分大小写</span></span><br><span class="line"><span class="built_in">print</span>(PureWindowsPath(<span class="string">&#x27;C://my_file.txt&#x27;</span>) == PureWindowsPath(<span class="string">&#x27;c://my_file.txt&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>比较特殊的是，<code>PurePath</code>类对象支持直接使用斜杠（<code>/</code>）作为多个字符串之间的连接符：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> *</span><br><span class="line">path = PurePosixPath(<span class="string">&#x27;C://&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(path / <span class="string">&#x27;my_file.txt&#x27;</span>) <span class="comment"># C:/my_file.txt</span></span><br></pre></td></tr></table></figure>
<p>通过以上方式构建的路径，其本质上就是字符串，因此我们完全可以使用 str() 将 PurePath 对象转换成字符串。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># Unix风格的路径区分大小写</span></span><br><span class="line">path = PurePosixPath(<span class="string">&#x27;C://&#x27;</span>,<span class="string">&#x27;my_file.txt&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(path)) <span class="comment"># C:/my_file.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="PurePath类实例属性和实例方法"><a href="#PurePath类实例属性和实例方法" class="headerlink" title="PurePath类实例属性和实例方法"></a>PurePath类实例属性和实例方法</h2><p>常用的以下<code>PurePath</code>类实例方法和属性。由于从本质上讲，<code>PurePath</code>的操作对象是字符串，因此这些实例属性和实例方法，实质也是对字符串进行操作。</p>
<table>
<thead>
<tr>
<th align="center">类实例属性和实例方法名</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PurePath.parts</td>
<td align="center">返回路径字符串中所包含的各部分。</td>
</tr>
<tr>
<td align="center">PurePath.drive</td>
<td align="center">返回路径字符串中的驱动器盘符。</td>
</tr>
<tr>
<td align="center">PurePath.root</td>
<td align="center">返回路径字符串中的根路径。</td>
</tr>
<tr>
<td align="center">PurePath.anchor</td>
<td align="center">返回路径字符串中的盘符和根路径。</td>
</tr>
<tr>
<td align="center">PurePath.parents</td>
<td align="center">返回当前路径的全部父路径。</td>
</tr>
<tr>
<td align="center">PurPath.parent</td>
<td align="center">返回当前路径的上一级路径，相当于 parents[0] 的返回值。</td>
</tr>
<tr>
<td align="center">PurePath.name</td>
<td align="center">返回当前路径中的文件名。</td>
</tr>
<tr>
<td align="center">PurePath.suffixes</td>
<td align="center">返回当前路径中的文件所有后缀名。</td>
</tr>
<tr>
<td align="center">PurePath.suffix</td>
<td align="center">返回当前路径中的文件后缀名。相当于 suffixes 属性返回的列表的最后一个元素。</td>
</tr>
<tr>
<td align="center">PurePath.stem</td>
<td align="center">返回当前路径中的主文件名。</td>
</tr>
<tr>
<td align="center">PurePath.as_posix()</td>
<td align="center">将当前路径转换成 UNIX 风格的路径。</td>
</tr>
<tr>
<td align="center">PurePath.as_uri()</td>
<td align="center">将当前路径转换成 URL。只有绝对路径才能转换，否则将会引发 ValueError。</td>
</tr>
<tr>
<td align="center">PurePath.is_absolute()</td>
<td align="center">判断当前路径是否为绝对路径。</td>
</tr>
<tr>
<td align="center">PurePath.joinpath(*other)</td>
<td align="center">将多个路径连接在一起，作用类似于前面介绍的斜杠（&#x2F;）连接符。</td>
</tr>
<tr>
<td align="center">PurePath.match(pattern)</td>
<td align="center">判断当前路径是否匹配指定通配符。</td>
</tr>
<tr>
<td align="center">PurePath.relative_to(*other)</td>
<td align="center">获取当前路径中去除基准路径之后的结果。</td>
</tr>
<tr>
<td align="center">PurePath.with_name(name)</td>
<td align="center">将当前路径中的文件名替换成新文件名。如果当前路径中没有文件名，则会引发 ValueError。</td>
</tr>
<tr>
<td align="center">PurePath.with_suffix(suffix)</td>
<td align="center">将当前路径中的文件后缀名替换成新的后缀名。如果当前路径中没有后缀名，则会添加新的后缀名。</td>
</tr>
</tbody></table>
<h2 id="Path类的功能和用法"><a href="#Path类的功能和用法" class="headerlink" title="Path类的功能和用法"></a>Path类的功能和用法</h2><p>和<code>PurPath</code>类相比，<code>Path</code>类的最大不同，就是支持对路径的真实性进行判断。</p>
<p><code>Path</code>是<code>PurePath</code>的子类，因此<code>Path</code>类除了支持<code>PurePath</code>提供的各种构造函数、实例属性以及实例方法之外，还提供甄别路径字符串有效性的方法，甚至还可以判断该路径对应的是文件还是文件夹，如果是文件，还支持对文件进行读写等操作。</p>
<p>和<code>PurePath</code>一样，<code>Path</code>同样有 2 个子类，分别为<code>PosixPath</code>（表示 UNIX 风格的路径）和<code>WindowsPath</code>（表示 Windows 风格的路径）。</p>
<h1 id="os-path模块"><a href="#os-path模块" class="headerlink" title="os.path模块"></a>os.path模块</h1><p>相比<code>pathlib</code>模块，<code>os.path</code>模块不仅提供了一些操作路径字符串的方法，还包含一些或者指定文件属性的一些方法。<code>os.path</code>模块常用的属性和方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">os.path.abspath(path)</td>
<td align="center">返回 path 的绝对路径。</td>
</tr>
<tr>
<td align="center">os.path.basename(path)</td>
<td align="center">获取 path 路径的基本名称，即 path 末尾到最后一个斜杠的位置之间的字符串。</td>
</tr>
<tr>
<td align="center">os.path.commonprefix(list)</td>
<td align="center">返回 list（多个路径）中，所有 path 共有的最长的路径。</td>
</tr>
<tr>
<td align="center">os.path.dirname(path)</td>
<td align="center">返回 path 路径中的目录部分。</td>
</tr>
<tr>
<td align="center">os.path.exists(path)</td>
<td align="center">判断 path 对应的文件是否存在，如果存在，返回 True；反之，返回 False。和 lexists() 的区别在于，exists()会自动判断失效的文件链接（类似 Windows 系统中文件的快捷方式），而 lexists() 却不会。</td>
</tr>
<tr>
<td align="center">os.path.lexists(path)</td>
<td align="center">判断路径是否存在，如果存在，则返回 True；反之，返回 False。</td>
</tr>
<tr>
<td align="center">os.path.expanduser(path)</td>
<td align="center">把 path 中包含的 “<del>“ 和 “</del>user” 转换成用户目录。</td>
</tr>
<tr>
<td align="center">os.path.expandvars(path)</td>
<td align="center">根据环境变量的值替换 path 中包含的 “$name” 和 “${name}”。</td>
</tr>
<tr>
<td align="center">os.path.getatime(path)</td>
<td align="center">返回 path 所指文件的最近访问时间（浮点型秒数）。</td>
</tr>
<tr>
<td align="center">os.path.getmtime(path)</td>
<td align="center">返回文件的最近修改时间（单位为秒）。</td>
</tr>
<tr>
<td align="center">os.path.getctime(path)</td>
<td align="center">返回文件的创建时间（单位为秒，自 1970 年 1 月 1 日起（又称 Unix 时间））。</td>
</tr>
<tr>
<td align="center">os.path.getsize(path)</td>
<td align="center">返回文件大小，如果文件不存在就返回错误。</td>
</tr>
<tr>
<td align="center">os.path.isabs(path)</td>
<td align="center">判断是否为绝对路径。</td>
</tr>
<tr>
<td align="center">os.path.isfile(path)</td>
<td align="center">判断路径是否为文件。</td>
</tr>
<tr>
<td align="center">os.path.isdir(path)</td>
<td align="center">判断路径是否为目录。</td>
</tr>
<tr>
<td align="center">os.path.islink(path)</td>
<td align="center">判断路径是否为链接文件（类似 Windows 系统中的快捷方式）。</td>
</tr>
<tr>
<td align="center">os.path.ismount(path)</td>
<td align="center">判断路径是否为挂载点。</td>
</tr>
<tr>
<td align="center">os.path.join(path1[, path2[, …]])</td>
<td align="center">把目录和文件名合成一个路径。</td>
</tr>
<tr>
<td align="center">os.path.normcase(path)</td>
<td align="center">转换 path 的大小写和斜杠。</td>
</tr>
<tr>
<td align="center">os.path.normpath(path)</td>
<td align="center">规范 path 字符串形式。</td>
</tr>
<tr>
<td align="center">os.path.realpath(path)</td>
<td align="center">返回 path 的真实路径。</td>
</tr>
<tr>
<td align="center">os.path.relpath(path[, start])</td>
<td align="center">从 start 开始计算相对路径。</td>
</tr>
<tr>
<td align="center">os.path.samefile(path1, path2)</td>
<td align="center">判断目录或文件是否相同。</td>
</tr>
<tr>
<td align="center">os.path.sameopenfile(fp1, fp2)</td>
<td align="center">判断 fp1 和 fp2 是否指向同一文件。</td>
</tr>
<tr>
<td align="center">os.path.samestat(stat1, stat2)</td>
<td align="center">判断 stat1 和 stat2 是否指向同一个文件。</td>
</tr>
<tr>
<td align="center">os.path.split(path)</td>
<td align="center">把路径分割成 dirname 和 basename，返回一个元组。</td>
</tr>
<tr>
<td align="center">os.path.splitdrive(path)</td>
<td align="center">一般用在 windows 下，返回驱动器名和路径组成的元组。</td>
</tr>
<tr>
<td align="center">os.path.splitext(path)</td>
<td align="center">分割路径，返回路径名和文件扩展名的元组。</td>
</tr>
<tr>
<td align="center">os.path.splitunc(path)</td>
<td align="center">把路径分割为加载点与文件。</td>
</tr>
<tr>
<td align="center">os.path.walk(path, visit, arg)</td>
<td align="center">遍历path，进入每个目录都调用 visit 函数，visit 函数必须有 3 个参数(arg, dirname, names)，dirname 表示当前目录的目录名，names 代表当前目录下的所有文件名，args 则为 walk 的第三个参数。</td>
</tr>
<tr>
<td align="center">os.path.supports_unicode_filenames</td>
<td align="center">设置是否可以将任意 Unicode 字符串用作文件名。</td>
</tr>
</tbody></table>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line"><span class="comment"># 获取绝对路径</span></span><br><span class="line"><span class="built_in">print</span>(path.abspath(<span class="string">&quot;my_file.txt&quot;</span>))</span><br><span class="line"><span class="comment"># 获取共同前缀</span></span><br><span class="line"><span class="built_in">print</span>(path.commonprefix([<span class="string">&#x27;C://my_file.txt&#x27;</span>, <span class="string">&#x27;C://a.txt&#x27;</span>]))</span><br><span class="line"><span class="comment"># 获取共同路径</span></span><br><span class="line"><span class="built_in">print</span>(path.commonpath([<span class="string">&#x27;http://c.biancheng.net/python/&#x27;</span>, <span class="string">&#x27;http://c.biancheng.net/shell/&#x27;</span>]))</span><br><span class="line"><span class="comment"># 获取目录</span></span><br><span class="line"><span class="built_in">print</span>(path.dirname(<span class="string">&#x27;C://my_file.txt&#x27;</span>))</span><br><span class="line"><span class="comment"># 判断指定目录是否存在</span></span><br><span class="line"><span class="built_in">print</span>(path.exists(<span class="string">&#x27;my_file.txt&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\mengma\Desktop\my_file.txt</span><br><span class="line">C://</span><br><span class="line">http:\c.biancheng.net</span><br><span class="line">C://</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h1 id="fnmatch模块：用于文件名的匹配"><a href="#fnmatch模块：用于文件名的匹配" class="headerlink" title="fnmatch模块：用于文件名的匹配"></a>fnmatch模块：用于文件名的匹配</h1><p><code>fnmatch</code>模块主要用于文件名称的匹配，其能力比简单的字符串匹配更强大，但比使用正则表达式相比稍弱。如果在数据处理操作中，只需要使用简单的通配符就能完成文件名的匹配，则使用<code>fnmatch</code>模块是不错的选择。</p>
<p><code>fnmatch</code>模块常用函数及功能：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fnmatch.filter(names, pattern)</td>
<td align="center">对 names 列表进行过滤，返回 names 列表中匹配 pattern 的文件名组成的子集合。</td>
</tr>
<tr>
<td align="center">fnmatch.fnmatch(filename, pattern)</td>
<td align="center">判断 filename 文件名，是否和指定 pattern 字符串匹配</td>
</tr>
<tr>
<td align="center">fnmatch.fnmatchcase(filename, pattern)</td>
<td align="center">和 fnmatch() 函数功能大致相同，只是该函数区分大小写。</td>
</tr>
<tr>
<td align="center">fnmatch.translate(pattern)</td>
<td align="center">将一个 UNIX shell 风格的 pattern 字符串，转换为正则表达式</td>
</tr>
</tbody></table>
<p><code>fnmatch</code>模块匹配文件名的模式使用的就是 UNIX shell 风格，其支持使用如下几个通配符：</p>
<ul>
<li><code>*</code>：可匹配任意个任意字符。</li>
<li><code>?</code>：可匹配一个任意字符。</li>
<li><code>[字符序列]</code>：可匹配中括号里字符序列中的任意字符。该字符序列也支持中画线表示法。比如<code>[a-c]</code>可代表 a、b 和 c 字符中任意一个。</li>
<li><code>[!字符序列]</code>：可匹配不在中括号里字符序列中的任意字符。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fnmatch</span><br><span class="line"><span class="comment">#filter()</span></span><br><span class="line"><span class="built_in">print</span>(fnmatch.<span class="built_in">filter</span>([<span class="string">&#x27;dlsf&#x27;</span>, <span class="string">&#x27;ewro.txt&#x27;</span>, <span class="string">&#x27;te.py&#x27;</span>, <span class="string">&#x27;youe.py&#x27;</span>], <span class="string">&#x27;*.txt&#x27;</span>))</span><br><span class="line"><span class="comment">#fnmatch()</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> [<span class="string">&#x27;word.doc&#x27;</span>,<span class="string">&#x27;index.py&#x27;</span>,<span class="string">&#x27;my_file.txt&#x27;</span>]:</span><br><span class="line">  <span class="keyword">if</span> fnmatch.fnmatch(file,<span class="string">&#x27;*.txt&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(file)</span><br><span class="line"><span class="comment">#fnmatchcase()</span></span><br><span class="line"><span class="built_in">print</span>([addr <span class="keyword">for</span> addr <span class="keyword">in</span> [<span class="string">&#x27;word.doc&#x27;</span>,<span class="string">&#x27;index.py&#x27;</span>,<span class="string">&#x27;my_file.txt&#x27;</span>,<span class="string">&#x27;a.TXT&#x27;</span>] <span class="keyword">if</span> fnmatch.fnmatchcase(addr, <span class="string">&#x27;*.txt&#x27;</span>)])</span><br><span class="line"><span class="comment">#translate()</span></span><br><span class="line"><span class="built_in">print</span>(fnmatch.translate(<span class="string">&#x27;a*b.txt&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;ewro.txt&#x27;]</span><br><span class="line">my_file.txt</span><br><span class="line">[&#x27;my_file.txt&#x27;]</span><br><span class="line">(?s:a.*b\.txt)\Z</span><br></pre></td></tr></table></figure>
<h1 id="tempfile模块：生成临时文件和临时目录"><a href="#tempfile模块：生成临时文件和临时目录" class="headerlink" title="tempfile模块：生成临时文件和临时目录"></a>tempfile模块：生成临时文件和临时目录</h1><p><code>tempfile</code>模块专门用于创建临时文件和临时目录。<code>tempfile</code>模块中常用的函数：</p>
<table>
<thead>
<tr>
<th align="center">tempfile 模块函数</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tempfile.TemporaryFile(mode&#x3D;’w+b’, buffering&#x3D;None, encoding&#x3D;None, newline&#x3D;None, suffix&#x3D;None, prefix&#x3D;None, dir&#x3D;None)</td>
<td align="center">创建临时文件。该函数返回一个类文件对象，也就是支持文件 I&#x2F;O。</td>
</tr>
<tr>
<td align="center">tempfile.NamedTemporaryFile(mode&#x3D;’w+b’, buffering&#x3D;None, encoding&#x3D;None, newline&#x3D;None, suffix&#x3D;None, prefix&#x3D;None, dir&#x3D;None, delete&#x3D;True)</td>
<td align="center">创建临时文件。该函数的功能与上一个函数的功能大致相同，只是它生成的临时文件在文件系统中有文件名。</td>
</tr>
<tr>
<td align="center">tempfile.SpooledTemporaryFile(max_size&#x3D;0, mode&#x3D;’w+b’, buffering&#x3D;None, encoding&#x3D;None, newline&#x3D;None, suffix&#x3D;None, prefix&#x3D;None, dir&#x3D;None)</td>
<td align="center">创建临时文件。与 TemporaryFile 函数相比，当程序向该临时文件输出数据时，会先输出到内存中，直到超过 max_size 才会真正输出到物理磁盘中。</td>
</tr>
<tr>
<td align="center">tempfile.TemporaryDirectory(suffix&#x3D;None, prefix&#x3D;None, dir&#x3D;None)</td>
<td align="center">生成临时目录。</td>
</tr>
<tr>
<td align="center">tempfile.gettempdir()</td>
<td align="center">获取系统的临时目录。</td>
</tr>
<tr>
<td align="center">tempfile.gettempdirb()</td>
<td align="center">与 gettempdir() 相同，只是该函数返回字节串。</td>
</tr>
<tr>
<td align="center">tempfile.gettempprefix()</td>
<td align="center">返回用于生成临时文件的前缀名。</td>
</tr>
<tr>
<td align="center">tempfile.gettempprefixb()</td>
<td align="center">与 gettempprefix() 相同，只是该函数返回字节串。</td>
</tr>
</tbody></table>
<blockquote>
<p>提示：表中有些函数包含很多参数，但这些参数都具有自己的默认值，因此如果没有特殊要求，可以不对其传参。</p>
</blockquote>
<p><code>tempfile</code>模块还提供了<code>tempfile.mkstemp()</code>和<code>tempfile.mkdtemp()</code>两个低级别的函数。上面介绍的 4 个用于创建临时文件和临时目录的函数都是高级别的函数，高级别的函数支持自动清理，而且可以与<code>with</code>语句一起使用，而这两个低级别的函数则不支持，因此一般推荐使用高级别的函数来创建临时文件和临时目录。</p>
<p>此外，<code>tempfile</code>模块还提供了<code>tempfile.tempdir</code>属性，通过对该属性赋值可以改变系统的临时目录。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="comment"># 创建临时文件</span></span><br><span class="line">fp = tempfile.TemporaryFile()</span><br><span class="line"><span class="built_in">print</span>(fp.name)</span><br><span class="line">fp.write(<span class="string">&#x27;两情若是久长时，&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">fp.write(<span class="string">&#x27;又岂在朝朝暮暮。&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 将文件指针移到开始处，准备读取文件</span></span><br><span class="line">fp.seek(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(fp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 输出刚才写入的内容</span></span><br><span class="line"><span class="comment"># 关闭文件，该文件将会被自动删除</span></span><br><span class="line">fp.close()</span><br><span class="line"><span class="comment"># 通过with语句创建临时文件，with会自动关闭临时文件</span></span><br><span class="line"><span class="keyword">with</span> tempfile.TemporaryFile() <span class="keyword">as</span> fp:</span><br><span class="line">  <span class="comment"># 写入内容</span></span><br><span class="line">  fp.write(<span class="string">b&#x27;I Love Python!&#x27;</span>)</span><br><span class="line">  <span class="comment"># 将文件指针移到开始处，准备读取文件</span></span><br><span class="line">  fp.seek(<span class="number">0</span>)</span><br><span class="line">  <span class="comment"># 读取文件内容</span></span><br><span class="line">  <span class="built_in">print</span>(fp.read()) <span class="comment"># b&#x27;I Love Python!&#x27;</span></span><br><span class="line"><span class="comment"># 通过with语句创建临时目录</span></span><br><span class="line"><span class="keyword">with</span> tempfile.TemporaryDirectory() <span class="keyword">as</span> tmpdirname:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;创建临时目录&#x27;</span>, tmpdirname)</span><br></pre></td></tr></table></figure>
<p>上面程序以两种方式来创建临时文件：</p>
<ul>
<li>第一种方式是手动创建临时文件，读写临时文件后需要主动关闭它，当程序关闭该临时文件时，该文件会被自动删除。</li>
<li>第二种方式则是使用<code>with</code>语句创建临时文件，这样<code>with</code>语句会自动关闭临时文件。</li>
</ul>
<p>上面程序最后还创建了临时目录。由于程序使用<code>with</code>语句来管理临时目录，因此程序也会自动删除该临时目录。</p>
<p>运行上面程序，可以看到如下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin\AppData\Local\Temp\tmphvehw9z1</span><br><span class="line">两情若是久长时，又岂在朝朝暮暮。</span><br><span class="line">b&#x27;I Love Python!&#x27;</span><br><span class="line">创建临时目录C:\Users\admin\AppData\Local\Temp\tmp3sjbnwob</span><br></pre></td></tr></table></figure>
<p>上面第一行输出结果就是程序生成的临时文件的文件名，最后一行输出结果就是程序生成的临时目录的目录名。需要注意的是，不要去找临时文件或临时文件夹，因为程序退出时该临时文件和临时文件夹都会被删除。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python函数和lambda表达式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/13/python/Python%E5%87%BD%E6%95%B0%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
    >Python函数和lambda表达式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/13/python/Python%E5%87%BD%E6%95%B0%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2022-12-13T04:08:52.000Z" itemprop="datePublished">2022-12-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>函数的本质就是一段有特定功能、可以重复使用的代码，这段代码已经被提前编写好了，并且为其起一个“好听”的名字。在后续编写程序过程中，如果需要同样的功能，直接通过起好的名字就可以调用这段代码。</p>
<h1 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h1><p>定义函数需要用<code>def</code>关键字实现：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数列表</span>):</span><br><span class="line">  <span class="comment"># 实现特定功能的多行代码</span></span><br><span class="line">  [<span class="keyword">return</span> [返回值]]</span><br></pre></td></tr></table></figure>
<p>其中，用<code>[]</code>括起来的为可选择部分，即可以使用，也可以省略。</p>
<p>各部分参数的含义：</p>
<ul>
<li>函数名：一个符合 Python 语法的标识符。</li>
<li>形参列表：设置该函数可以接收多少个参数，多个参数之间用逗号（<code>,</code>）分隔。</li>
<li><code>[return [返回值] ]</code>：整体作为函数的可选参参数，用于设置该函数的返回值。也就是说，一个函数，可以用返回值，也可以没有返回值，是否需要根据实际情况而定。</li>
</ul>
<p>注意，在创建函数时，即使函数不需要参数，也必须保留一对空的<code>()</code>，否则 Python 解释器将提示<code>invaild syntax</code>错误。另外，如果想定义一个没有任何功能的空函数，可以使用<code>pass</code>语句作为占位符。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义个空函数，没有实际意义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pass_dis</span>():</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#定义一个比较字符串大小的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_max</span>(<span class="params">str1,str2</span>):</span><br><span class="line">  <span class="built_in">str</span> = str1 <span class="keyword">if</span> str1 &gt; str2 <span class="keyword">else</span> str2</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure>
<p>函数中的<code>return</code>语句可以直接返回一个表达式的值，例如修改上面的<code>str_max()</code>函数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">str_max</span>(<span class="params">str1,str2</span>):</span><br><span class="line">  <span class="keyword">return</span> str1 <span class="keyword">if</span> str1 &gt; str2 <span class="keyword">else</span> str2</span><br></pre></td></tr></table></figure>
<p>该函数的功能，和上面的<code>str_max()</code>函数是完全一样的，只是省略了创建<code>str</code>变量，因此函数代码更加简洁。</p>
<h1 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h1><p>调用函数也就是执行函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[返回值] = 函数名([形参值])</span><br></pre></td></tr></table></figure>
<p>其中，函数名即指的是要调用的函数的名称；形参值指的是当初创建函数时要求传入的各个形参的值。如果该函数有返回值，我们可以通过一个变量来接收该值，当然也可以不接受。</p>
<p>需要注意的是，创建函数有多少个形参，那么调用时就需要传入多少个值，且顺序必须和创建函数时一致。即便该函数没有参数，函数名后的小括号也不能省略。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pass_dis()</span><br><span class="line">strmax = str_max(<span class="string">&quot;python&quot;</span>,<span class="string">&quot;shell&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(strmax) <span class="comment"># shell</span></span><br></pre></td></tr></table></figure>
<p>首先，对于调用空函数来说，由于函数本身并不包含任何有价值的执行代码，也没有返回值，所以调用空函数不会有任何效果。</p>
<p>其次，对于上面程序中调用<code>str_max()</code>函数，由于当初定义该函数为其设置了 2 个参数，因此这里在调用该参数，就必须传入 2 个参数。同时，由于该函数内部还使用了<code>return</code>语句，因此我们可以使用<code>strmax</code>变量来接收该函数的返回值。</p>
<h1 id="为函数提供说明文档"><a href="#为函数提供说明文档" class="headerlink" title="为函数提供说明文档"></a>为函数提供说明文档</h1><p>通过调用 Python 的<code>help()</code>内置函数或者<code>__doc__</code>属性，我们可以查看某个函数的使用说明文档。事实上，无论是 Python 提供给我们的函数，还是自定义的函数，其说明文档都需要设计该函数的程序员自己编写。</p>
<p>其实，函数的说明文档，本质就是一段字符串，只不过作为说明文档，字符串的放置位置是有讲究的，函数的说明文档通常位于函数内部、所有代码的最前面。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个比较字符串大小的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str_max</span>(<span class="params">str1,str2</span>):</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  比较 2 个字符串的大小</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="built_in">str</span> = str1 <span class="keyword">if</span> str1 &gt; str2 <span class="keyword">else</span> str2</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line"><span class="built_in">help</span>(str_max)</span><br><span class="line"><span class="comment">#print(str_max.__doc__)</span></span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Help on function str_max in module __main__:</span><br><span class="line"></span><br><span class="line">str_max(str1, str2)</span><br><span class="line">  比较 2 个字符串的大小</span><br></pre></td></tr></table></figure>
<p>上面程序中，还可以使用<code>__doc__</code>属性来获取<code>str_max()</code>函数的说明文档，即使用最后一行的输出语句，其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较 2 个字符串的大小</span><br></pre></td></tr></table></figure>
<h1 id="函数值传递和引用传递"><a href="#函数值传递和引用传递" class="headerlink" title="函数值传递和引用传递"></a>函数值传递和引用传递</h1><p>通常情况下，定义函数时都会选择有参数的函数形式，函数参数的作用是传递数据给函数，令其对接收的数据做具体的操作处理。</p>
<p>在使用函数时，经常会用到形式参数（简称“形参”）和实际参数（简称“实参”），二者都叫参数，之间的区别是：</p>
<ul>
<li>形式参数：在定义函数时，函数名后面括号中的参数就是形式参数:<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义函数时，这里的函数参数 obj 就是形式参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">obj</span>):</span><br><span class="line">  <span class="built_in">print</span>(obj)</span><br></pre></td></tr></table></figure></li>
<li>实际参数：在调用函数时，函数名后面括号中的参数称为实际参数，也就是函数的调用者给函数的参数。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;测试&quot;</span></span><br><span class="line"><span class="comment">#调用已经定义好的 demo 函数，此时传入的函数参数 a 就是实际参数</span></span><br><span class="line">demo(a)</span><br></pre></td></tr></table></figure>
根据实际参数的类型不同，函数参数的传递方式可分为 2 种，分别为值传递和引用（地址）传递：</li>
<li>值传递：适用于实参类型为不可变类型（字符串、数字、元组）；</li>
<li>引用（地址）传递：适用于实参类型为可变类型（列表，字典）；</li>
</ul>
<p>值传递和引用传递的区别是，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。</p>
<p>例如，定义一个名为<code>demo</code>的函数，分别为传入一个字符串类型的变量（代表值传递）和列表类型的变量（代表引用传递）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">obj</span>) :</span><br><span class="line">  obj += obj</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;形参值为：&quot;</span>,obj)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-------值传递-----&quot;</span>)</span><br><span class="line">a = <span class="string">&quot;测试&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值为：&quot;</span>,a)</span><br><span class="line">demo(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;实参值为：&quot;</span>,a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----引用传递-----&quot;</span>)</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a的值为：&quot;</span>,a)</span><br><span class="line">demo(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;实参值为：&quot;</span>,a)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-------值传递-----</span><br><span class="line">a的值为： 测试</span><br><span class="line">形参值为： 测试测试</span><br><span class="line">实参值为： 测试</span><br><span class="line">-----引用传递-----</span><br><span class="line">a的值为： [1, 2, 3]</span><br><span class="line">形参值为： [1, 2, 3, 1, 2, 3]</span><br><span class="line">实参值为： [1, 2, 3, 1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>分析运行结果不难看出，在执行值传递时，改变形式参数的值，实际参数并不会发生改变；而在进行引用传递时，改变形式参数的值，实际参数也会发生同样的改变。</p>
<h1 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h1><p>位置参数，有时也称必备参数，指的是必须按照正确的顺序将实际参数传到函数中，换句话说，调用函数时传入实际参数的数量和位置都必须和定义函数时保持一致。</p>
<h2 id="实参和形参数量必须一致"><a href="#实参和形参数量必须一致" class="headerlink" title="实参和形参数量必须一致"></a>实参和形参数量必须一致</h2><p>在调用函数，指定的实际参数的数量，必须和形式参数的数量一致（传多传少都不行），否则 Python 解释器会抛出<code>TypeError</code>异常，并提示缺少必要的位置参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">girth</span>(<span class="params">width , height</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * (width + height)</span><br><span class="line"><span class="comment">#调用函数时，必须传递 2 个参数，否则会引发错误</span></span><br><span class="line"><span class="built_in">print</span>(girth(<span class="number">3</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;C:\Users\mengma\Desktop\1.py&quot;, line 4, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(girth(3))</span></span><br><span class="line"><span class="string">TypeError: girth() missing 1 required positional argument: &#x27;height&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>同样，多传参数也会抛出异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">girth</span>(<span class="params">width , height</span>):</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * (width + height)</span><br><span class="line"><span class="comment">#调用函数时，必须传递 2 个参数，否则会引发错误</span></span><br><span class="line"><span class="built_in">print</span>(girth(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;C:\Users\mengma\Desktop\1.py&quot;, line 4, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(girth(3,2,4))</span></span><br><span class="line"><span class="string">TypeError: girth() takes 2 positional arguments but 3 were given</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="实参和形参位置必须一致"><a href="#实参和形参位置必须一致" class="headerlink" title="实参和形参位置必须一致"></a>实参和形参位置必须一致</h2><p>在调用函数时，传入实际参数的位置必须和形式参数位置一一对应，否则会产生以下 2 种结果：</p>
<h3 id="1-抛出TypeError异常"><a href="#1-抛出TypeError异常" class="headerlink" title="1. 抛出TypeError异常"></a>1. 抛出<code>TypeError</code>异常</h3><p>当实际参数类型和形式参数类型不一致，并且在函数中，这两种类型之间不能正常转换，此时就会抛出<code>TypeError</code>异常。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">height,width</span>):</span><br><span class="line">  <span class="keyword">return</span> height * width / <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(area(<span class="string">&quot;测试&quot;</span>, <span class="number">3</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;C:\Users\mengma\Desktop\1.py&quot;, line 3, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(area(&quot;测试&quot;,3))</span></span><br><span class="line"><span class="string">  File &quot;C:\Users\mengma\Desktop\1.py&quot;, line 2, in area</span></span><br><span class="line"><span class="string">    return height*width/2</span></span><br><span class="line"><span class="string">TypeError: unsupported operand type(s) for /: &#x27;str&#x27; and &#x27;int&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以上显示的异常信息，就是因为字符串类型和整形数值做除法运算。</p>
<h3 id="2-产生的结果和预期不符"><a href="#2-产生的结果和预期不符" class="headerlink" title="2. 产生的结果和预期不符"></a>2. 产生的结果和预期不符</h3><p>调用函数时，如果指定的实际参数和形式参数的位置不一致，但它们的数据类型相同，那么程序将不会抛出异常，只不过导致运行结果和预期不符。</p>
<p>例如，设计一个求梯形面积的函数，并利用此函数求上底为 4cm，下底为 3cm，高为 5cm 的梯形的面积。但如果交互高和下低参数的传入位置，计算结果将导致错误：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">upper_base, lower_bottom, height</span>):</span><br><span class="line">  <span class="keyword">return</span> (upper_base + lower_bottom) * height / <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正确结果为：&quot;</span>,area(<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>)) <span class="comment"># 正确结果为： 17.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;错误结果为：&quot;</span>,area(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>)) <span class="comment"># 错误结果为： 13.5</span></span><br></pre></td></tr></table></figure>
<h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>关键字参数是指使用形式参数的名字来确定输入的参数值。通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dis_str</span>(<span class="params">str1, str2</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;str1:&quot;</span>, str1)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;str2:&quot;</span>, str2)</span><br><span class="line"><span class="comment">#位置参数</span></span><br><span class="line">dis_str(<span class="string">&quot;python&quot;</span>, <span class="string">&quot;shell&quot;</span>)</span><br><span class="line"><span class="comment">#关键字参数</span></span><br><span class="line">dis_str(<span class="string">&quot;python&quot;</span>, str2=<span class="string">&quot;shell&quot;</span>)</span><br><span class="line">dis_str(str2=<span class="string">&quot;python&quot;</span>, str1=<span class="string">&quot;shell&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str1: python</span><br><span class="line">str2: shell</span><br><span class="line">str1: python</span><br><span class="line">str2: shell</span><br><span class="line">str1: shell</span><br><span class="line">str2: python</span><br></pre></td></tr></table></figure>
<p>可以看到，在调用有参函数时，既可以根据位置参数来调用，也可以使用关键字参数（程序中第 8 行）来调用。在使用关键字参数调用时，可以任意调换参数传参的位置。</p>
<p>当然，还可以像第 7 行代码这样，使用位置参数和关键字参数混合传参的方式。但需要注意，混合传参时关键字参数必须位于所有的位置参数之后。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置参数必须放在关键字参数之前，下面代码错误</span></span><br><span class="line">dis_str(str1=<span class="string">&quot;python&quot;</span>, <span class="string">&quot;shell&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Python 解释器会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>在调用函数时如果不指定某个参数，Python 解释器会抛出异常。为了解决这个问题，Python 允许为参数设置默认值，即在定义函数时，直接给形式参数指定一个默认值。这样的话，即便调用函数时没有给拥有默认值的形参传递参数，该参数可以直接使用定义函数时设置的默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(..., 形参名，形参名=默认值)：</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure>
<p>注意，在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#str1没有默认参数，str2有默认参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dis_str</span>(<span class="params">str1, str2 = <span class="string">&quot;python&quot;</span></span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;str1:&quot;</span>,str1)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;str2:&quot;</span>,str2)</span><br><span class="line">dis_str(<span class="string">&quot;shell&quot;</span>)</span><br><span class="line">dis_str(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;golang&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1: shell</span><br><span class="line">str2: python</span><br><span class="line">str1: java</span><br><span class="line">str2: golang</span><br></pre></td></tr></table></figure>
<p>当然在调用<code>dis_str()</code>函数时，也可以给所有的参数传值，这时即便<code>str2</code>有默认值，它也会优先使用传递给它的新值。</p>
<p>同时，结合关键字参数，以下 3 种调用<code>dis_str()</code>函数的方式也是可以的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dis_str(str1 = <span class="string">&quot;shell&quot;</span>)</span><br><span class="line">dis_str(<span class="string">&quot;java&quot;</span>, str2 = <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">dis_str(str1 = <span class="string">&quot;java&quot;</span>, str2 = <span class="string">&quot;golang&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>再次强调，当定义一个有默认值参数的函数时，有默认值的参数必须位于所有没默认值参数的后面。因此，下面例子中定义的函数是不正确的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#语法错误</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dis_str</span>(<span class="params">str1=<span class="string">&quot;python&quot;</span>, str2, str3</span>):</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>显然，<code>str1</code>设有默认值，而<code>str2</code>和<code>str3</code>没有默认值，因此<code>str1</code>必须位于<code>str2</code>和<code>str3</code>之后。</p>
<p>对于自己自定义的函数，可以轻易知道哪个参数有默认值，但如果使用 Python 提供的内置函数，又或者其它第三方提供的函数，怎么知道哪些参数有默认值呢？</p>
<p>Pyhton 中，可以使用<code>函数名.__defaults__</code>查看函数的默认值参数的当前值，其返回值是一个元组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dis_str.__defaults__)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;python&#x27;,)</span><br></pre></td></tr></table></figure>
<h1 id="None（空值）"><a href="#None（空值）" class="headerlink" title="None（空值）"></a>None（空值）</h1><p>在 Python 中，有一个特殊的常量<code>None</code>。和<code>False</code>不同，它不表示 0，也不表示空字符串，而表示没有值，也就是空值。</p>
<p>这里的空值并不代表空对象，即<code>None</code>和<code>[]、&#39;&#39;</code>不同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span> <span class="keyword">is</span> []</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span> <span class="keyword">is</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><code>None</code>有自己的数据类型，我们可以在 IDLE 中使用<code>type()</code>函数查看它的类型：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;NoneType&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，它属于<code>NoneType</code>类型。</p>
<p>需要注意的是，<code>None</code>是<code>NoneType</code>数据类型的唯一值，也就是说，我们不能再创建其它<code>NoneType</code>类型的变量，但是可以将<code>None</code>赋值给任何变量。如果希望变量中存储的东西不与任何其它值混淆，就可以使用<code>None</code>。</p>
<p>除此之外，<code>None</code>常用于<code>assert</code>、判断以及函数无返回值的情况。<code>print()</code>函数返回值就是<code>None</code>。因为它的功能是在屏幕上显示文本，根本不需要返回任何值，所以<code>print()</code>就返回<code>None</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>spam = <span class="built_in">print</span>(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line">Hello!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span> == spam</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>另外，对于所有没有<code>return</code>语句的函数定义，Python 都会在末尾加上<code>return None</code>，使用不带值的<code>return</code>语句（也就是只有<code>return</code>关键字本身），那么就返回<code>None</code>。</p>
<h1 id="return函数返回值"><a href="#return函数返回值" class="headerlink" title="return函数返回值"></a>return函数返回值</h1><p>用<code>def</code>语句创建函数时，可以用<code>return</code>语句指定应该返回的值，该返回值可以是任意类型。需要注意的是，<code>return</code>语句在同一函数中可以出现多次，但只要有一个得到执行，就会直接结束函数的执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return [返回值]</span><br></pre></td></tr></table></figure>
<p>其中，返回值参数可以指定，也可以省略不写（将返回空值<code>None</code>）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">  c = a + b</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line"><span class="comment">#函数赋值给变量</span></span><br><span class="line">c = add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># 7</span></span><br><span class="line"><span class="comment">#函数返回值作为其他函数的实际参数</span></span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
<p>本例中，<code>add()</code>函数既可以用来计算两个数的和，也可以连接两个字符串，它会返回计算的结果。</p>
<p>通过<code>return</code>语句指定返回值后，我们在调用函数时，既可以将该函数赋值给一个变量，用变量保存函数的返回值，也可以将函数再作为某个函数的实际参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isGreater0</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(isGreater0(<span class="number">5</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(isGreater0(<span class="number">0</span>)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>可以看到，函数中可以同时包含多个<code>return</code>语句，但需要注意的是，最终真正执行的做多只有 1 个，且一旦执行，函数运行会立即结束。</p>
<p>以上实例中，我们通过<code>return</code>语句，都仅返回了一个值，但其实通过<code>return</code>语句，可以返回多个值。</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>所谓作用域，就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在整段代码的任意位置使用，有些变量只能在函数内部使用，有些变量只能在<code>for</code>循环内部使用。</p>
<p>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，这样的变量称为局部变量。</p>
<p>当函数被执行时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">  add = <span class="string">&quot;python&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;函数内部 add =&quot;</span>,add)</span><br><span class="line">demo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部 add =&quot;</span>,add)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数内部 add = python</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\file.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    print(&quot;函数外部 add =&quot;,add)</span><br><span class="line">NameError: name &#x27;add&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>可以看到，如果试图在函数外部访问其内部定义的变量，Python 解释器会报<code>NameError</code>错误，并提示我们没有定义要访问的变量，这也证实了当函数执行完毕后，其内部定义的变量会被销毁并回收。</p>
<p>值得一提的是，函数的参数也属于局部变量，只能在函数内部使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">name,add</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;函数内部 name =&quot;</span>,name)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;函数内部 add =&quot;</span>,add)</span><br><span class="line">demo(<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部 name =&quot;</span>,name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部 add =&quot;</span>,add)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数内部 name = Python教程</span><br><span class="line">函数内部 add = python</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\file.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    print(&quot;函数外部 name =&quot;,name)</span><br><span class="line">NameError: name &#x27;name&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>由于 Python 解释器是逐行运行程序代码，由此这里仅提示给我“name 没有定义”，实际上在函数外部访问<code>add</code>变量也会报同样的错误。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>除了在函数内部定义变量，Python 还允许在所有函数的外部定义变量，这样的变量称为全局变量。</p>
<p>和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。</p>
<p>定义全局变量的方式有以下 2 种：</p>
<ul>
<li>在函数体外定义的变量，一定是全局变量：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;shell&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;函数体内访问：&quot;</span>,add)</span><br><span class="line">text()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数体外访问：&#x27;</span>,add)</span><br></pre></td></tr></table></figure>
运行结果为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数体内访问： shell</span><br><span class="line">函数体外访问： shell</span><br></pre></td></tr></table></figure></li>
<li>在函数体内定义全局变量。即使用<code>global</code>关键字对变量进行修饰后，该变量就会变为全局变量。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">  <span class="keyword">global</span> add</span><br><span class="line">  add= <span class="string">&quot;java&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;函数体内访问：&quot;</span>, add)</span><br><span class="line">text()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;函数体外访问：&#x27;</span>, add)</span><br></pre></td></tr></table></figure>
运行结果为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数体内访问： java</span><br><span class="line">函数体外访问： java</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，在使用<code>global</code>关键字修饰变量名时，不能直接给变量赋初值，否则会引发语法错误。</p>
<h2 id="获取指定作用域范围中的变量"><a href="#获取指定作用域范围中的变量" class="headerlink" title="获取指定作用域范围中的变量"></a>获取指定作用域范围中的变量</h2><p>在一些特定场景中，我们可能需要获取某个作用域内（全局范围内或者局部范围内）所有的变量，Python 提供了以下 3 种方式：</p>
<h4 id="1-globals-函数"><a href="#1-globals-函数" class="headerlink" title="1) globals()函数"></a>1) globals()函数</h4><p><code>globals()</code>函数为 Python 的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。</p>
<p>举个例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">    <span class="comment">#局部变量</span></span><br><span class="line">    Shename = <span class="string">&quot;shell教程&quot;</span></span><br><span class="line">    Sheadd= <span class="string">&quot;shell&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; ...... , &#x27;Pyname&#x27;: &#x27;Python教程&#x27;, &#x27;Pyadd&#x27;: &#x27;python&#x27;, ......&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>globals()</code>函数返回的字典中，会默认包含有很多变量，这些都是 Python 主程序内置的。</p>
<p>可以看到，通过调用<code>globals()</code>函数，我们可以得到一个包含所有全局变量的字典。并且，通过该字典，我们还可以访问指定变量，甚至如果需要，还可以修改它的值。例如，在上面程序的基础上，添加如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>()[<span class="string">&#x27;Pyname&#x27;</span>])</span><br><span class="line"><span class="built_in">globals</span>()[<span class="string">&#x27;Pyname&#x27;</span>] = <span class="string">&quot;Python入门教程&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Pyname)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python教程</span><br><span class="line">Python入门教程</span><br></pre></td></tr></table></figure>
<h4 id="2-locals-函数"><a href="#2-locals-函数" class="headerlink" title="2) locals()函数"></a>2) locals()函数</h4><p><code>locals()</code>函数也是 Python 内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。这里所谓的“当前作用域”指的是，在函数内部调用<code>locals()</code>函数，会获得包含所有局部变量的字典；而在全局范文内调用<code>locals()</code>函数，其功能和<code>globals()</code>函数相同。</p>
<p>举个例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">  <span class="comment">#局部变量</span></span><br><span class="line">  Shename = <span class="string">&quot;shell教程&quot;</span></span><br><span class="line">  Sheadd= <span class="string">&quot;shell&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;函数内部的 locals:&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">text()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;函数外部的 locals:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line">程序执行结果为：</span><br><span class="line">函数内部的 <span class="built_in">locals</span>:</span><br><span class="line">&#123;<span class="string">&#x27;Sheadd&#x27;</span>: <span class="string">&#x27;shell&#x27;</span>, <span class="string">&#x27;Shename&#x27;</span>: <span class="string">&#x27;shell教程&#x27;</span>&#125;</span><br><span class="line">函数外部的 <span class="built_in">locals</span>:</span><br><span class="line">&#123;...... , <span class="string">&#x27;Pyname&#x27;</span>: <span class="string">&#x27;Python教程&#x27;</span>, <span class="string">&#x27;Pyadd&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, ...... &#125;</span><br></pre></td></tr></table></figure>
<p>当使用<code>locals()</code>函数获取所有全局变量时，和<code>globals()</code>函数一样，其返回的字典中会默认包含有很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。</p>
<p>注意，当使用<code>locals()</code>函数获得所有局部变量组成的字典时，可以向<code>globals()</code>函数那样，通过指定键访问对应的变量值，但无法对变量值做修改。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://c.biancheng.net/python/&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text</span>():</span><br><span class="line">  <span class="comment">#局部变量</span></span><br><span class="line">  Shename = <span class="string">&quot;shell教程&quot;</span></span><br><span class="line">  Sheadd= <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">locals</span>()[<span class="string">&#x27;Shename&#x27;</span>])</span><br><span class="line">  <span class="built_in">locals</span>()[<span class="string">&#x27;Shename&#x27;</span>] = <span class="string">&quot;shell入门教程&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(Shename)</span><br><span class="line">text()</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell教程</span><br><span class="line">shell教程</span><br></pre></td></tr></table></figure>
<p>显然，<code>locals()</code>返回的局部变量组成的字典，可以用来访问变量，但无法修改变量的值。</p>
<h4 id="3-vars-object"><a href="#3-vars-object" class="headerlink" title="3) vars(object)"></a>3) vars(object)</h4><p><code>vars()</code>函数也是 Python 内置函数，其功能是返回一个指定<code>object</code>对象范围内所有变量组成的字典。如果不传入<code>object</code>参数，<code>vars()</code>和<code>locals()</code>的作用完全相同。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>:</span><br><span class="line">    name = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">    add = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有 object：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(Demo))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;无 object：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>())</span><br><span class="line">程序执行结果为：</span><br><span class="line">有 <span class="built_in">object</span>：</span><br><span class="line">&#123;...... , <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Python 教程&#x27;</span>, <span class="string">&#x27;add&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, ......&#125;</span><br><span class="line">无 <span class="built_in">object</span>：</span><br><span class="line">&#123;...... , <span class="string">&#x27;Pyname&#x27;</span>: <span class="string">&#x27;Python教程&#x27;</span>, <span class="string">&#x27;Pyadd&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, ...... &#125;</span><br></pre></td></tr></table></figure>
<h1 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h1><p>Python 支持在函数内部定义函数，此类函数又称为局部函数。</p>
<p>和局部变量一样，默认情况下局部函数只能在其所在函数的作用域内使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">  <span class="comment">#局部函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">  <span class="comment">#调用局部函数</span></span><br><span class="line">  indef()</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">outdef()</span><br></pre></td></tr></table></figure>
<p>就如同全局函数返回其局部变量，就可以扩大该变量的作用域一样，通过将局部函数作为所在函数的返回值，也可以扩大局部函数的使用范围。例如，修改上面程序为：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">  <span class="comment">#局部函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用局部函数&quot;</span>)</span><br><span class="line">  <span class="comment">#调用局部函数</span></span><br><span class="line">  <span class="keyword">return</span> indef</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">new_indef = outdef()</span><br><span class="line"><span class="comment"># 调用全局函数中的局部函数</span></span><br><span class="line">new_indef()</span><br></pre></td></tr></table></figure>
<p>因此，对于局部函数的作用域，可以总结为：如果所在函数没有返回局部函数，则局部函数的可用范围仅限于所在函数内部；反之，如果所在函数将局部函数作为返回值，则局部函数的作用域就会扩大，既可以在所在函数内部使用，也可以在所在函数的作用域中使用。</p>
<p>以上面程序中的<code>outdef()</code>和<code>indef()</code>为例，如果<code>outdef()</code>不将<code>indef</code>作为返回值，则<code>indef()</code>只能在<code>outdef()</code>函数内部使用；反之，则<code>indef()</code>函数既可以在<code>outdef()</code>函数内部使用，也可以在<code>outdef()</code>函数的作用域，也就是全局范围内使用。</p>
<p>另外值得一提的是，如果局部函数中定义有和所在函数中变量同名的变量，也会发生“遮蔽”的问题。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">  name = <span class="string">&quot;所在函数中定义的 name 变量&quot;</span></span><br><span class="line">  <span class="comment">#局部函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    name = <span class="string">&quot;局部函数中定义的 name 变量&quot;</span></span><br><span class="line">  indef()</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">outdef()</span><br></pre></td></tr></table></figure>
<p>执行此程序，Python 解释器会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable &#x27;name&#x27; referenced before assignment</span><br></pre></td></tr></table></figure>
<p>此错误直译过来的意思是“局部变量 name 还没定义就使用”。导致该错误的原因就在于，局部函数<code>indef()</code>中定义的<code>name</code>变量遮蔽了所在函数<code>outdef()</code>中定义的<code>name</code>变量。再加上，<code>indef()</code>函数中<code>name</code>变量的定义位于<code>print()</code>输出语句之后，导致<code>print(name)</code>语句在执行时找不到定义的<code>name</code>变量，因此程序报错。</p>
<p>由于这里的<code>name</code>变量也是局部变量，因此<code>globals()</code>函数或者<code>globals</code>关键字，并不适用于解决此问题。这里可以使用 Python 提供的<code>nonlocal</code>关键字。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outdef</span> ():</span><br><span class="line">  name = <span class="string">&quot;所在函数中定义的 name 变量&quot;</span></span><br><span class="line">  <span class="comment">#局部函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">indef</span>():</span><br><span class="line">    <span class="keyword">nonlocal</span> name</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="comment">#修改name变量的值</span></span><br><span class="line">    name = <span class="string">&quot;局部函数中定义的 name 变量&quot;</span></span><br><span class="line">  indef()</span><br><span class="line"><span class="comment">#调用全局函数</span></span><br><span class="line">outdef()</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所在函数中定义的 name 变量</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>闭包，又称闭包函数或者闭合函数，其实和前面讲的嵌套函数类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。一般情况下，返回的函数会赋值给一个变量，这个变量可以在后面被继续执行调用。</p>
<p>例如，计算一个数的<code>n</code>次幂，用闭包可以写成下面的代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#闭包函数，其中 exponent 称为自由变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nth_power</span>(<span class="params">exponent</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">exponent_of</span>(<span class="params">base</span>):</span><br><span class="line">    <span class="keyword">return</span> base ** exponent</span><br><span class="line">  <span class="keyword">return</span> exponent_of <span class="comment"># 返回值是 exponent_of 函数</span></span><br><span class="line">square = nth_power(<span class="number">2</span>) <span class="comment"># 计算一个数的平方</span></span><br><span class="line">cube = nth_power(<span class="number">3</span>) <span class="comment"># 计算一个数的立方</span></span><br><span class="line"><span class="built_in">print</span>(square(<span class="number">2</span>))  <span class="comment"># 计算 2 的平方</span></span><br><span class="line"><span class="built_in">print</span>(cube(<span class="number">2</span>)) <span class="comment"># 计算 2 的立方</span></span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>在上面程序中，外部函数<code>nth_power()</code>的返回值是函数<code>exponent_of()</code>，而不是一个具体的数值。</p>
<p>需要注意的是，在执行完<code>square = nth_power(2)</code>和<code>cube = nth_power(3)</code>后，外部函数<code>nth_power()</code>的参数<code>exponent</code>会和内部函数<code>exponent_of</code>一起赋值给<code>squre</code>和<code>cube</code>，这样在之后调用<code>square(2)</code>或者<code>cube(2)</code>时，程序就能顺利地输出结果，而不会报错说参数<code>exponent</code>没有定义。</p>
<p>为什么要闭包呢？上面的程序，完全可以写成下面的形式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nth_power_rewrite</span>(<span class="params">base, exponent</span>):</span><br><span class="line">  <span class="keyword">return</span> base ** exponent</span><br></pre></td></tr></table></figure>
<p>上面程序确实可以实现相同的功能，不过使用闭包，可以让程序变得更简洁易读。设想一下，比如需要计算很多个数的平方，那么写成下面哪一种形式更好呢？</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用闭包</span></span><br><span class="line">res1 = nth_power_rewrite(base1, <span class="number">2</span>)</span><br><span class="line">res2 = nth_power_rewrite(base2, <span class="number">2</span>)</span><br><span class="line">res3 = nth_power_rewrite(base3, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 使用闭包</span></span><br><span class="line">square = nth_power(<span class="number">2</span>)</span><br><span class="line">res1 = square(base1)</span><br><span class="line">res2 = square(base2)</span><br><span class="line">res3 = square(base3)</span><br></pre></td></tr></table></figure>
<p>显然第二种方式表达更为简洁，在每次调用函数时，都可以少输入一个参数。</p>
<p>其次，和缩减嵌套函数的优点类似，函数开头需要做一些额外工作，当需要多次调用该函数时，如果将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要开销，提高程序的运行效率。</p>
<h2 id="Python闭包的-closure-属性"><a href="#Python闭包的-closure-属性" class="headerlink" title="Python闭包的__closure__属性"></a>Python闭包的__closure__属性</h2><p>闭包比普通的函数多了一个<code>__closure__</code>属性，该属性记录着自由变量的地址。当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用。</p>
<p>以<code>nth_power()</code>为例，当其被调用时，可以通过<code>__closure__</code>属性获取自由变量（也就是程序中的<code>exponent</code>参数）存储的地址：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nth_power</span>(<span class="params">exponent</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">exponent_of</span>(<span class="params">base</span>):</span><br><span class="line">    <span class="keyword">return</span> base ** exponent</span><br><span class="line">  <span class="keyword">return</span> exponent_of</span><br><span class="line">square = nth_power(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#查看 __closure__ 的值</span></span><br><span class="line"><span class="built_in">print</span>(square.__closure__)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;cell at 0x0000014454DFA948: int object at 0x00000000513CC6D0&gt;,)</span><br></pre></td></tr></table></figure>
<p>可以看到，显示的内容是一个<code>int</code>整数类型，这就是<code>square</code>中自由变量<code>exponent</code>的初始值。还可以看到，<code>__closure__</code>属性的类型是一个元组，这表明闭包可以支持多个自由变量的形式。</p>
<h1 id="lambda表达式（匿名函数）"><a href="#lambda表达式（匿名函数）" class="headerlink" title="lambda表达式（匿名函数）"></a>lambda表达式（匿名函数）</h1><p>对于定义一个简单的函数，Python 还提供了另外一种方法，即 lambda 表达式。</p>
<p>lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = lambda [list] : 表达式</span><br></pre></td></tr></table></figure>
<p>其中，定义 lambda 表达式，必须使用 lambda 关键字；<code>[list]</code>作为可选参数，等同于定义函数是指定的参数列表；<code>value</code>为该表达式的名称。</p>
<p>该语法格式转换成普通函数的形式，如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">name</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">  <span class="keyword">return</span> 表达式</span><br><span class="line">name(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>显然，使用普通方法定义此函数，需要 3 行代码，而使用 lambda 表达式仅需 1 行。</p>
<p>举个例子，如果设计一个求 2 个数之和的函数，使用普通函数的方式，定义如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
<p>由于上面程序中，<code>add()</code>函数内部仅有 1 行表达式，因此该函数可以直接用 lambda 表达式表示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
<p>可以这样理解 lambda 表达式，其就是简单函数（函数体仅是单行的表达式）的简写版本。相比函数，lamba 表达式具有以下  2 个优势：</p>
<ul>
<li>对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁；</li>
<li>对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。</li>
</ul>
<h1 id="eval-和exec-函数"><a href="#eval-和exec-函数" class="headerlink" title="eval()和exec()函数"></a>eval()和exec()函数</h1><p><code>eval()</code>和<code>exec()</code>函数都属于 Python 的内置函数。</p>
<p><code>eval()</code>和<code>exec()</code>函数的功能是相似的，都可以执行一个字符串形式的 Python 代码（代码以字符串的形式提供），相当于一个 Python 的解释器。二者不同之处在于，<code>eval()</code>执行完要返回结果，而<code>exec()</code>执行完不返回结果。</p>
<h2 id="eval-和exec-的用法"><a href="#eval-和exec-的用法" class="headerlink" title="eval()和exec()的用法"></a>eval()和exec()的用法</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(expression, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, /)</span><br><span class="line"><span class="built_in">exec</span>(expression, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, /)</span><br></pre></td></tr></table></figure>
<p>可以看到，二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下：</p>
<ul>
<li><code>expression</code>：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数<code>globals</code>和<code>locals</code>的限制，只有在<code>globals</code>字典和<code>locals</code>字典作用域内的函数和变量才能被执行。</li>
<li><code>globals</code>：这个参数管控的是一个全局的命名空间，即<code>expression</code>可以使用全局命名空间中的函数。如果只是提供了<code>globals</code>参数，而没有提供自定义的<code>__builtins__</code>，则系统会将当前环境中的<code>__builtins__</code>复制到自己提供的<code>globals</code>中，然后才会进行计算；如果连<code>globals</code>这个参数都没有被提供，则使用 Python 的全局命名空间。</li>
<li><code>locals</code>：这个参数管控的是一个局部的命名空间，和<code>globals</code>类似，当它和<code>globals</code>中有重复或冲突时，以<code>locals</code>的为准。如果<code>locals</code>没有被提供，则默认为<code>globals</code>。</li>
</ul>
<p>注意，<code>__builtins__</code>是 Python 的内建模块，平时使用的<code>int、str、abs</code>都在这个模块中。通过<code>print(dic[&quot;__builtins__&quot;])</code>语句可以查看<code>__builtins__</code>所对应的<code>value</code>。</p>
<p>首先，通过如下的例子来演示参数<code>globals</code>作用域的作用，注意观察它是何时将<code>__builtins__</code>复制<code>globals</code>字典中去的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic=&#123;&#125; <span class="comment">#定义一个字典</span></span><br><span class="line">dic[<span class="string">&#x27;b&#x27;</span>] = <span class="number">3</span> <span class="comment">#在 dic 中加一条元素，key 为 b</span></span><br><span class="line"><span class="built_in">print</span> (dic.keys()) <span class="comment">#先将 dic 的 key 打印出来，有一个元素 b</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 4&quot;</span>, dic) <span class="comment">#在 exec 执行的语句后面跟一个作用域 dic</span></span><br><span class="line"><span class="built_in">print</span>(dic.keys()) <span class="comment">#exec 后，dic 的 key 多了一个</span></span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict_keys([&#x27;b&#x27;])</span><br><span class="line">dict_keys([&#x27;b&#x27;, &#x27;__builtins__&#x27;, &#x27;a&#x27;])</span><br></pre></td></tr></table></figure>
<p>上面的代码是在作用域<code>dic</code>下执行了一句<code>a = 4</code>的代码。可以看出，<code>exec()</code>之前<code>dic</code>中的<code>key</code>只有一个<code>b</code>。执行完<code>exec()</code>之后，系统在<code>dic</code>中生成了两个新的<code>key</code>，分别是<code>a</code>和<code>__builtins__</code>。其中，<code>a</code>为执行语句生成的变量，系统将其放到指定的作用域字典里；<code>__builtins__</code>是系统加入的内置<code>key</code>。</p>
<p><code>locals</code>参数的用法就很简单了：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">c=<span class="number">30</span></span><br><span class="line">g=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">8</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line">t=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">eval</span>(<span class="string">&#x27;a+b+c&#x27;</span>, g, t)) <span class="comment">#定义一个字典 116</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">116</span><br></pre></td></tr></table></figure>
<h2 id="exec-和eval-的区别"><a href="#exec-和eval-的区别" class="headerlink" title="exec()和eval()的区别"></a>exec()和eval()的区别</h2><p>它们的区别在于，<code>eval()</code>执行完会返回结果，而<code>exec()</code>执行完不返回结果。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;a = 2&quot;</span>) <span class="comment">#相当于直接执行 a=2</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = <span class="built_in">exec</span>(<span class="string">&quot;2+3&quot;</span>) <span class="comment">#相当于直接执行 2+3，但是并没有返回值，a 应为 None</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = <span class="built_in">eval</span>(<span class="string">&#x27;2+3&#x27;</span>) <span class="comment">#执行 2+3，并把结果返回给 a</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">None</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>exec()</code>中最适合放置运行后没有结果的语句，而<code>eval()</code>中适合放置有结果返回的语句。</p>
<p>如果<code>eval()</code>里放置一个没有结果返回的语句会怎样呢？例如下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a= eval(&quot;a = 2&quot;)</span><br></pre></td></tr></table></figure>
<p>这时 Python 解释器会报<code>SyntaxError</code>错误，提示<code>eval()</code>中不识别等号语法。</p>
<h4 id="eval-和-exec-函数的应用场景"><a href="#eval-和-exec-函数的应用场景" class="headerlink" title="eval() 和 exec() 函数的应用场景"></a>eval() 和 exec() 函数的应用场景</h4><p>在使用 Python 开发服务端程序时，这两个函数应用得非常广泛。例如，客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接跳过<code>eval()</code>或<code>exec()</code>来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。</p>
<p>需要注意的是，在使用<code>eval()</code>或是<code>exec()</code>来处理请求代码时，函数<code>eval()</code>和<code>exec()</code>常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制<code>eval()</code>和<code>exec()</code>的执行范围。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python流程控制"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/11/python/Python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"
    >Python流程控制</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/11/python/Python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="article-date">
  <time datetime="2022-12-11T11:53:21.000Z" itemprop="datePublished">2022-12-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="if-else条件语句"><a href="#if-else条件语句" class="headerlink" title="if else条件语句"></a>if else条件语句</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if 表达式：</span><br><span class="line">  代码块</span><br><span class="line"></span><br><span class="line">if 表达式：</span><br><span class="line">  代码块 1</span><br><span class="line">else：</span><br><span class="line">  代码块 2</span><br><span class="line"></span><br><span class="line">if 表达式 1：</span><br><span class="line">  代码块 1</span><br><span class="line">elif 表达式 2：</span><br><span class="line">  代码块 2</span><br><span class="line">elif 表达式 3：</span><br><span class="line">  代码块 3</span><br><span class="line">...//其它elif语句</span><br><span class="line">else：</span><br><span class="line">  代码块 n</span><br></pre></td></tr></table></figure>
<h1 id="if-else-如何判断表达式是否成立"><a href="#if-else-如何判断表达式是否成立" class="headerlink" title="if else 如何判断表达式是否成立"></a>if else 如何判断表达式是否成立</h1><p><code>if</code>和<code>elif</code>后面的“表达式”的形式是很自由的，只要表达式有一个结果，不管这个结果是什么类型，Python 都能判断它是“真”还是“假”。</p>
<p>布尔类型（<code>bool</code>）只有两个值，分别是<code>True</code>和<code>False</code>，Python 会把<code>True</code>当做“真”，把<code>False</code>当做“假”。</p>
<p>对于数字，Python 会把 0 和 0.0 当做“假”，把其它值当做“真”。</p>
<p>对于其它类型，当对象为空或者为<code>None</code>时，Python 会把它们当做“假”，其它情况当做真。比如，下面的表达式都是不成立的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>  <span class="comment">#空字符串</span></span><br><span class="line">[]  <span class="comment">#空列表</span></span><br><span class="line">()  <span class="comment">#空元组</span></span><br><span class="line">&#123;&#125;  <span class="comment">#空字典</span></span><br><span class="line"><span class="literal">None</span>  <span class="comment">#空值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> b:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;b是True&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;b是False&#x27;</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> n:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;n不是零值&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;n是零值&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> s:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;s不是空字符串&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;s是空字符串&#x27;</span>)</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">if</span> l:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;l不是空列表&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;l是空列表&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> d:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;d不是空字典&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;d是空字典&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;函数被调用&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> func():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;func()返回值不是空&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;func()返回值为空&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b是False</span><br><span class="line">n是零值</span><br><span class="line">s是空字符串</span><br><span class="line">l是空列表</span><br><span class="line">d是空字典</span><br><span class="line">函数被调用</span><br><span class="line">func()返回值为空</span><br></pre></td></tr></table></figure>
<p>说明：对于没有<code>return</code>语句的函数，返回值为空，也即<code>None</code>。</p>
<h1 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">int</span>( <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄：&quot;</span>) )</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">12</span> :</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;婴幼儿&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">12</span> <span class="keyword">and</span> age &lt; <span class="number">18</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;青少年&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt; <span class="number">30</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;成年人&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">30</span> <span class="keyword">and</span> age &lt; <span class="number">50</span>:</span><br><span class="line">  <span class="comment">#<span class="doctag">TODO:</span> 成年人</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;老年人&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>当年龄大于等于 30 并且小于 50 时，我们没有使用<code>print()</code>语句，而是使用了一个注释，希望以后再处理成年人的情况。当 Python 执行到该<code>elif</code>分支时，会跳过注释，什么都不执行。</p>
<p>但是 Python 提供了一种更加专业的做法，就是空语句<code>pass</code>。<code>pass</code>是 Python 中的关键字，用来让解释器跳过此处，什么都不做。</p>
<p>就像上面的情况，有时候程序需要占一个位置，或者放一条语句，但又不希望这条语句做任何事情，此时就可以通过<code>pass</code>语句来实现。使用<code>pass</code>语句比使用注释更加优雅。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">int</span>( <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄：&quot;</span>) )</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">12</span> :</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;婴幼儿&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">12</span> <span class="keyword">and</span> age &lt; <span class="number">18</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;青少年&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt; <span class="number">30</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;成年人&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">30</span> <span class="keyword">and</span> age &lt; <span class="number">50</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;老年人&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="assert断言函数"><a href="#assert断言函数" class="headerlink" title="assert断言函数"></a>assert断言函数</h1><p><code>assert</code>语句，又称断言语句，可以看做是功能缩小版的<code>if</code>语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报<code>AssertionError</code>错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 表达式</span><br></pre></td></tr></table></figure>
<p><code>assert</code>语句的执行流程可以用<code>if</code>判断语句表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 表达式==True:</span><br><span class="line">  程序继续执行</span><br><span class="line">else:</span><br><span class="line">  程序报 AssertionError 错误</span><br></pre></td></tr></table></figure>
<p>明明<code>assert</code>会令程序崩溃，为什么还要使用它呢？这是因为，与其让程序在晚些时候崩溃，不如在错误条件出现时，就直接让程序崩溃，这有利于我们对程序排错，提高程序的健壮性。</p>
<p>因此，<code>assert</code>语句通常用于检查用户的输入是否符合规定，还经常用作程序初期测试和调试过程中的辅助工具。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mathmark = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment">#断言数学考试分数是否位于正常范围内</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= mathmark &lt;= <span class="number">100</span></span><br><span class="line"><span class="comment">#只有当 mathmark 位于 [0,100]范围内，程序才会继续执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数学考试分数为：&quot;</span>, mathmark)</span><br></pre></td></tr></table></figure>
<p>运行该程序，测试数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">90</span><br><span class="line">数学考试分数为： 90</span><br></pre></td></tr></table></figure>
<p>再次执行该程序，测试数据为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">159</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\file.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    assert 0 &lt;= mathmark &lt;= 100</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>
<p>可以看到，当<code>assert</code>语句后的表达式值为真时，程序继续执行；反之，程序停止执行，并报<code>AssertionError</code>错误。</p>
<h1 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件表达式：</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure>
<h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 迭代变量 in 字符串|列表|元组|字典|集合：</span><br><span class="line">  代码块</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;计算 1+2+...+100 的结果为：&quot;</span>)</span><br><span class="line"><span class="comment">#保存累加结果的变量</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="comment">#逐个获取从 1 到 100 这些值，并做累加操作</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">  result += i</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> my_list:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;ele =&#x27;</span>, ele)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ele = 1</span><br><span class="line">ele = 2</span><br><span class="line">ele = 3</span><br><span class="line">ele = 4</span><br><span class="line">ele = 5</span><br></pre></td></tr></table></figure>
<h1 id="循环结构中else用法"><a href="#循环结构中else用法" class="headerlink" title="循环结构中else用法"></a>循环结构中else用法</h1><p>Python 中，无论是<code>while</code>循环还是<code>for</code>循环，其后都可以紧跟着一个<code>else</code>代码块，它的作用是当循环条件为<code>False</code>跳出循环时，程序会最先执行<code>else</code>代码块中的代码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python&quot;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(add):</span><br><span class="line">  <span class="built_in">print</span>(add[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\n执行 else 代码块&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">执行 else 代码块</span><br></pre></td></tr></table></figure>
<p>上面程序中，当<code>i==len(add)</code>结束循环时（确切的说，是在结束循环之前），Python 解释器会执行<code>while</code>循环后的<code>else</code>代码块。</p>
<p>修改上面程序，去掉<code>else</code>代码块：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python&quot;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(add):</span><br><span class="line">  <span class="built_in">print</span>(add[i],end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">#原本位于 else 代码块中的代码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n执行 else 代码块&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">执行 else 代码块</span><br></pre></td></tr></table></figure>
<p>那么，<code>else</code>代码块真的没有用吗？当然不是。</p>
<p>当然，我们也可以为<code>for</code>循环添加一个<code>else</code>代码块：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  add:</span><br><span class="line">  <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\n执行 else 代码块&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">执行 else 代码块</span><br></pre></td></tr></table></figure>
<h1 id="break"><a href="#break" class="headerlink" title="break"></a>break</h1><p>在执行<code>while</code>循环或者<code>for</code>循环时，只要循环条件满足，程序将会一直执行循环体，不停地转圈。但在某些场景，我们可能希望在循环结束前就强制结束循环，Python 提供了 2 种强制离开当前循环体的办法：</p>
<ul>
<li>使用<code>continue</code>语句，可以跳过执行本次循环体中剩余的代码，转而执行下一次的循环。</li>
<li>使用<code>break</code>语句，可以完全终止当前循环。</li>
</ul>
<p><code>break</code>语句可以立即终止当前循环的执行，跳出当前所在的循环结构。无论是<code>while</code>循环还是<code>for</code>循环，只要执行<code>break</code>语句，就会直接结束当前正在执行的循环体。</p>
<p><code>break</code>语句的语法非常简单，只需要在相应<code>while</code>或<code>for</code>语句中直接加入即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python,shell&quot;</span></span><br><span class="line"><span class="comment"># 一个简单的for循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> add:</span><br><span class="line">  <span class="keyword">if</span> i == <span class="string">&#x27;,&#x27;</span> :</span><br><span class="line">    <span class="comment">#终止循环</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n执行循环体外的代码&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">执行循环体外的代码</span><br></pre></td></tr></table></figure>
<p>分析上面程序不难看出，当循环至<code>add</code>字符串中的逗号（<code>,</code>）时，程序执行<code>break</code>语句，其会直接终止当前的循环，跳出循环体。</p>
<p><code>break</code>语句一般会结合<code>if</code>语句进行搭配使用，表示在某种条件下跳出循环体。</p>
<p>注意，<code>for</code>循环后也可以配备一个<code>else</code>语句。这种情况下，如果使用<code>break</code>语句跳出循环体，不会执行<code>else</code>中包含的代码。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python,shell&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> add:</span><br><span class="line">  <span class="keyword">if</span> i == <span class="string">&#x27;,&#x27;</span> :</span><br><span class="line">    <span class="comment">#终止循环</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行 else 语句中的代码&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n执行循环体外的代码&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">执行循环体外的代码</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出，使用<code>break</code>跳出当前循环体之后，该循环后的<code>else</code>代码块也不会被执行。但是，如果将<code>else</code>代码块中的代码直接放在循环体的后面，则该部分代码将会被执行。</p>
<p>另外，对于嵌套的循环结构来说，<code>break</code>语句只会终止所在循环体的执行，而不会作用于所有的循环体。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python,shell&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> add:</span><br><span class="line">    <span class="keyword">if</span> j == <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">      <span class="keyword">break</span>   </span><br><span class="line">    <span class="built_in">print</span>(j,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\n跳出内循环&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">跳出内循环</span><br><span class="line">python</span><br><span class="line">跳出内循环</span><br><span class="line">python</span><br><span class="line">跳出内循环</span><br></pre></td></tr></table></figure>
<p>分析上面程序，每当执行内层循环时，只要循环至<code>add</code>字符串中的逗号（<code>,</code>）就会执行<code>break</code>语句，它会立即停止执行当前所在的内存循环体，转而继续执行外层循环。</p>
<p>在嵌套循环结构中，如何同时跳出内层循环和外层循环呢？最简单的方法就是借用一个<code>bool</code>类型的变量。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python,shell&quot;</span></span><br><span class="line"><span class="comment">#提前定义一个 bool 变量，并为其赋初值</span></span><br><span class="line">flag = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> add:</span><br><span class="line">    <span class="keyword">if</span> j == <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">      <span class="comment">#在 break 前，修改 flag 的值</span></span><br><span class="line">      flag = <span class="literal">True</span></span><br><span class="line">      <span class="keyword">break</span>   </span><br><span class="line">    <span class="built_in">print</span>(j,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;\n跳出内循环&quot;</span>)</span><br><span class="line">  <span class="comment">#在外层循环体中再次使用 break</span></span><br><span class="line">  <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;跳出外层循环&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过借助一个<code>bool</code>类型的变量<code>flag</code>，在跳出内循环时更改<code>flag</code>的值，同时在外层循环体中，判断<code>flag</code>的值是否发生改动，如有改动，则再次执行<code>break</code>跳出外层循环；反之，则继续执行外层循环。</p>
<p>因此，上面程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">跳出内循环</span><br><span class="line">跳出外层循环</span><br></pre></td></tr></table></figure>
<p>当然，这里仅跳出了 2 层嵌套循环，此方法支持跳出多层嵌套循环。</p>
<h1 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h1><p>和<code>break</code>语句相比，<code>continue</code>语句的作用则没有那么强大，它只会终止执行本次循环中剩下的代码，直接从下一次循环继续执行。</p>
<p><code>continue</code>语句的用法和<code>break</code>语句一样，只要<code>while</code>或<code>for</code>语句中的相应位置加入即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="string">&quot;python,shell&quot;</span></span><br><span class="line"><span class="comment"># 一个简单的for循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> add:</span><br><span class="line">  <span class="keyword">if</span> i == <span class="string">&#x27;,&#x27;</span> :</span><br><span class="line">    <span class="comment"># 忽略本次循环的剩下语句</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">shell</span><br></pre></td></tr></table></figure>
<p>可以看到，当遍历<code>add</code>字符串至逗号（<code>,</code>）时，会进入<code>if</code>判断语句执行<code>print()</code>语句和<code>continue</code>语句。其中，<code>print()</code>语句起到换行的作用，而<code>continue</code>语句会使 Python 解释器忽略执行第 8 行代码，直接从下一次循环开始执行。</p>
<h1 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h1><p><code>zip()</code>函数是 Python 内置函数之一，它可以将多个序列（列表、元组、字典、集合、字符串以及<code>range()</code>区间构成的列表）“压缩”成一个<code>zip</code>对象。所谓“压缩”，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的元组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip(iterable, ...)</span><br></pre></td></tr></table></figure>
<p>其中<code>iterable,...</code>表示多个列表、元组、字典、集合、字符串，甚至还可以为<code>range()</code>区间。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line">my_tuple = (<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>)</span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(my_list,my_tuple)])</span><br><span class="line">my_dic = &#123;<span class="number">31</span>:<span class="number">2</span>,<span class="number">32</span>:<span class="number">4</span>,<span class="number">33</span>:<span class="number">5</span>&#125;</span><br><span class="line">my_set = &#123;<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>&#125;</span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(my_dic)])</span><br><span class="line">my_pychar = <span class="string">&quot;python&quot;</span></span><br><span class="line">my_shechar = <span class="string">&quot;shell&quot;</span></span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(my_pychar,my_shechar)])</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(11, 21), (12, 22), (13, 23)]</span><br><span class="line">[(31,), (32,), (33,)]</span><br><span class="line">[(&#x27;p&#x27;, &#x27;s&#x27;), (&#x27;y&#x27;, &#x27;h&#x27;), (&#x27;t&#x27;, &#x27;e&#x27;), (&#x27;h&#x27;, &#x27;l&#x27;), (&#x27;o&#x27;, &#x27;l&#x27;)]</span><br></pre></td></tr></table></figure>
<p>在使用<code>zip()</code>函数“压缩”多个序列时，它会分别取各序列中第 1 个元素、第 2 个元素、… 第<code>n</code>个元素，各自组成新的元组。需要注意的是，当多个序列中元素个数不一致时，会以最短的序列为准进行压缩。</p>
<p>另外，对于<code>zip()</code>函数返回的<code>zip</code>对象，既可以像上面程序那样，通过遍历提取其存储的元组，也可以向下面程序这样，通过调用<code>list()</code>函数将<code>zip()</code>对象强制转换成列表：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line">my_tuple = (<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">zip</span>(my_list,my_tuple))) <span class="comment"># [(11, 21), (12, 22), (13, 23)]</span></span><br></pre></td></tr></table></figure>
<h1 id="reversed函数"><a href="#reversed函数" class="headerlink" title="reversed函数"></a>reversed函数</h1><p><code>reserved()</code>是 Pyton 内置函数之一，其功能是对于给定的序列（包括列表、元组、字符串以及<code>range(n)</code>区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed(seq)</span><br></pre></td></tr></table></figure>
<p>其中，<code>seq</code>可以是列表，元素，字符串以及<code>range()</code>生成的区间列表。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将列表进行逆序</span></span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])]) <span class="comment"># [5, 4, 3, 2, 1]</span></span><br><span class="line"><span class="comment">#将元组进行逆序</span></span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))]) <span class="comment"># [5, 4, 3, 2, 1]</span></span><br><span class="line"><span class="comment">#将字符串进行逆序</span></span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="string">&quot;abcdefg&quot;</span>)]) <span class="comment"># [&#x27;g&#x27;, &#x27;f&#x27;, &#x27;e&#x27;, &#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">#将 range() 生成的区间列表进行逆序</span></span><br><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">10</span>))]) <span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>
<p>除了使用列表推导式的方式，还可以使用<code>list()</code>函数，将<code>reversed()</code>函数逆序返回的迭代器，直接转换成列表。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将列表进行逆序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))) <span class="comment"># [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p>再次强调，使用<code>reversed()</code>函数进行逆序操作，并不会修改原来序列中元素的顺序：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">#将列表进行逆序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">reversed</span>(a))) <span class="comment"># [5, 4, 3, 2, 1]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a=&quot;</span>,a) <span class="comment"># a=[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h1 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h1><p><code>sorted()</code>作为 Python 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = <span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)  </span><br></pre></td></tr></table></figure>
<p>其中，<code>iterable</code>表示指定的序列，<code>key</code>参数可以自定义排序规则；<code>reverse</code>参数指定以升序（<code>False</code>，默认）还是降序（<code>True</code>）进行排序。<code>sorted()</code>函数会返回一个排好序的列表。</p>
<p>注意，<code>key</code>参数和<code>reverse</code>参数是可选参数，即可以使用，也可以忽略。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对列表进行排序</span></span><br><span class="line">a = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a)) <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">#对元组进行排序</span></span><br><span class="line">a = (<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a)) <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">#字典默认按照key进行排序</span></span><br><span class="line">a = &#123;<span class="number">4</span>:<span class="number">1</span>, <span class="number">5</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">6</span>, <span class="number">1</span>:<span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a.items())) <span class="comment"># [(1, 8), (2, 6), (3, 3), (4, 1), (5, 2)]</span></span><br><span class="line"><span class="comment">#对集合进行排序</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a)) <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">#对字符串进行排序</span></span><br><span class="line">a = <span class="string">&quot;51423&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a)) <span class="comment"># [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>再次强调，使用<code>sorted()</code>函数对序列进行排序，并不会在原序列的基础进行修改，而是会重新生成一个排好序的列表。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对列表进行排序</span></span><br><span class="line">a = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a)) <span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">#再次输出原来的列表 a</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># [5, 3, 4, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>显然，<code>sorted()</code>函数不会改变所传入的序列，而是返回一个新的、排序好的列表。</p>
<p>除此之外，<code>sorted()</code>函数默认对序列中元素进行升序排序，通过手动将其<code>reverse</code>参数值改为<code>True</code>，可实现降序排序。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对列表进行排序</span></span><br><span class="line">a = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a, reverse=<span class="literal">True</span>)) <span class="comment"># [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<p>另外在调用<code>sorted()</code>函数时，还可传入一个<code>key</code>参数，它可以接受一个函数，该函数的功能是指定<code>sorted()</code>函数按照什么标准进行排序。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chars=[<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;shell&#x27;</span>, <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;golang&#x27;</span>]</span><br><span class="line"><span class="comment">#默认排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(chars)) <span class="comment"># [&#x27;golang&#x27;, &#x27;java&#x27;, &#x27;python&#x27;, &#x27;shell&#x27;]</span></span><br><span class="line"><span class="comment">#自定义按照字符串长度排序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(chars,key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x))) <span class="comment"># [&#x27;java&#x27;, &#x27;shell&#x27;, &#x27;python&#x27;, &#x27;golang&#x27;]</span></span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python字符串常用方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/09/python/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"
    >Python字符串常用方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/09/python/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2022-12-09T09:25:21.000Z" itemprop="datePublished">2022-12-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><p>拼接（连接）字符串可以直接将两个字符串紧挨着写在一起：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strname = <span class="string">&quot;str1&quot;</span> <span class="string">&quot;str2&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>strname</code>表示拼接以后的字符串变量名，<code>str1</code>和<code>str2</code>是要拼接的字符串内容。使用这种写法，Python 会自动将两个字符串拼接在一起。</p>
<p>需要注意的是，这种写法只能拼接字符串常量。如果需要使用变量，就得借助<code>+</code>运算符来拼接：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strname = str1 + str2</span><br></pre></td></tr></table></figure>
<p>当然，<code>+</code>运算符也能拼接字符串常量。</p>
<h1 id="字符串和数字的拼接"><a href="#字符串和数字的拼接" class="headerlink" title="字符串和数字的拼接"></a>字符串和数字的拼接</h1><p>Python 不允许直接拼接数字和字符串，所以必须先将数字转换成字符串。可以借助<code>str()</code>和<code>repr()</code>函数将数字转换为字符串：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>(obj)</span><br><span class="line"><span class="built_in">repr</span>(obj)</span><br></pre></td></tr></table></figure>
<p><code>obj</code>表示要转换的对象，它可以是数字、列表、元组、字典等多种类型的数据。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">age = <span class="number">8</span></span><br><span class="line">course = <span class="number">3</span></span><br><span class="line">info = name + <span class="string">&quot;已经&quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot;岁了，已经上&quot;</span> + <span class="built_in">repr</span>(course) + <span class="string">&quot;年级了。&quot;</span></span><br><span class="line"><span class="built_in">print</span>(info) <span class="comment"># 小明已经8岁了，已经上3年级了。</span></span><br></pre></td></tr></table></figure>
<h2 id="str-和-repr-的区别"><a href="#str-和-repr-的区别" class="headerlink" title="str() 和 repr() 的区别"></a>str() 和 repr() 的区别</h2><p><code>str()</code>和<code>repr()</code>函数虽然都可以将数字转换成字符串，但它们之间是有区别的：</p>
<ul>
<li><code>str()</code>用于将数据转换成适合人类阅读的字符串形式。</li>
<li><code>repr()</code>用于将数据转换成适合解释器阅读的字符串形式（Python 表达式的形式），适合在开发和调试阶段使用；如果没有等价的语法，则会发生<code>SyntaxError</code>异常。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;http://www.baidu.com/test/&quot;</span></span><br><span class="line">s_str = <span class="built_in">str</span>(s)</span><br><span class="line">s_repr = <span class="built_in">repr</span>(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s_str)) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span> (s_str) <span class="comment"># http://www.baidu.com/test/</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(s_repr)) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span> (s_repr) <span class="comment"># &#x27;http://www.baidu.com/test/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>本例中，<code>s</code>本身就是一个字符串，但是我们依然使用<code>str()</code>和<code>repr()</code>对它进行了转换。从运行结果可以看出，<code>str()</code>保留了字符串最原始的样子，而<code>repr()</code>使用引号将字符串包围起来，这就是 Python 字符串的表达式形式。</p>
<p>另外，在 Python 交互式编程环境中输入一个表达式（变量、加减乘除、逻辑运算等）时，Python 会自动使用<code>repr()</code>函数处理该表达式。</p>
<h1 id="截取字符串（字符串切片）"><a href="#截取字符串（字符串切片）" class="headerlink" title="截取字符串（字符串切片）"></a>截取字符串（字符串切片）</h1><p>从本质上讲，字符串是由多个字符构成的，字符之间是有顺序的，这个顺序号就称为索引（<code>index</code>）。Python 允许通过索引来操作字符串中的单个或者多个字符，比如获取指定索引处的字符，返回指定字符的索引值等。</p>
<h2 id="获取单个字符"><a href="#获取单个字符" class="headerlink" title="获取单个字符"></a>获取单个字符</h2><p>知道字符串名字以后，在方括号<code>[ ]</code>中使用索引即可访问对应的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strname[index]</span><br></pre></td></tr></table></figure>
<p><code>strname</code>表示字符串名字，<code>index</code>表示索引值。</p>
<p>Python 允许从字符串的两端使用索引：</p>
<ul>
<li>当以字符串的左端（字符串的开头）为起点时，索引是从 0 开始计数的；字符串的第一个字符的索引为 0，第二个字符的索引为 1，第三个字符串的索引为 2 ……</li>
<li>当以字符串的右端（字符串的末尾）为起点时，索引是从 -1 开始计数的；字符串的倒数第一个字符的索引为 -1，倒数第二个字符的索引为 -2，倒数第三个字符的索引为 -3 ……</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://www.test.com/&#x27;</span></span><br><span class="line"><span class="comment">#获取索引为10的字符</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">10</span>]) <span class="comment"># .</span></span><br><span class="line"><span class="comment">#获取索引为 6 的字符</span></span><br><span class="line"><span class="built_in">print</span>(url[-<span class="number">6</span>]) <span class="comment"># t</span></span><br></pre></td></tr></table></figure>
<h1 id="获取多个字符（字符串截去-x2F-字符串切片）"><a href="#获取多个字符（字符串截去-x2F-字符串切片）" class="headerlink" title="获取多个字符（字符串截去&#x2F;字符串切片）"></a>获取多个字符（字符串截去&#x2F;字符串切片）</h1><p>使用<code>[ ]</code>除了可以获取单个字符外，还可以指定一个范围来获取多个字符，也就是一个子串或者片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strname[start : end : step]</span><br></pre></td></tr></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li><code>strname</code>：要截取的字符串；</li>
<li><code>start</code>：表示要截取的第一个字符所在的索引（截取时包含该字符）。如果不指定，默认为 0，也就是从字符串的开头截取；</li>
<li><code>end</code>：表示要截取的最后一个字符所在的索引（截取时不包含该字符）。如果不指定，默认为字符串的长度；</li>
<li><code>step</code>：指的是从<code>start</code>索引处的字符开始，每<code>step</code>个距离获取一个字符，直至<code>end</code>索引出的字符。<code>step</code>默认值为 1，当省略该值时，最后一个冒号也可以省略。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://www.testdem.com/java/&#x27;</span></span><br><span class="line"><span class="comment">#获取索引从7处到22（不包含22）的子串</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">7</span>: <span class="number">22</span>]) <span class="comment"># www.testdem.com</span></span><br><span class="line"><span class="comment">#获取索引从7处到-6的子串</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">7</span>: -<span class="number">6</span>]) <span class="comment"># www.testdem.com</span></span><br><span class="line"><span class="comment">#获取索引从-21到6的子串</span></span><br><span class="line"><span class="built_in">print</span>(url[-<span class="number">21</span>: -<span class="number">6</span>]) <span class="comment"># www.testdem.com</span></span><br><span class="line"><span class="comment">#从索引3开始，每隔4个字符取出一个字符，直到索引22为止</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">3</span>: <span class="number">22</span>: <span class="number">4</span>]) <span class="comment"># pwtdo</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://www.testdem.com/java/&#x27;</span></span><br><span class="line"><span class="comment">#获取从索引5开始，直到末尾的子串</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">7</span>: ]) <span class="comment"># www.testdem.com</span></span><br><span class="line"><span class="comment">#获取从索引-21开始，直到末尾的子串</span></span><br><span class="line"><span class="built_in">print</span>(url[-<span class="number">21</span>: ]) <span class="comment"># www.testdem.com</span></span><br><span class="line"><span class="comment">#从开头截取字符串，直到索引22为止</span></span><br><span class="line"><span class="built_in">print</span>(url[: <span class="number">22</span>]) <span class="comment"># http://www.testdem.com</span></span><br><span class="line"><span class="comment">#每隔3个字符取出一个字符</span></span><br><span class="line"><span class="built_in">print</span>(url[:: <span class="number">3</span>]) <span class="comment"># hp/wed.ma/</span></span><br></pre></td></tr></table></figure>
<h1 id="len-函数"><a href="#len-函数" class="headerlink" title="len()函数"></a>len()函数</h1><p>要想知道一个字符串有多少个字符（获得字符串长度），或者一个字符串占用多少个字节，可以使用<code>len</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len（string）</span><br></pre></td></tr></table></figure>
<p>其中<code>string</code>用于指定要进行长度统计的字符串。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;http://www.test.com&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(a) <span class="comment"># 19</span></span><br></pre></td></tr></table></figure>
<p>在实际开发中，除了常常要获取字符串的长度外，有时还要获取字符串的字节数。</p>
<p>在 Python 中，不同的字符所占的字节数不同，数字、英文字母、小数点、下划线以及空格，各占一个字节，而一个汉字可能占 2~4 个字节，具体占多少个，取决于采用的编码方式。例如，汉字在 GBK&#x2F;GB2312 编码中占用 2 个字节，而在 UTF-8 编码中一般占用 3 个字节。</p>
<p>我们可以通过使用<code>encode()</code>方法，将字符串进行编码后再获取它的字节数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;人生苦短，我用Python&quot;</span></span><br><span class="line"><span class="built_in">len</span>(str1.encode()) <span class="comment"># 27</span></span><br></pre></td></tr></table></figure>
<p>因为汉字加中文标点符号共 7 个，占 21 个字节，而英文字母和英文的标点符号占 6 个字节，一共占用 27 个字节。</p>
<p>同理，如果要获取采用 GBK 编码的字符串的长度，可以执行如下代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;人生苦短，我用Python&quot;</span></span><br><span class="line"><span class="built_in">len</span>(str1.encode(<span class="string">&#x27;gbk&#x27;</span>)) <span class="comment"># 20</span></span><br></pre></td></tr></table></figure>
<h1 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h1><p><code>split()</code>方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(sep,maxsplit)</span><br></pre></td></tr></table></figure>
<p>此方法中各部分参数的含义分别是：</p>
<ul>
<li><code>str</code>：表示要进行分割的字符串；</li>
<li><code>sep</code>：用于指定分隔符，可以包含多个字符。此参数默认为<code>None</code>，表示所有空字符，包括空格、换行符<code>\n</code>、制表符<code>\t</code>等。</li>
<li><code>maxsplit</code>：可选参数，用于指定分割的次数，最后列表中子串的个数最多为<code>maxsplit+1</code>。如果不指定或者指定为 -1，则表示分割次数没有限制。</li>
</ul>
<p>在<code>split</code>方法中，如果不指定<code>sep</code>参数，需要以<code>str.split(maxsplit=xxx)</code>的格式指定<code>maxsplit</code>参数。</p>
<p>同内建函数（如<code>len</code>）的使用方式不同，字符串变量所拥有的方法，只能采用“字符串.方法名()”的方式调用。\</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;小明 &gt;&gt;&gt; xiaoming&quot;</span></span><br><span class="line">list1 = <span class="built_in">str</span>.split() <span class="comment">#采用默认分隔符进行分割</span></span><br><span class="line">list1 <span class="comment"># [&#x27;小明&#x27;, &#x27;&gt;&gt;&gt;&#x27;, &#x27;xiaoming&#x27;]</span></span><br><span class="line">list2 = <span class="built_in">str</span>.split(<span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>) <span class="comment">#采用多个字符进行分割</span></span><br><span class="line">list2 <span class="comment"># [&#x27;小明 &#x27;, &#x27;xiaoming&#x27;]</span></span><br><span class="line">list3 = <span class="built_in">str</span>.split(<span class="string">&#x27;&gt;&#x27;</span>) <span class="comment">#采用 &gt; 字符进行分割</span></span><br><span class="line">list3 <span class="comment"># [&#x27;小明 &#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;xiaoming&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，在未指定<code>sep</code>参数时，<code>split()</code>方法默认采用空字符进行分割，但当字符串中有连续的空格或其他空字符时，都会被视为一个分隔符对字符串进行分割：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;小明   &gt;&gt;&gt;   xiaoming&quot;</span>  <span class="comment">#包含 3 个连续的空格</span></span><br><span class="line">list6 = <span class="built_in">str</span>.split()</span><br><span class="line">list6 <span class="comment"># [&#x27;小明&#x27;, &#x27;&gt;&gt;&gt;&#x27;, &#x27;xiaoming&#x27;]</span></span><br></pre></td></tr></table></figure>
<h1 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h1><p><code>join()</code>方法是<code>split()</code>方法的逆方法，用来将列表（或元组）中包含的多个字符串连接成一个字符串。</p>
<p>使用<code>join()</code>方法合并字符串时，它会将列表（或元组）中多个字符串采用固定的分隔符连接在一起。例如，字符串<code>www.baidu.com</code>就可以看做是通过分隔符“.”将<code>[&#39;www&#39;,&#39;baidu&#39;,&#39;com&#39;]</code>列表合并为一个字符串的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newstr = str.join(iterable)</span><br></pre></td></tr></table></figure>
<p>各参数的含义如下：</p>
<ul>
<li><code>newstr</code>：表示合并后生成的新字符串；</li>
<li><code>str</code>：用于指定合并时的分隔符；</li>
<li><code>iterable</code>：做合并操作的源字符串数据，允许以列表、元组等形式提供。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;www&#x27;</span>,<span class="string">&#x27;baidu&#x27;</span>,<span class="string">&#x27;com&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;.&#x27;</span>.join(<span class="built_in">list</span>) <span class="comment"># &#x27;www.baidu.com&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;usr&#x27;</span>,<span class="string">&#x27;bin&#x27;</span>,<span class="string">&#x27;env&#x27;</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">dir</span>) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;/&#x27;</span>.join(<span class="built_in">dir</span>) <span class="comment"># &#x27;/usr/bin/env&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="count-方法"><a href="#count-方法" class="headerlink" title="count()方法"></a>count()方法</h1><p><code>count</code>方法用于检索指定字符串在另一字符串中出现的次数，如果检索的字符串不存在，则返回 0，否则返回出现的次数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.count(sub[,start[,end]])</span><br></pre></td></tr></table></figure>
<p>各参数的具体含义如下：</p>
<ul>
<li><code>str</code>：表示原字符串；</li>
<li><code>sub</code>：表示要检索的字符串；</li>
<li><code>start</code>：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；</li>
<li><code>end</code>：指定检索的终止位置，如果不指定，则表示一直检索到结尾。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.count(<span class="string">&#x27;.&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">str</span>.count(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>) <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">str</span>.count(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>字符串中各字符对应的检索值，从 0 开始，因此，本例中检索值 1 对应的是第 2 个字符‘.’，从输出结果可以分析出，从指定索引位置开始检索，其中也包含此索引位置。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.count(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>, -<span class="number">3</span>) <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">str</span>.count(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>, -<span class="number">4</span>) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<h1 id="find-方法"><a href="#find-方法" class="headerlink" title="find()方法"></a>find()方法</h1><p><code>find()</code>方法用于检索字符串中是否包含目标字符串，如果包含，则返回第一次出现该字符串的索引；反之，则返回 -1。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.find(sub[,start[,end]])</span><br></pre></td></tr></table></figure>
<p>各参数的含义：</p>
<ul>
<li><code>str</code>：表示原字符串；</li>
<li><code>sub</code>：表示要检索的目标字符串；</li>
<li><code>start</code>：表示开始检索的起始位置。如果不指定，则默认从头开始检索；</li>
<li><code>end</code>：表示结束检索的结束位置。如果不指定，则默认一直检索到结尾。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.find(<span class="string">&#x27;.&#x27;</span>) <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">str</span>.find(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>) <span class="comment"># 9</span></span><br><span class="line"><span class="built_in">str</span>.find(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>, -<span class="number">4</span>) <span class="comment"># -1</span></span><br></pre></td></tr></table></figure>
<p>位于索引<code>（4，-4）</code>之间的字符串为<code>baidu</code>，由于其不包含“.”，因此<code>find()</code>方法的返回值为 -1。</p>
<p>Python 还提供了<code>rfind()</code>方法，<code>rfind()</code>是从字符串右边开始检索。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.rfind(<span class="string">&#x27;.&#x27;</span>) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<h1 id="index-方法"><a href="#index-方法" class="headerlink" title="index()方法"></a>index()方法</h1><p>同<code>find()</code>方法类似，<code>index()</code>方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，<code>index()</code>方法会抛出异常。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.index(sub[,start[,end]])</span><br></pre></td></tr></table></figure>
<p>各参数的含义：</p>
<ul>
<li><code>str</code>：表示原字符串；</li>
<li><code>sub</code>：表示要检索的子字符串；</li>
<li><code>start</code>：表示检索开始的起始位置，如果不指定，默认从头开始检索；</li>
<li><code>end</code>：表示检索的结束位置，如果不指定，默认一直检索到结尾。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.index(<span class="string">&#x27;.&#x27;</span>) <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">str</span>.index(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#49&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">str</span>.index(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">ValueError: substring <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
<p>字符串变量还具有<code>rindex()</code>方法，其作用和<code>index()</code>方法类似，不同之处在于它是从右边开始检索：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.rindex(<span class="string">&#x27;.&#x27;</span>) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串对齐方法（ljust-、rjust-和center-）"><a href="#字符串对齐方法（ljust-、rjust-和center-）" class="headerlink" title="字符串对齐方法（ljust()、rjust()和center()）"></a>字符串对齐方法（ljust()、rjust()和center()）</h1><p><code>str</code>提供了 3 种可用来进行文本对齐的方法，分别是<code>ljust()、rjust()</code>和<code>center()</code>方法。</p>
<h2 id="ljust-方法"><a href="#ljust-方法" class="headerlink" title="ljust()方法"></a>ljust()方法</h2><p><code>ljust()</code>方法的功能是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.ljust(width[, fillchar])</span><br></pre></td></tr></table></figure>
<p>各个参数的含义：</p>
<ul>
<li><code>S</code>：表示要进行填充的字符串；</li>
<li><code>width</code>：表示包括<code>S</code>本身长度在内，字符串要占的总长度；</li>
<li><code>fillchar</code>：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&#x27;http://www.baidu.com/python/&#x27;</span></span><br><span class="line">addr = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.ljust(<span class="number">35</span>)) <span class="comment"># http://www.baidu.com/python/</span></span><br><span class="line"><span class="built_in">print</span>(addr.ljust(<span class="number">35</span>)) <span class="comment"># http://www.baidu.com/</span></span><br></pre></td></tr></table></figure>
<p>注意，该输出结果中除了明显可见的网址字符串外，其后还有空格字符存在，每行一共 35 个字符长度。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&#x27;http://www.baidu.com/python/&#x27;</span></span><br><span class="line">addr = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.ljust(<span class="number">35</span>,<span class="string">&#x27;-&#x27;</span>)) <span class="comment"># http://www.baidu.com/python/------</span></span><br><span class="line"><span class="built_in">print</span>(addr.ljust(<span class="number">35</span>,<span class="string">&#x27;-&#x27;</span>)) <span class="comment"># http://www.baidu.com--------------</span></span><br></pre></td></tr></table></figure>
<h2 id="rjust-方法"><a href="#rjust-方法" class="headerlink" title="rjust()方法"></a>rjust()方法</h2><p><code>rjust()</code>和<code>ljust()</code>方法类似，唯一的不同在于，<code>rjust()</code>方法是向字符串的左侧填充指定字符，从而达到右对齐文本的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.rjust(width[, fillchar])</span><br></pre></td></tr></table></figure>
<p>其中各个参数的含义和<code>ljust()</code>完全相同。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&#x27;http://www.baidu.com/python/&#x27;</span></span><br><span class="line">addr = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.rjust(<span class="number">35</span>)) <span class="comment"># http://www.baidu.com/python/</span></span><br><span class="line"><span class="built_in">print</span>(addr.rjust(<span class="number">35</span>)) <span class="comment"># http://www.baidu.com</span></span><br></pre></td></tr></table></figure>
<p>可以看到，每行字符串都占用 35 个字节的位置，实现了整体的右对齐效果。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&#x27;http://www.baidu.com/python/&#x27;</span></span><br><span class="line">addr = <span class="string">&#x27;http://www.baidu.com/&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.rjust(<span class="number">35</span>,<span class="string">&#x27;-&#x27;</span>)) <span class="comment"># ------http://www.baidu.com/python/</span></span><br><span class="line"><span class="built_in">print</span>(addr.rjust(<span class="number">35</span>,<span class="string">&#x27;-&#x27;</span>)) <span class="comment"># ----------http://www.baidu.com/python/</span></span><br></pre></td></tr></table></figure>
<h1 id="center-方法"><a href="#center-方法" class="headerlink" title="center()方法"></a>center()方法</h1><p><code>center()</code>字符串方法与<code>ljust()</code>和<code>rjust()</code>的用法类似，但它让文本居中，而不是左对齐或右对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.center(width[, fillchar])</span><br></pre></td></tr></table></figure>
<p>其中各个参数的含义和<code>ljust()、rjust()</code>方法相同。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&#x27;http://www.baidu.com/python/&#x27;</span></span><br><span class="line">addr = <span class="string">&#x27;http://www.baidu.com/&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.center(<span class="number">35</span>,)) <span class="comment"># http://www.baidu.com/python/</span></span><br><span class="line"><span class="built_in">print</span>(addr.center(<span class="number">35</span>,)) <span class="comment"># http://www.baidu.com</span></span><br><span class="line">```   </span><br><span class="line">```py</span><br><span class="line">S = <span class="string">&#x27;http://www.baidu.com/python/&#x27;</span></span><br><span class="line">addr = <span class="string">&#x27;http://www.baidu.com/&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(S.center(<span class="number">35</span>,<span class="string">&#x27;-&#x27;</span>)) <span class="comment"># ---http://www.baidu.com/python/---</span></span><br><span class="line"><span class="built_in">print</span>(addr.center(<span class="number">35</span>,<span class="string">&#x27;-&#x27;</span>)) <span class="comment"># --------http://www.baidu.com--------</span></span><br></pre></td></tr></table></figure>
<h1 id="startswith-和endswith-方法"><a href="#startswith-和endswith-方法" class="headerlink" title="startswith()和endswith()方法"></a>startswith()和endswith()方法</h1><h2 id="startswith-方法"><a href="#startswith-方法" class="headerlink" title="startswith()方法"></a>startswith()方法</h2><p><code>startswith()</code>方法用于检索字符串是否以指定字符串开头，如果是返回<code>True</code>；反之返回<code>False</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.startswith(sub[,start[,end]])</span><br></pre></td></tr></table></figure>
<p>各个参数的含义：</p>
<ul>
<li><code>str</code>：表示原字符串；</li>
<li><code>sub</code>：要检索的子串；</li>
<li><code>start</code>：指定检索开始的起始位置索引，如果不指定，则默认从头开始检索；</li>
<li><code>end</code>：指定检索的结束位置索引，如果不指定，则默认一直检索在结束。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.startswith(<span class="string">&quot;w&quot;</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">str</span>.startswith(<span class="string">&quot;http&quot;</span>) <span class="comment"># False</span></span><br><span class="line"><span class="built_in">str</span>.startswith(<span class="string">&quot;w&quot;</span>, <span class="number">2</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h2 id="endswith-方法"><a href="#endswith-方法" class="headerlink" title="endswith()方法"></a>endswith()方法</h2><p><code>endswith()</code>方法用于检索字符串是否以指定字符串结尾，如果是则返回<code>True</code>；反之则返回<code>False</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.endswith(sub[,start[,end]])</span><br></pre></td></tr></table></figure>
<p>各参数的含义：</p>
<ul>
<li><code>str</code>：表示原字符串；</li>
<li><code>sub</code>：表示要检索的字符串；</li>
<li><code>start</code>：指定检索开始时的起始位置索引（字符串第一个字符对应的索引值为 0），如果不指定，默认从头开始检索。</li>
<li><code>end</code>：指定检索的结束位置索引，如果不指定，默认一直检索到结束。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.endswith(<span class="string">&quot;com&quot;</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h1><p>字符串变量提供了 3 种对字符串中的字母进行大小写转换的方法，分别是<code>title()、lower()</code>和<code>upper()</code>。</p>
<h2 id="title-方法"><a href="#title-方法" class="headerlink" title="title()方法"></a>title()方法</h2><p><code>title()</code>方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.title()</span><br></pre></td></tr></table></figure>
<p>其中，<code>str</code>表示要进行转换的字符串。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;www.baidu.com&quot;</span></span><br><span class="line"><span class="built_in">str</span>.title() <span class="comment"># &#x27;Www.Baidu.Co,&#x27;</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;I LIKE C&quot;</span></span><br><span class="line"><span class="built_in">str</span>.title() <span class="comment"># &#x27;I Like C&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="lower-方法"><a href="#lower-方法" class="headerlink" title="lower()方法"></a>lower()方法</h2><p><code>lower()</code>方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.lower()</span><br></pre></td></tr></table></figure>
<p>其中，<code>str</code>表示要进行转换的字符串。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;I LIKE C&quot;</span></span><br><span class="line"><span class="built_in">str</span>.lower() <span class="comment"># &#x27;i like c&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="upper-方法"><a href="#upper-方法" class="headerlink" title="upper()方法"></a>upper()方法</h2><p><code>upper()</code>的功能和<code>lower()</code>方法恰好相反，它用于将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.upper()</span><br></pre></td></tr></table></figure>
<p>其中，<code>str</code>表示要进行转换的字符串。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;i like C&quot;</span></span><br><span class="line"><span class="built_in">str</span>.upper() <span class="comment"># &#x27;I LIKE C&#x27;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，以上 3 个方法都仅限于将转换后的新字符串返回，而不会修改原字符串。</p>
<h1 id="去除字符串中空格"><a href="#去除字符串中空格" class="headerlink" title="去除字符串中空格"></a>去除字符串中空格</h1><p>在一些场景中，字符串前后不允许出现空格和特殊字符，此时就需要去除字符串中的空格和特殊字符。这里的特殊字符，指的是制表符（<code>\t</code>）、回车符（<code>\r</code>）、换行符（<code>\n</code>）等。</p>
<p>字符串变量提供了 3 种方法来删除字符串中多余的空格和特殊字符：</p>
<ul>
<li><code>strip()</code>：删除字符串前后（左右两侧）的空格或特殊字符。</li>
<li><code>lstrip()</code>：删除字符串前面（左边）的空格或特殊字符。</li>
<li><code>rstrip()</code>：删除字符串后面（右边）的空格或特殊字符。</li>
</ul>
<p>注意，Python 的<code>str</code>是不可变的（不可变的意思是指，字符串一旦形成，它所包含的字符序列就不能发生任何改变），因此这三个方法只是返回字符串前面或后面空白被删除之后的副本，并不会改变字符串本身。</p>
<h2 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip()方法"></a>strip()方法</h2><p><code>strip()</code>方法用于删除字符串左右两个的空格和特殊字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.strip([chars])</span><br></pre></td></tr></table></figure>
<p>其中，<code>str</code>表示原字符串，<code>[chars]</code>用来指定要删除的字符，可以同时指定多个，如果不手动指定，则默认会删除空格以及制表符、回车符、换行符等特殊字符。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;  www.baidu.com \t\n\r&quot;</span></span><br><span class="line"><span class="built_in">str</span>.strip() <span class="comment"># &#x27;www.baidu.com&#x27;</span></span><br><span class="line"><span class="built_in">str</span>.strip(<span class="string">&quot; ,\r&quot;</span>) <span class="comment"># &#x27;www.baidu.com \t\n&#x27;</span></span><br><span class="line"><span class="built_in">str</span> <span class="comment"># &#x27;  www.baidu.com \t\n\r&#x27;</span></span><br></pre></td></tr></table></figure>
<p>通过<code>strip()</code>确实能够删除字符串左右两侧的空格和特殊字符，但并没有真正改变字符串本身。</p>
<h2 id="lstrip-方法"><a href="#lstrip-方法" class="headerlink" title="lstrip()方法"></a>lstrip()方法</h2><p><code>lstrip()</code>方法用于去掉字符串左侧的空格和特殊字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.lstrip([chars])</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;  www.baidu.com \t\n\r&quot;</span></span><br><span class="line"><span class="built_in">str</span>.lstrip() <span class="comment"># &#x27;www.baidu.com \t\n\r&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="rstrip-方法"><a href="#rstrip-方法" class="headerlink" title="rstrip()方法"></a>rstrip()方法</h2><p><code>rstrip()</code>方法用于删除字符串右侧的空格和特殊字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.rstrip([chars])</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;  www.baidu.com \t\n\r&quot;</span></span><br><span class="line"><span class="built_in">str</span>.rstrip() <span class="comment"># &#x27;  www.baidu.com&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="format-格式化输出方法"><a href="#format-格式化输出方法" class="headerlink" title="format()格式化输出方法"></a>format()格式化输出方法</h1><p>使用<code>%</code>操作符对各种类型的数据进行格式化输出，这是早期 Python 提供的方法。自 Python 2.6 版本开始，字符串类型提供了<code>format()</code>方法对字符串进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.format(args)</span><br></pre></td></tr></table></figure>
<p><code>str</code>用于指定字符串的显示样式；<code>args</code>用于指定要进行格式转换的项，如果有多项，之间有逗号进行分割。</p>
<p>在创建显示样式模板时，需要使用<code>&#123;&#125;</code>和<code>:</code>来指定占位符，其完整的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; [index][ : [ [fill] align] [sign] [#] [width] [.precision] [type] ] &#125;</span><br></pre></td></tr></table></figure>
<p>注意，格式中用 [] 括起来的参数都是可选参数，即可以使用，也可以不使用。各个参数的含义如下：</p>
<ul>
<li><code>index</code>：指定：后边设置的格式要作用到<code>args</code>中第几个数据，数据的索引值从 0 开始。如果省略此选项，则会根据<code>args</code>中数据的先后顺序自动分配。</li>
<li><code>fill</code>：指定空白处填充的字符。注意，当填充字符为逗号(,)且作用于整数或浮点数时，该整数（或浮点数）会以逗号分隔的形式输出，例如（1000000会输出 1,000,000）。</li>
<li><code>align</code>：指定数据的对齐方式。</li>
<li><code>sign</code>：指定有无符号数。</li>
<li><code>width</code>：指定输出数据时所占的宽度。</li>
<li><code>.precision</code>：指定保留的小数位数。</li>
<li><code>type</code>：指定输出数据的具体类型。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">align</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;</td>
<td align="center">数据左对齐。</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">数据右对齐。</td>
</tr>
<tr>
<td align="center">&#x3D;</td>
<td align="center">数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对数字类型有效。</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">数据居中，此选项需和 width 参数一起使用。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">sign参数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">正数前加正号，负数前加负号。</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">正数前不加正号，负数前加负号。</td>
</tr>
<tr>
<td align="center">空格</td>
<td align="center">正数前加空格，负数前加负号。</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">对于二进制数、八进制数和十六进制数，使用此参数，各进制数前会分别显示 0b、0o、0x前缀；反之则不显示前缀。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">type类型值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s</td>
<td align="center">对字符串类型格式化。</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">十进制整数。</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">将十进制整数自动转换成对应的 Unicode 字符。</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">或者 E 	转换成科学计数法后，再格式化输出。</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">或 G	自动在 e 和 f（或 E 和 F）中切换。</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">将十进制数自动转换成二进制表示，再格式化输出。</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">将十进制数自动转换成八进制表示，再格式化输出。</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">或者 X	将十进制数自动转换成十六进制表示，再格式化输出。</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">或者 F	转换为浮点数（默认小数点后保留 6 位），再格式化输出。</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">显示百分比（默认显示小数点后 6 位）。</td>
</tr>
</tbody></table>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;网站名称：&#123;:&gt;9s&#125;\t网址：&#123;:s&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.<span class="built_in">format</span>(<span class="string">&quot;百度&quot;</span>,<span class="string">&quot;www.baidu.com&quot;</span>)) <span class="comment"># 网站名称：   百度 网址：www.baidu.com</span></span><br></pre></td></tr></table></figure>
<p>在实际开发中，数值类型有多种显示需求，比如货币形式、百分比形式等，使用<code>format()</code>方法可以将数值格式化为不同的形式。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以货币形式显示</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;货币形式：&#123;:,d&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1000000</span>)) <span class="comment"># 货币形式：1,000,000</span></span><br><span class="line"><span class="comment">#科学计数法表示</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;科学计数法：&#123;:E&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">1200.12</span>)) <span class="comment"># 科学计数法：1.200120E+03</span></span><br><span class="line"><span class="comment">#以十六进制表示</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;100的十六进制：&#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">100</span>)) <span class="comment"># 100的十六进制：0x64</span></span><br><span class="line"><span class="comment">#输出百分比形式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0.01的百分比表示：&#123;:.0%&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">0.01</span>)) <span class="comment"># 0.01的百分比表示：1%</span></span><br></pre></td></tr></table></figure>
<h1 id="encode-和decode-方法"><a href="#encode-和decode-方法" class="headerlink" title="encode()和decode()方法"></a>encode()和decode()方法</h1><p>最早的字符串编码是 ASCII 编码，它仅仅对 10 个数字、26 个大小写英文字母以及一些特殊字符进行了编码。ASCII 码做多只能表示 256 个符号，每个字符只需要占用 1 个字节。</p>
<p>随着信息技术的发展，各国的文字都需要进行编码，于是相继出现了 GBK、GB2312、UTF-8 编码等，其中 GBK 和 GB2312 是我国制定的中文编码标准，规定英文字符母占用 1 个字节，中文字符占用 2 个字节；而 UTF-8 是国际通过的编码格式，它包含了全世界所有国家需要用到的字符，其规定英文字符占用 1 个字节，中文字符占用 3 个字节。</p>
<p>Python 3.x 默认采用 UTF-8 编码格式，有效地解决了中文乱码的问题。</p>
<p>在 Python 中，有 2 种常用的字符串类型，分别为<code>str</code>和<code>bytes</code>类型，其中<code>str</code>用来表示 Unicode 字符，<code>bytes</code>用来表示二进制数据。<code>str</code>类型和<code>bytes</code>类型之间就需要使用<code>encode()</code>和<code>decode()</code>方法进行转换。</p>
<h2 id="encode-方法"><a href="#encode-方法" class="headerlink" title="encode()方法"></a>encode()方法</h2><p><code>encode()</code>方法为字符串类型（<code>str</code>）提供的方法，用于将<code>str</code>类型转换成<code>bytes</code>类型，这个过程也称为“编码”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.encode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;])</span><br></pre></td></tr></table></figure>
<p>注意，格式中用<code>[]</code>括起来的参数为可选参数，也就是说，在使用此方法时，可以使用<code>[]</code>中的参数，也可以不使用。</p>
<p><code>encode()</code>参数及含义：</p>
<ul>
<li><code>str</code>表示要进行转换的字符串。</li>
<li><code>encoding = &quot;utf-8&quot;</code>指定进行编码时采用的字符编码，该选项默认采用 utf-8 编码。例如，如果想使用简体中文，可以设置 gb2312。<br>当方法中只使用这一个参数时，可以省略前边的<code>encoding=</code>，直接写编码格式，例如<code>str.encode(&quot;UTF-8&quot;)</code>。</li>
<li><code>errors = &quot;strict&quot;</code>指定错误处理方式，其可选择值可以是：</li>
<li><code>strict</code>：遇到非法字符就抛出异常。</li>
<li><code>ignore</code>：忽略非法字符。</li>
<li><code>replace</code>：用“？”替换非法字符。</li>
<li><code>xmlcharrefreplace</code>：使用<code>xml</code>的字符引用。该参数的默认值为<code>strict</code>。</li>
</ul>
<p>注意，使用<code>encode()</code>方法对原字符串进行编码，不会直接修改原字符串，如果想修改原字符串，需要重新赋值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;测试&quot;</span></span><br><span class="line"><span class="built_in">str</span>.encode()</span><br><span class="line"><span class="string">b&#x27;C\xe8\xaf\xad\xe8&#x27;</span></span><br></pre></td></tr></table></figure>
<p>此方式默认采用 UTF-8 编码，也可以手动指定其它编码格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;测试&quot;</span></span><br><span class="line"><span class="built_in">str</span>.encode(<span class="string">&#x27;GBK&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;C\xd3\xef\xd1\xd4&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="decode-方法"><a href="#decode-方法" class="headerlink" title="decode()方法"></a>decode()方法</h2><p>和<code>encode()</code>方法正好相反，<code>decode()</code>方法用于将<code>bytes</code>类型的二进制数据转换为<code>str</code>类型，这个过程也称为“解码”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes.decode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;])</span><br></pre></td></tr></table></figure>
<p><code>decode()</code>参数及含义：</p>
<ul>
<li><code>bytes</code>表示要进行转换的二进制数据。</li>
<li><code>encoding=&quot;utf-8&quot;</code>指定解码时采用的字符编码，默认采用 utf-8 格式。当方法中只使用这一个参数时，可以省略<code>encoding=</code>，直接写编码方式即可。注意，对<code>bytes</code>类型数据解码，要选择和当初编码时一样的格式。</li>
<li><code>errors = &quot;strict&quot;</code>指定错误处理方式，其可选择值可以是：</li>
<li><code>strict</code>：遇到非法字符就抛出异常。</li>
<li><code>ignore</code>：忽略非法字符。</li>
<li><code>replace</code>：用<code>?</code>替换非法字符。</li>
<li><code>xmlcharrefreplace</code>：使用<code>xml</code>的字符引用。该参数的默认值为<code>strict</code>。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="built_in">bytes</span>=<span class="built_in">str</span>.encode()</span><br><span class="line"><span class="built_in">bytes</span>.decode()</span><br><span class="line"><span class="string">&#x27;小明&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意，如果编码时采用的不是默认的 UTF-8 编码，则解码时要选择和编码时一样的格式，否则会抛出异常：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="built_in">bytes</span> = <span class="built_in">str</span>.encode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line"><span class="built_in">bytes</span>.decode()  <span class="comment">#默认使用 UTF-8 编码，会抛出以下异常</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;pyshell#10&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">bytes</span>.decode()</span><br><span class="line">UnicodeDecodeError: <span class="string">&#x27;utf-8&#x27;</span> codec can<span class="string">&#x27;t decode byte 0xd3 in position 1: invalid continuation byte</span></span><br><span class="line"><span class="string">bytes.decode(&quot;GBK&quot;)</span></span><br><span class="line"><span class="string">&#x27;</span>小明<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="dir-和help-帮助函数"><a href="#dir-和help-帮助函数" class="headerlink" title="dir()和help()帮助函数"></a>dir()和help()帮助函数</h1><p><code>dir()</code>函数用来列出某个类或者某个模块中的全部内容，包括变量、方法、函数和类等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(obj)</span><br></pre></td></tr></table></figure>
<p><code>obj</code>表示要查看的对象。<code>obj</code>可以不写，此时<code>dir()</code>会列出当前范围内的变量、方法和定义的类型。</p>
<p><code>help()</code>函数用来查看某个函数或者模块的帮助文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(obj)</span><br></pre></td></tr></table></figure>
<p><code>obj</code>表示要查看的对象。<code>obj</code>可以不写，此时<code>help()</code>会进入帮助子程序。</p>
<p>掌握了以上两个函数，我们就可以自行查阅 Python 中所有方法、函数、变量、类的用法和功能了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>(<span class="built_in">str</span>)</span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isascii&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>在 Python 标准库中，以<code>__</code>开头和结尾的方法都是私有的，不能在类的外部调用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>(<span class="built_in">str</span>.lower)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">lower(self, /)</span><br><span class="line">    Return a copy of the string converted to lowercase.</span><br></pre></td></tr></table></figure>
<p>注意，使用<code>help()</code>查看某个函数的用法时，函数名后边不能带括号，例如将上面的命令写作<code>help(str.lower())</code>就是错误的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python集合"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/07/python/Python%E9%9B%86%E5%90%88/"
    >Python集合</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/07/python/Python%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2022-12-07T08:41:21.000Z" itemprop="datePublished">2022-12-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Python 中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。</p>
<p>从形式上看，和字典类似，Python 集合会将所有元素放在一对大括号<code>&#123;&#125;</code>中，相邻元素之间用<code>,</code>分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;element1,element2,...,elementn&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>elementn</code>表示集合中的元素，个数没有限制。</p>
<p>从内容上看，同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出<code>TypeError</code>错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;&#123;&#x27;a&#x27;:1&#125;&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    &#123;&#123;&#x27;a&#x27;:1&#125;&#125;</span><br><span class="line">TypeError: unhashable type: &#x27;dict&#x27;</span><br><span class="line">&gt;&gt;&gt; &#123;[1,2,3]&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    &#123;[1,2,3]&#125;</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br><span class="line">&gt;&gt;&gt; &#123;&#123;1,2,3&#125;&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#10&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    &#123;&#123;1,2,3&#125;&#125;</span><br><span class="line">TypeError: unhashable type: &#x27;set&#x27;</span><br></pre></td></tr></table></figure>
<p>并且需要注意的是，数据必须保证是唯一的，因为集合对于每种数据元素，只会保留一份。</p>
<p>由于 Python 中的集合是无序的，所以每次输出时元素的排序顺序可能都不相同。</p>
<p>Python 中有两种集合类型，一种是<code>set</code>类型的集合，另一种是<code>frozenset</code>类型的集合，它们唯一的区别是，<code>set</code>类型集合可以做添加、删除元素的操作，而<code>forzenset</code>类型集合不行。</p>
<h1 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h1><p>Python 提供了 2 种创建集合的方法，分别是使用<code>&#123;&#125;</code>创建和使用<code>set()</code>函数将列表、元组等类型数据转换为集合。</p>
<h2 id="使用-创建"><a href="#使用-创建" class="headerlink" title="使用 {} 创建"></a>使用 {} 创建</h2><p>创建<code>set</code>集合可以像列表、元素和字典一样，直接将集合赋值给变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname = &#123;element1,element2,...,elementn&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>setname</code>表示集合的名称。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;1, &#x27;c&#x27;, (1, 2, 3)&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="set-函数创建集合"><a href="#set-函数创建集合" class="headerlink" title="set()函数创建集合"></a>set()函数创建集合</h2><p><code>set()</code>函数为内置函数，其功能是将字符串、列表、元组、<code>range</code>对象等可迭代对象转换成集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname = set(iteration)</span><br></pre></td></tr></table></figure>
<p>其中，<code>iteration</code>就表示字符串、列表、元组、<code>range</code>对象等数据。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set1 = <span class="built_in">set</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">set3 = <span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;set1:&quot;</span>, set1) <span class="comment"># set1: &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;set2:&quot;</span>, set2) <span class="comment"># set2: &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;set3:&quot;</span>, set3) <span class="comment"># set3: &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果要创建空集合，只能使用<code>set()</code>函数实现。因为直接使用一对<code>&#123;&#125;</code>，Python 解释器会将其视为一个空字典。</p>
</blockquote>
<h2 id="访问集合元素"><a href="#访问集合元素" class="headerlink" title="访问集合元素"></a>访问集合元素</h2><p>由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> a:</span><br><span class="line">  <span class="built_in">print</span>(ele,end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 c (1, 2, 3)</span><br></pre></td></tr></table></figure>
<h2 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h2><p>删除集合类型可以使用<code>del()</code>语句：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">del</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, &#x27;c&#x27;, (1, 2, 3)&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\1.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    print(a)</span><br><span class="line">NameError: name &#x27;a&#x27; is not defined</span><br></pre></td></tr></table></figure>
<h1 id="向集合中添加元素"><a href="#向集合中添加元素" class="headerlink" title="向集合中添加元素"></a>向集合中添加元素</h1><p><code>set</code>集合中添加元素，可以使用<code>set</code>类型提供的<code>add()</code>方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname.add(element)</span><br></pre></td></tr></table></figure>
<p>其中，<code>setname</code>表示要添加元素的集合，<code>element</code>表示要添加的元素内容。</p>
<p>需要注意的是，使用<code>add()</code>方法添加的元素，只能是数字、字符串、元组或者布尔类型（<code>True</code>和<code>False</code>）值，不能添加列表、字典、集合这类可变的数据，否则 Python 解释器会报<code>TypeError</code>错误。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a.add((<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.add([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;(1, 2), 1, 2, 3&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\1.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    a.add([1,2])</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="从集合中删除元素"><a href="#从集合中删除元素" class="headerlink" title="从集合中删除元素"></a>从集合中删除元素</h1><p>删除现有<code>set</code>集合中的指定元素，可以使用<code>remove()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setname.remove(element)</span><br></pre></td></tr></table></figure>
<p>使用此方法删除集合中元素，需要注意的是，如果被删除元素本就不包含在集合中，则此方法会抛出<code>KeyError</code>错误：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;2, 3&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\1.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    a.remove(1)</span><br><span class="line">KeyError: 1</span><br></pre></td></tr></table></figure>
<p>上面程序中，由于集合中的元素 1 已被删除，因此当再次尝试使用<code>remove()</code>方法删除时，会引发<code>KeyError</code>错误。</p>
<p>如果我们不想在删除失败时令解释器提示<code>KeyError</code>错误，还可以使用<code>discard()</code>方法，此方法和<code>remove()</code>方法的用法完全相同，唯一的区别就是，当删除集合中元素失败时，此方法不会抛出任何错误。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a.remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a.discard(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;2, 3&#125;</span><br><span class="line">&#123;2, 3&#125;</span><br></pre></td></tr></table></figure>
<h1 id="集合做交集、并集、差集运算"><a href="#集合做交集、并集、差集运算" class="headerlink" title="集合做交集、并集、差集运算"></a>集合做交集、并集、差集运算</h1><p>有 2 个集合，分别为<code>set1=&#123;1, 2, 3&#125;</code>和<code>set2=&#123;3, 4, 5&#125;</code>。以这两个集合为例，分别做不同运算的结果如表。</p>
<table>
<thead>
<tr>
<th align="center">运算操作</th>
<th align="center">Python运算符</th>
<th align="center">含义</th>
<th align="center">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="center">交集</td>
<td align="center">&amp;</td>
<td align="center">取两集合公共的元素</td>
<td align="center">set1 &amp; set2 <br> {3}</td>
</tr>
<tr>
<td align="center">并集</td>
<td align="center">&#96;</td>
<td align="center">&#96;</td>
<td align="center">取两集合全部的元素</td>
</tr>
<tr>
<td align="center">差集</td>
<td align="center">-</td>
<td align="center">取一个集合中另一集合没有的元素</td>
<td align="center">set1 - set2 <br> {1,2} <br> set2 - set1 <br> {4,5}</td>
</tr>
<tr>
<td align="center">对称差集</td>
<td align="center">^</td>
<td align="center">取集合 A 和 B 中不属于 A&amp;B 的元素</td>
<td align="center">set1 ^ set2 <br> {1,2,4,5}</td>
</tr>
</tbody></table>
<h1 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h1><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">语法格式</th>
<th align="center">功能</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">add()</td>
<td align="center">set1.add()</td>
<td align="center">向 set1 集合中添加数字、字符串、元组或者布尔类型</td>
<td align="center">set1 &#x3D; {1,2,3} <br> set1.add((1,2)) <br> set1 <br> {(1, 2), 1, 2, 3}</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">set1.clear()</td>
<td align="center">清空 set1 集合中所有元素</td>
<td align="center">set1 &#x3D; {1,2,3} <br> set1.clear() <br> set1 <br> set() <br> set()才表示空集合，{}表示的是空字典</td>
</tr>
<tr>
<td align="center">copy()</td>
<td align="center">set2 &#x3D; set1.copy()</td>
<td align="center">拷贝 set1 集合给 set2</td>
<td align="center">set1 &#x3D; {1,2,3} <br> set2 &#x3D; set1.copy() <br> set1.add(4) <br> set1 {1, 2, 3, 4} <br> set1 {1, 2, 3}</td>
</tr>
<tr>
<td align="center">difference()</td>
<td align="center">set3 &#x3D; set1.difference(set2)</td>
<td align="center">将 set1 中有而 set2 没有的元素给 set3</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {3,4} set3 &#x3D; set1.difference(set2) set3 {1, 2}</td>
</tr>
<tr>
<td align="center">difference_update()</td>
<td align="center">set1.difference_update(set2)</td>
<td align="center">从 set1 中删除与 set2 相同的元素</td>
<td align="center">set1 &#x3D; {1,2,3} <br> set2 &#x3D; {3,4} <br> set1.difference_update(set2) <br> set1 {1, 2}</td>
</tr>
<tr>
<td align="center">discard()</td>
<td align="center">set1.discard(elem)</td>
<td align="center">删除 set1 中的 elem 元素</td>
<td align="center">set1 &#x3D; {1,2,3} <br> set1.discard(2) <br> set1 {1, 3} <br> set1.discard(4) {1, 3}</td>
</tr>
<tr>
<td align="center">intersection()</td>
<td align="center">set3 &#x3D; set1.intersection(set2)</td>
<td align="center">取 set1 和 set2 的交集给 set3</td>
<td align="center">set1 &#x3D; {1,2,3} <br> set2 &#x3D; {3,4} <br> set3 &#x3D; set1.intersection(set2) <br> set3 {3}</td>
</tr>
<tr>
<td align="center">intersection_update()</td>
<td align="center">set1.intersection_update(set2)</td>
<td align="center">取 set1和 set2 的交集，并更新给 set1</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {3,4} <br> set1.intersection_update(set2) <br> set1 {3}</td>
</tr>
<tr>
<td align="center">isdisjoint()</td>
<td align="center">set1.isdisjoint(set2)</td>
<td align="center">判断 set1 和 set2 是否没有交集，有交集返回 False；没有交集返回 True</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {3,4} <br> set1.isdisjoint(set2) <br> False</td>
</tr>
<tr>
<td align="center">issubset()</td>
<td align="center">set1.issubset(set2)</td>
<td align="center">判断 set1 是否是 set2 的子集</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {1,2} <br> set1.issubset(set2) <br> False</td>
</tr>
<tr>
<td align="center">issuperset()</td>
<td align="center">set1.issuperset(set2)</td>
<td align="center">判断 set2 是否是 set1 的子集</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {1,2} <br> set1.issuperset(set2) <br> True</td>
</tr>
<tr>
<td align="center">pop()</td>
<td align="center">a &#x3D; set1.pop()</td>
<td align="center">取 set1 中一个元素，并赋值给 a</td>
<td align="center">set1 &#x3D; {1,2,3} <br> a &#x3D; set1.pop() <br> set1 {2,3} a 1</td>
</tr>
<tr>
<td align="center">remove()</td>
<td align="center">set1.remove(elem)</td>
<td align="center">移除 set1 中的 elem 元素</td>
<td align="center">set1 &#x3D; {1,2,3} set1.remove(2) <br> set1 {1, 3} <br> set1.remove(4)</td>
</tr>
<tr>
<td align="center">symmetric_difference()</td>
<td align="center">set3 &#x3D; set1.symmetric_difference(set2)</td>
<td align="center">取 set1 和 set2 中互不相同的元素，给 set3</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {3,4} <br> set3 &#x3D; set1.symmetric_difference(set2) <br> set3 {1, 2, 4}</td>
</tr>
<tr>
<td align="center">symmetric_difference_update()</td>
<td align="center">set1.symmetric_difference_update(set2)</td>
<td align="center">取 set1 和 set2 中互不相同的元素，并更新给 set1</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {3,4} <br> set1.symmetric_difference_update(set2) <br> set1 {1, 2, 4}</td>
</tr>
<tr>
<td align="center">union()</td>
<td align="center">set3 &#x3D; set1.union(set2)</td>
<td align="center">取 set1 和 set2 的并集，赋给 set3</td>
<td align="center">set1 &#x3D; {1,2,3} set2 &#x3D; {3,4} <br> set3&#x3D;set1.union(set2) <br> set3 {1, 2, 3, 4}</td>
</tr>
<tr>
<td align="center">update()</td>
<td align="center">set1.update(elem)</td>
<td align="center">添加列表或集合中的元素到 set1</td>
<td align="center">set1 &#x3D; {1,2,3} <br> set1.update([3,4]) <br> set1 {1,2,3,4}</td>
</tr>
</tbody></table>
<h1 id="frozenset集合"><a href="#frozenset集合" class="headerlink" title="frozenset集合"></a>frozenset集合</h1><p><code>set</code>集合是可变序列，程序可以改变序列中的元素；<code>frozenset</code>集合是不可变序列，程序不能改变序列中的元素。<code>set</code>集合中所有能改变集合本身的方法，比如<code>remove()、discard()、add()</code>等，<code>frozenset</code>都不支持；<code>set</code>集合中不改变集合本身的方法，<code>fronzenset</code>都支持。</p>
<p>我们可以在交互式编程环境中输入<code>dir(frozenset)</code>来查看<code>frozenset</code>集合支持的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(frozenset)</span><br><span class="line">[&#x27;copy&#x27;, &#x27;difference&#x27;, &#x27;intersection&#x27;, &#x27;isdisjoint&#x27;, &#x27;issubset&#x27;, &#x27;issuperset&#x27;, &#x27;symmetric_difference&#x27;, &#x27;union&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>frozenset</code>集合的这些方法和<code>set</code>集合中同名方法的功能是一样的。</p>
<p>两种情况下可以使用<code>fronzenset</code>：</p>
<ul>
<li>当集合的元素不需要改变时，我们可以使用<code>fronzenset</code>替代<code>set</code>，这样更加安全。</li>
<li>有时候程序要求必须是不可变对象，这个时候也要使用<code>fronzenset</code>替代<code>set</code>。比如，字典（<code>dict</code>）的键（<code>key</code>）就要求是不可变对象。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>&#125;</span><br><span class="line">fs = <span class="built_in">frozenset</span>([<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Shell&#x27;</span>])</span><br><span class="line">s_sub = &#123;<span class="string">&#x27;PHP&#x27;</span>, <span class="string">&#x27;C#&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#向set集合中添加frozenset</span></span><br><span class="line">s.add(fs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s =&#x27;</span>, s)</span><br><span class="line"><span class="comment">#向为set集合添加子set集合</span></span><br><span class="line">s.add(s_sub)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s =&#x27;</span>, s)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;&#x27;Python&#x27;, frozenset(&#123;&#x27;Java&#x27;, &#x27;Shell&#x27;&#125;), &#x27;C&#x27;, &#x27;C++&#x27;&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;C:\Users\mozhiyan\Desktop\demo.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">        s.add(s_sub)</span><br><span class="line">TypeError: unhashable type: &#x27;set&#x27;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>set</code>集合本身的元素必须是不可变的，所以<code>set</code>的元素不能是<code>set</code>，只能是<code>frozenset</code>。第 5 行代码向<code>set</code>中添加<code>frozenset</code>是没问题的，因为<code>frozenset</code>是不可变的；但是，第 8 行代码中尝试向<code>set</code>中添加子<code>set</code>，这是不允许的，因为<code>set</code>是可变的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/类特殊成员"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/06/python/%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/"
    >Python类特殊成员</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/06/python/%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/" class="article-date">
  <time datetime="2022-12-06T03:22:50.000Z" itemprop="datePublished">2022-12-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="new"><a href="#new" class="headerlink" title="new()"></a><strong>new</strong>()</h1><p><code>__new__()</code> 是一种负责创建类实例的静态方法，它无需使用<code>staticmethod</code>装饰器修饰，且该方法会优先<code>__init__()</code>初始化方法被调用。 </p>
<p>一般情况下，覆写<code>__new__()</code>的实现将会使用合适的参数调用其超类的<code>super().__new__()</code>，并在返回之前修改实例。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demoClass</span>:</span><br><span class="line">  instances_created = <span class="number">0</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,*args,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__new__():&quot;</span>,cls,args,kwargs)</span><br><span class="line">    instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">    instance.number = cls.instances_created</span><br><span class="line">    cls.instances_created += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,attribute</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__init__():&quot;</span>,self,attribute)</span><br><span class="line">    self.attribute = attribute</span><br><span class="line">test1 = demoClass(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">test2 = demoClass(<span class="string">&quot;xyz&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(test1.number,test1.instances_created)</span><br><span class="line"><span class="built_in">print</span>(test2.number,test2.instances_created)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__new__(): &lt;class &#x27;__main__.demoClass&#x27;&gt; (&#x27;abc&#x27;,) &#123;&#125;</span><br><span class="line">__init__(): &lt;__main__.demoClass object at 0x0000026FC0DF8080&gt; abc</span><br><span class="line">__new__(): &lt;class &#x27;__main__.demoClass&#x27;&gt; (&#x27;xyz&#x27;,) &#123;&#125;</span><br><span class="line">__init__(): &lt;__main__.demoClass object at 0x0000026FC0DED358&gt; xyz</span><br><span class="line">0 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<p><code>__new__()</code>通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对<code>__init__()</code>方法的调用。而在某些情况下（比如需要修改不可变类实例（Python 的某些内置类型）的创建行为），利用这一点会事半功倍。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">nonZero</span>(<span class="title class_ inherited__">int</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls,value</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,value) <span class="keyword">if</span> value != <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,skipped_value</span>):</span><br><span class="line">    <span class="comment">#此例中会跳过此方法</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;__init__()&quot;</span>)</span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nonZero(-<span class="number">12</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nonZero(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__init__()</span><br><span class="line">&lt;class &#x27;__main__.nonZero&#x27;&gt;</span><br><span class="line">&lt;class &#x27;NoneType&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>那么，什么情况下使用<code>__new__()</code>呢？答案很简单，在<code>__init__()</code>不够用的时候。</p>
<p>例如，前面例子中对 Python 不可变的内置类型（如<code>int、str、float</code>等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在<code>__init__()</code>方法中对其进行修改。</p>
<p>有些读者可能会认为，<code>__new__()</code>对执行重要的对象初始化很有用，如果用户忘记使用<code>super()</code>，可能会漏掉这一初始化。虽然这听上去很合理，但有一个主要的缺点，即如果使用这样的方法，那么即便初始化过程已经是预期的行为，程序员明确跳过初始化步骤也会变得更加困难。不仅如此，它还破坏了“<code>__init__()</code>中执行所有初始化工作”的潜规则。</p>
<blockquote>
<p>注意，由于<code>__new__()</code>不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。一般来说，对于特定问题，最好搜索其他可用的解决方案，最好不要影响对象的创建过程，使其违背程序员的预期。比如说，前面提到的覆写不可变类型初始化的例子，完全可以用工厂方法（一种设计模式）来替代。</p>
</blockquote>
<p>Python中大量使用<code>__new__()</code>方法且合理的，就是<code>MetaClass</code>元类。</p>
<h1 id="repr-方法：显示属性"><a href="#repr-方法：显示属性" class="headerlink" title="repr()方法：显示属性"></a><strong>repr</strong>()方法：显示属性</h1><p>我们经常会直接输出类的实例化对象，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.CLanguage object at 0x000001A7275221D0&gt;</span><br></pre></td></tr></table></figure>
<p>通常情况下，直接输出某个实例化对象，本意往往是想了解该对象的基本信息，例如该对象有哪些属性，它们的值各是多少等等。但默认情况下，我们得到的信息只会是“类名+object at+内存地址”，对我们了解该实例化对象帮助不大。</p>
<p>那么，有没有可能自定义输出实例化对象时的信息呢？答案是肯定，通过重写类的<code>__repr__()</code>方法即可。事实上，当我们输出某个实例化对象时，其调用的就是该对象的<code>__repr__()</code>方法，输出的是该方法的返回值。</p>
<p>以开头的程序为例，执行<code>print(clangs)</code>等同于执行<code>print(clangs.__repr__())</code>，程序的输出结果是一样的（输出的内存地址可能不同）。</p>
<p>和<code>__init__(self)</code>的性质一样，Python 中的每个类都包含<code>__repr__()</code>方法，因为<code>object</code>类包含<code>__reper__()</code>方法，而 Python 中所有的类都直接或间接继承自<code>object</code>类。</p>
<p>默认情况下，<code>__repr__()</code>会返回和调用者有关的 “类名+object at+内存地址”信息。当然，我们还可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;CLanguage[name=&quot;</span>+ self.name +<span class="string">&quot;,add=&quot;</span> + self.add +<span class="string">&quot;]&quot;</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLanguage[name=小明,add=xiaoming]</span><br></pre></td></tr></table></figure>
<p>由此可见，<code>__repr__()</code>方法是类的实例化对象用来做“自我介绍”的方法，默认情况下，它会返回当前对象的“类名+object at+内存地址”，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。</p>
<h1 id="del-方法：销毁对象"><a href="#del-方法：销毁对象" class="headerlink" title="del()方法：销毁对象"></a><strong>del</strong>()方法：销毁对象</h1><p>我们知道，Python 通过调用<code>__init__()</code>方法构造当前类的实例化对象，而<code>__del__()</code>方法，功能正好和<code>__init__()</code>相反，其用来销毁实例化对象。</p>
<p>事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（整个过程称为垃圾回收（简称GC））。<br>大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制（下面会讲），能自动将不需要使用的实例对象进行销毁。</p>
<p>无论是手动销毁，还是 Python 自动帮我们销毁，都会调用<code>__del__()</code>方法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用 __init__() 方法构造对象&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用__del__() 销毁对象，释放其空间&quot;</span>)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="keyword">del</span> clangs</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用 __init__() 方法构造对象</span><br><span class="line">调用__del__() 销毁对象，释放其空间</span><br></pre></td></tr></table></figure>
<p>但是，千万不要误认为，只要为该实例对象调用 <strong>del</strong>() 方法，该对象所占用的内存空间就会被释放。举个例子：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用 __init__() 方法构造对象&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用__del__() 销毁对象，释放其空间&quot;</span>)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="comment">#添加一个引用clangs对象的实例对象</span></span><br><span class="line">cl = clangs</span><br><span class="line"><span class="keyword">del</span> clangs</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;***********&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用 __init__() 方法构造对象</span><br><span class="line">***********</span><br><span class="line">调用__del__() 销毁对象，释放其空间</span><br></pre></td></tr></table></figure>
<p>注意，最后一行输出信息，是程序执行即将结束时调用<code>__del__()</code>方法输出的。</p>
<p>可以看到，当程序中有其它变量（比如这里的 cl）引用该实例对象时，即便手动调用<code>__del__()</code>方法，该方法也不会立即执行。这和 Python 的垃圾回收机制的实现有关。</p>
<p>Python 采用自动引用计数（简称 ARC）的方式实现垃圾回收机制。该方法的核心思想是：每个 Python 对象都会配置一个计数器，初始 Python 实例对象的计数器值都为 0，如果有变量引用该实例对象，其计数器的值会加 1，依次类推；反之，每当一个变量取消对该实例对象的引用，计数器会减 1。如果一个 Python 对象的的计数器值为 0，则表明没有变量引用该 Python 对象，即证明程序不再需要它，此时 Python 就会自动调用<code>__del__()</code>方法将其回收。</p>
<p>以上面程序中的 clangs 为例，实际上构建 clangs 实例对象的过程分为 2 步，先使用 CLanguage() 调用该类中的<code>__init__()</code>方法构造出一个该类的对象（将其称为 C，计数器为 0），并立即用 clangs 这个变量作为所建实例对象的引用（ C 的计数器值 + 1）。在此基础上，又有一个 clang 变量引用 clangs（其实相当于引用 CLanguage()，此时 C 的计数器再 +1 ），这时如果调用del clangs语句，只会导致 C 的计数器减 1（值变为 1），因为 C 的计数器值不为 0，因此 C 不会被销毁（不会执行<code>__del__()</code>方法）。</p>
<p>如果在上面程序结尾，添加如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">del cl</span><br><span class="line">print(&quot;-----------&quot;)</span><br><span class="line">则程序的执行结果为：</span><br><span class="line">调用 __init__() 方法构造对象</span><br><span class="line">***********</span><br><span class="line">调用__del__() 销毁对象，释放其空间</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure>
<p>可以看到，当执行 del cl 语句时，其应用的对象实例对象 C 的计数器继续 -1（变为 0），对于计数器为 0 的实例对象，Python 会自动将其视为垃圾进行回收。</p>
<p>需要额外说明的是，如果我们重写子类的 <strong>del</strong>() 方法（父类为非<code>object</code>的类），则必须显式调用父类的 <strong>del</strong>() 方法，这样才能保证在回收子类对象时，其占用的资源（可能包含继承自父类的部分资源）能被彻底释放。为了说明这一点，这里举一个反例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用父类 __del__() 方法&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cl</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用子类 __del__() 方法&quot;</span>)</span><br><span class="line">c = cl()</span><br><span class="line"><span class="keyword">del</span> c</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用子类 __del__() 方法</span><br></pre></td></tr></table></figure>
<h1 id="dir-用法：列出对象的所有属性（方法）名"><a href="#dir-用法：列出对象的所有属性（方法）名" class="headerlink" title="dir()用法：列出对象的所有属性（方法）名"></a><strong>dir</strong>()用法：列出对象的所有属性（方法）名</h1><p><code>dir()</code>函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self,):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(clangs))</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;add&#x27;, &#x27;name&#x27;, &#x27;say&#x27;]</span><br></pre></td></tr></table></figure>
<p>注意，通过<code>dir()</code>函数，不仅仅输出本类中新添加的属性名和方法（最后 3 个），还会输出从父类（这里为<code>object</code>类）继承得到的属性名和方法名。</p>
<p>值得一提的是，<code>dir()</code>函数的内部实现，其实是在调用参数对象<code>__dir__()</code>方法的基础上，对该方法返回的属性名和方法名做了排序。</p>
<p>所以，除了使用<code>dir()</code>函数，我们完全可以自行调用该对象具有的<code>__dir__()</code>方法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self,):</span><br><span class="line">        self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.__dir__())</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;name&#x27;, &#x27;add&#x27;, &#x27;__module__&#x27;, &#x27;__init__&#x27;, &#x27;say&#x27;, &#x27;__dict__&#x27;, &#x27;__weakref__&#x27;, &#x27;__doc__&#x27;, &#x27;__repr__&#x27;, &#x27;__hash__&#x27;, &#x27;__str__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__setattr__&#x27;, &#x27;__delattr__&#x27;, &#x27;__lt__&#x27;, &#x27;__le__&#x27;, &#x27;__eq__&#x27;, &#x27;__ne__&#x27;, &#x27;__gt__&#x27;, &#x27;__ge__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__reduce__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__format__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__dir__&#x27;, &#x27;__class__&#x27;]</span><br></pre></td></tr></table></figure>
<p>显然，使用<code>__dir__()</code>方法和<code>dir()</code>函数输出的数据是相同，仅仅顺序不同。</p>
<h1 id="dict-属性：查看对象内部所有属性名和属性值组成的字典"><a href="#dict-属性：查看对象内部所有属性名和属性值组成的字典" class="headerlink" title="__dict__属性：查看对象内部所有属性名和属性值组成的字典"></a>__dict__属性：查看对象内部所有属性名和属性值组成的字典</h1><p>在 Python 类的内部，无论是类属性还是实例属性，都是以字典的形式进行存储的，其中属性名作为键，而值作为该键对应的值。</p>
<p>为了方便用户查看类中包含哪些属性，Python 类提供了<code>__dict__</code>属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用，用类名直接调用<code>__dict__</code>，会输出该由类中所有类属性组成的字典；而使用类的实例对象调用<code>__dict__</code>，会输出由类中所有实例属性组成的字典。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="comment">#通过类名调用__dict__</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.__dict__)</span><br><span class="line"><span class="comment">#通过类实例对象调用 __dict__</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.__dict__)</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;__init__&#x27;: &lt;function CLanguage.__init__ at 0x0000022C69833E18&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;CLanguage&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;CLanguage&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;add&#x27;: &#x27;xiaoming&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>不仅如此，对于具有继承关系的父类和子类来说，父类有自己的<code>__dict__</code>，同样子类也有自己的<code>__dict__</code>，它不会包含父类的<code>__dict__</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CL</span>(<span class="title class_ inherited__">CLanguage</span>):</span><br><span class="line">  c = <span class="number">1</span></span><br><span class="line">  d = <span class="number">2</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.na = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line">    self.ad = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="comment">#父类名调用__dict__</span></span><br><span class="line"><span class="built_in">print</span>(CLanguage.__dict__)</span><br><span class="line"><span class="comment">#子类名调用__dict__</span></span><br><span class="line"><span class="built_in">print</span>(CL.__dict__)</span><br><span class="line"><span class="comment">#父类实例对象调用 __dict__</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.__dict__)</span><br><span class="line"><span class="comment">#子类实例对象调用 __dict__</span></span><br><span class="line">cl = CL()</span><br><span class="line"><span class="built_in">print</span>(cl.__dict__)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;__init__&#x27;: &lt;function CLanguage.__init__ at 0x000001721A853E18&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;CLanguage&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;CLanguage&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="line">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;c&#x27;: 1, &#x27;d&#x27;: 2, &#x27;__init__&#x27;: &lt;function CL.__init__ at 0x000001721CD15510&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;add&#x27;: &#x27;xiaoming&#x27;&#125;</span><br><span class="line">&#123;&#x27;na&#x27;: &#x27;Python教程&#x27;, &#x27;ad&#x27;: &#x27;xiaohong&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>显然，通过子类直接调用的<code>__dict__</code>中，并没有包含父类中的<code>a</code>和<code>b</code>类属性；同样，通过子类对象调用的<code>__dict__</code>，也没有包含父类对象拥有的<code>name</code>和<code>add</code>实例属性。</p>
<p>除此之外，借助由类实例对象调用<code>__dict__</code>属性获取的字典，可以使用字典的方式对其中实例属性的值进行修改，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  a = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="comment">#通过类实例对象调用 __dict__</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.__dict__)</span><br><span class="line">clangs.__dict__[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;小明&#x27;, &#x27;add&#x27;: &#x27;xiaoming&#x27;&#125;</span><br><span class="line">Python教程</span><br></pre></td></tr></table></figure>
<p>注意，无法通过类似的方式修改类变量的值。</p>
<h1 id="setattr-、getattr-、hasattr"><a href="#setattr-、getattr-、hasattr" class="headerlink" title="setattr()、getattr()、hasattr()"></a>setattr()、getattr()、hasattr()</h1><h2 id="hasattr-函数"><a href="#hasattr-函数" class="headerlink" title="hasattr()函数"></a>hasattr()函数</h2><p><code>hasattr()</code>函数用来判断某个类实例对象是否包含指定名称的属性或方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, name)</span><br></pre></td></tr></table></figure>
<p>其中<code>obj</code>指的是某个类的实例对象，<code>name</code>表示指定的属性名或方法名。同时，该函数会将判断的结果（<code>True</code>或者<code>False</code>）作为返回值反馈回来。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我正在学Python&quot;</span>)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(clangs,<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(clangs,<span class="string">&quot;add&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(clangs,<span class="string">&quot;say&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>显然，无论是属性名还是方法名，都在<code>hasattr()</code>函数的匹配范围内。因此，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。</p>
<h2 id="getattr-函数"><a href="#getattr-函数" class="headerlink" title="getattr() 函数"></a>getattr() 函数</h2><p><code>getattr()</code>函数获取某个类实例对象中指定属性的值。没错，和<code>hasattr()</code>函数不同，该函数只会从类对象包含的所有属性中进行查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getattr(obj, name[, default])</span><br></pre></td></tr></table></figure>
<p>其中，<code>obj</code>表示指定的类实例对象，<code>name</code>表示指定的属性名，而<code>default</code>是可选参数，用于设定该函数的默认返回值，即当函数查找失败时，如果不指定<code>default</code>参数，则程序将直接报<code>AttributeError</code>错误，反之该函数将返回<code>default</code>指定的值。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我正在学Python&quot;</span>)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(clangs,<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(clangs,<span class="string">&quot;add&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(clangs,<span class="string">&quot;say&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(clangs,<span class="string">&quot;display&quot;</span>,<span class="string">&#x27;nodisplay&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming</span><br><span class="line">xiaoming</span><br><span class="line">&lt;bound method CLanguage.say of &lt;__main__.CLanguage object at 0x000001FC2F2E3198&gt;&gt;</span><br><span class="line">nodisplay</span><br></pre></td></tr></table></figure>
<p>可以看到，对于类中已有的属性，<code>getattr()</code>会返回它们的值，而如果该名称为方法名，则返回该方法的状态信息；反之，如果该明白不为类对象所有，要么返回默认的参数，要么程序报<code>AttributeError</code>错误。</p>
<h2 id="setattr-函数"><a href="#setattr-函数" class="headerlink" title="setattr()函数"></a>setattr()函数</h2><p><code>setattr()</code>函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setattr(obj, name, value)</span><br></pre></td></tr></table></figure>
<p>首先，下面例子演示如何通过该函数修改某个类实例对象的属性值：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我正在学Python&quot;</span>)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br><span class="line"><span class="built_in">print</span>(clangs.add)</span><br><span class="line"><span class="built_in">setattr</span>(clangs,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小红&quot;</span>)</span><br><span class="line"><span class="built_in">setattr</span>(clangs,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;xiaohong&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br><span class="line"><span class="built_in">print</span>(clangs.add)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">xiaoming</span><br><span class="line">小红</span><br><span class="line">xiaohong</span><br></pre></td></tr></table></figure>
<p>甚至利用<code>setattr()</code>函数，还可以将类属性修改为一个类方法，同样也可以将类方法修改成一个类属性。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我正在学Python&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br><span class="line"><span class="built_in">print</span>(clangs.add)</span><br><span class="line"><span class="built_in">setattr</span>(clangs,<span class="string">&quot;name&quot;</span>,say)</span><br><span class="line">clangs.name(clangs)</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">xiaoming</span><br><span class="line">我正在学Python</span><br></pre></td></tr></table></figure>
<p>显然，通过修改<code>name</code>属性的值为<code>say</code>（这是一个外部定义的函数），原来的<code>name</code>属性就变成了一个<code>name()</code>方法。</p>
<p>使用<code>setattr()</code>函数对实例对象中执行名称的属性或方法进行修改时，如果该名称查找失败，Python 解释器不会报错，而是会给该实例对象动态添加一个指定名称的属性或方法。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;我正在学Python&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="built_in">setattr</span>(clangs,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小明&quot;</span>)</span><br><span class="line"><span class="built_in">setattr</span>(clangs,<span class="string">&quot;say&quot;</span>,say)</span><br><span class="line"><span class="built_in">print</span>(clangs.name)</span><br><span class="line">clangs.say(clangs)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">我正在学Python</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然<code>CLanguage</code>为空类，但通过<code>setattr()</code>函数，我们为<code>clangs</code>对象动态添加了一个<code>name</code>属性和一个<code>say()</code>方法。</p>
<h1 id="issubclass和isinstance函数：检查类型"><a href="#issubclass和isinstance函数：检查类型" class="headerlink" title="issubclass和isinstance函数：检查类型"></a>issubclass和isinstance函数：检查类型</h1><p>Python 提供了如下两个函数来检查类型：</p>
<ul>
<li><code>issubclass(cls, class_or_tuple)</code>：检查<code>cls</code>是否为后一个类或元组包含的多个类中任意类的子类。</li>
<li><code>isinstance(obj, class_or_tuple)</code>：检查<code>obj</code>是否为后一个类或元组包含的多个类中任意类的对象。</li>
</ul>
<p>通过使用上面两个函数，程序可以方便地先执行检查，然后才调用方法，这样可以保证程序不会出现意外情况。</p>
<p>如下程序示范了通过这两个函数来检查类型：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个字符串</span></span><br><span class="line">hello = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment"># &quot;Hello&quot;是str类的实例，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&quot;Hello&quot;是否是str类的实例: &#x27;</span>, <span class="built_in">isinstance</span>(hello, <span class="built_in">str</span>))</span><br><span class="line"><span class="comment"># &quot;Hello&quot;是object类的子类的实例，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&quot;Hello&quot;是否是object类的实例: &#x27;</span>, <span class="built_in">isinstance</span>(hello, <span class="built_in">object</span>))</span><br><span class="line"><span class="comment"># str是object类的子类，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;str是否是object类的子类: &#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="comment"># &quot;Hello&quot;不是tuple类及其子类的实例，输出False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&quot;Hello&quot;是否是tuple类的实例: &#x27;</span>, <span class="built_in">isinstance</span>(hello, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="comment"># str不是tuple类的子类，输出False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;str是否是tuple类的子类: &#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="comment"># 定义一个列表</span></span><br><span class="line">my_list = [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># [2, 4]是list类的实例，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[2, 4]是否是list类的实例: &#x27;</span>, <span class="built_in">isinstance</span>(my_list, <span class="built_in">list</span>))</span><br><span class="line"><span class="comment"># [2, 4]是object类的子类的实例，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[2, 4]是否是object类及其子类的实例: &#x27;</span>, <span class="built_in">isinstance</span>(my_list, <span class="built_in">object</span>))</span><br><span class="line"><span class="comment"># list是object类的子类，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list是否是object类的子类: &#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">list</span>, <span class="built_in">object</span>))</span><br><span class="line"><span class="comment"># [2, 4]不是tuple类及其子类的实例，输出False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[2, 4]是否是tuple类及其子类的实例: &#x27;</span>, <span class="built_in">isinstance</span>([<span class="number">2</span>, <span class="number">4</span>], <span class="built_in">tuple</span>))</span><br><span class="line"><span class="comment"># list不是tuple类的子类，输出False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;list是否是tuple类的子类: &#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br></pre></td></tr></table></figure>
<p>通过上面程序可以看出，<code>issubclass()</code>和<code>isinstance()</code>两个函数的用法差不多，区别只是<code>issubclass()</code>的第一个参数是类名，而<code>isinstance()</code>的第一个参数是变量，这也与两个函数的意义对应：<code>issubclass</code>用于判断是否为子类，而<code>isinstance()</code>用于判断是否为该类或子类的实例。</p>
<p><code>issubclass()</code>和<code>isinstance()</code>两个函数的第二个参数都可使用元组。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = (<span class="number">20</span>, <span class="string">&#x27;fkit&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data是否为列表或元组: &#x27;</span>, <span class="built_in">isinstance</span>(data, (<span class="built_in">list</span>, <span class="built_in">tuple</span>))) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># str不是list或者tuple的子类，输出False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;str是否为list或tuple的子类: &#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)))</span><br><span class="line"><span class="comment"># str是list或tuple或object的子类，输出True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;str是否为list或tuple或object的子类 &#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, (<span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="built_in">object</span>)))</span><br></pre></td></tr></table></figure>
<p>此外，Python 为所有类都提供了一个<code>__bases__</code>属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组。例如如下代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;类A的所有父类:&#x27;</span>, A.__bases__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;类B的所有父类:&#x27;</span>, B.__bases__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;类C的所有父类:&#x27;</span>, C.__bases__)</span><br></pre></td></tr></table></figure>
<p>运行上面程序，可以看到如下运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类A的所有父类: (&lt;class &#x27;object&#x27;&gt;,)</span><br><span class="line">类B的所有父类: (&lt;class &#x27;object&#x27;&gt;,)</span><br><span class="line">类C的所有父类: (&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;)</span><br></pre></td></tr></table></figure>
<p>从上面的运行结果可以看出，如果在定义类时没有显式指定它的父类，则这些类默认的父类是<code>object</code>类。</p>
<p>Python 还为所有类都提供了一个<code>__subclasses__()</code>方法，通过该方法可以查看该类的所有直接子类，该方法返回该类的所有子类组成的列表。例如在上面程序中增加如下两行：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;类A的所有子类:&#x27;</span>, A.__subclasses__())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;类B的所有子类:&#x27;</span>, B.__subclasses__())</span><br></pre></td></tr></table></figure>
<p>运行上面代码，可以看到如下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类A的所有子类: [&lt;class &#x27;__main__.C&#x27;&gt;]</span><br><span class="line">类B的所有子类: [&lt;class &#x27;__main__.C&#x27;&gt;]</span><br></pre></td></tr></table></figure>
<h1 id="call"><a href="#call" class="headerlink" title="call()"></a><strong>call</strong>()</h1><p>该方法的功能类似于在类中重载<code>()</code>运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="comment"># 定义__call__方法</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,name,add</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用__call__()方法&quot;</span>,name,add)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">clangs(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;xiaoming&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用__call__()方法 小明 xiaoming</span><br></pre></td></tr></table></figure>
<p>可以看到，通过在<code>CLanguage</code>类中实现<code>__call__()</code>方法，使的<code>clangs</code>实例对象变为了可调用对象。</p>
<p>Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。</p>
<p>对于可调用对象，实际上“名称()”可以理解为是“名称.<strong>call</strong>()”的简写。仍以上面程序中定义的 clangs 实例对象为例，其最后一行代码还可以改写为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clangs.__call__(&quot;C语言中文网&quot;,&quot;http://c.biancheng.net&quot;)</span><br></pre></td></tr></table></figure>
<p>运行程序会发现，其运行结果和之前完全相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def say():</span><br><span class="line">  print(&quot;Python教程：http://c.biancheng.net/python&quot;)</span><br><span class="line">say()</span><br><span class="line">say.__call__()</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python教程：http://c.biancheng.net/python</span><br><span class="line">Python教程：http://c.biancheng.net/python</span><br></pre></td></tr></table></figure>
<p>不仅如此，类中的实例方法也有以上 2 种调用方式。</p>
<h2 id="用-call-弥补-hasattr-函数的短板"><a href="#用-call-弥补-hasattr-函数的短板" class="headerlink" title="用 call() 弥补 hasattr() 函数的短板"></a>用 <strong>call</strong>() 弥补 hasattr() 函数的短板</h2><p><code>hasattr()</code>函数的功能是查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。</p>
<p>要解决这个问题，我们可以借助可调用对象的概念。要知道，类实例对象包含的方法，其实也属于可调用对象，但类属性却不是。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLanguage</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">    self.name = <span class="string">&quot;小明&quot;</span></span><br><span class="line">    self.add = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;我正在学Python&quot;</span>)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(clangs,<span class="string">&quot;name&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(clangs.name,<span class="string">&quot;__call__&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(clangs,<span class="string">&quot;say&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(clangs.say,<span class="string">&quot;__call__&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">**********</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>可以看到，由于<code>name</code>是类属性，它没有以<code>__call__</code>为名的<code>__call__()</code>方法；而<code>say</code>是类方法，它是可调用对象，因此它有<code>__call__()</code>方法。</p>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>Python 中的各个序列类型，每个类型都有其独特的操作方法，例如列表类型支持直接做加法操作实现添加元素的功能，字符串类型支持直接做加法实现字符串的拼接功能，也就是说，同样的运算符对于不同序列类型的意义是不一样的，这是怎么做到的呢？</p>
<p>其实在 Python 内部，每种序列类型都是 Python 的一个类，例如列表是<code>list</code>类，字典是<code>dict</code>类等，这些序列类的内部使用了一个叫作“重载运算符”的技术来实现不同运算符所对应的操作。</p>
<p>所谓重载运算符，指的是在类中定义并实现一个与运算符对应的处理方法，这样当类对象在进行运算符操作时，系统就会调用类中相应的方法来处理。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>: <span class="comment">#自定义一个类</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name , age</span>): <span class="comment">#定义该类的初始化函数</span></span><br><span class="line">    self.name = name <span class="comment">#将传入的参数值赋值给成员交量</span></span><br><span class="line">    self.age = age</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>): <span class="comment">#用于将值转化为字符串形式，等同于 str(obj)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;name:&quot;</span>+self.name+<span class="string">&quot;;age:&quot;</span>+<span class="built_in">str</span>(self.age)</span><br><span class="line">  </span><br><span class="line">  __repr__ = __str__ <span class="comment">#转化为供解释器读取的形式</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, record</span>): <span class="comment">#重载 self&lt;record 运算符</span></span><br><span class="line">    <span class="keyword">if</span> self.age &lt; record.age:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, record</span>): <span class="comment">#重载 + 号运算符</span></span><br><span class="line">    <span class="keyword">return</span> MyClass(self.name, self.age+record.age)</span><br><span class="line">myc = MyClass(<span class="string">&quot;Anna&quot;</span>, <span class="number">42</span>) <span class="comment">#实例化一个对象 Anna，并为其初始化</span></span><br><span class="line">mycl = MyClass(<span class="string">&quot;Gary&quot;</span>, <span class="number">23</span>) <span class="comment">#实例化一个对象 Gary，并为其初始化</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(myc)) <span class="comment">#格式化对象 myc，</span></span><br><span class="line"><span class="built_in">print</span>(myc) <span class="comment">#解释器读取对象 myc，调用 repr</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> (myc)) <span class="comment">#格式化对象 myc ，输出&quot;name:Anna;age:42&quot;</span></span><br><span class="line"><span class="built_in">print</span>(myc &lt; mycl) <span class="comment">#比较 myc&lt;mycl 的结果，输出 False</span></span><br><span class="line"><span class="built_in">print</span> (myc+mycl) <span class="comment">#进行两个 MyClass 对象的相加运算，输出 &quot;name:Anna;age:65&quot;</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name:Anna;age:42</span><br><span class="line">name:Anna;age:42</span><br><span class="line">name:Anna;age:42</span><br><span class="line">False</span><br><span class="line">name:Anna;age:65</span><br></pre></td></tr></table></figure>
<p>这个例子中，MyClass 类中重载了<code>repr、str、&lt;、+</code>运算符，并用<code>MyClass</code>实例化了两个对象<code>myc</code>和<code>mycl</code>。</p>
<p>通过将<code>myc</code>进行<code>repr、str</code>运算，从输出结果中可以看到，程序调用了重载的操作符方法<code>__repr__</code>和<code>__str__</code>。而令<code>myc</code>和<code>mycl</code>进行 &lt; 号的比较运算以及加法运算，从输出结果中可以看出，程序调用了重载 &lt; 号的方法<code>__lt__</code>和<code>__add__</code>方法。</p>
<p>Python 常用重载运算符</p>
<table>
<thead>
<tr>
<th align="center">重载运算符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>new</strong></td>
<td align="center">创建类，在 <strong>init</strong> 之前创建对象</td>
</tr>
<tr>
<td align="center"><strong>init</strong></td>
<td align="center">类的构造函数，其功能是创建类对象时做初始化工作。</td>
</tr>
<tr>
<td align="center"><strong>del</strong></td>
<td align="center">析构函数，其功能是销毁对象时进行回收资源的操作</td>
</tr>
<tr>
<td align="center"><strong>add</strong></td>
<td align="center">加法运算符 +，当类对象 X 做例如 X+Y 或者 X+&#x3D;Y 等操作，内部会调用此方法。但如果类中对 <strong>iadd</strong> 方法进行了重载，则类对象 X 在做 X+&#x3D;Y 类似操作时，会优先选择调用 <strong>iadd</strong> 方法。</td>
</tr>
<tr>
<td align="center"><strong>radd</strong></td>
<td align="center">当类对象 X 做类似 Y+X 的运算时，会调用此方法。</td>
</tr>
<tr>
<td align="center"><strong>iadd</strong></td>
<td align="center">重载 +&#x3D; 运算符，也就是说，当类对象 X 做类似 X+&#x3D;Y 的操作时，会调用此方法。</td>
</tr>
<tr>
<td align="center"><strong>or</strong></td>
<td align="center">“或”运算符</td>
</tr>
<tr>
<td align="center"><strong>repr__，__str</strong></td>
<td align="center">格式转换方法，分别对应函数 repr(X)、str(X)</td>
</tr>
<tr>
<td align="center"><strong>call</strong></td>
<td align="center">函数调用，类似于 X(*args, **kwargs) 语句</td>
</tr>
<tr>
<td align="center"><strong>getattr</strong></td>
<td align="center">点号运算，用来获取类属性</td>
</tr>
<tr>
<td align="center"><strong>setattr</strong></td>
<td align="center">属性赋值语句，类似于 X.any&#x3D;value</td>
</tr>
<tr>
<td align="center"><strong>delattr</strong></td>
<td align="center">删除属性，类似于 del X.any</td>
</tr>
<tr>
<td align="center"><strong>getattribute</strong></td>
<td align="center">获取属性，类似于 X.any</td>
</tr>
<tr>
<td align="center"><strong>getitem</strong></td>
<td align="center">索引运算，类似于 X[key]，X[i:j]</td>
</tr>
<tr>
<td align="center"><strong>setitem</strong></td>
<td align="center">索引赋值语句，类似于 X[key], X[i:j]&#x3D;sequence</td>
</tr>
<tr>
<td align="center"><strong>delitem</strong></td>
<td align="center">索引和分片删除</td>
</tr>
<tr>
<td align="center"><strong>get</strong>, <strong>set</strong>, <strong>delete</strong></td>
<td align="center">描述符属性，类似于 X.attr，X.attr&#x3D;value，del X.attr</td>
</tr>
<tr>
<td align="center"><strong>len</strong></td>
<td align="center">计算长度，类似于 len(X)</td>
</tr>
<tr>
<td align="center"><strong>lt__，__gt__，__le__，__ge__，__eq__，__ne</strong></td>
<td align="center">比较，分别对应于 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;、!&#x3D; 运算符。</td>
</tr>
<tr>
<td align="center"><strong>iter__，__next</strong></td>
<td align="center">迭代环境下，生成迭代器与取下一条，类似于 I&#x3D;iter(X) 和 next()</td>
</tr>
<tr>
<td align="center"><strong>contains</strong></td>
<td align="center">成员关系测试，类似于 item in X</td>
</tr>
<tr>
<td align="center"><strong>index</strong></td>
<td align="center">整数值，类似于 hex(X)，bin(X)，oct(X)</td>
</tr>
<tr>
<td align="center"><strong>enter__，__exit</strong></td>
<td align="center">在对类对象执行类似 with obj as var 的操作之前，会先调用 <strong>enter</strong> 方法，其结果会传给 var；在最终结束该操作之前，会调用 <strong>exit</strong> 方法（常用于做一些清理、扫尾的工作）</td>
</tr>
</tbody></table>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>列表（<code>list</code>）、元组（<code>tuple</code>）、字典（<code>dict</code>）、集合（<code>set</code>）这些序列式容器，有一个共同的特性，它们都支持使用<code>for</code>循环遍历存储的元素，都是可迭代的，因此它们又有一个别称，即迭代器。</p>
<p>从字面来理解，迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这些 Python 提供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。</p>
<p>如果要自定义实现一个迭代器，则类中必须实现如下 2 个方法：</p>
<ul>
<li><code>__next__(self)</code>：返回容器的下一个元素。</li>
<li><code>__iter__(self)</code>：该方法返回一个迭代器（<code>iterator</code>）。</li>
</ul>
<p>例如，下面程序自定义了一个简易的列表容器迭代器，支持迭代：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">listDemo</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.__date=[]</span><br><span class="line">    self.__step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.__step &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br><span class="line">    self.__step -= <span class="number">1</span></span><br><span class="line">    <span class="comment">#返回下一个元素</span></span><br><span class="line">    <span class="keyword">return</span> self.__date[self.__step]</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment">#实例对象本身就是迭代器对象，因此直接返回 self 即可</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  <span class="comment">#添加元素</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,key,value</span>):</span><br><span class="line">    self.__date.insert(key,value)</span><br><span class="line">    self.__step += <span class="number">1</span></span><br><span class="line">mylist = listDemo()</span><br><span class="line">mylist[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">mylist[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>除此之外，Python 内置的<code>iter()</code>函数也会返回一个迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iter(obj[, sentinel])</span><br></pre></td></tr></table></figure>
<p>其中，<code>obj</code>必须是一个可迭代的容器对象，而<code>sentinel</code>作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象。</p>
<p>可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加<code>__call__()</code>方法，就可以将该类的实例对象编程可调用对象。</p>
<p>我们常用的是仅有 1 个参数的<code>iter()</code>函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的<code>__next__()</code>方法即可实现迭代。例如；</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将列表转换为迭代器</span></span><br><span class="line">myIter = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 依次获取迭代器的下一个元素</span></span><br><span class="line"><span class="built_in">print</span>(myIter.__next__())</span><br><span class="line"><span class="built_in">print</span>(myIter.__next__())</span><br><span class="line"><span class="built_in">print</span>(myIter.__next__())</span><br><span class="line"><span class="built_in">print</span>(myIter.__next__())</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\mengma\Desktop\demo.py&quot;, line 7, in &lt;module&gt;</span><br><span class="line">    print(myIter.__next__())</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>另外，也可以使用<code>next()</code>内置函数来迭代，即<code>next(myIter)</code>，和<code>__next__()</code>方法是完全一样的。</p>
<p>从程序的执行结果可以看出，当迭代完存储的所有元素之后，如果继续迭代，则<code>__next__()</code>方法会抛出<code>StopIteration</code>异常。</p>
<p><code>iter()</code>函数第 2 个参数的作用，如果使用该参数，则要求第一个<code>obj</code>参数必须传入可调用对象（可以不支持迭代），这样当使用返回的迭代器调用<code>__next__()</code>方法时，它会通过执行<code>obj()</code>调用<code>__call__()</code>方法，如果该方法的返回值和第 2 个参数值相同，则输出<code>StopInteration</code>异常；反之，则输出<code>__call__()</code>方法的返回值。</p>
<p>例如，修改 listDemo 类如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">listDemo</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    self.__date=[]</span><br><span class="line">    self.__step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self,key,value</span>):</span><br><span class="line">    self.__date.insert(key,value)</span><br><span class="line">    self.__step += <span class="number">1</span></span><br><span class="line">  <span class="comment">#是该类实例对象成为可调用对象</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">    self.__step-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self.__date[self.__step]</span><br><span class="line">mylist = listDemo()</span><br><span class="line">mylist[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">mylist[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line"><span class="comment">#将 mylist 变为迭代器</span></span><br><span class="line">a = <span class="built_in">iter</span>(mylist,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a.__next__())</span><br><span class="line"><span class="built_in">print</span>(a.__next__())</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;D:\python3.6\1.py&quot;, line 20, in &lt;module&gt;</span><br><span class="line">    print(a.__next__())</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>输出结果中，之所以最终抛出<code>StopIteration</code>异常，是因为这里原本要输出的元素 1 和<code>iter()</code>函数的第 2 个参数相同。</p>
<p>迭代器本身是一个底层的特性和概念，在程序中并不常用，但它为生成器这一更有趣的特性提供了基础。</p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器本质上也是迭代器，不过它比较特殊。</p>
<p>以<code>list</code>容器为例，在使用该容器迭代一组数据时，必须事先将所有数据存储到容器中，才能开始迭代；而生成器却不同，它可以实现在迭代的同时生成元素。<br>也就是说，对于可以用某种算法推算得到的多个数据，生成器并不会一次性生成它们，而是什么时候需要，才什么时候生成。</p>
<p>不仅如此，生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：</p>
<ul>
<li>定义一个以<code>yield</code>关键字标识返回值的函数；</li>
<li>调用刚刚创建的函数，即可创建一个生成器。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intNum</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;开始执行&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;继续执行&quot;</span>)</span><br><span class="line">num = intNum()</span><br></pre></td></tr></table></figure>
<p>由此，我们就成功创建了一个<code>num</code>生成器对象。显然，和普通函数不同，<code>intNum()</code>函数的返回值用的是 <code>yield</code>关键字，而不是<code>return</code>关键字，此类函数又成为生成器函数。</p>
<p>和<code>return</code>相比，<code>yield</code>除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。不仅如此，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。</p>
<p>要想使生成器函数得以执行，或者想使执行完<code>yield</code>语句立即暂停的程序得以继续执行，有以下 2 种方式：</p>
<ul>
<li>通过生成器（上面程序中的<code>num</code>）调用<code>next()</code>内置函数或者<code>__next__()</code>方法；</li>
<li>通过<code>for</code>循环遍历生成器。</li>
</ul>
<p>例如，在上面程序的基础上，添加如下语句：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#调用 next() 内置函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(num))</span><br><span class="line"><span class="comment">#调用 __next__() 方法</span></span><br><span class="line"><span class="built_in">print</span>(num.__next__())</span><br><span class="line"><span class="comment">#通过for循环遍历生成器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">  <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">0</span><br><span class="line">继续执行</span><br><span class="line">1</span><br><span class="line">继续执行</span><br><span class="line">2</span><br><span class="line">继续执行</span><br><span class="line">3</span><br><span class="line">继续执行</span><br><span class="line">4</span><br><span class="line">继续执行</span><br></pre></td></tr></table></figure>
<p>一个程序的执行流程：</p>
<ol>
<li>首先，在创建有<code>num</code>生成器的前提下，通过其调用<code>next()</code>内置函数，会使 Python 解释器开始执行<code>intNum()</code>生成器函数中的代码，因此会输出“开始执行”，程序会一直执行到<code>yield i</code>，而此时的<code>i==0</code>，因此 Python 解释器输出“0”。由于受到<code>yield</code>的影响，程序会在此处暂停。</li>
<li>然后，我们使用 num 生成器调用<code>__next__()</code>方法，该方法的作用和<code>next()</code>函数完全相同（事实上，<code>next()</code>函数的底层执行的也是 <code>__next__()</code>方法），它会是程序继续执行，即输出“继续执行”，程序又会执行到<code>yield i</code>，此时<code>i==1</code>，因此输出“1”，然后程序暂停。</li>
<li>最后，我们使用<code>for</code>循环遍历<code>num</code>生成器，之所以能这么做，是因为<code>for</code>循环底层会不断地调用<code>next()</code>函数，使暂停的程序继续执行，因此会输出后续的结果。</li>
</ol>
<p>注意，在 Python 2.x 版本中不能使用<code>__next__()</code>方法，可以使用<code>next()</code>内置函数，另外生成器还有<code>next()</code>方法（即以 num.next() 的方式调用）。</p>
<p>除此之外，还可以使用<code>list()</code>函数和<code>tuple()</code>函数，直接将生成器能生成的所有值存储成列表或者元组的形式。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = intNum()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(num))</span><br><span class="line">num = intNum()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(num))</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">开始执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">[0, 1, 2, 3, 4]</span><br><span class="line">开始执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">继续执行</span><br><span class="line">(0, 1, 2, 3, 4)</span><br></pre></td></tr></table></figure>
<p>通过输出结果可以判断出，<code>list()</code>和<code>tuple()</code>底层实现和<code>for</code>循环的遍历过程是类似的。</p>
<p>相比迭代器，生成器最明显的优势就是节省内存空间，即它不会一次性生成所有的数据，而是什么时候需要，什么时候生成。</p>
<h1 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="@函数装饰器"></a>@函数装饰器</h1><p>Python 内置的 3 种函数装饰器，分别是<code>＠staticmethod、＠classmethod</code>和<code>@property</code>，其中<code>staticmethod()、classmethod()</code>和<code>property()</code>都是 Python 的内置函数。</p>
<p>那么，函数装饰器的工作原理是怎样的呢？假设用<code>funA()</code>函数装饰器去装饰<code>funB()</code>函数，如下所示：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#funA 作为装饰器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funA</span>(<span class="params">fn</span>):</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  fn() <span class="comment"># 执行传入的fn参数</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funB</span>():</span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>实际上，上面程序完全等价于下面的程序：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funA</span>(<span class="params">fn</span>):</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  fn() <span class="comment"># 执行传入的fn参数</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funB</span>():</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">funB = funA(funB)</span><br></pre></td></tr></table></figure>
<p>通过比对以上 2 段程序不难发现，使用函数装饰器<code>A()</code>去装饰另一个函数<code>B()</code>，其底层执行了如下 2 步操作：</p>
<ul>
<li>将<code>B</code>作为参数传给<code>A()</code>函数；</li>
<li>将<code>A()</code>函数执行完成的返回值反馈回<code>B</code>。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#funA 作为装饰器函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funA</span>(<span class="params">fn</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">  fn() <span class="comment"># 执行传入的fn参数</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;装饰器函数的返回值&quot;</span></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funB</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;学习 Python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行流程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">学习 Python</span><br><span class="line">xiaoming</span><br></pre></td></tr></table></figure>
<p>在此基础上，如果在程序末尾添加如下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(funB)</span><br></pre></td></tr></table></figure>
<p>其输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">装饰器函数的返回值</span><br></pre></td></tr></table></figure>
<p>显然，被“＠函数”修饰的函数不再是原来的函数，而是被替换成一个新的东西（取决于装饰器的返回值），即如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，那么被修饰的函数名依然表示一个函数。<br>实际上，所谓函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。</p>
<h2 id="带参数的函数装饰器"><a href="#带参数的函数装饰器" class="headerlink" title="带参数的函数装饰器"></a>带参数的函数装饰器</h2><p>在分析<code>funA()</code>函数装饰器和<code>funB()</code>函数的关系时，当<code>funB()</code>函数无参数时，可以直接将<code>funB</code>作为<code>funA()</code>的参数传入。但是，如果被修饰的函数本身带有参数，那应该如何传值呢？</p>
<p>比较简单的解决方法就是在函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funA</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="comment"># 定义一个嵌套函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">arc</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Python教程:&quot;</span>,arc)</span><br><span class="line">    <span class="keyword">return</span> say</span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funB</span>(<span class="params">arc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;funB():&quot;</span>, a)</span><br><span class="line">funB(<span class="string">&quot;http://c.biancheng.net/python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>程序执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python教程: http://c.biancheng.net/python</span><br></pre></td></tr></table></figure>
<p>其实，它和如下程序是等价的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funA</span>(<span class="params">fn</span>):</span><br><span class="line">  <span class="comment"># 定义一个嵌套函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">arc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Python教程:&quot;</span>,arc)</span><br><span class="line">  <span class="keyword">return</span> say</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funB</span>(<span class="params">arc</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;funB():&quot;</span>, a)</span><br><span class="line">   </span><br><span class="line">funB = funA(funB)</span><br><span class="line">funB(<span class="string">&quot;http://c.biancheng.net/python&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果运行此程序会发现，它的输出结果和上面程序相同。</p>
<p>显然，通过<code>funB()</code>函数被装饰器<code>funA()</code>修饰，<code>funB</code>就被赋值为<code>say</code>。这意味着，虽然我们在程序显式调用的是<code>funB()</code>函数，但其实执行的是装饰器嵌套的<code>say()</code>函数。</p>
<p>但还有一个问题需要解决，即如果当前程序中，有多个（≥ 2）函数被同一个装饰器函数修饰，这些函数带有的参数个数并不相等，怎么办呢？</p>
<p>最简单的解决方式是用<code>*args</code>和<code>**kwargs</code>作为装饰器内部嵌套函数的参数，<code>*args</code>和<code>**kwargs</code>表示接受任意数量和类型的参数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">funA</span>(<span class="params">fn</span>):</span><br><span class="line">  <span class="comment"># 定义一个嵌套函数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">    fn(*args,**kwargs)</span><br><span class="line">  <span class="keyword">return</span> say</span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">funB</span>(<span class="params">arc</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;百度：&quot;</span>,arc)</span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">other_funB</span>(<span class="params">name,arc</span>):</span><br><span class="line">  <span class="built_in">print</span>(name,arc)</span><br><span class="line">funB(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line">other_funB(<span class="string">&quot;测试：&quot;</span>,<span class="string">&quot;http://www.test.com&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">百度： http://www.baidu.com</span><br><span class="line">测试： http://www.test.com</span><br></pre></td></tr></table></figure>
<h2 id="函数装饰器可以嵌套"><a href="#函数装饰器可以嵌套" class="headerlink" title="函数装饰器可以嵌套"></a>函数装饰器可以嵌套</h2><p>上面示例中，都是使用一个装饰器的情况，但实际上，Python 也支持多个装饰器，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="meta">@funB</span></span><br><span class="line"><span class="meta">@funC</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>上面程序的执行顺序是里到外，所以它等效于下面这行代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun = funA(funB(funC(fun)))</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python字典"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/05/python/Python%E5%AD%97%E5%85%B8/"
    >Python字典</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/05/python/Python%E5%AD%97%E5%85%B8/" class="article-date">
  <time datetime="2022-12-05T07:18:21.000Z" itemprop="datePublished">2022-12-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Python 字典（<code>dict</code>）是一种无序的、可变的序列，它的元素以“键值对（<code>key-value</code>）”的形式存储。相对地，列表（<code>list</code>）和元组（<code>tuple</code>）都是有序的序列，它们的元素在底层是挨着存放的。</p>
<p>字典类型是 Python 中唯一的映射类型。</p>
<p>字典中，习惯将各元素对应的索引称为键（<code>key</code>），各个键对应的元素称为值（<code>value</code>），键及其关联的值称为“键值对”。</p>
<p>总的来说，字典类型所具有的主要特征如表。</p>
<table>
<thead>
<tr>
<th align="center">主要特征</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过键而不是通过索引来读取元素</td>
<td align="center">字典类型有时也称为关联数组或者散列表（hash）。它是通过键将一系列的值联系起来的，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。</td>
</tr>
<tr>
<td align="center">字典是任意数据类型的无序集合</td>
<td align="center">和列表、元组不同，通常会将索引值 0 对应的元素称为第一个元素，而字典中的元素是无序的。</td>
</tr>
<tr>
<td align="center">字典是可变的，并且可以任意嵌套</td>
<td align="center">字典可以在原处增长或者缩短（无需生成一个副本），并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其它的字典。</td>
</tr>
<tr>
<td align="center">字典中的键必须唯一</td>
<td align="center">字典中，不支持同一个键出现多次，否则只会保留最后一个键值对。</td>
</tr>
<tr>
<td align="center">字典中的键必须不可变</td>
<td align="center">字典中每个键值对的键是不可变的，只能使用数字、字符串或者元组，不能使用列表。</td>
</tr>
</tbody></table>
<p>Python 中的字典类型相当于 Java 或者 C++ 中的 Map 对象。</p>
<p>和列表、元组一样，字典也有它自己的类型。Python 中，字典的数据类型为 dict，通过 type() 函数即可查看：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;  <span class="comment">#a是一个字典类型</span></span><br><span class="line"><span class="built_in">type</span>(a) <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h1><h2 id="1-使用-创建字典"><a href="#1-使用-创建字典" class="headerlink" title="1.使用 { } 创建字典"></a>1.使用 { } 创建字典</h2><p>由于字典中每个元素都包含两部分，分别是键（<code>key</code>）和值（<code>value</code>），因此在创建字典时，键和值之间使用冒号<code>:</code>分隔，相邻元素之间使用逗号<code>,</code>分隔，所有元素放在大括号<code>&#123; &#125;</code>中。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictname = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>:<span class="string">&#x27;value2&#x27;</span>, ..., <span class="string">&#x27;keyn&#x27;</span>:valuen&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>dictname</code>表示字典变量名，<code>keyn: valuen</code>表示各个元素的键值对。需要注意的是，同一字典中的各个键必须唯一，不能重复。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用字符串作为key</span></span><br><span class="line">scores = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">84</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(scores) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;英语&#x27;: 92, &#x27;语文&#x27;: 84&#125;</span></span><br><span class="line"><span class="comment">#使用元组和数字作为key</span></span><br><span class="line">dict1 = &#123;(<span class="number">20</span>, <span class="number">30</span>): <span class="string">&#x27;great&#x27;</span>, <span class="number">30</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="built_in">print</span>(dict1) <span class="comment"># &#123;(20, 30): &#x27;great&#x27;, 30: [1, 2, 3]&#125;</span></span><br><span class="line"><span class="comment">#创建空元组</span></span><br><span class="line">dict2 = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(dict2) <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，字典的键可以是整数、字符串或者元组，只要符合唯一和不可变的特性就行；字典的值可以是 Python 支持的任意数据类型。</p>
<h2 id="2-通过-fromkeys-方法创建字典"><a href="#2-通过-fromkeys-方法创建字典" class="headerlink" title="2.通过 fromkeys() 方法创建字典"></a>2.通过 fromkeys() 方法创建字典</h2><p>还可以使用<code>dict</code>字典类型提供的<code>fromkeys()</code>方法创建带有默认值的字典：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictname = <span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>，value=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其中，<code>list</code>参数表示字典中所有键的列表（<code>list</code>）；<code>value</code>参数表示默认值，如果不写，则为空值<code>None</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">knowledge = [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>]</span><br><span class="line">scores = <span class="built_in">dict</span>.fromkeys(knowledge, <span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(scores) <span class="comment"># &#123;&#x27;语文&#x27;: 60, &#x27;英语&#x27;: 60, &#x27;数学&#x27;: 60&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>knowledge</code>列表中的元素全部作为了<code>scores</code>字典的键，而各个键对应的值都是 60。这种创建方式通常用于初始化字典，设置<code>value</code>的默认值。</p>
<h2 id="3-通过-dict-映射函数创建字典"><a href="#3-通过-dict-映射函数创建字典" class="headerlink" title="3.通过 dict() 映射函数创建字典"></a>3.通过 dict() 映射函数创建字典</h2><p>通过<code>dict()</code>函数创建字典的写法有多种，下面列出了常用的几种方式，它们创建的都是同一个字典<code>a</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法1</span></span><br><span class="line"><span class="comment"># str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。</span></span><br><span class="line">a = <span class="built_in">dict</span>(str1=value1, str2=value2, str3=value3)	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2</span></span><br><span class="line"><span class="comment">#方式1</span></span><br><span class="line">demo = [(<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>), (<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>), (<span class="string">&#x27;three&#x27;</span>,<span class="number">3</span>)]</span><br><span class="line"><span class="comment">#方式2</span></span><br><span class="line">demo = [[<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>], [<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>], [<span class="string">&#x27;three&#x27;</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="comment">#方式3</span></span><br><span class="line">demo = ((<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>), (<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>), (<span class="string">&#x27;three&#x27;</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#方式4</span></span><br><span class="line">demo = ([<span class="string">&#x27;two&#x27;</span>,<span class="number">2</span>], [<span class="string">&#x27;one&#x27;</span>,<span class="number">1</span>], [<span class="string">&#x27;three&#x27;</span>,<span class="number">3</span>])</span><br><span class="line">a = <span class="built_in">dict</span>(demo)</span><br><span class="line"><span class="comment"># 向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3</span></span><br><span class="line">keys = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>] <span class="comment">#还可以是字符串或元组</span></span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">#还可以是字符串或元组</span></span><br><span class="line">a = <span class="built_in">dict</span>( <span class="built_in">zip</span>(keys, values) )</span><br><span class="line"><span class="comment"># 通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。</span></span><br></pre></td></tr></table></figure>
<p>注意，无论采用以上哪种方式创建字典，字典中各元素的键都只能是字符串、元组或数字，不能是列表。列表是可变的，不能作为键。</p>
<p>如果不为<code>dict()</code>函数传入任何参数，则代表创建一个空的字典：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空的字典</span></span><br><span class="line">d = <span class="built_in">dict</span>()</span><br><span class="line"><span class="built_in">print</span>(d) <span class="comment"># &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h1><p>列表和元组是通过下标来访问元素的，而字典不同，它通过键来访问对应的值。因为字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictname[key]</span><br></pre></td></tr></table></figure>
<p>其中，<code>dictname</code>表示字典变量的名字，<code>key</code>表示键名。注意，键必须是存在的，否则会抛出异常。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = ([<span class="string">&#x27;two&#x27;</span>,<span class="number">26</span>], [<span class="string">&#x27;one&#x27;</span>,<span class="number">88</span>], [<span class="string">&#x27;three&#x27;</span>,<span class="number">100</span>], [<span class="string">&#x27;four&#x27;</span>,-<span class="number">59</span>])</span><br><span class="line">dic = <span class="built_in">dict</span>(tup)</span><br><span class="line"><span class="built_in">print</span>(dic[<span class="string">&#x27;one&#x27;</span>])  <span class="comment">#键存在</span></span><br><span class="line"><span class="built_in">print</span>(dic[<span class="string">&#x27;five&#x27;</span>])  <span class="comment">#键不存在</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">88</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;C:\Users\mozhiyan\Desktop\demo.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">        print(dic[&#x27;five&#x27;])  #键不存在</span><br><span class="line">KeyError: &#x27;five&#x27;</span><br></pre></td></tr></table></figure>
<p>除了上面这种方式外，Python 更推荐使用<code>dict</code>类型提供的<code>get()</code>方法来获取指定键对应的值。当指定的键不存在时，<code>get()</code>方法不会抛出异常。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictname.get(key[,default])</span><br></pre></td></tr></table></figure>
<p>其中，<code>dictname</code>表示字典变量的名字；<code>key</code>表示指定的键；<code>default</code>用于指定要查询的键不存在时，此方法返回的默认值，如果不手动指定，会返回<code>None</code>。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>(two=<span class="number">0.65</span>, one=<span class="number">88</span>, three=<span class="number">100</span>, four=-<span class="number">59</span>)</span><br><span class="line"><span class="built_in">print</span>( a.get(<span class="string">&#x27;one&#x27;</span>) ) <span class="comment"># 88</span></span><br></pre></td></tr></table></figure>
<p>注意，当键不存在时，<code>get()</code>返回空值<code>None</code>，如果想明确地提示用户该键不存在，那么可以手动设置<code>get()</code>的第二个参数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>(two=<span class="number">0.65</span>, one=<span class="number">88</span>, three=<span class="number">100</span>, four=-<span class="number">59</span>)</span><br><span class="line"><span class="built_in">print</span>( a.get(<span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;该键不存在&#x27;</span>) ) <span class="comment"># 该键不存在</span></span><br></pre></td></tr></table></figure>
<h1 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h1><p>和删除列表、元组一样，手动删除字典也可以使用<code>del</code>关键字：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>(two=<span class="number">0.65</span>, one=<span class="number">88</span>, three=<span class="number">100</span>, four=-<span class="number">59</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;two&#x27;: 0.65, &#x27;one&#x27;: 88, &#x27;three&#x27;: 100, &#x27;four&#x27;: -59&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;C:\Users\mozhiyan\Desktop\demo.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">        print(a)</span><br><span class="line">NameError: name &#x27;a&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>Python 自带垃圾回收功能，会自动销毁不用的字典，所以一般不需要通过<code>del</code>来手动删除。</p>
<h1 id="字典基本操作"><a href="#字典基本操作" class="headerlink" title="字典基本操作"></a>字典基本操作</h1><p>由于字典属于可变序列，所以我们可以任意操作字典中的键值对。Python 中，常见的字典操作有以下几种：</p>
<ul>
<li>向现有字典中添加新的键值对。</li>
<li>修改现有字典中的键值对。</li>
<li>从现有字典中删除指定的键值对。</li>
<li>判断现有字典中是否存在指定的键值对。</li>
</ul>
<p>字典是由一个一个的<code>key-value</code>构成的，<code>key</code>是找到数据的关键，Python 对字典的操作都是通过<code>key</code>来完成的。</p>
<h2 id="字典添加键值对"><a href="#字典添加键值对" class="headerlink" title="字典添加键值对"></a>字典添加键值对</h2><p>为字典添加新的键值对很简单，直接给不存在的<code>key</code>赋值即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictname[key] = value</span><br></pre></td></tr></table></figure>
<p>对各个部分的说明：</p>
<ul>
<li><code>dictname</code>表示字典名称。</li>
<li><code>key</code>表示新的键。</li>
<li><code>value</code>表示新的值，只要是 Python 支持的数据类型都可以。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>:<span class="number">95</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95&#125;</span></span><br><span class="line"><span class="comment">#添加新键值对</span></span><br><span class="line">a[<span class="string">&#x27;语文&#x27;</span>] = <span class="number">89</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89&#125;</span></span><br><span class="line"><span class="comment">#再次添加新键值对</span></span><br><span class="line">a[<span class="string">&#x27;英语&#x27;</span>] = <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="字典修改键值对"><a href="#字典修改键值对" class="headerlink" title="字典修改键值对"></a>字典修改键值对</h2><p>Python 字典中键（<code>key</code>）的名字不能被修改，我们只能修改值（<code>value</code>）。</p>
<p>字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span></span><br><span class="line">a[<span class="string">&#x27;语文&#x27;</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 100, &#x27;英语&#x27;: 90&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，字典中没有再添加一个<code>&#123;&#39;语文&#39;:100&#125;</code>键值对，而是对原有键值对<code>&#123;&#39;语文&#39;: 89&#125;</code>中的<code>value</code>做了修改。</p>
<h2 id="Python字典删除键值对"><a href="#Python字典删除键值对" class="headerlink" title="Python字典删除键值对"></a>Python字典删除键值对</h2><p>如果要删除字典中的键值对，还是可以使用<code>del</code>语句。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用del语句删除键值对</span></span><br><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;语文&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="string">&#x27;数学&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;英语&#x27;: 90&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="判断字典中是否存在指定键值对"><a href="#判断字典中是否存在指定键值对" class="headerlink" title="判断字典中是否存在指定键值对"></a>判断字典中是否存在指定键值对</h2><p>如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用<code>in</code>或<code>not in</code>运算符。<br>需要指出的是，对于<code>dict</code>而言，<code>in</code>或<code>not in</code>运算符都是基于<code>key</code>来判断的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="comment"># 判断 a 中是否包含名为&#x27;数学&#x27;的key</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> a) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 判断 a 是否包含名为&#x27;物理&#x27;的key</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;物理&#x27;</span> <span class="keyword">in</span> a) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>通过<code>in</code>（或<code>not in</code>）运算符，我们可以很轻易地判断出现有字典中是否包含某个键，如果存在，由于通过键可以很轻易的获取对应的值，因此很容易就能判断出字典中是否有指定的键值对。</p>
<h1 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h1><p>字典的数据类型为<code>dict</code>，我们可使用<code>dir(dict)</code>来查看该类型包含哪些方法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>(<span class="built_in">dict</span>)</span><br><span class="line">[<span class="string">&#x27;clear&#x27;</span>, <span class="string">&#x27;copy&#x27;</span>, <span class="string">&#x27;fromkeys&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;items&#x27;</span>, <span class="string">&#x27;keys&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;popitem&#x27;</span>, <span class="string">&#x27;setdefault&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;values&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="keys-、values-和-items-方法"><a href="#keys-、values-和-items-方法" class="headerlink" title="keys()、values() 和 items() 方法"></a>keys()、values() 和 items() 方法</h2><p>这三个方法都用来获取字典中的特定数据：</p>
<ul>
<li><code>keys()</code>方法用于返回字典中的所有键（<code>key</code>）；</li>
<li><code>values()</code>方法用于返回字典中所有键对应的值（<code>value</code>）；</li>
<li><code>items()</code>用于返回字典中所有的键值对（<code>key-value</code>）。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(scores.keys()) <span class="comment"># dict_keys([&#x27;数学&#x27;, &#x27;语文&#x27;, &#x27;英语&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(scores.values()) <span class="comment"># dict_values([95, 89, 90])</span></span><br><span class="line"><span class="built_in">print</span>(scores.items()) <span class="comment"># dict_items([(&#x27;数学&#x27;, 95), (&#x27;语文&#x27;, 89), (&#x27;英语&#x27;, 90)])</span></span><br></pre></td></tr></table></figure>
<p>可以发现，<code>keys()、values()</code>和<code>items()</code>返回值的类型分别为<code>dict_keys、dict_values</code>和<code>dict_items</code>。</p>
<p>需要注意的是，它们的返回值并不是我们常见的列表或者元组类型，因为 Python 3.x 不希望用户直接操作这几个方法的返回值。</p>
<p>如果想使用这三个方法返回的数据，一般有下面两种方案：</p>
<ol>
<li>使用<code>list()</code>函数，将它们返回的数据转换成列表：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line">b = <span class="built_in">list</span>(a.keys())</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># [&#x27;数学&#x27;, &#x27;语文&#x27;, &#x27;英语&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li>使用<code>for in</code>循环遍历它们的返回值：<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> a.keys():</span><br><span class="line">    <span class="built_in">print</span>(k,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n---------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a.values():</span><br><span class="line">    <span class="built_in">print</span>(v,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n---------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> a.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;key:&quot;</span>,k,<span class="string">&quot; value:&quot;</span>,v)</span><br></pre></td></tr></table></figure>
运行结果为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数学 语文 英语</span><br><span class="line">---------------</span><br><span class="line">95 89 90</span><br><span class="line">---------------</span><br><span class="line">key: 数学  value: 95</span><br><span class="line">key: 语文  value: 89</span><br><span class="line">key: 英语  value: 90</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="copy-方法"><a href="#copy-方法" class="headerlink" title="copy() 方法"></a>copy() 方法</h2><p><code>copy()</code>方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: [1, 2, 3]&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>copy()</code>方法将字典<code>a</code>的数据全部拷贝给了字典<code>b</code>。</p>
<p>注意，<code>copy()</code>方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。拿拷贝字典<code>a</code>为例，<code>copy()</code>方法只会对最表层的键值对进行深拷贝，也就是说，它会再申请一块内存用来存放<code>&#123;&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: []&#125;</code>；而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，<code>b</code>中的<code>[1,2,3]</code>的值不是自己独有，而是和<code>a</code>共有。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line"><span class="comment">#向 a 中添加新键值对，由于b已经提前将 a 所有键值对都深拷贝过来，因此 a 添加新键值对，不会影响 b。</span></span><br><span class="line">a[<span class="string">&#x27;four&#x27;</span>]=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: [1, 2, 3], &#x27;four&#x27;: 100&#125;</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: [1, 2, 3]&#125;</span></span><br><span class="line"><span class="comment">#由于 b 和 a 共享[1,2,3]（浅拷贝），因此移除 a 中列表中的元素，也会影响 b。</span></span><br><span class="line">a[<span class="string">&#x27;three&#x27;</span>].remove(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: [2, 3], &#x27;four&#x27;: 100&#125;</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: [2, 3]&#125;</span></span><br></pre></td></tr></table></figure>
<p>从运行结果不难看出，对<code>a</code>增加新键值对，<code>b</code>不变；而修改<code>a</code>某键值对中列表内的元素，<code>b</code>也会相应改变。</p>
<h2 id="update-方法"><a href="#update-方法" class="headerlink" title="update() 方法"></a>update() 方法</h2><p><code>update()</code>方法可以使用一个字典所包含的键值对来更新己有的字典。</p>
<p>在执行<code>update()</code>方法时，如果被更新的字典中己包含对应的键值对，那么原<code>value</code>会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">a.update(&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">4.5</span>, <span class="string">&#x27;four&#x27;</span>: <span class="number">9.3</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;one&#x27;: 4.5, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3, &#x27;four&#x27;: 9.3&#125;</span></span><br></pre></td></tr></table></figure>
<p>从运行结果可以看出，由于被更新的字典中已包含<code>key</code>为<code>one</code>的键值对，因此更新时该键值对的<code>value</code>将被改写；而被更新的字典中不包含<code>key</code>为<code>four</code>的键值对，所以更新时会为原字典增加一个新的键值对。</p>
<h2 id="pop-和-popitem-方法"><a href="#pop-和-popitem-方法" class="headerlink" title="pop() 和 popitem() 方法"></a>pop() 和 popitem() 方法</h2><p><code>pop()</code>和<code>popitem()</code>都用来删除字典中的键值对，不同的是，<code>pop()</code>用来删除指定的键值对，而<code>popitem()</code>用来随机删除一个键值对：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictname.pop(key)</span><br><span class="line">dictname.popitem()</span><br></pre></td></tr></table></figure>
<p>其中，<code>dictname</code>表示字典名称，<code>key</code>表示键。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;化学&#x27;</span>: <span class="number">83</span>, <span class="string">&#x27;生物&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;物理&#x27;</span>: <span class="number">89</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90, &#x27;化学&#x27;: 83, &#x27;生物&#x27;: 98, &#x27;物理&#x27;: 89&#125;</span></span><br><span class="line">a.pop(<span class="string">&#x27;化学&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90, &#x27;生物&#x27;: 98, &#x27;物理&#x27;: 89&#125;</span></span><br><span class="line">a.popitem()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90, &#x27;生物&#x27;: 98&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="对-popitem-的说明"><a href="#对-popitem-的说明" class="headerlink" title="对 popitem() 的说明"></a>对 popitem() 的说明</h3><p>其实，说<code>popitem()</code>随机删除字典中的一个键值对是不准确的，虽然字典是一种无须的列表，但键值对在底层也是有存储顺序的，<code>popitem()</code>总是弹出底层中的最后一个<code>key-value</code>，这和列表的<code>pop()</code>方法类似，都实现了数据结构中“出栈”的操作。</p>
<h2 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault() 方法"></a>setdefault() 方法</h2><p><code>setdefault()</code>方法用来返回某个<code>key</code>对应的<code>value</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dictname.setdefault(key, defaultvalue)</span><br></pre></td></tr></table></figure>
<p>说明，<code>dictname</code>表示字典名称，<code>key</code>表示键，<code>defaultvalue</code>表示默认值（可以不写，不写的话是<code>None</code>）。</p>
<p>当指定的<code>key</code>不存在时，<code>setdefault()</code>会先为这个不存在的<code>key</code>设置一个默认的<code>defaultvalue</code>，然后再返回<code>defaultvalue</code>。</p>
<p>也就是说，<code>setdefault()</code>方法总能返回指定<code>key</code>对应的<code>value</code>：</p>
<ul>
<li>如果该<code>key</code>存在，那么直接返回该<code>key</code>对应的<code>value</code>；</li>
<li>如果该<code>key</code>不存在，那么先为该<code>key</code>设置默认的<code>defaultvalue</code>，然后再返回该<code>key</code>对应的<code>defaultvalue</code>。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span></span><br><span class="line"><span class="comment">#key不存在，指定默认值</span></span><br><span class="line">a.setdefault(<span class="string">&#x27;物理&#x27;</span>, <span class="number">94</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90, &#x27;物理&#x27;: 94&#125;</span></span><br><span class="line"><span class="comment">#key不存在，不指定默认值</span></span><br><span class="line">a.setdefault(<span class="string">&#x27;化学&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90, &#x27;物理&#x27;: 94, &#x27;化学&#x27;: None&#125;</span></span><br><span class="line"><span class="comment">#key存在，指定默认值</span></span><br><span class="line">a.setdefault(<span class="string">&#x27;数学&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90, &#x27;物理&#x27;: 94, &#x27;化学&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-python/Python元组"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/12/04/python/Python%E5%85%83%E7%BB%84/"
    >Python元组</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/12/04/python/Python%E5%85%83%E7%BB%84/" class="article-date">
  <time datetime="2022-12-04T07:18:21.000Z" itemprop="datePublished">2022-12-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>元组（<code>tuple</code>）是 Python 中另一个重要的序列结构，和列表类似，元组也是由一系列按特定顺序排序的元素组成。</p>
<p>元组和列表的不同之处在于：</p>
<ul>
<li>列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；</li>
<li>而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。</li>
</ul>
<p>元组也可以看做是不可变的列表，通常情况下，元组用于保存无需修改的内容。</p>
<p>从形式上看，元组的所有元素都放在一对小括号( )中，相邻元素之间用逗号,分隔，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(element1, element2, ... , elementn)</span><br></pre></td></tr></table></figure>
<p>其中<code>element1~elementn</code>表示元组中的各个元素，个数没有限制，只要是 Python 支持的数据类型就可以。</p>
<p>从存储内容上看，元组可以存储整数、实数、字符串、列表、元组等任何类型的数据，并且在同一个元组中，元素的类型可以不同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">1</span>, [<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>], (<span class="string">&quot;abc&quot;</span>,<span class="number">3.0</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>( (<span class="string">&quot;www.baidu.com&quot;</span>,<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>],(<span class="string">&quot;abc&quot;</span>,<span class="number">3.0</span>)) ) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，元组是<code>tuple</code>类型。</p>
<h1 id="Python创建元组"><a href="#Python创建元组" class="headerlink" title="Python创建元组"></a>Python创建元组</h1><p>Python 提供了两种创建元组的方法。</p>
<h2 id="使用-直接创建"><a href="#使用-直接创建" class="headerlink" title="使用 ( ) 直接创建"></a>使用 ( ) 直接创建</h2><p>通过<code>( )</code>创建元组后，一般使用<code>=</code>将它赋值给某个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuplename = (element1, element2, ..., elementn)</span><br></pre></td></tr></table></figure>
<p>其中，<code>tuplename</code>表示变量名，<code>element1 ~ elementn</code>表示元组的元素。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = (<span class="number">7</span>, <span class="number">14</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">35</span>)</span><br><span class="line">abc = ( <span class="string">&quot;Python&quot;</span>, <span class="number">19</span>, [<span class="number">1</span>,<span class="number">2</span>], (<span class="string">&#x27;c&#x27;</span>,<span class="number">2.0</span>) )</span><br></pre></td></tr></table></figure>
<p>在 Python 中，元组通常都是使用一对小括号将所有元素包围起来的，但小括号不是必须的，只要将各元素用逗号隔开，Python 就会将其视为元组。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">course = <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"><span class="built_in">print</span>(course) <span class="comment"># (&#x27;小明&#x27;, &#x27;xiaoming&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号<code>,</code>，否则 Python 解释器会将它视为字符串。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最后加上逗号</span></span><br><span class="line">a =(<span class="string">&quot;cplus&quot;</span>,)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment"># (&#x27;cplus&#x27;,)</span></span><br><span class="line"><span class="comment">#最后不加逗号</span></span><br><span class="line">b = (<span class="string">&quot;socket&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b)) <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># socket</span></span><br></pre></td></tr></table></figure>
<h2 id="使用tuple-函数创建元组"><a href="#使用tuple-函数创建元组" class="headerlink" title="使用tuple()函数创建元组"></a>使用tuple()函数创建元组</h2><p>除了使用<code>( )</code>创建元组外，Python 还提供了一个内置的函数<code>tuple()</code>，用来将其它数据类型转换为元组类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple(data)</span><br></pre></td></tr></table></figure>
<p>其中，<code>data</code>表示可以转化为元组的数据，包括字符串、元组、<code>range</code>对象等。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将字符串转换成元组</span></span><br><span class="line">tup1 = <span class="built_in">tuple</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1) <span class="comment"># (&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)</span></span><br><span class="line"><span class="comment">#将列表转换成元组</span></span><br><span class="line">list1 = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>]</span><br><span class="line">tup2 = <span class="built_in">tuple</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(tup2) <span class="comment"># (&#x27;Python&#x27;, &#x27;Java&#x27;, &#x27;C++&#x27;, &#x27;JavaScript&#x27;)</span></span><br><span class="line"><span class="comment">#将字典转换成元组</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">42</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line">tup3 = <span class="built_in">tuple</span>(dict1)</span><br><span class="line"><span class="built_in">print</span>(tup3) <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br><span class="line"><span class="comment">#将区间转换成元组</span></span><br><span class="line">range1 = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">tup4 = <span class="built_in">tuple</span>(range1)</span><br><span class="line"><span class="built_in">print</span>(tup4) <span class="comment"># (1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="comment">#创建空元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>()) <span class="comment"># ()</span></span><br></pre></td></tr></table></figure>
<h1 id="访问元组元素"><a href="#访问元组元素" class="headerlink" title="访问元组元素"></a>访问元组元素</h1><p>和列表一样，我们可以使用索引（<code>Index</code>）访问元组中的某个元素（得到的是一个元素的值），也可以使用切片访问元组中的一组元素（得到的是一个新的子元组）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuplename[i]</span><br></pre></td></tr></table></figure>
<p>其中，<code>tuplename</code>表示元组名字，<code>i</code>表示索引值。元组的索引可以是正数，也可以是负数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuplename[start : end : step]</span><br></pre></td></tr></table></figure>
<p>其中，<code>start</code>表示起始索引，<code>end</code>表示结束索引，<code>step</code>表示步长。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="built_in">tuple</span>(<span class="string">&quot;http://c.biancheng.net/shell/&quot;</span>)</span><br><span class="line"><span class="comment">#使用索引访问元组中的某个元素</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">3</span>])  <span class="comment">#使用正数索引</span></span><br><span class="line"><span class="built_in">print</span>(url[-<span class="number">4</span>])  <span class="comment">#使用负数索引</span></span><br><span class="line"><span class="comment">#使用切片访问元组中的一组元素</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">9</span>: <span class="number">18</span>])  <span class="comment">#使用正数切片</span></span><br><span class="line"><span class="built_in">print</span>(url[<span class="number">9</span>: <span class="number">18</span>: <span class="number">3</span>])  <span class="comment">#指定步长</span></span><br><span class="line"><span class="built_in">print</span>(url[-<span class="number">6</span>: -<span class="number">1</span>])  <span class="comment">#使用负数切片</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">e</span><br><span class="line">(&#x27;b&#x27;, &#x27;i&#x27;, &#x27;a&#x27;, &#x27;n&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;g&#x27;)</span><br><span class="line">(&#x27;b&#x27;, &#x27;n&#x27;, &#x27;e&#x27;)</span><br><span class="line">(&#x27;s&#x27;, &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;)</span><br></pre></td></tr></table></figure>
<h1 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h1><p>元组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">100</span>, <span class="number">0.5</span>, -<span class="number">36</span>, <span class="number">73</span>)</span><br><span class="line"><span class="built_in">print</span>(tup) <span class="comment"># (100, 0.5, -36, 73)</span></span><br><span class="line"><span class="comment">#对元组进行重新赋值</span></span><br><span class="line">tup = (<span class="string">&#x27;小明&#x27;</span>,<span class="string">&quot;xiaoming&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup) <span class="comment"># (&#x27;小明&#x27;,&quot;xiaoming&quot;)</span></span><br></pre></td></tr></table></figure>
<p>另外，还可以通过连接多个元组（使用+可以拼接元组）的方式向元组中添加新元素：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">100</span>, <span class="number">0.5</span>, -<span class="number">36</span>, <span class="number">73</span>)</span><br><span class="line">tup2 = (<span class="number">3</span>+<span class="number">12j</span>, -<span class="number">54.6</span>, <span class="number">99</span>)</span><br><span class="line"><span class="built_in">print</span>(tup1+tup2) <span class="comment"># (100, 0.5, -36, 73, (3+12j), -54.6, 99)</span></span><br><span class="line"><span class="built_in">print</span>(tup1) <span class="comment"># (100, 0.5, -36, 73)</span></span><br><span class="line"><span class="built_in">print</span>(tup2) <span class="comment"># ((3+12j), -54.6, 99)</span></span><br></pre></td></tr></table></figure>
<p>你看，使用<code>+</code>拼接元组以后，<code>tup1</code>和<code>tup2</code>的内容没法发生改变，这说明生成的是一个新的元组。</p>
<h1 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h1><p>可以通过<code>del</code>关键字将其删除：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="string">&#x27;百度&#x27;</span>, <span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br><span class="line"><span class="keyword">del</span> tup</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;百度&#x27;, &quot;http://www.baidu.com/&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File &quot;C:\Users\mozhiyan\Desktop\demo.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">        print(tup)</span><br><span class="line">NameError: name &#x27;tup&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>Python 自带垃圾回收功能，会自动销毁不用的元组，所以一般不需要通过<code>del</code>来手动删除。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/6/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>