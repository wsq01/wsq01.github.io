<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-SQL/SQL 视图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/12/SQL/SQL%20%E8%A7%86%E5%9B%BE/"
    >SQL 视图</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/12/SQL/SQL%20%E8%A7%86%E5%9B%BE/" class="article-date">
  <time datetime="2020-02-12T03:44:31.000Z" itemprop="datePublished">2020-02-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>视图，也就是虚拟表，本身是不具有数据的，它是 SQL 中的一个重要概念。从下面这张图中，你能看到，虚拟表的创建连接了一个或多个数据表，不同的查询应用都可以建立在虚拟表之上。</p>
<img src="/2020/02/12/SQL/SQL%20%E8%A7%86%E5%9B%BE/img1.jpeg" class="">

<p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。</p>
<h1 id="如何创建，更新和删除视图"><a href="#如何创建，更新和删除视图" class="headerlink" title="如何创建，更新和删除视图"></a>如何创建，更新和删除视图</h1><p>视图作为一张虚拟表，帮我们封装了底层与数据表的接口。它相当于是一张表或多张表的数据结果集。视图的这一特点，可以帮我们简化复杂的 SQL 查询，比如在编写视图后，我们就可以直接重用它，而不需要考虑视图中包含的基础查询的细节。同样，我们也可以根据需要更改数据格式，返回与底层数据表格式不同的数据。</p>
<p>通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p>
<h2 id="创建视图：CREATE-VIEW"><a href="#创建视图：CREATE-VIEW" class="headerlink" title="创建视图：CREATE VIEW"></a>创建视图：CREATE VIEW</h2><p>创建视图的语法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>
<p>实际上就是我们在 SQL 查询语句的基础上封装了视图<code>VIEW</code>，这样就会基于 SQL 语句的结果集形成一张虚拟表。其中<code>view_name</code>为视图名称，<code>column1、column2</code>代表列名，<code>condition</code>代表查询过滤条件。</p>
<p>我们以 NBA 球员数据表为例。我们想要查询比 NBA 球员平均身高高的球员都有哪些，显示他们的球员<code>ID</code>和身高。假设我们给这个视图起个名字<code>player_above_avg_height</code>，那么创建视图可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_above_avg_height <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> player_id, height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(height) <span class="keyword">from</span> player)</span><br></pre></td></tr></table></figure>
<p>视图查询结果（18 条记录）：</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">height</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10003</td>
<td align="center">2.11</td>
</tr>
<tr>
<td align="center">10004</td>
<td align="center">2.16</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10037</td>
<td align="center">2.08</td>
</tr>
</tbody></table>
<p>当视图创建之后，它就相当于一个虚拟表，可以直接使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player_above_avg_height</span><br></pre></td></tr></table></figure>
<p>运行结果和上面一样。</p>
<h2 id="嵌套视图"><a href="#嵌套视图" class="headerlink" title="嵌套视图"></a>嵌套视图</h2><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图，比如我们想在虚拟表<code>player_above_avg_height</code>的基础上，找到比这个表中的球员平均身高高的球员，作为新的视图<code>player_above_above_avg_height</code>，那么可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_above_above_avg_height <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> player_id, height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(height) <span class="keyword">from</span> player_above_avg_height)</span><br></pre></td></tr></table></figure>
<p>视图查询结果（11 条记录）：</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">height</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10003</td>
<td align="center">2.11</td>
</tr>
<tr>
<td align="center">10004</td>
<td align="center">2.16</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10037</td>
<td align="center">2.08</td>
</tr>
</tbody></table>
<p>你能看到这个视图的数据记录数为 11 个，比之前的记录少了 7 个。</p>
<h2 id="修改视图：ALTER-VIEW"><a href="#修改视图：ALTER-VIEW" class="headerlink" title="修改视图：ALTER VIEW"></a>修改视图：ALTER VIEW</h2><p>修改视图的语法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>
<p>你能看出来它的语法和创建视图一样，只是对原有视图的更新。比如我们想更新视图<code>player_above_avg_height</code>，增加一个<code>player_name</code>字段，可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> player_above_avg_height <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> player_id, player_name, height</span><br><span class="line"><span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(height) <span class="keyword">from</span> player)</span><br></pre></td></tr></table></figure>
<p>这样的话，下次再对视图进行查询的时候，视图结果就进行了更新。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player_above_avg_height</span><br></pre></td></tr></table></figure>
<p>运行结果（18 条记录）：</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">player_name</th>
<th align="center">height</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10003</td>
<td align="center">安德烈·德拉蒙德</td>
<td align="center">2.11</td>
</tr>
<tr>
<td align="center">10004</td>
<td align="center">索恩·马克</td>
<td align="center">2.16</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10037</td>
<td align="center">伊凯·阿尼博古</td>
<td align="center">2.08</td>
</tr>
</tbody></table>
<h2 id="删除视图：DROP-VIEW"><a href="#删除视图：DROP-VIEW" class="headerlink" title="删除视图：DROP VIEW"></a>删除视图：DROP VIEW</h2><p>删除视图的语法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> view_name</span><br></pre></td></tr></table></figure>
<p>比如我们想把刚才创建的视图删除，可以使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> player_above_avg_height</span><br></pre></td></tr></table></figure>
<p>需要说明的是，SQLite 不支持视图的修改，仅支持只读视图，也就是说你只能使用<code>CREATE VIEW</code>和<code>DROP VIEW</code>，如果想要修改视图，就需要先<code>DROP</code>然后再<code>CREATE</code>。</p>
<h1 id="如何使用视图简化-SQL-操作"><a href="#如何使用视图简化-SQL-操作" class="headerlink" title="如何使用视图简化 SQL 操作"></a>如何使用视图简化 SQL 操作</h1><p>从上面这个例子中，你能看出视图就是对<code>SELECT</code>语句进行了封装，方便我们重用它们。下面我们再来看几个视图使用的例子。</p>
<h2 id="利用视图完成复杂的连接"><a href="#利用视图完成复杂的连接" class="headerlink" title="利用视图完成复杂的连接"></a>利用视图完成复杂的连接</h2><p>举一个 NBA 球员和身高等级连接的例子，有两张表，分别为<code>player</code>和<code>height_grades</code>。其中<code>height_grades</code>记录了不同身高对应的身高等级。这里我们可以通过创建视图，来完成球员以及对应身高等级的查询。</p>
<p>首先我们对<code>player</code>表和<code>height_grades</code>表进行连接，关联条件是球员的身高<code>height</code>（在身高等级表规定的最低身高和最高身高之间），这样就可以得到这个球员对应的身高等级，对应的字段为<code>height_level</code>。然后我们通过<code>SELECT</code>得到我们想要查询的字段，分别为球员姓名<code>player_name</code>、球员身高<code>height</code>，还有对应的身高等级<code>height_level</code>。然后把取得的查询结果集放到视图<code>player_height_grades</code>中，即：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_height_grades <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> p.player_name, p.height, h.height_level</span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">as</span> p <span class="keyword">JOIN</span> height_grades <span class="keyword">as</span> h</span><br><span class="line"><span class="keyword">ON</span> height <span class="keyword">BETWEEN</span> h.height_lowest <span class="keyword">AND</span> h.height_highest</span><br></pre></td></tr></table></figure>
<p>运行结果（37 条记录）：</p>
<table>
<thead>
<tr>
<th align="center"><code>player_name</code></th>
<th align="center"><code>height</code></th>
<th align="center"><code>height_level</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">韦恩·艾灵顿</td>
<td align="center">1.93</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">雷吉·杰克逊</td>
<td align="center">1.91</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">伊凯·阿尼博古</td>
<td align="center">2.08</td>
<td align="center">A</td>
</tr>
</tbody></table>
<p>以后我们进行查询的时候，可以直接通过视图查询，比如我想查询身高介于<code>1.90m</code>和<code>2.08m</code>之间的球员及他们对应的身高：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player_height_grades <span class="keyword">WHERE</span> height <span class="operator">&gt;=</span> <span class="number">1.90</span> <span class="keyword">AND</span> height <span class="operator">&lt;=</span> <span class="number">2.08</span></span><br></pre></td></tr></table></figure>
<p>运行结果（26 条记录）：</p>
<table>
<thead>
<tr>
<th align="center"><code>player_name</code></th>
<th align="center"><code>height</code></th>
<th align="center"><code>height_level</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">韦恩·艾灵顿</td>
<td align="center">1.93</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">雷吉·杰克逊</td>
<td align="center">1.91</td>
<td align="center">B</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">伊凯·阿尼博古</td>
<td align="center">2.08</td>
<td align="center">A</td>
</tr>
</tbody></table>
<p>这样就把一个相对复杂的连接查询转化成了视图查询。</p>
<h1 id="利用视图对数据进行格式化"><a href="#利用视图对数据进行格式化" class="headerlink" title="利用视图对数据进行格式化"></a>利用视图对数据进行格式化</h1><p>我们经常需要输出某个格式的内容，比如我们想输出球员姓名和对应的球队，对应格式为<code>player_name(team_name)</code>，就可以使用视图来完成数据格式化的操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> player_team <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(player_name, <span class="string">&#x27;(&#x27;</span> , team.team_name , <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> player_team <span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">WHERE</span> player.team_id <span class="operator">=</span> team.team_id</span><br></pre></td></tr></table></figure>
<p>首先我们将<code>player</code>表和<code>team</code>表进行连接，关联条件是相同的<code>team_id</code>。我们想要的格式是<code>player_name(team_name)</code>，因此我们使用<code>CONCAT</code>函数，即<code>CONCAT(player_name, &#39;(&#39; , team.team_name , &#39;)&#39;)</code>，将<code>player_name</code>字段和<code>team_name</code>字段进行拼接，得到了拼接值被命名为<code>player_team</code>的字段名，将它放到视图<code>player_team</code>中。</p>
<p>这样的话，我们直接查询视图，就可以得到格式化后的结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player_team</span><br></pre></td></tr></table></figure>
<p>运行结果（37 条记录）：</p>
<table>
<thead>
<tr>
<th align="center"><code>player_team</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">韦恩·艾灵顿(底特律活塞)</td>
</tr>
<tr>
<td align="center">雷吉·杰克逊(底特律活塞)</td>
</tr>
<tr>
<td align="center">…</td>
</tr>
<tr>
<td align="center">安德烈·德拉蒙德(底特律活塞)</td>
</tr>
</tbody></table>
<h1 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h1><p>我们在数据查询中，有很多统计的需求可以通过视图来完成。正确地使用视图可以帮我们简化复杂的数据处理。</p>
<p>我以球员比赛成绩表为例，对应的是<code>player_score</code>表。这张表中一共有 19 个字段，它们代表的含义如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">game_id <br> 比赛ID</td>
<td align="center">player_id <br> 球员ID</td>
<td align="center">is_first <br> 是否首发</td>
<td align="center">playing_time <br> 出场时间</td>
</tr>
<tr>
<td align="center">rebound <br> 篮板球</td>
<td align="center">rebound_o <br> 前场篮板</td>
<td align="center">rebound_d <br> 后场篮板</td>
<td align="center">assist <br> 助攻</td>
</tr>
<tr>
<td align="center">score <br> 比分</td>
<td align="center">steal <br> 抢断</td>
<td align="center">blockshot <br> 盖帽</td>
<td align="center">fault <br> 失误</td>
</tr>
<tr>
<td align="center">foul <br> 犯规</td>
<td align="center">shoot_attempts <br> 出手</td>
<td align="center">shoot_hits <br> 命中</td>
<td align="center">shoot_3_attempts 3分出手</td>
</tr>
<tr>
<td align="center">shoot_3_hits <br> 3分命中</td>
<td align="center">shoot_p_appempts <br> 罚球出手</td>
<td align="center">shoot_p_hits <br> 罚球命中</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果我想要统计每位球员在每场比赛中的二分球、三分球和罚球的得分，可以通过创建视图完成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> game_player_score <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> game_id, player_id, (shoot_hits<span class="operator">-</span>shoot_3_hits)<span class="operator">*</span><span class="number">2</span> <span class="keyword">AS</span> shoot_2_points, shoot_3_hits<span class="operator">*</span><span class="number">3</span> <span class="keyword">AS</span> shoot_3_points, shoot_p_hits <span class="keyword">AS</span> shoot_p_points, score  <span class="keyword">FROM</span> player_score</span><br></pre></td></tr></table></figure>
<p>然后通过查询视图就可以完成。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> game_player_score</span><br></pre></td></tr></table></figure>
<p>运行结果（19 条记录）：</p>
<table>
<thead>
<tr>
<th align="center">game_id</th>
<th align="center">player_id</th>
<th align="center">shoot_2_points</th>
<th align="center">shoot_3_points</th>
<th align="center">shoot_p_points</th>
<th align="center">score</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10001</td>
<td align="center">10001</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">2</td>
<td align="center">26</td>
</tr>
<tr>
<td align="center">10001</td>
<td align="center">10002</td>
<td align="center">14</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">10001</td>
<td align="center">10003</td>
<td align="center">16</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">18</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10002</td>
<td align="center">10032</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>你能看出正确使用视图可以简化复杂的 SQL 查询，让 SQL 更加清爽易用。不过有一点需要注意，视图是虚拟表，它只是封装了底层的数据表查询接口，因此有些 RDBMS 不支持对视图创建索引（有些 RDBMS 则支持，比如新版本的 SQL Server）。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用视图有很多好处，比如安全、简单清晰。</p>
<ul>
<li>安全性：虚拟表是基于底层数据表的，我们在使用视图时，一般不会轻易通过视图对底层数据进行修改，即使是使用单表的视图，也会受到限制，比如计算字段，类型转换等是无法通过视图来对底层数据进行修改的，这也在一定程度上保证了数据表的数据安全性。同时，我们还可以针对不同用户开放不同的数据查询权限，比如人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</li>
<li>简单清晰：视图是对 SQL 查询的封装，它可以将原本复杂的 SQL 查询简化，在编写好查询之后，我们就可以直接重用它而不必要知道基本的查询细节。同时我们还可以在视图之上再嵌套视图。这样就好比我们在进行模块化编程一样，不仅结构清晰，还提升了代码的复用率。</li>
</ul>
<p>另外，我们也需要了解到视图是虚拟表，本身不存储数据，如果想要通过视图对底层数据表的数据进行修改也会受到很多限制，通常我们是把视图用于查询，也就是对 SQL 查询的一种封装。那么它和临时表又有什么区别呢？在实际工作中，我们可能会见到各种临时数据。比如你可能会问，如果我在做一个电商的系统，中间会有个购物车的功能，需要临时统计购物车中的商品和金额，那该怎么办呢？这里就需要用到临时表了，临时表是真实存在的数据表，不过它不用于长期存放数据，只为当前连接存在，关闭连接后，临时表就会自动释放。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL子查询"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/08/SQL/SQL%E5%AD%90%E6%9F%A5%E8%AF%A2/"
    >SQL 子查询</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/08/SQL/SQL%E5%AD%90%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time datetime="2020-02-08T07:14:53.000Z" itemprop="datePublished">2020-02-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是关联子查询，什么是非关联子查询"><a href="#什么是关联子查询，什么是非关联子查询" class="headerlink" title="什么是关联子查询，什么是非关联子查询"></a>什么是关联子查询，什么是非关联子查询</h1><p>子查询虽然是一种嵌套查询的形式，不过我们依然可以依据子查询是否执行多次，从而将子查询划分为关联子查询和非关联子查询。</p>
<p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做非关联子查询。</p>
<p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为关联子查询。</p>
<p>单说概念有点抽象，我们用数据表举例说明一下。这里我创建了 NBA 球员数据库，SQL 文件你可以从<a target="_blank" rel="noopener" href="https://github.com/cystanford/sql_nba_data">GitHub上下载</a>。</p>
<p>文件中一共包括了 5 张表，<code>player</code>表为球员表，<code>team</code>为球队表，<code>team_score</code>为球队比赛表，<code>player_score</code>为球员比赛成绩表，<code>height_grades</code>为球员身高对应的等级表。</p>
<p>其中<code>player</code>表，也就是球员表，一共有 37 个球员，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">team_id</th>
<th align="center">player_name</th>
<th align="center">height</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10001</td>
<td align="center">1001</td>
<td align="center">韦恩·艾灵顿</td>
<td align="center">1.93</td>
</tr>
<tr>
<td align="center">10002</td>
<td align="center">1001</td>
<td align="center">雷吉·杰克逊</td>
<td align="center">1.91</td>
</tr>
<tr>
<td align="center">10003</td>
<td align="center">1001</td>
<td align="center">安德烈·德拉蒙德</td>
<td align="center">2.11</td>
</tr>
<tr>
<td align="center">10004</td>
<td align="center">1001</td>
<td align="center">索恩·马克</td>
<td align="center">2.16</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10037</td>
<td align="center">1001</td>
<td align="center">伊凯·阿尼博古</td>
<td align="center">2.08</td>
</tr>
</tbody></table>
<p><code>team</code>表为球队表，一共有 3 支球队，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">team_id</th>
<th align="center">team_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1001</td>
<td align="center">底特律活塞</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">印第安纳步行者</td>
</tr>
<tr>
<td align="center">1003</td>
<td align="center">亚特兰大老鹰</td>
</tr>
</tbody></table>
<p><code>team_score</code>表为球队比赛成绩表，一共记录了两场比赛的成绩，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">game_id</th>
<th align="center">h_team_id</th>
<th align="center">v_team_id</th>
<th align="center">h_team_score</th>
<th align="center">v-team_score</th>
<th align="center">game_date</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10001</td>
<td align="center">1001</td>
<td align="center">1002</td>
<td align="center">102</td>
<td align="center">111</td>
<td align="center">2019-04-01</td>
</tr>
<tr>
<td align="center">10002</td>
<td align="center">1002</td>
<td align="center">1003</td>
<td align="center">135</td>
<td align="center">134</td>
<td align="center">2019-04-10</td>
</tr>
</tbody></table>
<p><code>player_score</code>表为球员比赛成绩表，记录了一场比赛中球员的表现。这张表一共包括 19 个字段，代表的含义如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">game_id <br> 比赛ID</td>
<td align="center">player_id <br> 球员ID</td>
<td align="center">is_first <br> 是否首发</td>
<td align="center">playing_time <br> 出场时间</td>
</tr>
<tr>
<td align="center">rebound <br> 篮板球</td>
<td align="center">rebound_o <br> 前场篮板</td>
<td align="center">rebound_d <br> 后场篮板</td>
<td align="center">assist <br> 助攻</td>
</tr>
<tr>
<td align="center">score <br> 比分</td>
<td align="center">steal <br> 抢断</td>
<td align="center">blockshot <br> 盖帽</td>
<td align="center">fault <br> 失误</td>
</tr>
<tr>
<td align="center">foul <br> 犯规</td>
<td align="center">shoot_attempts <br> 总出手</td>
<td align="center">shoot_hits <br> 命中</td>
<td align="center">shoot_3_attempts <br> 3分出手</td>
</tr>
<tr>
<td align="center">shoot_3_hits <br> 3分命中</td>
<td align="center">shoot_p_attempts <br> 罚球出手</td>
<td align="center">shoot_p_hits <br> 罚球命中</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>其中<code>shoot_attempts</code>代表总出手的次数，它等于二分球出手和三分球出手次数的总和。比如 2019 年 4 月 1 日，韦恩·艾灵顿在底特律活塞和印第安纳步行者的比赛中，总出手次数为 19，总命中 10，三分球 13 投 4 中，罚球 4 罚 2 中，因此总分<code>score=(10-4)×2+4×3+2=26</code>，也就是二分球得分<code>12+</code>三分球得分<code>12+</code>罚球得分<code>2=26</code>。</p>
<p>需要说明的是，通常在工作中，数据表的字段比较多，一开始创建的时候会知道每个字段的定义，过了一段时间再回过头来看，对当初的定义就不那么确定了，容易混淆字段，解决这一问题最好的方式就是做个说明文档，用实例举例。</p>
<p>比如<code>shoot_attempts</code>是总出手次数（这里的总出手次数 &#x3D; 二分球出手次数 + 三分球出手次数，不包括罚球的次数），用上面提到的韦恩·艾灵顿的例子做补充说明，再回过头来看这张表的时候，就可以很容易理解每个字段的定义了。</p>
<p>我们以 NBA 球员数据表为例，假设我们想要知道哪个球员的身高最高，最高身高是多少，就可以采用子查询的方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>: <span class="keyword">SELECT</span> player_name, height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> height <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">max</span>(height) <span class="keyword">FROM</span> player)</span><br></pre></td></tr></table></figure>
<p>运行结果：（1 条记录）</p>
<table>
<thead>
<tr>
<th align="center">player_name</th>
<th align="center">height</th>
</tr>
</thead>
<tbody><tr>
<td align="center">索恩·马克</td>
<td align="center">2.16</td>
</tr>
</tbody></table>
<p>你能看到，通过<code>SELECT max(height) FROM player</code>可以得到最高身高这个数值，结果为 2.16，然后我们再通过<code>player</code>这个表，看谁具有这个身高，再进行输出，这样的子查询就是非关联子查询。</p>
<p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。比如我们想要查找每个球队中大于平均身高的球员有哪些，并显示他们的球员姓名、身高以及所在球队<code>ID</code>。</p>
<p>首先我们需要统计球队的平均身高，即<code>SELECT avg(height) FROM player AS b WHERE a.team_id = b.team_id</code>，然后筛选身高大于这个数值的球员姓名、身高和球队<code>ID</code>，即：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name, height, team_id <span class="keyword">FROM</span> player <span class="keyword">AS</span> a <span class="keyword">WHERE</span> height <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">avg</span>(height) <span class="keyword">FROM</span> player <span class="keyword">AS</span> b <span class="keyword">WHERE</span> a.team_id <span class="operator">=</span> b.team_id)</span><br></pre></td></tr></table></figure>
<p>运行结果：（18 条记录）</p>
<table>
<thead>
<tr>
<th align="center">player_name</th>
<th align="center">height</th>
<th align="center">team_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">安德烈·德拉蒙德</td>
<td align="center">2.11</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">索恩·马克</td>
<td align="center">2.16</td>
<td align="center">1001</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">伊凯·阿尼博古</td>
<td align="center">2.08</td>
<td align="center">1002</td>
</tr>
</tbody></table>
<h1 id="EXISTS-子查询"><a href="#EXISTS-子查询" class="headerlink" title="EXISTS 子查询"></a>EXISTS 子查询</h1><p>关联子查询通常也会和<code>EXISTS</code>一起来使用，<code>EXISTS</code>子查询用来判断条件是否满足，满足的话为<code>True</code>，不满足为<code>False</code>。</p>
<p>比如我们想要看出场过的球员都有哪些，并且显示他们的姓名、球员<code>ID</code>和球队<code>ID</code>。在这个统计中，是否出场是通过<code>player_score</code>这张表中的球员出场表现来统计的，如果某个球员在<code>player_score</code>中有出场记录则代表他出场过，这里就使用到了<code>EXISTS</code>子查询，即<code>EXISTS (SELECT player_id FROM player_score WHERE player.player_id = player_score.player_id)</code>，然后将它作为筛选的条件，实际上也是关联子查询，即：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> player_id, team_id, player_name <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> player_id <span class="keyword">FROM</span> player_score <span class="keyword">WHERE</span> player.player_id <span class="operator">=</span> player_score.player_id)</span><br></pre></td></tr></table></figure>
<p>运行结果：（19 条记录）</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">team_id</th>
<th align="center">player_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10001</td>
<td align="center">1001</td>
<td align="center">韦恩·艾灵顿</td>
</tr>
<tr>
<td align="center">10002</td>
<td align="center">1001</td>
<td align="center">雷吉·杰克逊</td>
</tr>
<tr>
<td align="center">10003</td>
<td align="center">1001</td>
<td align="center">安德烈·德拉蒙德</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10032</td>
<td align="center">1002</td>
<td align="center">TJ·利夫</td>
</tr>
</tbody></table>
<p>同样，<code>NOT EXISTS</code>就是不存在的意思，我们也可以通过<code>NOT EXISTS</code>查询不存在于<code>player_score</code>表中的球员信息，比如主表中的<code>player_id</code>不在子表<code>player_score</code>中，判断语句为<code>NOT EXISTS (SELECT player_id FROM player_score WHERE player.player_id = player_score.player_id)</code>。整体的 SQL 语句为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>: <span class="keyword">SELECT</span> player_id, team_id, player_name <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> player_id <span class="keyword">FROM</span> player_score <span class="keyword">WHERE</span> player.player_id <span class="operator">=</span> player_score.player_id)</span><br></pre></td></tr></table></figure>
<p>运行结果：（18 条记录）</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">team_id</th>
<th align="center">player_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10011</td>
<td align="center">1001</td>
<td align="center">布雷克·格里芬</td>
</tr>
<tr>
<td align="center">10012</td>
<td align="center">1001</td>
<td align="center">雷吉·巴洛克</td>
</tr>
<tr>
<td align="center">10013</td>
<td align="center">1001</td>
<td align="center">卢克·肯纳德</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10037</td>
<td align="center">1002</td>
<td align="center">伊凯·阿尼博古</td>
</tr>
</tbody></table>
<h1 id="集合比较子查询"><a href="#集合比较子查询" class="headerlink" title="集合比较子查询"></a>集合比较子查询</h1><p>集合比较子查询的作用是与另一个查询结果集进行比较，我们可以在子查询中使用<code>IN、ANY、ALL</code>和<code>SOME</code>操作符，它们的含义和英文意义一样：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">IN</td>
<td align="center">判断是否在集合中</td>
</tr>
<tr>
<td align="center">ANY</td>
<td align="center">需要与比较操作符一起使用，与子查询返回的任何值做比较</td>
</tr>
<tr>
<td align="center">ALL</td>
<td align="center">需要与比较操作符一起使用，与子查询返回的所有值做比较</td>
</tr>
<tr>
<td align="center">SOME</td>
<td align="center">实际上是ANY的别名，作用相同，一般常用ANY</td>
</tr>
</tbody></table>
<p>还是通过上面那个例子，假设我们想要看出场过的球员都有哪些，可以采用<code>IN</code>子查询来进行操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_id, team_id, player_name <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> player_id <span class="keyword">FROM</span> player_score <span class="keyword">WHERE</span> player.player_id <span class="operator">=</span> player_score.player_id)</span><br></pre></td></tr></table></figure>
<p>你会发现运行结果和上面的是一样的，那么问题来了，既然<code>IN</code>和<code>EXISTS</code>都可以得到相同的结果，那么我们该使用<code>IN</code>还是<code>EXISTS</code>呢？</p>
<p>我们可以把这个模式抽象为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> cc <span class="keyword">IN</span> (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> EXIST (<span class="keyword">SELECT</span> cc <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.cc<span class="operator">=</span>A.cc)</span><br></pre></td></tr></table></figure>
<p>实际上在查询过程中，在我们对<code>cc</code>列建立索引的情况下，我们还需要判断表 A 和表 B 的大小。在这里例子当中，表 A 指的是<code>player</code>表，表 B 指的是<code>player_score</code>表。如果表 A 比表 B 大，那么<code>IN</code>子查询的效率要比<code>EXIST</code>子查询效率高，因为这时 B 表中如果对<code>cc</code>列进行了索引，那么<code>IN</code>子查询的效率就会比较高。</p>
<p>同样，如果表 A 比表 B 小，那么使用<code>EXISTS</code>子查询效率会更高，因为我们可以使用到 A 表中对<code>cc</code>列的索引，而不用从 B 中进行<code>cc</code>列的查询。</p>
<p>了解了<code>IN</code>查询后，我们来看下<code>ANY</code>和<code>ALL</code>子查询。<code>ANY</code>和<code>ALL</code>都需要使用比较符，比较符包括了（&gt;）（&#x3D;）（&lt;）（&gt;&#x3D;）（&lt;&#x3D;）和（&lt;&gt;）等。</p>
<p>如果我们想要查询球员表中，比印第安纳步行者（对应的<code>team_id</code>为 1002）中任何一个球员身高高的球员的信息，并且输出他们的球员<code>ID</code>、球员姓名和球员身高，该怎么写呢？首先我们需要找出所有印第安纳步行者队中的球员身高，即<code>SELECT height FROM player WHERE team_id = 1002</code>，然后使用<code>ANY</code>子查询即：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>: <span class="keyword">SELECT</span> player_id, player_name, height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> team_id <span class="operator">=</span> <span class="number">1002</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：（35 条记录）</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">player_name</th>
<th align="center">height</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10001</td>
<td align="center">韦恩·艾灵顿</td>
<td align="center">1.93</td>
</tr>
<tr>
<td align="center">10002</td>
<td align="center">雷吉·杰克逊</td>
<td align="center">1.91</td>
</tr>
<tr>
<td align="center">10003</td>
<td align="center">安德烈·德拉蒙德</td>
<td align="center">2.11</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10037</td>
<td align="center">伊凯·阿尼博古</td>
<td align="center">2.08</td>
</tr>
</tbody></table>
<p>运行结果为 35 条，你发现有 2 个人的身高是不如印第安纳步行者的所有球员的。</p>
<p>同样，如果我们想要知道比印第安纳步行者（对应的<code>team_id</code>为 1002）中所有球员身高都高的球员的信息，并且输出球员<code>ID</code>、球员姓名和球员身高，该怎么写呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>: <span class="keyword">SELECT</span> player_id, player_name, height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> height <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> team_id <span class="operator">=</span> <span class="number">1002</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：（1 条记录）</p>
<table>
<thead>
<tr>
<th align="center">player_id</th>
<th align="center">player_name</th>
<th align="center">height</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10004</td>
<td align="center">索恩·马克</td>
<td align="center">2.16</td>
</tr>
</tbody></table>
<p>我们能看到比印第安纳步行者所有球员都高的球员，在<code>player</code>这张表（一共 37 个球员）中只有索恩·马克。</p>
<p>需要强调的是<code>ANY、ALL</code>关键字必须与一个比较操作符一起使用。因为如果你不使用比较操作符，就起不到集合比较的作用，那么使用<code>ANY</code>和<code>ALL</code>就没有任何意义。</p>
<h1 id="将子查询作为计算字段"><a href="#将子查询作为计算字段" class="headerlink" title="将子查询作为计算字段"></a>将子查询作为计算字段</h1><p>实际上子查询也可以作为主查询的计算字段。比如我想查询每个球队的球员数，也就是对应<code>team</code>这张表，我需要查询相同的<code>team_id</code>在<code>player</code>这张表中所有的球员数量是多少。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>: <span class="keyword">SELECT</span> team_name, (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> player.team_id <span class="operator">=</span> team.team_id) <span class="keyword">AS</span> player_num <span class="keyword">FROM</span> team</span><br></pre></td></tr></table></figure>
<p>运行结果：（3 条记录）</p>
<table>
<thead>
<tr>
<th align="center">team_name</th>
<th align="center">player_num</th>
</tr>
</thead>
<tbody><tr>
<td align="center">底特律活塞</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">印第安纳步行者</td>
<td align="center">17</td>
</tr>
<tr>
<td align="center">亚特兰大老鹰</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>你能看到，在<code>player</code>表中只有底特律活塞和印第安纳步行者的球员数据，所以它们的<code>player_num</code>不为 0，而亚特兰大老鹰的<code>player_num</code>等于 0。在查询的时候，我将子查询<code>SELECT count(*) FROM player WHERE player.team_id = team.team_id</code>作为了计算字段，通常我们需要给这个计算字段起一个别名，这里我用的是<code>player_num</code>，因为子查询的语句比较长，使用别名更容易理解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>按照子查询执行的次数，我们可以将子查询分成关联子查询和非关联子查询，其中非关联子查询与主查询的执行无关，只需要执行一次即可，而关联子查询，则需要将主查询的字段值传入子查询中进行关联查询。</p>
<p>同时，在子查询中你可能会使用到<code>EXISTS、IN、ANY、ALL</code>和<code>SOME</code>等关键字。在某些情况下使用<code>EXISTS</code>和<code>IN</code>可以得到相同的效果，具体使用哪个执行效率更高，则需要看字段的索引情况以及表 A 和表 B 哪个表更大。同样，<code>IN、ANY、ALL、SOME</code>这些关键字是用于集合比较的，<code>SOME</code>是<code>ANY</code>的别名，当我们使用<code>ANY</code>或<code>ALL</code>的时候，一定要使用比较操作符。</p>
<p>SQL 中，子查询的使用大大增强了<code>SELECT</code>查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 函数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/07/SQL/SQL%20%E5%87%BD%E6%95%B0/"
    >SQL 函数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/07/SQL/SQL%20%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2020-02-07T06:11:02.000Z" itemprop="datePublished">2020-02-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作，比如求某列数据的平均值，或者求字符串的长度等。从函数定义的角度出发，我们可以将函数分成内置函数和自定义函数。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的。</p>
<h1 id="什么是-SQL-函数"><a href="#什么是-SQL-函数" class="headerlink" title="什么是 SQL 函数"></a>什么是 SQL 函数</h1><p>SQL 中的函数一般是在数据上执行的，可以很方便地转换和处理数据。一般来说，当我们从数据表中检索出数据之后，就可以进一步对这些数据进行操作，得到更有意义的结果，比如返回指定条件的函数，或者求某个字段的平均值等。</p>
<h1 id="常用的-SQL-函数有哪些"><a href="#常用的-SQL-函数有哪些" class="headerlink" title="常用的 SQL 函数有哪些"></a>常用的 SQL 函数有哪些</h1><p>SQL 提供了一些常用的内置函数，当然你也可以自己定义 SQL 函数。SQL 的内置函数对于不同的数据库软件来说具有一定的通用性，我们可以把内置函数分成四类：</p>
<ul>
<li>算术函数</li>
<li>字符串函数</li>
<li>日期函数</li>
<li>转换函数</li>
</ul>
<p>这 4 类函数分别代表了算术处理、字符串处理、日期处理、数据类型转换，它们是 SQL 函数常用的划分形式。</p>
<p>函数是对提取出来的数据进行操作，那么数据表中字段类型的定义有哪几种呢？</p>
<p>我们经常会保存一些数值，不论是整数类型，还是浮点类型，实际上对应的就是数值类型。同样我们也会保存一些文本内容，可能是人名，也可能是某个说明，对应的就是字符串类型。此外我们还需要保存时间，也就是日期类型。那么针对数值、字符串和日期类型的数据，我们可以对它们分别进行算术函数、字符串函数以及日期函数的操作。如果想要完成不同类型数据之间的转换，就可以使用转换函数。</p>
<h2 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h2><p>算术函数，顾名思义就是对数值类型的字段进行算术运算。常用的算术函数及含义如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>ABS()</code></td>
<td align="center">取绝对值</td>
</tr>
<tr>
<td align="center"><code>MOD()</code></td>
<td align="center">取余</td>
</tr>
<tr>
<td align="center"><code>ROUND()</code></td>
<td align="center">四舍五入为指定的小数位数，需要有两个参数，分别为字段名称、小数位数</td>
</tr>
</tbody></table>
<p>例：</p>
<p><code>SELECT ABS(-2)</code>，运行结果为 2。</p>
<p><code>SELECT MOD(101,3)</code>，运行结果 2。</p>
<p><code>SELECT ROUND(37.25,1)</code>，运行结果 37.3。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>常用的字符串函数操作包括了字符串拼接，大小写转换，求长度以及字符串替换和截取等。具体的函数名称及含义如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>CONCAT()</code></td>
<td align="center">将多个字符串拼接起来</td>
</tr>
<tr>
<td align="center"><code>LENGTH()</code></td>
<td align="center">计算字段的长度，一个汉字算3个字符，一个数字或字母算一个字符</td>
</tr>
<tr>
<td align="center"><code>CHAR_LENGTH()</code></td>
<td align="center">计算字段的长度，汉字、数字、字母都算一个字符</td>
</tr>
<tr>
<td align="center"><code>LOWER()</code></td>
<td align="center">将字符串中的字符转化为小写</td>
</tr>
<tr>
<td align="center"><code>UPPER()</code></td>
<td align="center">将字符串中的字符转化为大写</td>
</tr>
<tr>
<td align="center"><code>REPLACE()</code></td>
<td align="center">替换函数，有3个参数，分别为：要替换的表达式或字段名、想要查找的被替换字符串、替换成哪个字符串</td>
</tr>
<tr>
<td align="center"><code>SUBSTRING()</code></td>
<td align="center">截取字符串，有3个参数，分别为：待截取的表达式或字段名、开始截取的位置、想要截取的字符串长度</td>
</tr>
</tbody></table>
<p>例：</p>
<p><code>SELECT CONCAT(&#39;abc&#39;, 123)</code>，运行结果为<code>abc123</code>。</p>
<p><code>SELECT LENGTH(&#39;你好&#39;)</code>，运行结果为 6。</p>
<p><code>SELECT CHAR_LENGTH(&#39;你好&#39;)</code>，运行结果为 2。</p>
<p><code>SELECT LOWER(&#39;ABC&#39;)</code>，运行结果为<code>abc</code>。</p>
<p><code>SELECT UPPER(&#39;abc&#39;)</code>，运行结果<code>ABC</code>。</p>
<p><code>SELECT REPLACE(&#39;fabcd&#39;, &#39;abc&#39;, 123)</code>，运行结果为 f123d。</p>
<p><code>SELECT SUBSTRING(&#39;fabcd&#39;, 1, 3)</code>，运行结果为<code>fab</code>。</p>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p>日期函数是对数据表中的日期进行处理，常用的函数包括：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>CURRENT_DATE()</code></td>
<td align="center">系统当前日期</td>
</tr>
<tr>
<td align="center"><code>CURRENT_TIME()</code></td>
<td align="center">系统当前时间，没有具体的日期</td>
</tr>
<tr>
<td align="center"><code>CURRENT_TIMESTAMP()</code></td>
<td align="center">系统当前时间，包括具体的日期+时间</td>
</tr>
<tr>
<td align="center"><code>EXTRACT()</code></td>
<td align="center">抽取具体的年、月、日</td>
</tr>
<tr>
<td align="center"><code>DATE()</code></td>
<td align="center">返回时间的日期部分</td>
</tr>
<tr>
<td align="center"><code>YEAR()</code></td>
<td align="center">返回时间的年份部分</td>
</tr>
<tr>
<td align="center"><code>MONTH()</code></td>
<td align="center">返回时间的月份部分</td>
</tr>
<tr>
<td align="center"><code>DAY()</code></td>
<td align="center">返回时间的天数部分</td>
</tr>
<tr>
<td align="center"><code>HOUR()</code></td>
<td align="center">返回时间的小时部分</td>
</tr>
<tr>
<td align="center"><code>MINUTE()</code></td>
<td align="center">返回时间的分钟部分</td>
</tr>
<tr>
<td align="center"><code>SECOND()</code></td>
<td align="center">返回时间的秒部分</td>
</tr>
</tbody></table>
<p>例：</p>
<p><code>SELECT CURRENT_DATE()</code>，运行结果为<code>2019-04-03</code>。</p>
<p><code>SELECT CURRENT_TIME()</code>，运行结果为<code>21:26:34</code>。</p>
<p><code>SELECT CURRENT_TIMESTAMP()</code>，运行结果为<code>2019-04-03 21:26:34</code>。</p>
<p><code>SELECT EXTRACT(YEAR FROM &#39;2019-04-03&#39;)</code>，运行结果为 2019。</p>
<p><code>SELECT DATE(&#39;2019-04-01 12:00:05&#39;)</code>，运行结果为<code>2019-04-01</code>。</p>
<p>这里需要注意的是，<code>DATE</code>日期格式必须是<code>yyyy-mm-dd</code>的形式。如果要进行日期比较，就要使用<code>DATE</code>函数，不要直接使用日期与字符串进行比较。</p>
<h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><p>转换函数可以转换数据之间的类型，常用的函数如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>CAST()</code></td>
<td align="center">数据类型转换，参数是一个表达式，表达式通过AS关键词分割了2个参数，分别是原始数据和目标数据类型</td>
</tr>
<tr>
<td align="center"><code>COALESCE()</code></td>
<td align="center">返回第一个非空数值</td>
</tr>
</tbody></table>
<p>例：</p>
<p><code>SELECT CAST(123.123 AS INT)</code>，运行结果会报错。</p>
<p><code>SELECT CAST(123.123 AS DECIMAL(8,2))</code>，运行结果为 123.12。</p>
<p><code>SELECT COALESCE(null,1,2)</code>，运行结果为 1。</p>
<p><code>CAST</code>函数在转换数据类型的时候，不会四舍五入，如果原数值有小数，那么转换为整数类型的时候就会报错。不过你可以指定转化的小数类型，在 MySQL 和 SQL Server 中，你可以用<code>DECIMAL(a,b)</code>来指定，其中<code>a</code>代表整数部分和小数部分加起来最大的位数，<code>b</code>代表小数位数，比如<code>DECIMAL(8,2)</code>代表的是精度为 8 位（整数加小数位数最多为 8 位），小数位数为 2 位的数据类型。所以<code>SELECT CAST(123.123 AS DECIMAL(8,2))</code>的转换结果为 123.12。</p>
<h1 id="用-SQL-函数对王者荣耀英雄数据做处理"><a href="#用-SQL-函数对王者荣耀英雄数据做处理" class="headerlink" title="用 SQL 函数对王者荣耀英雄数据做处理"></a>用 SQL 函数对王者荣耀英雄数据做处理</h1><p>王者荣耀英雄数据库，一共有 69 个英雄，23 个属性值。SQL 文件见<a target="_blank" rel="noopener" href="https://github.com/cystanford/sql_heros_data">Github 地址</a>。</p>
<p>我们现在把这个文件导入到 MySQL 中，你可以使用 Navicat 可视化数据库管理工具将<code>.sql</code>文件导入到数据库中。数据表为<code>heros</code>，然后使用 SQL 函数，对这个英雄数据表进行处理。</p>
<p>首先显示英雄以及他的物攻成长，对应字段为<code>attack_growth</code>。我们让这个字段精确到小数点后一位，需要使用的是算术函数里的<code>ROUND</code>函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, ROUND(attack_growth,<span class="number">1</span>) <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>代码中，<code>ROUND(attack_growth,1)</code>中的<code>attack_growth</code>代表想要处理的数据，“1”代表四舍五入的位数，也就是我们这里需要精确到的位数。</p>
<p>运行结果为：</p>
<table>
<thead>
<tr>
<th align="center"><code>name</code></th>
<th align="center"><code>ROUND(attack_growth, 1)</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">夏侯惇</td>
<td align="center">12.0</td>
</tr>
<tr>
<td align="center">钟无艳</td>
<td align="center">11.0</td>
</tr>
<tr>
<td align="center">张飞</td>
<td align="center">11.0</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">百里守约</td>
<td align="center">16.0</td>
</tr>
</tbody></table>
<p>假设我们想显示英雄最大生命值的最大值，就需要用到<code>MAX</code>函数。在数据中，“最大生命值”对应的列数为<code>hp_max</code>，在代码中的格式为<code>MAX(hp_max)</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hp_max) <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>运行结果为 9328。</p>
<p>假如我们想要知道最大生命值最大的是哪个英雄，以及对应的数值，就需要分成两个步骤来处理：首先找到英雄的最大生命值的最大值，即<code>SELECT MAX(hp_max) FROM heros</code>，然后再筛选最大生命值等于这个最大值的英雄，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> hp_max <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hp_max) <span class="keyword">FROM</span> heros)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<table>
<thead>
<tr>
<th align="center"><code>name</code></th>
<th align="center"><code>hp_max</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">廉颇</td>
<td align="center">9328</td>
</tr>
</tbody></table>
<p>假如我们想显示英雄的名字，以及他们的名字字数，需要用到<code>CHAR_LENGTH</code>函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(name), name <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<table>
<thead>
<tr>
<th align="center"><code>CHAR_LENGTH(name)</code></th>
<th align="center"><code>name</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">夏侯惇</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">钟无艳</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">百里守约</td>
</tr>
</tbody></table>
<p>假如想要提取英雄上线日期（对应字段<code>birthdate</code>）的年份，只显示有上线日期的英雄即可（有些英雄没有上线日期的数据，不需要显示），这里我们需要使用<code>EXTRACT</code>函数，提取某一个时间元素。所以我们需要筛选上线日期不为空的英雄，即<code>WHERE birthdate is not null</code>，然后再显示他们的名字和上线日期的年份，即：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>： <span class="keyword">SELECT</span> name, <span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> birthdate) <span class="keyword">AS</span> birthdate <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> birthdate <span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<p>或者使用如下形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>: <span class="keyword">SELECT</span> name, <span class="keyword">YEAR</span>(birthdate) <span class="keyword">AS</span> birthdate <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> birthdate <span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<table>
<thead>
<tr>
<th align="center"><code>name</code></th>
<th align="center"><code>birthdate</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">夏侯惇</td>
<td align="center">2016</td>
</tr>
<tr>
<td align="center">牛魔</td>
<td align="center">2015</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">百里守约</td>
<td align="center">2017</td>
</tr>
</tbody></table>
<p>假设我们需要找出在 2016 年 10 月 1 日之后上线的所有英雄。这里我们可以采用<code>DATE</code>函数来判断<code>birthdate</code>的日期是否大于<code>2016-10-01</code>，即<code>WHERE DATE(birthdate)&gt;&#39;2016-10-01&#39;</code>，然后再显示符合要求的全部字段信息，即：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>： <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> <span class="type">DATE</span>(birthdate)<span class="operator">&gt;</span><span class="string">&#x27;2016-10-01&#x27;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是下面这种写法是不安全的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> birthdate<span class="operator">&gt;</span><span class="string">&#x27;2016-10-01&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因为很多时候你无法确认<code>birthdate</code>的数据类型是字符串，还是<code>datetime</code>类型，如果你想对日期部分进行比较，那么使用<code>DATE(birthdate)</code>来进行比较是更安全的。</p>
<p>假设我们需要知道在 2016 年 10 月 1 日之后上线英雄的平均最大生命值、平均最大法力和最高物攻最大值。同样我们需要先筛选日期条件，即<code>WHERE DATE(birthdate)&gt;&#39;2016-10-01&#39;</code>，然后再选择<code>AVG(hp_max), AVG(mp_max), MAX(attack_max)</code>字段进行显示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>： <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(hp_max), <span class="built_in">AVG</span>(mp_max), <span class="built_in">MAX</span>(attack_max) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> <span class="type">DATE</span>(birthdate)<span class="operator">&gt;</span><span class="string">&#x27;2016-10-01&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<table>
<thead>
<tr>
<th align="center"><code>AVG(hp_max)</code></th>
<th align="center"><code>AVG(mp_max)</code></th>
<th align="center"><code>MAX(attack_max)</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">6611.5000</td>
<td align="center">1821.5000</td>
<td align="center">410</td>
</tr>
</tbody></table>
<h1 id="为什么使用-SQL-函数会带来问题"><a href="#为什么使用-SQL-函数会带来问题" class="headerlink" title="为什么使用 SQL 函数会带来问题"></a>为什么使用 SQL 函数会带来问题</h1><p>尽管 SQL 函数使用起来会很方便，但我们使用的时候还是要谨慎，因为你使用的函数很可能在运行环境中无法工作，这是为什么呢？</p>
<p>语言是有不同版本的，比如 Python 会有 2.7 版本和 3.x 版本，不过它们之间的函数差异不大，也就在 10% 左右。但我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为<code>Concat()</code>。大部分 DBMS 会有自己特定的函数，这就意味着采用 SQL 函数的代码可移植性是很差的，因此在使用函数的时候需要特别注意。</p>
<p>在 SQL 中，使用函数的时候需要格外留意。不过如果工程量不大，使用的是同一个 DBMS 的话，还是可以使用函数简化操作的，这样也能提高代码效率。只是在系统集成，或者在多个 DBMS 同时存在的情况下，使用函数的时候就需要慎重一些。</p>
<p>比如<code>CONCAT()</code>是字符串拼接函数，在 MySQL 和 Oracle 中都有这个函数，但是在这两个 DBMS 中作用却不一样，<code>CONCAT</code>函数在 MySQL 中可以连接多个字符串，而在 Oracle 中<code>CONCAT</code>函数只能连接两个字符串，如果要连接多个字符串就需要用（||）连字符来解决。</p>
<h1 id="关于大小写的规范"><a href="#关于大小写的规范" class="headerlink" title="关于大小写的规范"></a>关于大小写的规范</h1><p>在 SQL 中，关键字和函数名是不用区分字母大小写的，比如<code>SELECT、WHERE、ORDER、GROUP BY</code>等关键字，以及<code>ABS、MOD、ROUND、MAX </code>等函数名。</p>
<p>不过在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，你可能会遇到不同的大小写问题。</p>
<p>比如 MySQL 在 Linux 的环境下，数据库名、表名、变量名是严格区分大小写的，而字段名是忽略大小写的。</p>
<p>而 MySQL 在 Windows 的环境下全部不区分大小写。</p>
<p>这就意味着如果你的变量名命名规范没有统一，就可能产生错误。这里有一个有关命名规范的建议：</p>
<ul>
<li>关键字和函数名称全部大写；</li>
<li>数据库名、表名、字段名称全部小写；</li>
<li>SQL 语句必须以分号结尾。</li>
</ul>
<p>虽然关键字和函数名称在 SQL 中不区分大小写，也就是如果小写的话同样可以执行，但是数据库名、表名和字段名在 Linux MySQL 环境下是区分大小写的，因此建议你统一这些字段的命名规则，比如全部采用小写的方式。同时将关键词和函数名称全部大写，以便于区分数据库名、表名、字段名。</p>
<h1 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h1><p>SQL 函数还有一种，叫做聚集函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。通常我们可以利用聚集函数汇总表的数据，如果稍微复杂一些，我们还需要先对数据做筛选，然后再进行聚集，比如先按照某个条件进行分组，对分组条件进行筛选，然后得到筛选后的分组的汇总信息。</p>
<h2 id="聚集函数都有哪些"><a href="#聚集函数都有哪些" class="headerlink" title="聚集函数都有哪些"></a>聚集函数都有哪些</h2><p>SQL 中的聚集函数一共包括 5 个，可以帮我们求某列的最大值、最小值和平均值等，它们分别是：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>COUNT()</code></td>
<td align="center">总行数</td>
</tr>
<tr>
<td align="center"><code>MAX()</code></td>
<td align="center">最大值</td>
</tr>
<tr>
<td align="center"><code>MIN()</code></td>
<td align="center">最小值</td>
</tr>
<tr>
<td align="center"><code>SUM()</code></td>
<td align="center">求和</td>
</tr>
<tr>
<td align="center"><code>AVG()</code></td>
<td align="center">平均值</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li><code>COUNT</code>、<code>SUM</code>、<code>AVG</code>函数中可以使用<code>DISTINCT</code>关键字去除指定列中的重复项。使用<code>DISTINCT</code>关键字后只是对不同行的值进行统计。</li>
<li><code>MIN</code>、<code>MAX</code>函数中的列或表达式可以是数字型、字符型或日期类型的值。如果是字符型的，则按照首字母从 A 到 Z 的顺序排序，如果首字母相同，则比较字符串中第二个字母的大小，以此类推。汉字则是按照其汉语拼音的全拼来排序。</li>
<li><code>SUM</code>和<code>AVG</code>函数中的表达式只能是数字类型的值。</li>
<li>除了<code>COUNT(*)</code>外，其他几个函数在计算时都忽略表达式中的空行（<code>NULL</code>行）。</li>
<li><code>COUNT</code>函数是用来计算数据表中的总行数，<code>SUM</code>函数是用来计算数据表中某一列的属性值的总和。</li>
</ul>
<p>我们继续使用<code>heros</code>数据表，对王者荣耀的英雄数据进行聚合。</p>
<p>如果我们想要查询最大生命值大于 6000 的英雄数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> hp_max <span class="operator">&gt;</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>
<p>运行结果为 41。</p>
<p>如果想要查询最大生命值大于 6000，且有次要定位的英雄数量，需要使用<code>COUNT</code>函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(role_assist) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> hp_max <span class="operator">&gt;</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>
<p>运行结果是 23。</p>
<p>需要说明的是，有些英雄没有次要定位，即<code>role_assist</code>为<code>NULL</code>，这时<code>COUNT(role_assist)</code>会忽略值为<code>NULL</code>的数据行，而<code>COUNT(*)</code>只是统计数据行数，不管某个字段是否为<code>NULL</code>。</p>
<p>如果我们想要查询射手（主要定位或者次要定位是射手）的最大生命值的最大值是多少，需要使用 MAX 函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(hp_max) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> role_main <span class="operator">=</span> <span class="string">&#x27;射手&#x27;</span> <span class="keyword">or</span> role_assist <span class="operator">=</span> <span class="string">&#x27;射手&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果为 6014。</p>
<p>上面的例子里，都是在一条<code>SELECT</code>语句中使用了一次聚集函数，实际上我们也可以在一条<code>SELECT</code>语句中进行多项聚集函数的查询，比如我们想知道射手（主要定位或者次要定位是射手）的英雄数、平均最大生命值、法力最大值的最大值、攻击最大值的最小值，以及这些英雄总的防御最大值等汇总数据。</p>
<p>如果想要知道英雄的数量，我们使用的是<code>COUNT(*)</code>函数，求平均值、最大值、最小值，以及总的防御最大值，我们分别使用的是<code>AVG、MAX、MIN</code>和<code>SUM</code>函数。另外我们还需要对英雄的主要定位和次要定位进行筛选，使用的是<code>WHERE role_main = &#39;射手&#39; or role_assist = &#39;射手&#39;</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>: <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="built_in">AVG</span>(hp_max), <span class="built_in">MAX</span>(mp_max), <span class="built_in">MIN</span>(attack_max), <span class="built_in">SUM</span>(defense_max) <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> role_main <span class="operator">=</span> <span class="string">&#x27;射手&#x27;</span> <span class="keyword">or</span> role_assist <span class="operator">=</span> <span class="string">&#x27;射手&#x27;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<table>
<thead>
<tr>
<th align="center"><code>COUNT(*)</code></th>
<th align="center"><code>AVG(hp_max)</code></th>
<th align="center"><code>MAX(mp_max)</code></th>
<th align="center"><code>MIN(attack_max)</code></th>
<th align="center"><code>SUM(defense_max)</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">10</td>
<td align="center">5798.5</td>
<td align="center">1784</td>
<td align="center">362</td>
<td align="center">3333</td>
</tr>
</tbody></table>
<p>需要说明的是<code>AVG、MAX、MIN</code>等聚集函数会自动忽略值为<code>NULL</code>的数据行，<code>MAX</code>和<code>MIN</code>函数也可以用于字符串类型数据的统计，如果是英文字母，则按照<code>A—Z</code>的顺序排列，越往后，数值越大。如果是汉字则按照全拼拼音进行排列。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(<span class="keyword">CONVERT</span>(name <span class="keyword">USING</span> gbk)), <span class="built_in">MAX</span>(<span class="keyword">CONVERT</span>(name <span class="keyword">USING</span> gbk)) <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 数据过滤"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/06/SQL/SQL%20%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/"
    >SQL 数据过滤</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/06/SQL/SQL%20%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4/" class="article-date">
  <time datetime="2020-02-06T08:23:03.000Z" itemprop="datePublished">2020-02-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p>在 SQL 中，我们可以使用<code>WHERE</code>子句对条件进行筛选，在此之前，你需要了解<code>WHERE</code>子句中的比较运算符。这些比较运算符的含义你可以参见下面这张表格：</p>
<table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">等于、小于、大于、不等于</td>
<td align="center"><code>=、&lt;、&gt;、!=</code></td>
</tr>
<tr>
<td align="center">不等于</td>
<td align="center"><code>&lt;&gt;</code>或<code>!=</code></td>
</tr>
<tr>
<td align="center">小于等于</td>
<td align="center"><code>&lt;=</code>或<code>!&gt;</code></td>
</tr>
<tr>
<td align="center">大于等于</td>
<td align="center"><code>&gt;=</code>或<code>!&lt;</code></td>
</tr>
<tr>
<td align="center">在指定的两个数值之间</td>
<td align="center"><code>BETWEEN</code></td>
</tr>
<tr>
<td align="center">为空值</td>
<td align="center"><code>IS NULL</code></td>
</tr>
</tbody></table>
<p>不同的 DBMS 支持的运算符可能是不同的，比如 Access 不支持（<code>!=</code>），不等于应该使用（<code>&lt;&gt;</code>）。在 MySQL 中，不支持（<code>!&gt;</code>）（<code>!&lt;</code>）等。</p>
<p><code>WHERE</code>子句的基本格式是：<code>SELECT ……(列名) FROM ……(表名) WHERE ……(子句条件)</code></p>
<p>比如我们想要查询所有最大生命值大于 6000 的英雄：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> hp_max <span class="operator">&gt;</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">hp_max</th>
</tr>
</thead>
<tbody><tr>
<td align="center">夏侯淳</td>
<td align="center">7350</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">凯</td>
<td align="center">6700</td>
</tr>
</tbody></table>
<p>想要查询所有最大生命值在 5399 到 6811 之间的英雄：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> hp_max <span class="keyword">BETWEEN</span> <span class="number">5399</span> <span class="keyword">AND</span> <span class="number">6811</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">hp_max</th>
</tr>
</thead>
<tbody><tr>
<td align="center">芈月</td>
<td align="center">6164</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">百里守约</td>
<td align="center">5611</td>
</tr>
</tbody></table>
<p>需要注意的是<code>hp_max</code>可以取值到最小值和最大值，即 5399 和 6811。</p>
<p>我们也可以对<code>heros</code>表中的<code>hp_max</code>字段进行空值检查。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> hp_max <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<p>运行结果为空，说明<code>heros</code>表中的<code>hp_max</code>字段没有存在空值的数据行。</p>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>如果我们存在多个<code>WHERE</code>条件子句，可以使用逻辑运算符：</p>
<table>
<thead>
<tr>
<th align="center">含义</th>
<th align="center">逻辑运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">并且</td>
<td align="center"><code>AND</code></td>
</tr>
<tr>
<td align="center">或者</td>
<td align="center"><code>OR</code></td>
</tr>
<tr>
<td align="center">在指定条件范围内</td>
<td align="center"><code>IN</code></td>
</tr>
<tr>
<td align="center">非</td>
<td align="center"><code>NOT</code></td>
</tr>
</tbody></table>
<p>我们还是通过例子来看下这些逻辑运算符的使用，同样采用<code>heros</code>这张表的数据查询。</p>
<p>假设想要筛选最大生命值大于 6000，最大法力大于 1700 的英雄，然后按照最大生命值和最大法力值之和从高到低进行排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max, mp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> hp_max <span class="operator">&gt;</span> <span class="number">6000</span> <span class="keyword">AND</span> mp_max <span class="operator">&gt;</span> <span class="number">1700</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> (hp_max<span class="operator">+</span>mp_max) <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">hp_max</th>
<th align="center">mp_max</th>
</tr>
</thead>
<tbody><tr>
<td align="center">廉颇</td>
<td align="center">9328</td>
<td align="center">1708</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">孙尚香</td>
<td align="center">6014</td>
<td align="center">1756</td>
</tr>
</tbody></table>
<p>如果<code>AND</code>和<code>OR</code>同时存在<code>WHERE</code>子句中会是怎样的呢？假设我们想要查询最大生命值加最大法力值大于 8000 的英雄，或者最大生命值大于 6000 并且最大法力值大于 1700 的英雄。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max, mp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> (hp_max<span class="operator">+</span>mp_max) <span class="operator">&gt;</span> <span class="number">8000</span> <span class="keyword">OR</span> hp_max <span class="operator">&gt;</span> <span class="number">6000</span> <span class="keyword">AND</span> mp_max <span class="operator">&gt;</span> <span class="number">1700</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> (hp_max<span class="operator">+</span>mp_max) <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>这次的条件查询多出来了 10 个英雄，这是因为我们放宽了条件，允许最大生命值 + 最大法力值大于 8000 的英雄显示出来。另外你需要注意到，当<code>WHERE</code>子句中同时存在<code>OR</code>和<code>AND</code>的时候，<code>AND</code>执行的优先级会更高，也就是说 SQL 会优先处理<code>AND</code>操作符，然后再处理<code>OR</code>操作符。</p>
<p>如果我们对这条查询语句<code>OR</code>两边的条件增加一个括号，结果会是怎样的呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max, mp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> ((hp_max<span class="operator">+</span>mp_max) <span class="operator">&gt;</span> <span class="number">8000</span> <span class="keyword">OR</span> hp_max <span class="operator">&gt;</span> <span class="number">6000</span>) <span class="keyword">AND</span> mp_max </span><br></pre></td></tr></table></figure>
<p>所以当<code>WHERE</code>子句中同时出现<code>AND</code>和<code>OR</code>操作符的时候，你需要考虑到执行的先后顺序，也就是两个操作符执行的优先级。一般来说<code>()</code>优先级最高，其次优先级是<code>AND</code>，然后是<code>OR</code>。</p>
<p>如果我想要查询主要定位或者次要定位是法师或是射手的英雄，同时英雄的上线时间不在<code>2016-01-01</code>到<code>2017-01-01</code>之间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：</span><br><span class="line"><span class="keyword">SELECT</span> name, role_main, role_assist, hp_max, mp_max, birthdate</span><br><span class="line"><span class="keyword">FROM</span> heros </span><br><span class="line"><span class="keyword">WHERE</span> (role_main <span class="keyword">IN</span> (<span class="string">&#x27;法师&#x27;</span>, <span class="string">&#x27;射手&#x27;</span>) <span class="keyword">OR</span> role_assist <span class="keyword">IN</span> (<span class="string">&#x27;法师&#x27;</span>, <span class="string">&#x27;射手&#x27;</span>)) </span><br><span class="line"><span class="keyword">AND</span> <span class="type">DATE</span>(birthdate) <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="string">&#x27;2016-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2017-01-01&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (hp_max <span class="operator">+</span> mp_max) <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>你能看到<code>WHERE</code>子句分成了两个部分。第一部分是关于主要定位和次要定位的条件过滤，使用的是<code>role_main in (&#39;法师&#39;, &#39;射手&#39;) OR role_assist in (&#39;法师&#39;, &#39;射手&#39;)</code>。这里用到了<code>IN</code>逻辑运算符，同时<code>role_main</code>和<code>role_assist</code>是<code>OR</code>（或）的关系。</p>
<p>第二部分是关于上线时间的条件过滤。<code>NOT</code>代表否，因为我们要找到不在<code>2016-01-01</code>到<code>2017-01-01</code>之间的日期，因此用到了<code>NOT BETWEEN &#39;2016-01-01&#39; AND &#39;2017-01-01&#39;</code>。同时我们是在对日期类型数据进行检索，所以使用到了<code>DATE</code>函数，将字段<code>birthdate</code>转化为日期类型再进行比较。</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">role_main</th>
<th align="center">role_assist</th>
<th align="center">hp_max</th>
<th align="center">mp_max</th>
<th align="center">birthdate</th>
</tr>
</thead>
<tbody><tr>
<td align="center">张良</td>
<td align="center">法师</td>
<td align="center"></td>
<td align="center">5799</td>
<td align="center">1988</td>
<td align="center">2015-10-26</td>
</tr>
<tr>
<td align="center">貂蝉</td>
<td align="center">法师</td>
<td align="center">刺客</td>
<td align="center">5611</td>
<td align="center">1960</td>
<td align="center">2015-12-15</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">芈月</td>
<td align="center">法师</td>
<td align="center">坦克</td>
<td align="center">6164</td>
<td align="center">100</td>
<td align="center">2015-12-08</td>
</tr>
</tbody></table>
<h1 id="使用通配符进行过滤"><a href="#使用通配符进行过滤" class="headerlink" title="使用通配符进行过滤"></a>使用通配符进行过滤</h1><p>刚才的条件过滤都是对已知值进行的过滤，还有一种情况是我们要检索文本中包含某个词的所有数据，这里就需要使用通配符。通配符就是我们用来匹配值的一部分的特殊字符。这里我们需要使用到<code>LIKE</code>操作符。</p>
<p>如果我们想要匹配任意字符串出现的任意次数，需要使用（<code>%</code>）通配符。比如我们想要查找英雄名中包含“太”字的英雄都有哪些：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;% 太 %&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">东皇太一</td>
</tr>
<tr>
<td align="center">太乙真人</td>
</tr>
</tbody></table>
<p>需要说明的是不同 DBMS 对通配符的定义不同，在 Access 中使用的是（<code>*</code>）而不是（<code>%</code>）。另外关于字符串的搜索可能是需要区分大小写的，比如<code>&#39;liu%&#39;</code>就不能匹配上<code>&#39;LIU BEI&#39;</code>。具体是否区分大小写还需要考虑不同的 DBMS 以及它们的配置。</p>
<p>如果我们想要匹配单个字符，就需要使用下划线 (<code>_</code>) 通配符。（<code>%</code>）和（<code>_</code>）的区别在于，（<code>%</code>）代表一个或多个字符，而（<code>_</code>）只代表一个字符。比如我们想要查找英雄名除了第一个字以外，包含“太”字的英雄有哪些。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;_% 太 %&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因为太乙真人的太是第一个字符，而<code>_%太%</code>中的太不是在第一个字符，所以匹配不到“太乙真人”，只可以匹配上“东皇太一”。</p>
<p>同样需要说明的是，在 Access 中使用（<code>?</code>）来代替（<code>_</code>），而且在 DB2 中是不支持通配符（<code>_</code>）的，因此你需要在使用的时候查阅相关的 DBMS 文档。</p>
<p>通配符还是很有用的，尤其是在进行字符串匹配的时候。不过在实际操作过程中，还是尽量少用通配符，因为它需要消耗数据库更长的时间来进行匹配。即使你对<code>LIKE</code>检索的字段进行了索引，索引的价值也可能会失效。如果要让索引生效，那么<code>LIKE</code>后面就不能以（<code>%</code>）开头，比如使用<code>LIKE &#39;%太%&#39;或LIKE &#39;%太&#39;</code>的时候就会对全表进行扫描。如果使用<code>LIKE &#39;太%&#39;</code>，同时检索的字段进行了索引的时候，则不会进行全表扫描。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL 检索数据"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/05/SQL/SQL%20%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/"
    >SQL 检索数据</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/05/SQL/SQL%20%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/" class="article-date">
  <time datetime="2020-02-05T07:15:09.000Z" itemprop="datePublished">2020-02-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>SELECT</code>的作用是从一个表或多个表中检索出想要的数据行。</p>
<h1 id="SELECT-查询的基础语法"><a href="#SELECT-查询的基础语法" class="headerlink" title="SELECT 查询的基础语法"></a>SELECT 查询的基础语法</h1><p><code>SELECT</code>可以帮助我们从一个表或多个表中进行数据查询。我们知道一个数据表是由列（字段名）和行（数据行）组成的，我们要返回满足条件的数据行，就需要在<code>SELECT</code>后面加上我们想要查询的列名，可以是一列，也可以是多个列。如果你不知道所有列名都有什么，也可以检索所有列。</p>
<p>下面这个王者荣耀英雄数据表里一共有 69 个英雄，23 个属性值（不包括英雄名<code>name</code>）。SQL 文件见<a target="_blank" rel="noopener" href="https://github.com/cystanford/sql_heros_data">Github 地址</a>。</p>
<table>
<thead>
<tr>
<th align="center"><code>id</code></th>
<th align="center"><code>name</code></th>
<th align="center"><code>hp_max</code></th>
<th align="center"><code>hp_growth</code></th>
<th align="center">…</th>
<th align="center"><code>role_assist</code></th>
<th align="center"><code>birthdate</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">10000</td>
<td align="center">夏侯淳</td>
<td align="center">7350</td>
<td align="center">288.8</td>
<td align="center"></td>
<td align="center">战士</td>
<td align="center">2016-07-19</td>
</tr>
<tr>
<td align="center">10001</td>
<td align="center">钟无艳</td>
<td align="center">7000</td>
<td align="center">275</td>
<td align="center"></td>
<td align="center">坦克</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10002</td>
<td align="center">张飞</td>
<td align="center">8341</td>
<td align="center">329</td>
<td align="center"></td>
<td align="center">辅助</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">10068</td>
<td align="center">百里守约</td>
<td align="center">5611</td>
<td align="center">185</td>
<td align="center"></td>
<td align="center">战士</td>
<td align="center">2017-08-08</td>
</tr>
</tbody></table>
<p>数据表中这 24 个字段（除了<code>id</code>以外），分别代表的含义见下图。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">name <br> 英雄名称</td>
<td align="center">hp_max <br> 最大生命</td>
<td align="center">hp_growth <br> 生命成长</td>
<td align="center">hp_start <br> 初始生命</td>
</tr>
<tr>
<td align="center">mp_max <br> 最大法力</td>
<td align="center">mp_growth <br> 法力成长</td>
<td align="center">mp_start <br> 初始法力</td>
<td align="center">attack_max <br> 最高物攻</td>
</tr>
<tr>
<td align="center">attack_growth <br> 物攻成长</td>
<td align="center">attack_start <br> 初始物攻</td>
<td align="center">defense_max <br> 最大物防</td>
<td align="center">defense_growth&#96; <br> 物防成长</td>
</tr>
<tr>
<td align="center">defense_start <br> 初始物防</td>
<td align="center">hp_5s_max <br> 最大没5秒回血</td>
<td align="center">hp_5s_growth <br> 每5秒回血成长</td>
<td align="center">hp_5s_start <br> 初始每5秒回血</td>
</tr>
<tr>
<td align="center">mp_5s_max <br> 最大每5秒回蓝</td>
<td align="center">mp_5s_growth <br> 每5s回蓝成长</td>
<td align="center">mp_5s_start <br> 初始每5秒回蓝</td>
<td align="center">attack_range <br> 攻击范围</td>
</tr>
<tr>
<td align="center">attack_speed_max <br> 最大攻速</td>
<td align="center">role_main <br> 主要定位</td>
<td align="center">role_assist <br> 次要定位</td>
<td align="center">birthdate <br> 上线时间</td>
</tr>
</tbody></table>
<h2 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h2><p>如果我们想要对数据表中的某一列进行检索，在<code>SELECT</code>后面加上这个列的字段名即可。比如我们想要检索数据表中都有哪些英雄。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>你可以看到这样就等于单独输出了<code>name</code>这一列。</p>
<table>
<thead>
<tr>
<th align="center"><code>name</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">夏侯淳</td>
</tr>
<tr>
<td align="center">钟无艳</td>
</tr>
<tr>
<td align="center">…</td>
</tr>
<tr>
<td align="center">百里守约</td>
</tr>
</tbody></table>
<p>我们也可以对多个列进行检索，在列名之间用逗号 (,) 分割即可。比如我们想要检索有哪些英雄，他们的最大生命、最大法力、最大物攻和最大物防分别是多少。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max, mp_max, attack_max, defense_max <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>这个表中一共有 25 个字段，除了<code>id</code>和英雄名<code>name</code>以外，还存在 23 个属性值，如果我们记不住所有的字段名称，可以使用<code>SELECT *</code>帮我们检索出所有的列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>我们在做数据探索的时候，<code>SELECT *</code>还是很有用的，这样我们就不需要写很长的<code>SELECT</code>语句了。但是在生产环境时要尽量避免使用<code>SELECT *</code>。</p>
<h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><p>我们在使用<code>SELECT</code>查询的时候，还有一些技巧可以使用，比如你可以给列名起别名。我们在进行检索的时候，可以给英雄名、最大生命、最大法力、最大物攻和最大物防等取别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name <span class="keyword">AS</span> n, hp_max <span class="keyword">AS</span> hm, mp_max <span class="keyword">AS</span> mm, attack_max <span class="keyword">AS</span> am, defense_max <span class="keyword">AS</span> dm <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>运行结果和上面多列检索的运行结果是一样的，只是将列名改成了<code>n、hm、mm、am</code>和<code>dm</code>。当然这里的列别名只是举例，一般来说起别名的作用是对原有名称进行简化，从而让 SQL 语句看起来更精简。同样我们也可以对表名称起别名，这个在多表连接查询的时候会用到。</p>
<h2 id="查询常数"><a href="#查询常数" class="headerlink" title="查询常数"></a>查询常数</h2><p><code>SELECT</code>查询还可以对常数进行查询。就是在<code>SELECT</code>查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。你可能会问为什么我们还要对常数进行查询呢？SQL 中的<code>SELECT</code>语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p>
<p>比如说，我们想对<code>heros</code>数据表中的英雄名进行查询，同时增加一列字段<code>platform</code>，这个字段固定值为“王者荣耀”，可以这样写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="string">&#x27;王者荣耀&#x27;</span> <span class="keyword">as</span> platform, name <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center"><code>plantform</code></th>
<th align="center"><code>name</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">王者荣耀</td>
<td align="center">夏侯淳</td>
</tr>
<tr>
<td align="center">王者荣耀</td>
<td align="center">钟无艳</td>
</tr>
<tr>
<td align="center">王者荣耀</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">王者荣耀</td>
<td align="center">百里守约</td>
</tr>
</tbody></table>
<p>在这个 SQL 语句中，我们虚构了一个<code>platform</code>字段，并且把它设置为固定值“王者荣耀”。</p>
<p>需要说明的是，如果常数是个字符串，那么使用单引号（’’）就非常重要了，比如‘王者荣耀’。单引号说明引号中的字符串是个常数，否则 SQL 会把王者荣耀当成列名进行查询，但实际上数据表里没有这个列名，就会引起错误。如果常数是英文字母，比如<code>&#39;WZRY&#39;</code>也需要加引号。如果常数是个数字，就可以直接写数字，不需要单引号，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="number">123</span> <span class="keyword">as</span> platform, name <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<h2 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h2><p>关于单个表的<code>SELECT</code>查询，还有一个非常实用的操作，就是从结果中去掉重复的行。使用的关键字是<code>DISTINCT</code>。比如我们想要看下<code>heros</code>表中关于攻击范围的取值都有哪些：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> attack_range <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<p>这样我们就能直观地看到攻击范围其实只有两个值，那就是近战和远程。</p>
<table>
<thead>
<tr>
<th align="center"><code>attack_range</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">近战</td>
</tr>
<tr>
<td align="center">远程</td>
</tr>
</tbody></table>
<p>如果我们带上英雄名称：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> attack_range, name <span class="keyword">FROM</span> heros</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center"><code>attack_range</code></th>
<th align="center"><code>name</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">近战</td>
<td align="center">夏侯淳</td>
</tr>
<tr>
<td align="center">近战</td>
<td align="center">钟无艳</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">远程</td>
<td align="center">百里守约</td>
</tr>
</tbody></table>
<p>这里有两点需要注意：<br><code>DISTINCT</code>需要放到所有列名的前面，如果写成<code>SELECT name, DISTINCT attack_range FROM heros</code>会报错。<br><code>DISTINCT</code>其实是对后面所有列名的组合进行去重，你能看到最后的结果是 69 条，因为这 69 个英雄名称不同，都有攻击范围（<code>attack_range</code>）这个属性值。如果你想要看都有哪些不同的攻击范围（<code>attack_range</code>），只需要写<code>DISTINCT attack_range</code>即可，后面不需要再加其他的列名了。</p>
<h1 id="如何排序检索数据"><a href="#如何排序检索数据" class="headerlink" title="如何排序检索数据"></a>如何排序检索数据</h1><p>当我们检索数据的时候，有时候需要按照某种顺序进行结果的返回，比如我们想要查询所有的英雄，按照最大生命从高到低的顺序进行排列，就需要使用<code>ORDER BY</code>子句。使用<code>ORDER BY</code>子句有以下几个点需要掌握：</p>
<ul>
<li>排序的列名：<code>ORDER BY</code>后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。</li>
<li>排序的顺序：<code>ORDER BY</code>后面可以注明排序规则，<code>ASC</code>代表递增排序，<code>DESC</code>代表递减排序。如果没有注明排序规则，默认情况下是按照<code>ASC</code>递增排序。我们很容易理解<code>ORDER BY</code>对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断<code>A</code>是在<code>B</code>之前，还是在<code>B</code>之后。比如使用 MySQL 在创建字段的时候设置为<code>BINARY</code>属性，就代表区分大小写。</li>
<li>非选择列排序：<code>ORDER BY</code>可以使用非选择列进行排序，所以即使在<code>SELECT</code>后面没有这个列名，你同样可以放到<code>ORDER BY</code>后面进行排序。</li>
<li><code>ORDER BY</code>的位置：<code>ORDER BY</code>通常位于<code>SELECT</code>语句的最后一条子句，否则会报错。</li>
</ul>
<p>假设我们想要显示英雄名称及最大生命值，按照最大生命值从高到低的方式进行排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">ORDER</span> <span class="keyword">BY</span> hp_max <span class="keyword">DESC</span> </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center"><code>name</code></th>
<th align="center"><code>hp_max</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">廉颇</td>
<td align="center">9328</td>
</tr>
<tr>
<td align="center">白起</td>
<td align="center">8638</td>
</tr>
<tr>
<td align="center">程咬金</td>
<td align="center">8611</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">武则天</td>
<td align="center">5037</td>
</tr>
</tbody></table>
<p>如果想要显示英雄名称及最大生命值，按照第一排序最大法力从低到高，当最大法力值相等的时候则按照第二排序进行，即最大生命值从高到低的方式进行排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">ORDER</span> <span class="keyword">BY</span> mp_max, hp_max <span class="keyword">DESC</span>  </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center"><code>name</code></th>
<th align="center"><code>hp_max</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">程咬金</td>
<td align="center">8611</td>
</tr>
<tr>
<td align="center">亚瑟</td>
<td align="center">8050</td>
</tr>
<tr>
<td align="center">曹操</td>
<td align="center">7473</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">妲己</td>
<td align="center">5824</td>
</tr>
</tbody></table>
<h1 id="约束返回结果的数量"><a href="#约束返回结果的数量" class="headerlink" title="约束返回结果的数量"></a>约束返回结果的数量</h1><p>另外在查询过程中，我们可以约束返回结果的数量，使用<code>LIMIT</code>关键字。比如我们想返回英雄名称及最大生命值，按照最大生命值从高到低排序，返回 5 条记录即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">ORDER</span> <span class="keyword">BY</span> hp_max <span class="keyword">DESC</span> LIMIT <span class="number">5</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center"><code>name</code></th>
<th align="center"><code>hp_max</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">廉颇</td>
<td align="center">9328</td>
</tr>
<tr>
<td align="center">白起</td>
<td align="center">8638</td>
</tr>
<tr>
<td align="center">程咬金</td>
<td align="center">8611</td>
</tr>
<tr>
<td align="center">刘婵</td>
<td align="center">8581</td>
</tr>
<tr>
<td align="center">牛魔</td>
<td align="center">8476</td>
</tr>
</tbody></table>
<p>有一点需要注意，约束返回结果的数量，在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用<code>LIMIT</code>关键字，而且需要放到<code>SELECT</code>语句的最后面。如果是 SQL Server 和 Access，需要使用<code>TOP</code>关键字，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> TOP <span class="number">5</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">ORDER</span> <span class="keyword">BY</span> hp_max <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>如果是 DB2，使用<code>FETCH FIRST 5 ROWS ONLY</code>这样的关键字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">ORDER</span> <span class="keyword">BY</span> hp_max <span class="keyword">DESC</span> <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span></span><br></pre></td></tr></table></figure>
<p>如果是 Oracle，你需要基于<code>ROWNUM</code>来统计行数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>：<span class="keyword">SELECT</span> name, hp_max <span class="keyword">FROM</span> heros <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span><span class="number">5</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> hp_max <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照<code>hp_max</code>从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。可以使用<code>SELECT name, hp_max FROM (SELECT name, hp_max FROM heros ORDER BY hp_max) WHERE ROWNUM &lt;=5</code>得到与上述方法一致的结果。</p>
<p>约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有 1 条，就可以使用<code>LIMIT 1</code>，告诉<code>SELECT</code>语句只需要返回一条记录即可。这样的好处就是<code>SELECT</code>不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p>
<h1 id="SELECT-的执行顺序"><a href="#SELECT-的执行顺序" class="headerlink" title="SELECT 的执行顺序"></a>SELECT 的执行顺序</h1><p>查询是<code>RDBMS</code>中最频繁的操作。我们在理解<code>SELECT</code>语法的时候，还需要了解<code>SELECT</code>执行时的底层原理。只有这样，才能让我们对 SQL 有更深刻的认识。</p>
<p>其中你需要记住<code>SELECT</code>查询时的两个顺序：</p>
<h2 id="1-关键字的顺序是不能颠倒的："><a href="#1-关键字的顺序是不能颠倒的：" class="headerlink" title="1. 关键字的顺序是不能颠倒的："></a>1. 关键字的顺序是不能颠倒的：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">GROUP</span> <span class="keyword">BY</span> ... <span class="keyword">HAVING</span> ... <span class="keyword">ORDER</span> <span class="keyword">BY</span> ...</span><br></pre></td></tr></table></figure>
<h2 id="2-SELECT-语句的执行顺序（在-MySQL-和-Oracle-中，SELECT-执行顺序基本相同）："><a href="#2-SELECT-语句的执行顺序（在-MySQL-和-Oracle-中，SELECT-执行顺序基本相同）：" class="headerlink" title="2.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）："></a>2.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="operator">&gt;</span> <span class="keyword">SELECT</span> 的字段 <span class="operator">&gt;</span> <span class="keyword">DISTINCT</span> <span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&gt;</span> LIMIT</span><br></pre></td></tr></table></figure>
<p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num # 顺序 <span class="number">5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id # 顺序 <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> # 顺序 <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id # 顺序 <span class="number">3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> # 顺序 <span class="number">4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> # 顺序 <span class="number">6</span></span><br><span class="line">LIMIT <span class="number">2</span> # 顺序 <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>在<code>SELECT</code>语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<p>SQL 的执行原理。</p>
<p>首先，你可以注意到，<code>SELECT</code>是先执行<code>FROM</code>这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<ol>
<li>首先先通过<code>CROSS JOIN</code>求笛卡尔积，相当于得到虚拟表<code>vt（virtual table）1-1</code>；</li>
<li>通过<code>ON</code>进行筛选，在虚拟表<code>vt1-1</code>的基础上进行筛选，得到虚拟表<code>vt1-2</code>；</li>
<li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表<code>vt1-2</code>的基础上增加外部行，得到虚拟表<code>vt1-3</code>。</li>
</ol>
<p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p>
<p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表<code>vt1</code>，就可以在此基础上再进行<code>WHERE</code>阶段。在这个阶段中，会根据<code>vt1</code>表的结果进行筛选过滤，得到虚拟表<code>vt2</code>。</p>
<p>然后进入第三步和第四步，也就是<code>GROUP</code>和<code>HAVING</code>阶段。在这个阶段中，实际上是在虚拟表<code>vt2</code>的基础上进行分组和分组过滤，得到中间的虚拟表<code>vt3</code>和<code>vt4</code>。</p>
<p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到<code>SELECT</code>和<code>DISTINCT</code>阶段。</p>
<p>首先在<code>SELECT</code>阶段会提取想要的字段，然后在<code>DISTINCT</code>阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5-1</code>和<code>vt5-2</code>。</p>
<p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是<code>ORDER BY</code>阶段，得到虚拟表<code>vt6</code>。</p>
<p>最后在<code>vt6</code>的基础上，取出指定行的记录，也就是<code>LIMIT</code>阶段，得到最终的结果，对应的是虚拟表<code>vt7</code>。</p>
<p>当然我们在写<code>SELECT</code>语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p>
<p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写<code>SELECT</code>语句的时候，还要注意相应的关键字顺序。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL DDL创建数据库&amp;数据表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/04/SQL/SQL%20DDL%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&%E6%95%B0%E6%8D%AE%E8%A1%A8/"
    >SQL DDL创建数据库&amp;数据表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/04/SQL/SQL%20DDL%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93&%E6%95%B0%E6%8D%AE%E8%A1%A8/" class="article-date">
  <time datetime="2020-02-04T03:22:14.000Z" itemprop="datePublished">2020-02-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>DDL 是 DBMS 的核心组件，也是 SQL 的重要组成部分，DDL 的正确性和稳定性是整个 SQL 运行的重要基础。</p>
<h1 id="DDL-的基础语法"><a href="#DDL-的基础语法" class="headerlink" title="DDL 的基础语法"></a>DDL 的基础语法</h1><p>DDL 的英文全称是<code>Data Definition Language</code>，中文是数据定义语言。它定义了数据库的结构和数据表的结构。</p>
<p>在 DDL 中，我们常用的功能是增删改，分别对应的命令是<code>CREATE、DROP</code>和<code>ALTER</code>。需要注意的是，在执行 DDL 的时候，不需要<code>COMMIT</code>，就可以完成执行任务。</p>
<ol>
<li>对数据库进行定义<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE nba; <span class="operator">/</span><span class="operator">/</span> 创建一个名为 nba 的数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE nba; <span class="operator">/</span><span class="operator">/</span> 删除一个名为 nba 的数据库</span><br></pre></td></tr></table></figure></li>
<li>对数据表进行定义<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h1><p>比如我们想创建一个球员表，表名为<code>player</code>，里面有两个字段，一个是<code>player_id</code>，它是<code>int</code>类型，另一个<code>player_name</code>字段是<code>varchar(255)</code>类型。这两个字段都不为空，且<code>player_id</code>是递增的。</p>
<p>那么创建的时候就可以写为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> player  (</span><br><span class="line">  player_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  player_name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，语句最后以分号（<code>;</code>）作为结束符，最后一个字段的定义结束后没有逗号。数据类型中<code>int(11)</code>代表整数类型，显示长度为 11 位，括号中的参数 11 代表的是最大有效显示长度，与类型包含的数值范围大小无关。<code>varchar(255)</code>代表的是最大长度为 255 的可变字符串类型。<code>NOT NULL</code>表明整个字段不能是空值，是一种数据约束。<code>AUTO_INCREMENT</code>代表主键自动增长。</p>
<p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。比如 Navicat，它是一个数据库管理和设计工具，跨平台，支持很多种数据库管理软件。</p>
<p>假如还是针对<code>player</code>这张表，我们想设计以下的字段：</p>
<table>
<thead>
<tr>
<th align="center">字段</th>
<th align="center">含义</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>player_id</code></td>
<td align="center">球员ID</td>
<td align="center"><code>int</code>整数类型，最大显示长度11</td>
</tr>
<tr>
<td align="center"><code>team_id</code></td>
<td align="center">球队ID</td>
<td align="center"><code>int</code>整数类型，最大显示长度11</td>
</tr>
<tr>
<td align="center"><code>player_name</code></td>
<td align="center">球员姓名</td>
<td align="center"><code>varchar</code>字符串类型，最大长度255</td>
</tr>
<tr>
<td align="center"><code>height</code></td>
<td align="center">身高</td>
<td align="center"><code>float</code>浮点类型，一共存储3个有效数字，其中小数点长度为2</td>
</tr>
</tbody></table>
<p>其中<code>player_id</code>是数据表<code>player</code>的主键，且自动增长，也就是<code>player_id</code>会从 1 开始，然后每次加 1。<code>player_id、team_id、player_name</code>这三个字段均不为空，<code>height</code>字段可以为空。</p>
<p>按照上面的设计需求，我们可以使用 Navicat 软件进行设计，如下所示：</p>


<p>然后，我们还可以对<code>player_name</code>字段进行索引，索引类型为<code>Unique</code>。使用 Navicat 设置如下：</p>


<p>这样一张<code>player</code>表就通过可视化工具设计好了。我们可以把这张表导出来，可以看看这张表对应的 SQL 语句是怎样的。方法是在 Navicat 左侧用右键选中<code>player</code>这张表，然后选择“转储 SQL 文件”→“仅结构”，这样就可以看到导出的 SQL 文件了，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `player`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `player`  (</span><br><span class="line">  `player_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `team_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `player_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `height` <span class="type">float</span>(<span class="number">3</span>, <span class="number">2</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0.00</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`player_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX `player_name`(`player_name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>
<p>你能看到整个 SQL 文件中的 DDL 处理，首先先删除<code>player</code>表（如果数据库中存在该表的话），然后再创建<code>player</code>表，里面的数据表和字段都使用了反引号，这是为了避免它们的名称与 MySQL 保留字段相同，对数据表和字段名称都加上了反引号。</p>
<p>其中<code>player_name</code>字段的字符集是<code>utf8</code>，排序规则是<code>utf8_general_ci</code>，代表对大小写不敏感，如果设置为<code>utf8_bin</code>，代表对大小写敏感。</p>
<p>因为<code>player_id</code>设置为了主键，因此在 DDL 中使用<code>PRIMARY KEY</code>进行规定，同时索引方法采用<code>BTREE</code>。</p>
<p>因为我们对<code>player_name</code>字段进行索引，在设置字段索引时，我们可以设置为<code>UNIQUE INDEX</code>（唯一索引），也可以设置为其他索引方式，比如<code>NORMAL INDEX</code>（普通索引），这里我们采用<code>UNIQUE INDEX</code>。唯一索引和普通索引的区别在于它对字段进行了唯一性的约束。在索引方式上，你可以选择<code>BTREE</code>或者<code>HASH</code>，这里采用了<code>BTREE</code>方法进行索引。</p>
<p>整个数据表的存储规则采用 InnoDB。InnoDB，它是 MySQL5.5 版本之后默认的存储引擎。同时，我们将字符集设置为<code>utf8</code>，排序规则为<code>utf8_general_ci</code>，行格式为<code>Dynamic</code>，就可以定义数据表的最后约定了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>
<p>可视化工具还是非常方便的，它能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p>
<h1 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h1><p>在创建表结构之后，我们还可以对表结构进行修改。</p>
<ol>
<li>添加字段，比如我在数据表中添加一个<code>age</code>字段，类型为<code>int(11)</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> player <span class="keyword">ADD</span> (age <span class="type">int</span>(<span class="number">11</span>));</span><br></pre></td></tr></table></figure></li>
<li>修改字段名，将<code>age</code>字段改成<code>player_age</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> player RENAME <span class="keyword">COLUMN</span> age <span class="keyword">to</span> player_age</span><br></pre></td></tr></table></figure></li>
<li>修改字段的数据类型，将<code>player_age</code>的数据类型设置为<code>float(3,1)</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> player MODIFY (player_age <span class="type">float</span>(<span class="number">3</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
<li>删除字段, 删除刚才添加的<code>player_age</code>字段<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> player <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> player_age;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="数据表的常见约束"><a href="#数据表的常见约束" class="headerlink" title="数据表的常见约束"></a>数据表的常见约束</h1><p>当我们创建数据表的时候，还会对字段进行约束，约束的目的在于保证 RDBMS 里面数据的准确性和一致性。下面，我们来看下常见的约束有哪些。</p>
<ul>
<li>首先是主键约束。<br>主键起的作用是唯一标识一条记录，不能重复，不能为空，即<code>UNIQUE+NOT NULL</code>。一个数据表的主键只能有一个。主键可以是一个字段，也可以由多个字段复合组成。在上面的例子中，我们就把<code>player_id</code>设置为了主键。</li>
<li>其次还有外键约束。<br>外键确保了表与表之间引用的完整性。一个表中的外键对应另一张表的主键。外键可以是重复的，也可以为空。比如<code>player_id</code>在<code>player</code>表中是主键，如果你想设置一个球员比分表即<code>player_score</code>，就可以在<code>player_score</code>中设置<code>player_id</code>为外键，关联到<code>player</code>表中。</li>
</ul>
<p>除了对键进行约束外，还有字段约束。</p>
<ul>
<li>唯一性约束。<br>唯一性约束表明了字段在表中的数值是唯一的，即使我们已经有了主键，还可以对其他字段进行唯一性约束。比如我们在<code>player</code>表中给<code>player_name</code>设置唯一性约束，就表明任何两个球员的姓名不能相同。需要注意的是，唯一性约束和普通索引（<code>NORMAL INDEX</code>）之间是有区别的。唯一性约束相当于创建了一个约束和普通索引，目的是保证字段的正确性，而普通索引只是提升数据检索的速度，并不对字段的唯一性进行约束。</li>
<li><code>NOT NULL</code>约束。<br>对字段定义了<code>NOT NULL</code>，即表明该字段不应为空，必须有取值。</li>
<li><code>DEFAULT</code>，表明了字段的默认值。如果在插入数据的时候，这个字段没有取值，就设置为默认值。比如我们将身高<code>height</code>字段的取值默认设置为<code>0.00</code>，即<code>DEFAULT 0.00</code>。</li>
<li><code>CHECK</code>约束，用来检查特定字段取值范围的有效性，<code>CHECK</code>约束的结果不能为<code>FALSE</code>，比如我们可以对身高<code>height</code>的数值进行<code>CHECK</code>约束，必须<code>≥0</code>，且<code>＜3</code>，即<code>CHECK(height&gt;=0 AND height&lt;3)</code>。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-SQL/SQL入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/03/SQL/SQL%E5%85%A5%E9%97%A8/"
    >SQL入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/03/SQL/SQL%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-02-03T03:02:21.000Z" itemprop="datePublished">2020-02-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/">SQL</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>我们可以把 SQL 语言按照功能划分成 4 个部分：</p>
<ul>
<li>DDL（<code>Data Definition Language</code>），也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</li>
<li>DML（<code>Data Manipulation Language</code>），数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li>
<li>DCL（<code>Data Control Language</code>），数据控制语言，我们用它来定义访问权限和安全级别。</li>
<li>DQL（<code>Data Query Language</code>），数据查询语言，我们用它查询想要的记录。</li>
</ul>
<h1 id="DB、DBS-和-DBMS-的区别是什么"><a href="#DB、DBS-和-DBMS-的区别是什么" class="headerlink" title="DB、DBS 和 DBMS 的区别是什么"></a>DB、DBS 和 DBMS 的区别是什么</h1><p>DBMS（<code>DataBase Management System</code>），数据库管理系统，实际上它可以对多个数据库进行管理，所以你可以理解为 DBMS &#x3D; 多个数据库（DB） + 管理程序。</p>
<p>DB（<code>DataBase</code>），也就是数据库。数据库是存储数据的集合，你可以把它理解为多个数据表。</p>
<p>DBS（<code>DataBase System</code>），数据库系统。它是更大的概念，包括了数据库、数据库管理系统以及数据库管理人员 DBA。</p>
<p>这里需要注意的是，虽然我们有时候把 Oracle、MySQL 等称之为数据库，但确切讲，它们应该是数据库管理系统，即 DBMS。</p>
<h2 id="常见DBMS"><a href="#常见DBMS" class="headerlink" title="常见DBMS"></a>常见DBMS</h2><table>
<thead>
<tr>
<th align="center">数据库管理系统</th>
<th align="center">数据库模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Oracle</td>
<td align="center">关系型</td>
</tr>
<tr>
<td align="center">MySQL</td>
<td align="center">关系型</td>
</tr>
<tr>
<td align="center">Microsoft SQL Server</td>
<td align="center">关系型</td>
</tr>
<tr>
<td align="center">MongoDB</td>
<td align="center">文档型</td>
</tr>
<tr>
<td align="center">Elasticsearch</td>
<td align="center">搜索引擎</td>
</tr>
<tr>
<td align="center">Redis</td>
<td align="center">键值型</td>
</tr>
<tr>
<td align="center">HBase</td>
<td align="center">列存储</td>
</tr>
</tbody></table>
<p>关系型数据库（RDBMS）就是建立在关系模型基础上的数据库，SQL 就是关系型数据库的查询语言。</p>
<p>相比于 SQL，NoSQL 泛指非关系型数据库，包括了键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。</p>
<p>键值型数据库通过<code>Key-Value</code>键值的方式来存储数据，其中<code>Key</code>和<code>Value</code>可以是简单的对象，也可以是复杂的对象。<code>Key</code>作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，同时缺点也很明显，它无法像关系型数据库一样自由使用条件过滤（比如<code>WHERE</code>），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。键值型数据库典型的使用场景是作为内容缓存。Redis 是最流行的键值型数据库。</p>
<p>文档型数据库用来管理文档，在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录，MongoDB 是最流行的文档型数据库。</p>
<p>搜索引擎也是数据库检索中的重要应用，常见的全文搜索引擎有 Elasticsearch、Splunk 和 Solr。虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎的优势在于采用了全文搜索的技术，核心原理是“倒排索引”。</p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储，而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。</p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p>
<h1 id="SQL是如何执行的"><a href="#SQL是如何执行的" class="headerlink" title="SQL是如何执行的"></a>SQL是如何执行的</h1><h2 id="Oracle-中的-SQL-是如何执行的"><a href="#Oracle-中的-SQL-是如何执行的" class="headerlink" title="Oracle 中的 SQL 是如何执行的"></a>Oracle 中的 SQL 是如何执行的</h2><p>SQL 在 Oracle 中的执行过程：</p>
<img src="/2020/02/03/SQL/SQL%E5%85%A5%E9%97%A8/img1.png" class="">

<p>从上面这张图中可以看出，SQL 语句在 Oracle 中经历了以下的几个步骤。</p>
<ul>
<li>语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</li>
<li>语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</li>
<li>权限检查：看用户是否具备访问该数据的权限。</li>
<li>共享池检查：共享池（<code>Shared Pool</code>）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。Oracle 通过检查共享池是否存在 SQL 语句的执行计划，来判断进行软解析，还是硬解析。那软解析和硬解析又该怎么理解呢？<br>在共享池中，Oracle 首先对 SQL 语句进行<code>Hash</code>运算，然后根据 Hash 值在库缓存（<code>Library Cache</code>）中查找，如果存在 SQL 语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是软解析。<br>如果没有找到 SQL 语句和执行计划，Oracle 就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是硬解析。</li>
<li>优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</li>
<li>执行器：当有了解析树和执行计划之后，就知道了 SQL 该怎么被执行，这样就可以在执行器中执行语句了。</li>
</ul>
<p>共享池是 Oracle 中的术语，包括了库缓存，数据字典缓冲区等。库缓存区主要缓存 SQL 语句和执行计划。而数据字典缓冲区存储的是 Oracle 中的对象定义，比如表、视图、索引等对象。当对 SQL 语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。</p>
<p>库缓存这一个步骤，决定了 SQL 语句是否需要进行硬解析。为了提升 SQL 的执行效率，我们应该尽量避免硬解析，因为在 SQL 的执行过程中，创建解析树，生成执行计划是很消耗资源的。</p>
<p>你可能会问，如何避免硬解析，尽量使用软解析呢？在 Oracle 中，绑定变量是它的一大特色。绑定变量就是在 SQL 语句中使用变量，通过不同的变量取值来改变 SQL 的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p>
<p>举个例子，我们可以使用下面的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> player <span class="keyword">where</span> player_id <span class="operator">=</span> <span class="number">10001</span>;</span><br></pre></td></tr></table></figure>
<p>你也可以使用绑定变量，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> player <span class="keyword">where</span> player_id <span class="operator">=</span> :player_id;</span><br></pre></td></tr></table></figure>
<p>这两个查询语句的效率在 Oracle 中是完全不同的。如果你在查询 player_id &#x3D; 10001 之后，还会查询 10002、10003 之类的数据，那么每一次查询都会创建一个新的查询解析。而第二种方式使用了绑定变量，那么在第一次查询之后，在共享池中就会存在这类查询的执行计划，也就是软解析。</p>
<p>因此我们可以通过使用绑定变量来减少硬解析，减少 Oracle 的解析工作量。但是这种方式也有缺点，使用动态 SQL 的方式，因为参数不同，会导致 SQL 的执行效率不同，同时 SQL 优化也会比较困难。</p>
<h2 id="MySQL-中的-SQL-是如何执行的"><a href="#MySQL-中的-SQL-是如何执行的" class="headerlink" title="MySQL 中的 SQL 是如何执行的"></a>MySQL 中的 SQL 是如何执行的</h2><p>首先 MySQL 是典型的 C&#x2F;S 架构，即 Client&#x2F;Server 架构，服务器端程序使用的 mysqld。整体的 MySQL 流程如下图所示：</p>
<img src="/2020/02/03/SQL/SQL%E5%85%A5%E9%97%A8/img2.png" class="">

<p>MySQL 由三层组成：</p>
<ul>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li>
<li>SQL 层：对 SQL 语句进行查询处理；</li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取。</li>
</ul>
<p>其中 SQL 层与数据库文件的存储方式无关，我们来看下 SQL 层的结构：</p>
<img src="/2020/02/03/SQL/SQL%E5%85%A5%E9%97%A8/img3.jpeg" class="">

<ol>
<li>查询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</li>
<li>解析器：在解析器中对 SQL 语句进行语法分析、语义分析。</li>
<li>优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索等。</li>
<li>执行器：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</li>
</ol>
<p>SQL 语句在 MySQL 中的流程是：SQL 语句→缓存查询→解析器→优化器→执行器。在一部分中，MySQL 和 Oracle 执行 SQL 的原理是一样的。</p>
<p>与 Oracle 不同的是，MySQL 的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的 MySQL 还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<ul>
<li>InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</li>
<li>MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。</li>
<li>Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。</li>
<li>NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。</li>
<li>Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。</li>
</ul>
<p>需要注意的是，数据库的设计在于表的设计，而在 MySQL 中每个表的设计都可以采用不同的存储引擎，我们可以根据实际的数据处理需要来选择存储引擎，这也是 MySQL 的强大之处。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/浏览器安全——HTTPS"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/26/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94HTTPS/"
    >浏览器安全——HTTPS</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/26/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94HTTPS/" class="article-date">
  <time datetime="2019-12-26T02:56:33.000Z" itemprop="datePublished">2019-12-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>起初设计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，<br>你们在通信过程中的一切内容都在中间人的掌握中，如下图：</p>
<img src="/2019/12/26/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94HTTPS/img1.png" class="" title="中间人攻击">

<p>从上图可以看出，我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。</p>
<p>具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户<br>一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。</p>
<h1 id="在-HTTP-协议栈中引入安全层"><a href="#在-HTTP-协议栈中引入安全层" class="headerlink" title="在 HTTP 协议栈中引入安全层"></a>在 HTTP 协议栈中引入安全层</h1><p>鉴于 HTTP 的明文传输使得传输过程毫无安全性可言，且制约了网上购物、在线转账等一系列场景应用，于是倒逼着我们要引入加密方案。</p>
<p>从 HTTP 协议栈层面来看，我们可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全层的数据都会被加密或者解密，你可以参考下图：</p>
<img src="/2019/12/26/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94HTTPS/img2.png" class="" title="HTTP VS HTTPS">

<p>从图中我们可以看出 HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP&#x2F;IP，因此要搞清楚<br>HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。</p>
<p>总的来说，安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。</p>
<p>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。</p>
<h2 id="第一版：使用对称加密"><a href="#第一版：使用对称加密" class="headerlink" title="第一版：使用对称加密"></a>第一版：使用对称加密</h2><p>提到加密，最简单的方式是使用对称加密。所谓对称加密是指加密和解密都使用的是相同的密钥。</p>
<p>了解了对称加密，下面我们就使用对称加密来实现第一版的 HTTPS。</p>
<p>要在两台电脑上加解密同一个文件，我们至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p>
<img src="/2019/12/26/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94HTTPS/img3.png" class="" title="使用对称加密实现 HTTPS">

<p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p>
<ul>
<li>浏览器发送它所支持的加密套件列表和一个随机数<code>client-random</code>，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li>
<li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数<code>service-random</code>，并将<code>service-random</code>和加密套件列表返回给浏览器。</li>
<li>最后浏览器和服务器分别返回确认消息。</li>
</ul>
<p>这样浏览器端和服务器端都有相同的<code>client-random</code>和<code>service-random</code>了，然后它们再使用相同的方法将<code>client-random</code>和<code>service-random</code>混合起来生成一个密钥<code>master secret</code>，有了密钥<code>master secret</code>和加密套件之后，双方就可以进行数据的加密传输了。</p>
<p>通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输<code>client-random</code>和<code>service-random</code>的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p>
<h2 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h2><p>不过非对称加密能够解决这个问题，因此接下来我们就利用非对称加密来实现我们第二版的 HTTPS，我们先看看什么是非对称加密。</p>
<p>和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</p>
<p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。下图是使用非对称加密改造的 HTTPS 协<br>议：</p>
<img src="/2019/12/26/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94HTTPS/img4.png" class="" title="非对称加密实现 HTTPS">

<p>根据该图，我们来分析下使用非对称加密的请求流程。</p>
<ul>
<li>首先浏览器还是发送加密套件列表给服务器。</li>
<li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li>
<li>最后就是浏览器和服务器返回确认消息。</li>
</ul>
<p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。</p>
<p>因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。</p>
<ul>
<li>第一个是非对称加密的效率太低。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li>
<li>第二个是无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</li>
</ul>
<h2 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h2><p>基于以上两点原因，我们最终选择了一个更加完美的方案，那就是在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。下图就是改造后的版本：</p>
<img src="/2019/12/26/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94HTTPS/img5.png" class="" title="混合加密实现 HTTPS">

<p>从图中可以看出，改造后的流程是这样的：</p>
<ul>
<li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数<code>client-random</code>；</li>
<li>服务器保存随机数<code>client-random</code>，选择对称加密和非对称加密的套件，然后生成随机数<code>service-random</code>，向浏览器发送选择的加密套件、<code>service-random</code>和公钥；</li>
<li>浏览器保存公钥，并利用<code>client-random</code>和<code>service-random</code>计算出来<code>pre-master</code>，然后利用公钥对<code>pre-master</code>加密，并向服务器发送加密后的数据；</li>
<li>最后服务器拿出自己的私钥，解密出<code>pre-master</code>数据，并返回确认消息。</li>
</ul>
<p>到此为止，服务器和浏览器就有了共同的<code>client-random、service-random</code>和<code>pre-master</code>，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。</p>
<p>有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p>
<p>需要特别注意的一点，<code>pre-master</code>是经过公钥加密之后传输的，所以黑客无法获取到<code>pre-master</code>，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。</p>
<h2 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h2><p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开百度的官网，但是黑客通过 DNS 劫持将百度官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务<br>器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</p>
<p>所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？</p>
<p>这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面<br>积等信息。</p>
<p>在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个权威机构，并通过这个权威机构给你颁发一个证书：房产证。</p>
<p>同理，一个网站要证明这个服务器就是这个网站的，也需要使用权威机构颁发的证书，这个权威机构称为CA（<code>Certificate Authority</code>），颁发的证书就称为数字证书（<code>DigitalCertificate</code>)。</p>
<p>对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p>
<p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p>


<p>相较于第三版的 HTTPS 协议，这里主要有两点改变：</p>
<ol>
<li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li>
<li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li>
</ol>
<p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p>
<h1 id="数字证书的申请和验证"><a href="#数字证书的申请和验证" class="headerlink" title="数字证书的申请和验证"></a>数字证书的申请和验证</h1><p>通过上面四个版本的迭代，我们实现了目前的 HTTPS 架构。</p>
<p>在第四版的 HTTPS 中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清楚。</p>
<h2 id="如何申请数字证书"><a href="#如何申请数字证书" class="headerlink" title="如何申请数字证书"></a>如何申请数字证书</h2><p>我们先来看看如何向 CA 申请证书。通常的申请流程分以下几步：</p>
<ul>
<li>首先需要准备一套私钥和公钥，私钥留着自己使用；</li>
<li>然后向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li>
<li>CA 通过线上、线下等多种渠道来验证网站所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li>
<li>如信息审核通过，CA 会向网站签发认证的数字证书，包含了网站的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA生成的签名。</li>
</ul>
<p>这样我们就完成了数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用<code>Hash</code>函数来计算网站提交的明文信息，并得出信息摘要；然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给网站的数字签名。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</p>
<h2 id="浏览器如何验证数字证书"><a href="#浏览器如何验证数字证书" class="headerlink" title="浏览器如何验证数字证书"></a>浏览器如何验证数字证书</h2><p>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。</p>
<p>浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的<code>Hash</code>函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确<br>认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。</p>
<p>这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个<br>CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。</p>
<p>另外，在申请和使用证书的过程中，还需要注意以下三点：</p>
<ol>
<li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li>
<li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li>
<li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于 HTTP 的明文传输特性，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这倒逼着我们需要引入加密机制。于是我们在 HTTP 协议栈的 TCP 和 HTTP 层之间插入了一个安全层，负责数据的加密和解密操作。</p>
<p>我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输<br>密钥，这样我们就解决传输效率和两端数据安全传输的问题。</p>
<p>采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="tag">浏览器工作原理与实践</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/浏览器安全——CSRF攻击"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94CSRF%E6%94%BB%E5%87%BB/"
    >浏览器安全——CSRF攻击</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94CSRF%E6%94%BB%E5%87%BB/" class="article-date">
  <time datetime="2019-12-25T10:41:43.000Z" itemprop="datePublished">2019-12-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>我们结合一个真实的关于 CSRF 攻击的典型案例来分析下，在 2007 年的某一天，David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。不过几经周折，David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。</p>
<h1 id="那-David-的域名是怎么被盗的呢？"><a href="#那-David-的域名是怎么被盗的呢？" class="headerlink" title="那 David 的域名是怎么被盗的呢？"></a>那 David 的域名是怎么被盗的呢？</h1><p>我们结合下图来分析下 David 域名的被盗流程：</p>
<img src="/2019/12/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94CSRF%E6%94%BB%E5%87%BB/img1.png" class="" title="David 域名被盗流程">

<ul>
<li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了<code>Cookie、Session</code>等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li>
<li>接着黑客通过各种手段引诱 David 去打开他的链接，比如<code>hacker.com</code>，然后在<code>hacker.com</code>页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱<br>中。</li>
<li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li>
</ul>
<p>以上就是 David 的域名被盗的完整过程，其中前两步就是 CSRF 攻击。</p>
<h1 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h1><p>CSRF 英文全称是<code>Cross-site request forgery</code>，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</p>
<p>通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。</p>
<p>下面我们以极客时间官网为例子，来分析这三种攻击方式都是怎么实施的。这里假设极客时间具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 同时支持 POST 和 Get # 接口</span><br><span class="line">https://time.geekbang.org/sendcoin # 参数</span><br><span class="line">## 目标用户</span><br><span class="line">user ## 目标金额</span><br><span class="line">number</span><br></pre></td></tr></table></figure>
<p>有了上面的转账接口，我们就可以来模拟 CSRF 攻击了。</p>
<h2 id="1-自动发起-Get-请求"><a href="#1-自动发起-Get-请求" class="headerlink" title="1. 自动发起 Get 请求"></a>1. 自动发起 Get 请求</h2><p>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 黑客的站点：CSRF 攻击演示 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://time.geekbang.org/sendcoin?user=hacker&amp;number=100&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在<code>img</code>标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起<code>img</code>的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用<br>户账户上的 100 极客币就被转移到黑客的账户上去了。</p>
<h2 id="2-自动发起-POST-请求"><a href="#2-自动发起-POST-请求" class="headerlink" title="2. 自动发起 POST 请求"></a>2. 自动发起 POST 请求</h2><p>除了自动发送 Get 请求之外，有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 黑客的站点：CSRF 攻击演示 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&#x27;hacker-form&#x27;</span> <span class="attr">action</span>=<span class="string">&quot;https://time.geekbang.org/sendcoin&quot;</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hacker-form&#x27;</span>).<span class="title function_">submit</span>(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨<br>站点 POST 数据提交。</p>
<h2 id="3-引诱用户点击链接"><a href="#3-引诱用户点击链接" class="headerlink" title="3. 引诱用户点击链接"></a>3. 引诱用户点击链接</h2><p>除了自动发起 Get 和 Post 请求之外，还有一种方式是诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">150</span> <span class="attr">src</span>=<span class="string">http://images.xuejuzi.cn/1612/1_161230185104_1.jpg</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://time.geekbang.org/sendcoin?user=hacker&amp;number=100&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">    点击下载美女照片</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。</p>
<p>以上三种就是黑客经常采用的攻击方式。如果当用户登录了极客时间，以上三种 CSRF 攻击方式中的任何一种发生时，那么服务器都会将一定金额的极客币发送到黑客账户。</p>
<p>到这里，相信你已经知道什么是 CSRF 攻击了。和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p>
<h1 id="如何防止-CSRF-攻击"><a href="#如何防止-CSRF-攻击" class="headerlink" title="如何防止 CSRF 攻击"></a>如何防止 CSRF 攻击</h1><p>了解了 CSRF 攻击的一些手段之后，我们再来看看 CSRF 攻击的一些“特征”，然后根据这些“特征”分析下如何防止 CSRF 攻击。下面是我总结的发起 CSRF 攻击的三个必要条件：</p>
<ul>
<li>第一个，目标站点一定要有 CSRF 漏洞；</li>
<li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li>
<li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>
</ul>
<p>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p>
<p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</p>
<h2 id="1-充分利用好-Cookie-的-SameSite-属性"><a href="#1-充分利用好-Cookie-的-SameSite-属性" class="headerlink" title="1. 充分利用好 Cookie 的 SameSite 属性"></a>1. 充分利用好 Cookie 的 SameSite 属性</h2><p>黑客会利用用户的登录状态来发起 CSRF 攻击，而<code>Cookie</code>正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在<code>Cookie</code>上来做文章。</p>
<p>通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止<code>Cookie</code>的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：</p>
<ul>
<li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键<code>Cookie</code>数据到服务器；</li>
<li>如果是同一个站点发起的请求，那么就需要保证<code>Cookie</code>数据正常发送。</li>
</ul>
<p><code>Cookie</code>中的<code>SameSite</code>属性正是为了解决这个问题的，通过使用<code>SameSite</code>可以有效地降低 CSRF 攻击的风险。</p>
<p>那<code>SameSite</code>是怎么防止 CSRF 攻击的呢？</p>
<p>在 HTTP 响应头中，通过<code>set-cookie</code>字段设置<code>Cookie</code>时，可以带上<code>SameSite</code>选项，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/</span><br></pre></td></tr></table></figure>
<p><code>SameSite</code>选项通常有<code>Strict、Lax</code>和<code>None</code>三个值。<br><code>Strict</code>最为严格。如果<code>SameSite</code>的值是<code>Strict</code>，那么浏览器会完全禁止第三方<code>Cookie</code>。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些<code>Cookie</code>设置了<code>SameSite = Strict</code>的话，那么这些<code>Cookie</code>是不会被发送到 InfoQ 的服<br>务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些<code>Cookie</code>。</p>
<p><code>Lax</code>相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交<code>Get</code>方式的表单这两种方式都会携带<code>Cookie</code>。但如果在第三方站点中使用 Post 方法，或者通过<code>img、iframe</code>等标签加载的 URL，这些场景都不会携带<code>Cookie</code>。</p>
<p>而如果使用<code>None</code>的话，在任何情况下都会发送<code>Cookie</code>数据。</p>
<p>对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的<code>Cookie</code>设置为<code>Strict</code>或者<code>Lax</code>模式，这样在跨站点请求时，这些关键的<code>Cookie</code>就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p>
<h2 id="2-验证请求的来源站点"><a href="#2-验证请求的来源站点" class="headerlink" title="2. 验证请求的来源站点"></a>2. 验证请求的来源站点</h2><p>接着我们再来了解另外一种防止 CSRF 攻击的策略，那就是在服务器端验证请求来源的站点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？</p>
<p>这就需要使用 HTTP 请求头中的<code>Referer</code>和<code>Origin</code>属性了。</p>
<p><code>Referer</code>是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如我从极客时间的官网打开了 InfoQ 的站点，那么请求头中的<code>Referer</code>值是极客时间的 URL，如下图：</p>
<img src="/2019/12/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94CSRF%E6%94%BB%E5%87%BB/img2.png" class="" title="HTTP 请求头中的 Referer 引用">

<p>虽然可以通过<code>Referer</code>告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传<code>Referer</code>值。</p>
<p>但在服务器端验证请求头中的<code>Referer</code>并不是太可靠，因此标准委员会又制定了<code>Origin</code>属性，在一些重要的场合，比如通过<code>XMLHttpRequest、Fecth</code>发起跨站请求或者通过 Post 方法发送请求时，都会带上<code>Origin</code>属性，如下图：</p>
<img src="/2019/12/25/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94CSRF%E6%94%BB%E5%87%BB/img3.png" class="" title="Post 请求时的 Origin 信息">

<p>从上图可以看出，<code>Origin</code>属性只包含了域名信息，并没有包含具体的 URL 路径，这是<code>Origin</code>和<code>Referer</code>的一个主要区别。在这里需要补充一点，<code>Origin</code>的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。</p>
<p>因此，服务器的策略是优先判断<code>Origin</code>，如果请求头中没有包含<code>Origin</code>属性，再根据实际情况判断是否使用<code>Referer</code>值。</p>
<h2 id="3-CSRF-Token"><a href="#3-CSRF-Token" class="headerlink" title="3. CSRF Token"></a>3. CSRF Token</h2><p>除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。<br>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://time.geekbang.org/sendcoin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf-token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nc98P987bcpncYhoadjoiydc9aj&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要发起 CSRF 攻击需要具备三个条件：目标站点存在漏洞、用户要登录过目标站点和黑客需要通过第三方站点发起攻击。</p>
<p>防止 CSRF 攻击主要有三种方式：充分利用好<code>Cookie</code>的<code>SameSite</code>属性、验证请求的来源站点和使用 CSRF Token。</p>
<p>这三种方式需要合理搭配使用，这样才可以有效地防止 CSRF 攻击。</p>
<p>页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让<code>XMLHttpRequest</code>和<code>Fetch</code>去跨域请求资源。</p>
<p>为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了<code>HttpOnly</code>机制来禁止<code>XMLHttpRequest</code>或者<code>Fetch</code>发送一些关键<code>Cookie</code>，引入了<code>SameSite</code>和<code>Origin</code>来防止 CSRF 攻击。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="tag">浏览器工作原理与实践</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/深入/浏览器安全——跨站脚本攻击(XSS)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/"
    >浏览器安全——跨站脚本攻击(XSS)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/" class="article-date">
  <time datetime="2019-12-24T07:13:52.000Z" itemprop="datePublished">2019-12-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认<code>XMLHttpRequest</code>和<code>Fetch</code>不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。</p>
<p>不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。</p>
<h1 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h1><p>XSS 全称是<code>Cross Site Scripting</code>，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p>
<p>最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。但是发展到现在，往 HTML 文件中注入恶意代码的方式越来越多了，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。</p>
<p>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。下面我们就来看看，如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情。</p>
<ul>
<li>可以窃取<code>Cookie</code>信息。恶意 JavaScript 可以通过<code>document.cookie</code>获取<code>Cookie</code>信息，然后通过<code>XMLHttpRequest</code>或者<code>Fetch</code>加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的<code>Cookie</code>信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>
<li>可以监听用户行为。恶意 JavaScript 可以使用<code>addEventListener</code>接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>
<li>可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>
<li>还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。</li>
</ul>
<p>除了以上几种情况外，恶意脚本还能做很多其他的事情。总之，如果让页面插入了恶意脚本，那么就相当于把我们页面的隐私数据和行为完全暴露给黑客了。</p>
<h1 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h1><p>现在我们知道了页面中被注入恶意的 JavaScript 脚本是一件非常危险的事情，所以网站开发者会尽可能地避免页面中被注入恶意脚本。要想避免站点被注入恶意脚本，就要知道有哪些常见的注入方式。通常情况下，主要有存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种方式来注入恶意脚本。</p>
<h2 id="1-存储型-XSS-攻击"><a href="#1-存储型-XSS-攻击" class="headerlink" title="1. 存储型 XSS 攻击"></a>1. 存储型 XSS 攻击</h2><p>我们先来看看存储型 XSS 攻击是怎么向 HTML 文件中注入恶意脚本的，你可以参考下图：</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img1.png" class="" title="存储型 XSS 攻击">

<p>通过上图，我们可以看出存储型 XSS 攻击大致需要经过如下步骤：</p>
<ul>
<li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li>
<li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li>
<li>当用户浏览该页面的时候，恶意脚本就会将用户的<code>Cookie</code>信息等数据上传到服务器。</li>
</ul>
<p>下面我们来看个例子，2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，如下图所示：</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img2.png" class="" title="黑客将恶意代码存储到漏洞服务器上">

<p>当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行（如下图），这样就可以获取用户的<code>Cookie</code>等数据信息。</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img3.png" class="" title="用户打开了含有恶意脚本的页面">

<p>当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。</p>
<p>恶意脚本可以通过<code>XMLHttpRequest</code>或者<code>Fetch</code>将用户的<code>Cookie</code>数据上传到黑客的服务器，如下图所示：</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img4.png" class="" title="将 Cookie 等数据上传到黑客服务器">

<p>黑客拿到了用户<code>Cookie</code>信息之后，就可以利用<code>Cookie</code>信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img5.png" class="" title="黑客利用 Cookie 信息登录用户账户">

<h2 id="2-反射型-XSS-攻击"><a href="#2-反射型-XSS-攻击" class="headerlink" title="2. 反射型 XSS 攻击"></a>2. 反射型 XSS 攻击</h2><p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</p>
<p>这样讲有点抽象，下面我们结合一个简单的 Node 服务程序来看看什么是反射型 XSS。首先我们使用 Node 来搭建一个简单的页面环境，搭建好的服务代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123; <span class="attr">title</span>: <span class="string">&#x27;Express&#x27;</span>,<span class="attr">xss</span>:req.<span class="property">query</span>.<span class="property">xss</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;/stylesheets/style.css&#x27;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&lt;%= title %&gt;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome to &lt;%= title %&gt;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      &lt;%- xss %&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这两段代码，第一段是路由，第二段是视图，作用是将 URL 中<code>xss</code>参数的内容显示在页面。我们可以在本地演示下，比如打开<code>http://localhost:3000/?xss=123</code>这个链接，这样在页面中展示就是“123”了（如下图）。</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img6.png" class="" title="正常打开页面">

<p>但当打开<code>http://localhost:3000/?xss=&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;</code>这段 URL 时，其结果如下图所示：</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img7.png" class="" title="反射型 XSS 攻击">

<p>通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。</p>
<p>另外需要注意的是，Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</p>
<h2 id="3-基于-DOM-的-XSS-攻击"><a href="#3-基于-DOM-的-XSS-攻击" class="headerlink" title="3. 基于 DOM 的 XSS 攻击"></a>3. 基于 DOM 的 XSS 攻击</h2><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p>
<h2 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h2><p>我们知道存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p>
<p>但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</p>
<p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>
<p>接下来我们就来看看一些常用的阻止 XSS 攻击的策略。</p>
<h2 id="1-服务器对输入脚本进行过滤或转码"><a href="#1-服务器对输入脚本进行过滤或转码" class="headerlink" title="1. 服务器对输入脚本进行过滤或转码"></a>1. 服务器对输入脚本进行过滤或转码</h2><p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:&lt;script&gt;alert(&#x27;你被 xss 攻击了&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码过滤后，只留下了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br></pre></td></tr></table></figure>
<p>这样，当用户再次请求该页面时，由于<code>&lt;script&gt;</code>标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p>
<p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:&amp;lt;script&amp;gt;alert(&amp;#39; 你被 xss 攻击了 &amp;#39;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>
<p>经过转码之后的内容，如<code>&lt;script&gt;</code>标签被转换为<code>&amp;lt;script&amp;gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</p>
<h2 id="2-充分利用-CSP"><a href="#2-充分利用-CSP" class="headerlink" title="2. 充分利用 CSP"></a>2. 充分利用 CSP</h2><p>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。</p>
<p>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p>
<ul>
<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li>
<li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li>
<li>禁止执行内联脚本和未授权的脚本；</li>
<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>
</ul>
<p>因此，利用好 CSP 能够有效降低 XSS 攻击的概率。</p>
<h2 id="3-使用-HttpOnly-属性"><a href="#3-使用-HttpOnly-属性" class="headerlink" title="3. 使用 HttpOnly 属性"></a>3. 使用 HttpOnly 属性</h2><p>由于很多 XSS 攻击都是来盗用<code>Cookie</code>的，因此还可以通过使用<code>HttpOnly</code>属性来保护我们<code>Cookie</code>的安全。</p>
<p>通常服务器可以将某些<code>Cookie</code>设置为<code>HttpOnly</code>标志，<code>HttpOnly</code>是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>set-cookie</code>属性值最后使用了<code>HttpOnly</code>来标记该<code>Cookie</code>。顾名思义，使用<code>HttpOnly</code>标记的<code>Cookie</code>只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段<code>Cookie</code>。我们还可以通过 Chrome 开发者工具来查看哪些<code>Cookie</code>被标记了<code>HttpOnly</code>，如下图：</p>
<img src="/2019/12/24/%E5%89%8D%E7%AB%AF/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/img8.png" class="" title="HttpOnly 演示">

<p>从图中可以看出，NID 这个<code>Cookie</code>的<code>HttpOlny</code>属性是被勾选上的，所以 NID 的内容是无法通过<code>document.cookie</code>是来读取的。</p>
<p>由于 JavaScript 无法读取设置了<code>HttpOnly</code>的<code>Cookie</code>数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了<code>HttpOnly</code>的数据。因此一些比较重要的数据我们建议设置<code>HttpOnly</code>标志。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器。常见的三种 XSS 攻击模式是存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击。</p>
<p>这三种攻击方式的共同点是都需要往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户数据上传到黑客的恶意服务器上。而三者的不同点在于注入的方式不一样，有通过服务器漏洞来进行注入的，还有在客户端直接注入的。</p>
<p>针对这些 XSS 攻击，主要有三种防范策略，第一种是通过服务器对输入的内容进行过滤或者转码，第二种是充分利用好 CSP，第三种是使用<code>HttpOnly</code>来保护重要的<code>Cookie</code>信息。</p>
<p>当然除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" rel="tag">浏览器工作原理与实践</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/26/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/28/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>