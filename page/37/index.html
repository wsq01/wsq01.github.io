<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/js/基础/JS数组"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/04/17/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E6%95%B0%E7%BB%84/"
    >JS数组</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/04/17/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E6%95%B0%E7%BB%84/" class="article-date">
  <time datetime="2018-04-17T15:19:46.000Z" itemprop="datePublished">2018-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>数组是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>
<p>除了在定义时赋值，数组也可以先定义后赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>任何类型的数据，都可以放入数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// Object &#123;a: 1&#125;</span></span><br><span class="line">arr[<span class="number">1</span>] <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// function ()&#123;return true;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面数组<code>arr</code>的3个成员依次是对象、数组、函数。</p>
<p>如果数组的元素还是数组，就形成了多维数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] <span class="comment">// 2</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>] <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h1 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h1><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(arr) <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。</p>
<p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="string">&#x27;0&#x27;</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p>
<p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1.00</span>] = <span class="number">6</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值。</p>
<p>对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr<span class="number">.0</span> <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）。</p>
<h1 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h1><p>数组的<code>length</code>属性，返回数组的成员数量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2<sup>32</sup> - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p>
<p>只要是数组，就一定有<code>length</code>属性。该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">9</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">1000</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 1001</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p>
<p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到<code>length</code>设置的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line">arr <span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，当数组的<code>length</code>属性设为2（即最大的整数键只能是1）那么整数键2（值为<code>c</code>）就已经不在数组中了，被自动删除了。</p>
<p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">arr <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">a.<span class="property">length</span> = <span class="number">3</span>;</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>。</p>
<p>如果人为设置<code>length</code>为不合法的值，JavaScript 会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置负值</span></span><br><span class="line">[].<span class="property">length</span> = -<span class="number">1</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素个数大于等于2的32次方</span></span><br><span class="line">[].<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符串</span></span><br><span class="line">[].<span class="property">length</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="comment">// RangeError: Invalid array length</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;p&#x27;</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">2.1</span>] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>。</p>
<p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">32</span>)] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// &quot;a&quot;</span></span><br><span class="line">arr[<span class="number">4294967296</span>] <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。</p>
<h1 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h1><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ];</span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> arr  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;2&#x27;</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p>
<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">100</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> <span class="keyword">in</span> arr <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> arr <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p>
<h1 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h1><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="property">foo</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure>
<p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组。</p>
<p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while循环</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; a.<span class="property">length</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l = a.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">while</span> (l--) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。</p>
<p>数组的<code>forEach</code>方法，也可以用来遍历数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line">colors.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(color);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<h1 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h1><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, , <span class="number">1</span>];</span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，数组的空位不影响<code>length</code>属性。</p>
<p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,];</span><br><span class="line"></span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">a <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样。</p>
<p>数组的空位是可以读取的，返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [, , ,];</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">x, i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不产生任何输出</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(a) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">x, i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 0. undefined</span></span><br><span class="line"><span class="comment">// 1. undefined</span></span><br><span class="line"><span class="comment">// 2. undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(a) <span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p>
<h1 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h1><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">obj[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">obj.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">obj.<span class="title function_">push</span>(<span class="string">&#x27;d&#x27;</span>) <span class="comment">// TypeError: obj.push is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">obj.<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">args</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">arguments</span> &#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = <span class="title function_">args</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">arrayLike[<span class="number">0</span>] <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">arrayLike.<span class="property">length</span> <span class="comment">// 2</span></span><br><span class="line">arrayLike <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM元素集</span></span><br><span class="line"><span class="keyword">var</span> elts = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;h3&#x27;</span>);</span><br><span class="line">elts.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line">elts <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">1</span>] <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike);</span><br></pre></td></tr></table></figure>
<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">value, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(arrayLike, print);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach 方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="keyword">function</span> (<span class="params">elem, i</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 for 循环</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="string">&#x27;. &#x27;</span> + <span class="variable language_">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="keyword">function</span> (<span class="params">chr</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">chr</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS 函数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/04/11/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E5%87%BD%E6%95%B0/"
    >JS函数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/04/11/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2018-04-11T14:32:27.000Z" itemprop="datePublished">2018-04-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><p>JavaScript有三种声明函数的方法。</p>
<h4 id="1-function-命令"><a href="#1-function-命令" class="headerlink" title="1.function 命令"></a>1.function 命令</h4><p><code>function</code>命令声明的代码区块，就是一个函数。<code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明。</p>
<h4 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2.函数表达式"></a>2.函数表达式</h4><p>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式。</p>
<p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x <span class="comment">// ReferenceError: x is not defined</span></span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>上面代码在函数表达式中，加入了函数名<code>x</code>。这个<code>x</code>只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。</p>
<h4 id="3-Function-构造函数"><a href="#3-Function-构造函数" class="headerlink" title="3.Function 构造函数"></a>3.Function 构造函数</h4><p>第三种声明函数的方式是<code>Function</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="title class_">Function</span>(</span><br><span class="line">  <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;return x + y&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Function</code>构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数。</p>
<p>可以传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="title class_">Function</span>(</span><br><span class="line">  <span class="string">&#x27;return &quot;hello world&quot;;&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Function</code>构造函数可以不使用<code>new</code>命令，返回结果完全一样。</p>
<p>总的来说，这种声明函数的方式非常不直观，几乎无人使用。</p>
<h2 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h2><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意。</p>
<h2 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h2><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。</p>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>。</p>
<p>函数可以调用自身，这就是递归。下面就是通过递归，计算斐波那契数列的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fib</span>(num - <span class="number">2</span>) + <span class="title function_">fib</span>(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fib</span>(<span class="number">6</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>fib</code>函数内部又调用了<code>fib</code>，计算得到斐波那契数列的第6个元素是8。</p>
<h2 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h2><p>JavaScript语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p>
<p>由于函数与其他数据类型地位平等，所以在JavaScript语言中又称函数为第一等公民。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> operator = add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数作为参数和返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">op</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>(add)(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h2><p>JavaScript引擎将函数名视同变量名，所以采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>表面上，上面代码好像在声明之前就调用了函数<code>f</code>。但是实际上，由于“变量提升”，函数<code>f</code>被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面的代码等同于下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f;</span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line">f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码第二行，调用<code>f</code>的时候，<code>f</code>只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错。因此，如果同时采用<code>function</code>命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h1 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h1><h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>函数的<code>name</code>属性返回函数的名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">f1.<span class="property">name</span> <span class="comment">// &quot;f1&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果是通过变量赋值定义的函数，那么<code>name</code>属性返回变量名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">f2.<span class="property">name</span> <span class="comment">// &quot;f2&quot;</span></span><br></pre></td></tr></table></figure>
<p>但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">function</span> <span class="title function_">myName</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">f3.<span class="property">name</span> <span class="comment">// &#x27;myName&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是<code>f3</code>，而<code>myName</code>这个名字只在函数体内部可用。</p>
<p><code>name</code>属性的一个用处，就是获取参数函数的名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(myFunc) <span class="comment">// myFunc</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数。</p>
<h2 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h2><p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>) &#123;&#125;</span><br><span class="line">f.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code>属性始终等于2。</p>
<p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（<code>overload</code>）。</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>函数的<code>toString</code>方法返回一个字符串，内容是函数的源码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">a</span>();</span><br><span class="line">  <span class="title function_">b</span>();</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">sqrt</span>.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Math.sqrt</code>是JavaScript引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示。</p>
<p>函数内部的注释也可以返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">// &quot;function f()&#123;/*</span></span><br><span class="line"><span class="comment">//   这是一个</span></span><br><span class="line"><span class="comment">//   多行注释</span></span><br><span class="line"><span class="comment">// */&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>利用这一点，可以变相实现多行字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multiline = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = fn.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">slice</span>(<span class="number">1</span>, arr.<span class="property">length</span> - <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">multiline</span>(f);</span><br><span class="line"><span class="comment">// &quot; 这是一个</span></span><br><span class="line"><span class="comment">//   多行注释&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>作用域（<code>scope</code>）指的是变量存在的范围。在ES5的规范中，JavaScript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6又新增了块级作用域。</p>
<p>对于顶层函数来说，函数外部声明的变量就是全局变量，它可以在函数内部读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v <span class="comment">// ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>v</code>在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 2</span></span><br><span class="line">v <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>v</code>同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量<code>v</code>覆盖了全局变量<code>v</code>。</p>
<p>注意，对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<h2 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h2><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h2><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">x</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。</p>
<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>
<p>很容易犯错的一点是，如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">y</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">y</span>(x) <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code>。但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了“闭包”现象。</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">square</span>(<span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">square</span>(<span class="number">3</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>上式的<code>x</code>就是<code>square</code>函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。</p>
<h2 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h2><p>函数参数不是必需的，JavaScript允许省略参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码的函数<code>f</code>定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为<code>undefined</code>。需要注意的是，函数的<code>length</code>属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>( , <span class="number">1</span>) <span class="comment">// SyntaxError: Unexpected token ,(…)</span></span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果省略第一个参数，就会报错。</p>
<h2 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h2><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  p = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(p);</span><br><span class="line"></span><br><span class="line">p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  o.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(obj);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址。因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值。</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(obj);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，在函数<code>f</code>内部，参数对象<code>obj</code>被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响。</p>
<h2 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h2><p>如果有同名的参数，则取最后出现的那个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>有两个参数，且参数名都是<code>a</code>。取值的时候，以后面的<code>a</code>为准，即使后面的<code>a</code>没有值或被省略，也是以其为准。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>调用函数<code>f</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code>。这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h2><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>
<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">one</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>
<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>; <span class="comment">// 开启严格模式</span></span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>
<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="与数组的关系"><a href="#与数组的关系" class="headerlink" title="与数组的关系"></a>与数组的关系</h4><p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> args = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  args.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（<code>closure</code>）是JavaScript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>() <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>。</p>
<p>但是，函数外部无法读取函数内部声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: n is not defined(</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的。</p>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">　　<span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是JavaScript语言特有的”链式作用域”结构，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">f1</span>();</span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了。</p>
<p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIncrementor</span>(<span class="params">start</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inc = <span class="title function_">createIncrementor</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">inc</span>() <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">inc</span>() <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">inc</span>() <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么会这样呢？原因就在于<code>inc</code>始终在内存中，而<code>inc</code>的存在依赖于<code>createIncrementor</code>，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setAge</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">getAge</span>: getAge,</span><br><span class="line">    <span class="attr">setAge</span>: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line">p1.<span class="title function_">setAge</span>(<span class="number">25</span>);</span><br><span class="line">p1.<span class="title function_">getAge</span>() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h2 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h2><p>在JavaScript中，圆括号<code>()</code>是一种运算符，跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print</code>函数。</p>
<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure>
<p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语句</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免解析上的歧义，JavaScript 引擎规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>
<p>解决方法就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>
<p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（<code>Immediately-Invoked Function Expression</code>），简称 IIFE。</p>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;())</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;())</span><br></pre></td></tr></table></figure>
<p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。</p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>甚至像下面这样写，也是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">~<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">-<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br><span class="line">+<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* code */</span> &#125;();</span><br></pre></td></tr></table></figure>
<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line"><span class="title function_">processData</span>(tmp);</span><br><span class="line"><span class="title function_">storeData</span>(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  <span class="title function_">processData</span>(tmp);</span><br><span class="line">  <span class="title function_">storeData</span>(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p>
<h1 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var a = 1;&#x27;</span>);</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码将字符串当作语句运行，生成了变量<code>a</code>。</p>
<p>如果参数字符串无法当作语句运行，那么就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;3x&#x27;</span>) <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>
<p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;return;&#x27;</span>); <span class="comment">// Uncaught SyntaxError: Illegal return statement</span></span><br></pre></td></tr></table></figure>
<p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用。</p>
<p>如果<code>eval</code>的参数不是字符串，那么会原样返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="number">123</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a = 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值。由于这个原因，<code>eval</code>有安全风险。</p>
<p>为了防止这种风险，JavaScript 规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;var foo = 123&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);  <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部。</p>
<p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">&#x27;foo = 2&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);  <span class="comment">// 2</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在。</p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p>
<h2 id="eval-的别名调用"><a href="#eval-的别名调用" class="headerlink" title="eval 的别名调用"></a>eval 的别名调用</h2><p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">eval</span>;</span><br><span class="line"><span class="title function_">m</span>(<span class="string">&#x27;var x = 1&#x27;</span>);</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令。</p>
<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="built_in">eval</span>;</span><br><span class="line">  <span class="title function_">e</span>(<span class="string">&#x27;console.log(a)&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。</p>
<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="string">&#x27;...&#x27;</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="built_in">eval</span>(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">(<span class="built_in">eval</span>, <span class="built_in">eval</span>)(<span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面这些形式都是<code>eval</code>的别名调用，作用域都是全局作用域。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/15/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E5%AF%B9%E8%B1%A1/"
    >JS对象</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/03/15/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2018-03-15T14:16:29.000Z" itemprop="datePublished">2018-03-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h2><p>对象是一组“键值对”（<code>key-value</code>）的集合，是一种无序的复合数据集合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，大括号就定义了一个对象，它被赋值给变量<code>obj</code>，所以变量<code>obj</code>就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是<code>foo: &#39;Hello&#39;</code>，其中<code>foo</code>是“键名”（成员的名称），字符串<code>Hello</code>是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是<code>bar: &#39;World&#39;</code>，<code>bar</code>是键名，<code>World</code>是键值。两个键值对之间用逗号分隔。</p>
<h2 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h2><p>对象的所有键名都是字符串（ES6 又引入了<code>Symbol</code>值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;bar&#x27;</span>: <span class="string">&#x27;World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果键名是数值，会被自动转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">3.2</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">1e2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">1e-2</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">.234</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="number">0xFF</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj</span><br><span class="line"><span class="comment">// Object &#123;</span></span><br><span class="line"><span class="comment">//   1: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   3.2: &quot;b&quot;,</span></span><br><span class="line"><span class="comment">//   100: true,</span></span><br><span class="line"><span class="comment">//   0.01: true,</span></span><br><span class="line"><span class="comment">//   0.234: true,</span></span><br><span class="line"><span class="comment">//   255: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;100&#x27;</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p>
<p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  1<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;1p&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;h w&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;p+q&#x27;</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象的每一个键名又称为“属性”（<code>property</code>），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">p</span>(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的属性<code>p</code>，就指向一个函数。</p>
<p>如果属性的值还是一个对象，就形成了链式引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">bar</span>: <span class="string">&#x27;hello&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">o1.<span class="property">foo</span> = o2;</span><br><span class="line">o1.<span class="property">foo</span>.<span class="property">bar</span> <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p>
<p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性可以动态创建，不必在对象声明时就指定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line">obj.<span class="property">foo</span> <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，直接对<code>obj</code>对象的<code>foo</code>属性赋值，结果就在运行时创建了<code>foo</code>属性。</p>
<h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">o2.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">o1.<span class="property">b</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</p>
<p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1 = <span class="number">1</span>;</span><br><span class="line">o2 <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line">y <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址。</p>
<h2 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h2><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>。</p>
<p>为了避免这种歧义，JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>上面的语句是一个代码块，而且只有解释为代码块，才能执行。</p>
<p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;) <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="comment">// &#123;foo: 123&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象。</p>
<h1 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h1><h2 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h2><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="string">&#x27;p&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>  <span class="comment">// 1</span></span><br><span class="line">obj[foo]  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>。</p>
<p>方括号运算符内部还可以使用表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27; world&#x27;</span>]</span><br><span class="line">obj[<span class="number">3</span> + <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>数字键可以不加引号，因为会自动转成字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0.7</span>: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">&#x27;0.7&#x27;</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">obj[<span class="number">0.7</span>] <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串。</p>
<p>注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">123</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj<span class="number">.123</span> <span class="comment">// 报错</span></span><br><span class="line">obj[<span class="number">123</span>] <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h2><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span> = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[<span class="string">&#x27;bar&#x27;</span>] = <span class="string">&#x27;World&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">p</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h2><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">key1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">key2</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj); <span class="comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的删除：delete-命令"><a href="#属性的删除：delete-命令" class="headerlink" title="属性的删除：delete 命令"></a>属性的删除：delete 命令</h2><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj) <span class="comment">// [&quot;p&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p</span> <span class="comment">// true</span></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p>
<p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p</span> <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">p</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">toString</span> <span class="comment">// true</span></span><br><span class="line">obj.<span class="property">toString</span> <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p>
<h2 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h2><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p>
<p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h2><p><code>for...in</code>循环用来遍历一个对象的全部属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;键名：&#x27;</span>, i);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;键值：&#x27;</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名： a</span></span><br><span class="line"><span class="comment">// 键值： 1</span></span><br><span class="line"><span class="comment">// 键名： b</span></span><br><span class="line"><span class="comment">// 键值： 2</span></span><br><span class="line"><span class="comment">// 键名： c</span></span><br><span class="line"><span class="comment">// 键值： 3</span></span><br></pre></td></tr></table></figure>
<p><code>for...in</code>循环有两个使用注意点。</p>
<ul>
<li>它遍历的是对象所有可遍历（<code>enumerable</code>）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString 属性是存在的</span></span><br><span class="line">obj.<span class="property">toString</span> <span class="comment">// toString() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125; <span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。</p>
<p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;老张&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure>
<h1 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h1><p><code>with</code>语句的格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">p1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">p2</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">obj.<span class="property">p1</span> = <span class="number">4</span>;</span><br><span class="line">obj.<span class="property">p2</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">with</span> (<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>])&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(href);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(style);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>].<span class="property">href</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>].<span class="property">title</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">links</span>[<span class="number">0</span>].<span class="property">style</span>);</span><br></pre></td></tr></table></figure>
<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  p1 = <span class="number">4</span>;</span><br><span class="line">  p2 = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">p1</span> <span class="comment">// undefined</span></span><br><span class="line">p1 <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p>
<p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">with</span>(<span class="params">obj1.obj2.obj3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.<span class="property">obj2</span>.<span class="property">obj3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(temp.<span class="property">p1</span> + temp.<span class="property">p2</span>);</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS 字符串"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/14/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"
    >JS字符串</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/03/14/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time datetime="2018-03-14T14:26:09.000Z" itemprop="datePublished">2018-03-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;key = &quot;value&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;It&#x27;s a long journey&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Did she say \&#x27;Hello\&#x27;?&#x27;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &#x27;Hello&#x27;?&quot;</span></span><br><span class="line"><span class="string">&quot;Did she say \&quot;Hello\&quot;?&quot;</span></span><br><span class="line"><span class="comment">// &quot;Did she say &quot;Hello&quot;?&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。</p>
<p>字符串默认只能写在一行内，分成多行将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c&#x27;</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure>
<p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">string&#x27;</span>;</span><br><span class="line"></span><br><span class="line">longString <span class="comment">// &quot;Long long long string&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p>
<p>连接运算符（<code>+</code>）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">&#x27;Long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;long &#x27;</span></span><br><span class="line">  + <span class="string">&#x27;string&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/*</span></span><br><span class="line"><span class="comment">line 1</span></span><br><span class="line"><span class="comment">line 2</span></span><br><span class="line"><span class="comment">line 3</span></span><br><span class="line"><span class="comment">*/</span>&#125;).<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="title function_">slice</span>(<span class="number">1</span>, -<span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;line 1</span></span><br><span class="line"><span class="comment">// line 2</span></span><br><span class="line"><span class="comment">// line 3&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，输出的字符串就是多行。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。<br>需要用反斜杠转义的特殊字符，主要有下面这些。</p>
<ul>
<li><code>\0</code> ：null（<code>\u0000</code>）</li>
<li><code>\b</code> ：后退键（<code>\u0008</code>）</li>
<li><code>\f</code> ：换页符（<code>\u000C</code>）</li>
<li><code>\n</code> ：换行符（<code>\u000A</code>）</li>
<li><code>\r</code> ：回车键（<code>\u000D</code>）</li>
<li><code>\t</code> ：制表符（<code>\u0009</code>）</li>
<li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li>
<li><code>\&#39;</code> ：单引号（<code>\u0027</code>）</li>
<li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li>
<li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li>
</ul>
<p>上面这些字符前面加上反斜杠，都表示特殊含义。</p>
<p>反斜杠还有三种特殊用法。<br>（1）<code>\HHH</code><br>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出256种字符。<br>（2）<code>\xHH</code><br><code>\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出256种字符。<br>（3）<code>\uXXXX</code><br><code>\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p>
<p>下面是这三种字符特殊写法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\251&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\xA9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"><span class="string">&#x27;\u00A9&#x27;</span> <span class="comment">// &quot;©&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\a&#x27;</span> <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a</code>是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。</p>
<p>如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Prev \\ Next&quot;</span></span><br><span class="line"><span class="comment">// &quot;Prev \ Next&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h2><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// &quot;h&quot;</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>[<span class="number">1</span>] <span class="comment">// &quot;e&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="number">3</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[-<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>[<span class="string">&#x27;x&#x27;</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s[<span class="number">0</span>];</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p>
<h2 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h2><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">s.<span class="property">length</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">length</span> = <span class="number">3</span>;</span><br><span class="line">s.<span class="property">length</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示字符串的<code>length</code>属性无法改变，但是不会报错。<br>#字符集<br>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p>
<p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;\u00A9&#x27;</span>;</span><br><span class="line">s <span class="comment">// &quot;©&quot;</span></span><br></pre></td></tr></table></figure>
<p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006F = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">foo <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一行的变量名<code>foo</code>是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p>
<p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p>
<p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆，</code>它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;𝌆&#x27;</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p>
<p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。<br>#Base64 转码<br>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>
<p>JavaScript 原生提供两个 Base64 相关的方法。</p>
<ul>
<li><code>btoa()</code>：任意值转为 Base64 编码</li>
<li><code>atob()</code>：Base64 编码转为原来的值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="title function_">btoa</span>(string) <span class="comment">// &quot;SGVsbG8gV29ybGQh&quot;</span></span><br><span class="line"><span class="title function_">atob</span>(<span class="string">&#x27;SGVsbG8gV29ybGQh&#x27;</span>) <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b64Encode</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">btoa</span>(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b64Decode</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="title function_">atob</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b64Encode</span>(<span class="string">&#x27;你好&#x27;</span>) <span class="comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span></span><br><span class="line"><span class="title function_">b64Decode</span>(<span class="string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="comment">// &quot;你好&quot;</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS 0.1 + 0.2的问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/09/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%200.1%20+%200.2%E7%9A%84%E9%97%AE%E9%A2%98/"
    >JS 0.1 + 0.2的问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/03/09/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%200.1%20+%200.2%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2018-03-09T14:21:41.000Z" itemprop="datePublished">2018-03-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="JavaScript中数字的存储机制"><a href="#JavaScript中数字的存储机制" class="headerlink" title="JavaScript中数字的存储机制"></a>JavaScript中数字的存储机制</h1><p>对于计算机而言，两个数字在相加时是以二进制形式进行的，在呈现结果时才转换成十进制。JS中的数字是用IEEE 754 双精度 64 位浮点数来存储的，它由64位组成，这64位由3部分组成，S：符号位，Exponent：指数域，Fraction：尾数域。</p>
<p>| | S(符号位) | P(阶码，指数位数) | M(尾数) | 表示公式 | 偏移量 |<br>| :- | :- | :- | :- | :- |<br>| 单精度浮点数 | 1(第31位) | 8(30到23位) | <code>(-1)^S*2(P-127)*1.M</code> | 127 |<br>| 双精度浮点数 | 1(第63位) | 11(62到52位) | <code>(-1)^S*2(P-127)*1.M</code> | 1023 |</p>
<h1 id="数字表示"><a href="#数字表示" class="headerlink" title="数字表示"></a>数字表示</h1><p>在计算机中，数字都是以二进制存储的，所以我们要先将 0.1 和 0.2 转化成二进制，对于十进制转二进制，整数部分除二取余，倒序排列，小数部分乘二取整，顺序排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">如：0.7=（0.1 0110 0110...）B</span><br><span class="line">0.7*2=1.4========取出整数部分1</span><br><span class="line">0.4*2=0.8========取出整数部分0</span><br><span class="line">0.8*2=1.6========取出整数部分1</span><br><span class="line">0.6*2=1.2========取出整数部分1</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br><span class="line">0.4*2=0.8========取出整数部分0</span><br><span class="line">0.8*2=1.6========取出整数部分1</span><br><span class="line">0.6*2=1.2========取出整数部分1</span><br><span class="line">0.2*2=0.4========取出整数部分0</span><br><span class="line"></span><br><span class="line"> // 0.1 转化为二进制</span><br><span class="line">0.0 0011 0011 0011 0011...(0011无限循环）</span><br><span class="line"></span><br><span class="line">// 0.2 转化为二进制</span><br><span class="line">0.0011 0011 0011 0011 0011...(0011无限循环）</span><br></pre></td></tr></table></figure>
<p>由于尾数只有52位，所以对于0.1和0.2转换后用IEEE 754 双精度64位浮点数来表示的二进制如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = -4; m =1.1001100110011001100110011001100110011001100110011010 (52位)</span><br><span class="line">e = -3; m =1.1001100110011001100110011001100110011001100110011010 (52位)</span><br></pre></td></tr></table></figure>
<p>然后我们把它相加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  e = -4; m = 1.1001100110011001100110011001100110011001100110011010 (52位)</span><br><span class="line">+ e = -3; m = 1.1001100110011001100110011001100110011001100110011010 (52位)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">相加时如果指数不一致，需要对齐，一般情况下是向右移，因为最右边的即使溢出了，损失的精度远远小于左边溢出。</span><br><span class="line">  e = -3; m = 0.1100110011001100110011001100110011001100110011001101 </span><br><span class="line">+ e = -3; m = 1.1001100110011001100110011001100110011001100110011010</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">  e = -3; m =10.0110011001100110011001100110011001100110011001100111</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">  e = -2; m = 1.0011001100110011001100110011001100110011001100110100(52位)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">= 0.010011001100110011001100110011001100110011001100110100</span><br><span class="line">= 0.30000000000000004(十进制)</span><br></pre></td></tr></table></figure>
<p>总结：我们可以看到，当十进制小数的二进制表示的有限数字超过 52 位时，在 JavaScript 里是不能精确存储的，这时候就存在舍入误差。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS 数值"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/07/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E6%95%B0%E5%80%BC/"
    >JS数值</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/03/07/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E6%95%B0%E5%80%BC/" class="article-date">
  <time datetime="2018-03-07T13:08:43.000Z" itemprop="datePublished">2018-03-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span> <span class="comment">// 2.9999999999999996</span></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h2><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p>
<ul>
<li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li>
<li>第2位到第12位（共11位）：指数部分</li>
<li>第13位到第64位（共52位）：小数部分（即有效数字）</li>
</ul>
<p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>
<p>指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是<code>1.xx...xx</code>的形式，其中<code>xx..xx</code>的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1)^符号位 * 1.xx...xx * 2^指数部分</span><br></pre></td></tr></table></figure>
<p>上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。</p>
<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2<sup>53</sup>到2<sup>53</sup>，都可以精确表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span> <span class="comment">// 9007199254740994</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span> <span class="comment">// 9007199254740996</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span> <span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多出的三个有效数字，将无法保存</span></span><br><span class="line"><span class="number">9007199254740992111</span> <span class="comment">// 9007199254740992000</span></span><br></pre></td></tr></table></figure>
<p>上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的<code>111</code>）都会无法保存，变成0。</p>
<h2 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h2><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。</p>
<p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">1075</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>下面是一个实际的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">  x = x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对<code>0.5</code>连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。</p>
<p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> <span class="comment">// 5e-324</span></span><br></pre></td></tr></table></figure>
<h1 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h1><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）。</p>
<p>数值也可以采用科学计数法表示，下面是几个科学计数法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123e3</span> <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span> <span class="comment">// 0.123</span></span><br><span class="line">-<span class="number">3.1E+12</span></span><br><span class="line"><span class="number">.1e-23</span></span><br></pre></td></tr></table></figure>
<p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p>
<p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p>
<h2 id="1-小数点前的数字多于21位。"><a href="#1-小数点前的数字多于21位。" class="headerlink" title="1.小数点前的数字多于21位。"></a>1.小数点前的数字多于21位。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234567890123456789012</span> <span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"><span class="number">123456789012345678901</span> <span class="comment">// 123456789012345680000</span></span><br></pre></td></tr></table></figure>
<h2 id="2-小数点后的零多于5个。"><a href="#2-小数点后的零多于5个。" class="headerlink" title="2.小数点后的零多于5个。"></a>2.小数点后的零多于5个。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span> <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span> <span class="comment">// 0.000003</span></span><br></pre></td></tr></table></figure>
<h1 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h1><p>使用字面量直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p>
<ul>
<li>十进制：没有前导0的数值。</li>
<li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li>
<li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li>
<li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li>
</ul>
<p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xff</span> <span class="comment">// 255</span></span><br><span class="line"><span class="number">0o377</span> <span class="comment">// 255</span></span><br><span class="line"><span class="number">0b11</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xzz <span class="comment">// 报错</span></span><br><span class="line">0o88 <span class="comment">// 报错</span></span><br><span class="line">0b22 <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字<code>8</code>和<code>9</code>，则该数值被视为十进制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0888</span> <span class="comment">// 888</span></span><br><span class="line"><span class="number">0777</span> <span class="comment">// 511</span></span><br></pre></td></tr></table></figure>
<p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p>
<h1 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h1><p>JavaScript 提供了几个特殊的数值。</p>
<h2 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h2><p>前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连<code>0</code>也不例外。</p>
<p>JavaScript 内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>几乎所有场合，正零和负零都会被当作正常的<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">-<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">(-<span class="number">0</span>).<span class="title function_">toString</span>() <span class="comment">// &#x27;0&#x27;</span></span><br><span class="line">(+<span class="number">0</span>).<span class="title function_">toString</span>() <span class="comment">// &#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> / +<span class="number">0</span>) === (<span class="number">1</span> / -<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的。</p>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><h4 id="1-含义"><a href="#1-含义" class="headerlink" title="1.含义"></a>1.含义</h4><p><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（<code>Not a Number</code>），主要出现在将字符串解析成数字出错的场合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="string">&#x27;x&#x27;</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）。</p>
<p>另外，一些数学函数的运算结果会出现<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">acos</span>(<span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-运算规则"><a href="#2-运算规则" class="headerlink" title="2.运算规则"></a>2.运算规则</h4><p><code>NaN</code>不等于任何值，包括它本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p><code>NaN</code>在布尔运算时被当作<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> + <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span> - <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span> * <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span> / <span class="number">32</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h2 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h2><h4 id="1-含义-1"><a href="#1-含义-1" class="headerlink" title="1.含义"></a>1.含义</h4><p><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回<code>Infinity</code>。第二个场景是<code>0</code>除以<code>0</code>会得到<code>NaN</code>，而非0数值除以<code>0</code>，会返回<code>Infinity</code>。</p>
<p><code>Infinity</code>有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> === -<span class="title class_">Infinity</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> / -<span class="number">0</span> <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="number">1</span> / -<span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，非零正数除以<code>-0</code>，会得到<code>-Infinity</code>，负数除以<code>-0</code>，会得到<code>Infinity</code>。</p>
<p>由于数值正向溢出、负向溢出和被<code>0</code>除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。</p>
<p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> &gt; <span class="number">1000</span> <span class="comment">// true</span></span><br><span class="line">-<span class="title class_">Infinity</span> &lt; -<span class="number">1000</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> &gt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="title class_">Infinity</span> &gt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Infinity</span> &lt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="title class_">Infinity</span> &lt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="2-运算规则-1"><a href="#2-运算规则-1" class="headerlink" title="2.运算规则"></a>2.运算规则</h4><p><code>Infinity</code>的四则运算，符合无穷的数学计算规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="title class_">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="title class_">Infinity</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="number">5</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="title class_">Infinity</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>0乘以<code>Infinity</code>，返回<code>NaN</code>；0除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以0，返回<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> * <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="title class_">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p><code>Infinity</code>加上或乘以<code>Infinity</code>，返回的还是<code>Infinity</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> + <span class="title class_">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="title class_">Infinity</span> * <span class="title class_">Infinity</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> - <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成0，等同于与<code>0</code>的计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> * <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="title class_">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="literal">null</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> - <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> * <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> / <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h1 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h1><h2 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h2><h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h4><p><code>parseInt</code>方法用于将字符串转为整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>如果字符串头部有空格，空格会被自动去除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;   81&#x27;</span>) <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>
<p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1.23&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8a&#x27;</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12**&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15e2&#x27;</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;15px&#x27;</span>) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;.3&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;+1&#x27;</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p>
<p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0x10&#x27;</span>) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>
<p>如果字符串以<code>0</code>开头，将其按照10进制解析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;011&#x27;</span>) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1e+21&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;8e-7&#x27;</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h4 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2.进制转换"></a>2.进制转换</h4><p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>) <span class="comment">// 1000</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">10</span>) <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<p>下面是转换指定进制的数的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">2</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">6</span>) <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br></pre></td></tr></table></figure>
<p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">37</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="number">0</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">null</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>, <span class="literal">undefined</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1546&#x27;</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;546&#x27;</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对于二进制来说，<code>1</code>是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code>都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>。</p>
<p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>) <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">0x11</span>), <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">0x11</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</p>
<p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">011</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">011</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">9</span>), <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt(&#39;011&#39;, 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p>
<p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p>
<h2 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h2><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p>如果字符串符合科学计数法，则会进行相应的转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;314e-2&#x27;</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;0.0314E+2&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14more non-digit characters&#x27;</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></table></figure>
<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;FF2&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p>
<p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h2><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>(<span class="string">&#x27;Hello&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>(&#123;&#125;)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;xzy&#x27;</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>([<span class="string">&#x27;xzy&#x27;</span>])) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">&#x27;123&#x27;</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值。</p>
<p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIsNaN</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIsNaN</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h2><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="title class_">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS null、undefined和布尔值"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/02/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20null%E3%80%81undefined%E5%92%8C%E5%B8%83%E5%B0%94%E5%80%BC/"
    >JS null、undefined和布尔值</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/03/02/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20null%E3%80%81undefined%E5%92%8C%E5%B8%83%E5%B0%94%E5%80%BC/" class="article-date">
  <time datetime="2018-03-02T08:11:14.000Z" itemprop="datePublished">2018-03-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a>数据类型概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript语言的每一个值，都属于某一种数据类型。JavaScript的数据类型共有六种。（ES6又新增了第七种<code>Symbol</code>类型的值。）</p>
<ul>
<li>数值（<code>number</code>）：整数和小数</li>
<li>字符串（<code>string</code>）：文本。</li>
<li>布尔值（<code>boolean</code>）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）</li>
<li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li>
<li><code>null</code>：表示空值，即此处的值为空。</li>
<li>对象（<code>object</code>）：各种值组成的集合。</li>
</ul>
<p>通常，数值、字符串、布尔值这三种类型，合称为原始类型的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于<code>undefined</code>和<code>null</code>，一般将它们看成两个特殊值。</p>
<p>对象是最复杂的数据类型，又可以分成三个子类型。</p>
<ul>
<li>狭义的对象（<code>object</code>）</li>
<li>数组（<code>array</code>）</li>
<li>函数（<code>function</code>）</li>
</ul>
<p>函数其实是处理数据的方法，JavaScript把它当成一种数据类型，可以赋值给变量，这为JavaScript的“函数式编程”奠定了基础。</p>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>JavaScript有三种方法，可以确定一个值到底是什么类型。</p>
<ul>
<li><code>typeof</code>运算符</li>
<li><code>instanceof</code>运算符</li>
<li><code>Object.prototype.toString</code>方法</li>
</ul>
<p><code>typeof</code>运算符可以返回一个值的数据类型。</p>
<p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span> <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// &quot;boolean&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数返回<code>function</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">typeof</span> f <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>undefined</code>返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v <span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"><span class="keyword">typeof</span> v  <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>实际编程中，这个特点通常用在判断语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象返回<code>object</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="variable language_">window</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在JavaScript内部，数组本质上只是一种特殊的对象。这里顺便提一下，<code>instanceof</code>运算符可以区分数组和对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// false</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>null</code>返回<code>object</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的JavaScript语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p>
<h1 id="null-undefined"><a href="#null-undefined" class="headerlink" title="null, undefined"></a>null, undefined</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，语法效果几乎没区别。</p>
<p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度吗？这与历史原因有关。</p>
<p>1995 年 JavaScript 诞生时，最初像 Java 一样，只设置了<code>null</code>表示”无”。根据 C 语言的传统，<code>null</code>可以自动转为<code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的JavaScript里面，<code>null</code>就像在Java里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为 0，很不容易发现错误。</p>
<p>因此，他又设计了一个<code>undefined</code>。区别是这样的：<code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h2 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h2><p><code>null</code>表示该变量有意缺少对象指向，即该处的值现在为空。<code>null</code>常在返回类型应是一个对象，但没有关联的值的地方使用。</p>
<p><code>undefined</code>表示尚未初始化的变量的值。<code>undefined</code>是全局对象的一个属性。也就是说，它是全局作用域的一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o.<span class="property">p</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><code>undefined</code></p>
<ul>
<li>这个变量从根本上就没有定义</li>
<li>隐藏式 空值</li>
</ul>
<p><code>null</code></p>
<ul>
<li>这个值虽然定义了，但它并未指向任何内存中的对象</li>
<li>声明式 空值</li>
</ul>
<h2 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>  <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> === !!<span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">undefined</span> + <span class="number">1</span>  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">null</span> + <span class="number">1</span>  <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">a</span>: <span class="literal">undefined</span>&#125;)  <span class="comment">// &#x27;&#123;&#125;&#x27;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">b</span>: <span class="literal">null</span>&#125;)  <span class="comment">// &#x27;&#123;b: null&#125;&#x27;</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">a</span>: <span class="literal">undefined</span>, <span class="attr">b</span>: <span class="literal">null</span>&#125;)  <span class="comment">// &#x27;&#123;b: null&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">undefined</span> = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> n === <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>()           <span class="comment">// false</span></span><br><span class="line"><span class="title function_">test</span>(<span class="literal">undefined</span>)  <span class="comment">// false</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;test&#x27;</span>)     <span class="comment">// ture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="literal">undefined</span> = <span class="string">&#x27;test&#x27;</span>  <span class="comment">// Uncaught SyntaxError: Identifier &#x27;undefined&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>
<p>在<code>if</code>语句中，它们都会被自动转为<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;undefined is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;null is false&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// null is false</span></span><br></pre></td></tr></table></figure>
<h2 id="深入探索"><a href="#深入探索" class="headerlink" title="深入探索"></a>深入探索</h2><h4 id="为什么-typeof-null-是-object？"><a href="#为什么-typeof-null-是-object？" class="headerlink" title="为什么 typeof null 是 object？"></a>为什么 typeof null 是 object？</h4><p><code>typeof null</code>输出为<code>object</code>其实是一个底层的错误，但直到现阶段都无法被修复。</p>
<p>原因是，在 JavaScript 初始版本中，值以 32 位存储。前 3 位表示数据类型的标记，其余位则是值。</p>
<p>对于所有的对象，它的前 3 位都以 000 作为类型标记位。在 JavaScript 早期版本中，<code>null</code>被认为是一个特殊的值，用来对应 C 中的空指针 。但 JavaScript 中没有 C 中的指针，所以<code>null</code>意味着什么都没有或者<code>void</code>并以全 0(32个) 表示。</p>
<p>因此每当 JavaScript 读取<code>null</code>时，它前端的 3 位将它视为对象类型 ，这也是为什么<code>typeof null</code>返回<code>object</code>的原因。</p>
<h4 id="为什么-null-1-和-undefined-1-表现不同？"><a href="#为什么-null-1-和-undefined-1-表现不同？" class="headerlink" title="为什么 null + 1 和 undefined + 1 表现不同？"></a>为什么 null + 1 和 undefined + 1 表现不同？</h4><p>在执行加法运算前，隐式类型转换会尝试将表达式中的变量转换为<code>number</code>类型。<code>null</code>转化为<code>number</code>时，会转换成 0。<code>undefined</code>转换为<code>number</code>时，会转换为<code>NaN</code>。</p>
<p>至于为什么执行如此的转换方式，我猜测是 JavaScript 早期的一个糟糕设计。</p>
<h4 id="为什么-JSON-stringify-会将值为-undefined-的内容删除？"><a href="#为什么-JSON-stringify-会将值为-undefined-的内容删除？" class="headerlink" title="为什么 JSON.stringify 会将值为 undefined 的内容删除？"></a>为什么 JSON.stringify 会将值为 undefined 的内容删除？</h4><p>JSON 会将<code>undefined</code>对应的<code>key</code>删除，这是 JSON 自身的转换原则。</p>
<p>在<code>undefined</code>的情况下，有无该条数据是没有区别的，因为他们在表现形式上并无不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">a</span>)  <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">a</span>)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="为什么-let-undefiend-x3D-’test’-可以覆盖掉-JavaScript-自身的-undefined？"><a href="#为什么-let-undefiend-x3D-’test’-可以覆盖掉-JavaScript-自身的-undefined？" class="headerlink" title="为什么 let undefiend&#x3D;’test’ 可以覆盖掉 JavaScript 自身的 undefined？"></a>为什么 let undefiend&#x3D;’test’ 可以覆盖掉 JavaScript 自身的 undefined？</h4><p>JavaScript 对于<code>undefined</code>的限制方式为全局创建了一个只读的<code>undefined</code>，但是并没有彻底禁止局部<code>undefined</code>变量的定义。</p>
<p>据说在 JavaScript 高版本禁止了该操作，但没有准确的依据。</p>
<p>请在任何时候，都不要进行<code>undefined</code>变量的覆盖，就算是你的 JSON 转换将<code>undefined</code>转换为<code>&#39;&#39;</code>。也不要通过该操作进行，这将是及其危险的行为。</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>布尔值代表“真”和“假”两个状态。“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值。</p>
<p>下列运算符会返回布尔值：</p>
<ul>
<li>前置逻辑运算符： <code>!</code></li>
<li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li>
<li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
</ul>
<p>如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>布尔值往往用于程序流程的控制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>if</code>命令后面的判断条件，预期应该是一个布尔值，所以JavaScript自动将空字符串，转为布尔值<code>false</code>，导致程序不会进入代码块，所以没有任何输出。</p>
<p>注意，空数组（<code>[]</code>）和空对象（<code>&#123;&#125;</code>）对应的布尔值，都是<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/基础/JS 基本语法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/03/01/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"
    >JS基本语法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2018/03/01/%E5%89%8D%E7%AB%AF/js/%E5%9F%BA%E7%A1%80/JS%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2018-03-01T12:32:12.000Z" itemprop="datePublished">2018-03-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是-JavaScript-语言？"><a href="#什么是-JavaScript-语言？" class="headerlink" title="什么是 JavaScript 语言？"></a>什么是 JavaScript 语言？</h1><p>JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（<code>script language</code>），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。</p>
<p>JavaScript 也是一种嵌入式语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I&#x2F;O（输入&#x2F;输出）相关的 API，都要靠宿主环境提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p>
<p>目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p>
<p>从语法角度看，JavaScript 语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。</p>
<p>JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如<code>Array</code>、<code>Date</code>、<code>Math</code>等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。</p>
<ul>
<li>浏览器控制类：操作浏览器</li>
<li>DOM 类：操作网页的各种元素</li>
<li>Web 类：实现互联网的各种功能</li>
</ul>
<p>如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。这些都可以在 Node 环境中找到。</p>
<h1 id="JavaScript-的基本语法"><a href="#JavaScript-的基本语法" class="headerlink" title="JavaScript 的基本语法"></a>JavaScript 的基本语法</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>JavaScript 程序的执行单位为行，也就是一行一行地执行。一般情况下，每一行就是一个语句。</p>
<p>语句（<code>statement</code>）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这条语句先用<code>var</code>命令，声明了变量<code>a</code>，然后将<code>1 + 3</code>的运算结果赋值给变量<code>a</code>。</p>
<p><code>1 + 3</code>叫做表达式（<code>expression</code>），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。</p>
<p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span> ; <span class="keyword">var</span> b = <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>分号前面可以没有任何内容，JavaScript引擎将其视为空语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;;;</span><br></pre></td></tr></table></figure>
<p>上面的代码就表示3个空语句。</p>
<p>表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码先声明变量<code>a</code>，然后在变量<code>a</code>与数值1之间建立引用关系，称为将数值1“赋值”给变量<code>a</code>。以后，引用变量名<code>a</code>就会得到数值1。最前面的<code>var</code>，是变量声明命令。它表示通知解释引擎，要创建一个变量<code>a</code>。</p>
<p>注意，JavaScript 的变量名区分大小写，<code>A</code>和<code>a</code>是两个不同的变量。</p>
<p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个特殊的值，表示“无定义”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>如果变量赋值的时候，忘了写<code>var</code>命令，这条语句也是有效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 基本等同</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但是，不写<code>var</code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用<code>var</code>命令声明变量。</p>
<p>如果一个变量没有声明就直接使用，JavaScript会报错，告诉你变量未定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码直接使用变量<code>x</code>，系统就报错，告诉你变量<code>x</code>没有声明。</p>
<p>可以在同一条<code>var</code>命令中声明多个变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br></pre></td></tr></table></figure>
<p>JavaScript是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>a</code>起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量<code>a</code>已经存在，所以不需要使用<code>var</code>命令。</p>
<p>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（<code>hoisting</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码首先使用<code>console.log</code>方法，在控制台显示变量<code>a</code>的值。这时变量<code>a</code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>最后的结果是显示<code>undefined</code>，表示变量<code>a</code>已声明，但还未赋值。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符（<code>identifier</code>）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript语言的标识符对大小写敏感，所以<code>a</code>和<code>A</code>是两个不同的标识符。</p>
<p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript引擎遇到非法标识符，就会报错。</p>
<p>简单说，标识符命名规则如下。</p>
<ul>
<li>第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。</li>
<li>第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字<code>0-9</code>。</li>
</ul>
<p>下面这些都是合法的标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg0</span><br><span class="line">_tmp</span><br><span class="line">$elem</span><br><span class="line">π</span><br></pre></td></tr></table></figure>
<p>下面这些则是不合法的标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1a  <span class="comment">// 第一个字符不能是数字</span></span><br><span class="line"><span class="number">23</span>  <span class="comment">// 同上</span></span><br><span class="line">***  <span class="comment">// 标识符不能包含星号</span></span><br><span class="line">a+b  <span class="comment">// 标识符不能包含加号</span></span><br><span class="line">-d  <span class="comment">// 标识符不能包含减号或连词线</span></span><br></pre></td></tr></table></figure>
<p>中文是合法的标识符，可以用作变量名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 临时变量 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JavaScript有一些保留字，不能用作标识符：<code>arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield</code>。</p>
</blockquote>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被JavaScript引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用<code>//</code>起头；另一种是多行注释，放在<code>/*</code>和<code>*/</code>之间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这是</span></span><br><span class="line"><span class="comment"> 多行</span></span><br><span class="line"><span class="comment"> 注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>; &lt;!-- x = <span class="number">2</span>;</span><br><span class="line">--&gt; x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，只有<code>x = 1</code>会执行，其他的部分都被注释掉了。</p>
<p>需要注意的是，<code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (n --&gt; <span class="number">0</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">countdown</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>n --&gt; 0</code>实际上会当作<code>n-- &gt; 0</code>，因此输出2、1、0。</p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>JavaScript使用大括号，将多个相关的语句组合在一起，称为“区块”（<code>block</code>）。</p>
<p>对于<code>var</code>命令来说，JavaScript的区块不构成单独的作用域（<code>scope</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码在区块内部，使用<code>var</code>命令声明并赋值了变量<code>a</code>，然后在区块外部，变量<code>a</code>依然有效，区块对于<code>var</code>命令不构成单独的作用域，与不使用区块的情况没有任何区别。在JavaScript语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如<code>for</code>、<code>if</code>、<code>while</code>、<code>function</code>等。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>JavaScript 提供<code>if</code>结构和<code>switch</code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p>
<h4 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a>if 结构</h4><p><code>if</code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值)</span><br><span class="line">  语句;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (布尔值) 语句;</span><br></pre></td></tr></table></figure>
<p>上面是<code>if</code>结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为<code>true</code>，就执行紧跟在后面的语句；如果结果为<code>false</code>，则跳过紧跟在后面的语句。</p>
<p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在<code>if</code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) &#123;</span><br><span class="line">  m += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议总是在<code>if</code>语句中使用大括号，因为这样方便插入语句。</p>
<p>注意，<code>if</code>后面的表达式之中，不要混淆赋值表达式（<code>=</code>）、严格相等运算符（<code>===</code>）和相等运算符（<code>==</code>）。尤其是赋值表达式不具有比较作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x = y) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的原意是，当<code>x</code>等于<code>y</code>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将<code>y</code>赋值给变量<code>x</code>，再判断变量<code>x</code>的值（等于2）的布尔值（结果为<code>true</code>）。</p>
<p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = <span class="number">2</span>) &#123; <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> = x) &#123; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h4 id="if…else-结构"><a href="#if…else-结构" class="headerlink" title="if…else 结构"></a>if…else 结构</h4><p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// 满足条件时，执行的语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不满足条件时，执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对同一个变量进行多次判断时，多个<code>if...else</code>语句可以连写在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>else</code>代码块总是与离自己最近的那个<code>if</code>语句配对。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">2</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码不会有任何输出，<code>else</code>代码块不会得到执行，因为它跟着的是最近的那个<code>if</code>语句，相当于下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想让<code>else</code>代码块跟随最上面的那个<code>if</code>语句，就要改变大括号的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>
<h2 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h2><p>多个<code>if...else</code>连在一起使用的时候，可以转为使用更方便的<code>switch</code>结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;banana&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码根据变量<code>fruit</code>的值，选择执行相应的<code>case</code>。如果所有<code>case</code>都不符合，则执行最后的<code>default</code>部分。需要注意的是，每个<code>case</code>代码块内部的<code>break</code>语句不能少，否则会接下去执行下一个<code>case</code>代码块，而不是跳出<code>switch</code>结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 等于1&#x27;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 等于2&#x27;</span>);</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 等于其他值&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x等于1</span></span><br><span class="line"><span class="comment">// x等于2</span></span><br><span class="line"><span class="comment">// x等于其他值</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>case</code>代码块之中没有<code>break</code>语句，导致不会跳出<code>switch</code>结构，而会一直执行下去。正确的写法是像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 等于1&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 等于2&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 等于其他值&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>语句部分和<code>case</code>语句部分，都可以使用表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span> + <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> + <span class="number">2</span>:</span><br><span class="line">    <span class="title function_">f</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="title function_">neverHappens</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>default</code>部分，是永远不会执行到的。</p>
<p>需要注意的是，<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">true</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 发生类型转换&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x 没有发生类型转换&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于变量<code>x</code>没有发生类型转换，所以不会执行<code>case true</code>的情况。这表明，<code>switch</code>语句内部采用的是“严格相等运算符”。</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?:"></a>三元运算符 ?:</h4><p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<code>?:</code>，也可以用于逻辑判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果“条件”为<code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even = (n % <span class="number">2</span> === <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果<code>n</code>可以被2整除，则<code>even</code>等于<code>true</code>，否则等于<code>false</code>。它等同于下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">  even = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  even = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个三元运算符可以被视为<code>if...else...</code>的简写形式，因此可以用于多种场合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  myVar ?</span><br><span class="line">  <span class="string">&#x27;myVar has a value&#x27;</span> :</span><br><span class="line">  <span class="string">&#x27;myVar does not have a value&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// myVar does not have a value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">&#x27;数字&#x27;</span> + n + <span class="string">&#x27;是&#x27;</span> + (n % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">&#x27;偶数&#x27;</span> : <span class="string">&#x27;奇数&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p>
<h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p><code>While</code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">  语句;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">while</span> (条件) 语句;</span><br></pre></td></tr></table></figure>
<p><code>while</code>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p><code>for</code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式)</span><br><span class="line">  语句</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>语句后面的括号里面，有三个表达式。</p>
<ul>
<li>初始化表达式（<code>initialize</code>）：确定循环变量的初始值，只在循环开始时执行一次。</li>
<li>条件表达式（<code>test</code>）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li>
<li>递增表达式（<code>increment</code>）：每轮循环的最后一个操作，通常用来递增循环变量。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，初始化表达式是<code>var i = 0</code>，即初始化一个变量<code>i</code>；测试表达式是<code>i &lt; x</code>，即只要<code>i</code>小于<code>x</code>，就会执行循环；递增表达式是<code>i++</code>，即每次循环结束后，<code>i</code>增大1。</p>
<p>所有<code>for</code>循环，都可以改写成<code>while</code>循环。上面的例子改为<code>while</code>循环，代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; x) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>语句的三个部分（<code>initialize、test、increment</code>），可以省略任何一个，也可以全部省略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码省略了<code>for</code>语句表达式的三个部分，结果就导致了一个无限循环。</p>
<h4 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h4><p><code>do...while</code>循环与<code>while</code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  语句</span><br><span class="line"><span class="keyword">while</span> (条件);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>
<p>不管条件是否为真，<code>do...while</code>循环至少运行一次，这是这种结构最大的特点。另外，<code>while</code>语句后面的分号注意不要省略。</p>
<h4 id="break语句和continue语句"><a href="#break语句和continue语句" class="headerlink" title="break语句和continue语句"></a>break语句和continue语句</h4><p><code>break</code>语句和<code>continue</code>语句都具有跳转作用，可以让代码不按既有的顺序执行。<br><code>break</code>语句用于跳出代码块或循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">100</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i 当前为：&#x27;</span> + i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码只会执行10次循环，一旦<code>i</code>等于10，就会跳出循环。</p>
<p><code>for</code>循环也可以使用<code>break</code>语句跳出循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码执行到<code>i</code>等于3，就会跳出循环。</p>
<p><code>continue</code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i 当前为：&#x27;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码只有在<code>i</code>为奇数时，才会输出<code>i</code>的值。如果<code>i</code>为偶数，则直接进入下一轮循环。</p>
<p>如果存在多重循环，不带参数的<code>break</code>语句和<code>continue</code>语句都只针对最内层循环。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-others/Hexo基本操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/11/23/others/Hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"
    >Hexo基本操作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2016/11/23/others/Hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2016-11-23T09:42:51.000Z" itemprop="datePublished">2016-11-23</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p>
<h1 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h1><p>Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source&#x2F;_posts 文件夹。</p>
<table>
<thead>
<tr>
<th align="center">布局</th>
<th align="center">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="center">post</td>
<td align="center">source&#x2F;_posts</td>
</tr>
<tr>
<td align="center">page</td>
<td align="center">source</td>
</tr>
<tr>
<td align="center">draft</td>
<td align="center">source&#x2F;_drafts</td>
</tr>
</tbody></table>
<p>如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。</p>
<h1 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h1><p>Hexo 默认以标题做为文件名称，但您可编辑<code>new_post_name</code>参数来改变默认的文件名称，举例来说，设为<code>:year-:month-:day-:title.md</code>可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>:title</code></td>
<td align="center">标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td align="center"><code>:year</code></td>
<td align="center">建立的年份，比如， 2015</td>
</tr>
<tr>
<td align="center"><code>:month</code></td>
<td align="center">建立的月份（有前导零），比如，04</td>
</tr>
<tr>
<td align="center"><code>:i_month</code></td>
<td align="center">建立的月份（无前导零），比如，4</td>
</tr>
<tr>
<td align="center"><code>:day</code></td>
<td align="center">建立的日期（有前导零），比如，07</td>
</tr>
<tr>
<td align="center"><code>:i_day</code></td>
<td align="center">建立的日期（无前导零），比如，7</td>
</tr>
</tbody></table>
<h1 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h1><p>刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source&#x2F;_drafts 文件夹，您可通过 publish 命令将草稿移动到 source&#x2F;_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</p>
<h1 id="模板（Scaffold）"><a href="#模板（Scaffold）" class="headerlink" title="模板（Scaffold）"></a>模板（Scaffold）</h1><p>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>
<p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th align="center">变量</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">layout</td>
<td align="center">布局</td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">标题</td>
</tr>
<tr>
<td align="center">date</td>
<td align="center">文件建立日期</td>
</tr>
</tbody></table>
<h1 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h1><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">layout</td>
<td align="center">布局</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">标题</td>
<td align="center">文章的文件名</td>
</tr>
<tr>
<td align="center">date</td>
<td align="center">建立日期</td>
<td align="center">文件建立日期</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">更新日期</td>
<td align="center">文件更新日期</td>
</tr>
<tr>
<td align="center">comments</td>
<td align="center">开启文章的评论功能</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">tags</td>
<td align="center">标签（不适用于分页）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">categories</td>
<td align="center">分类（不适用于分页）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">permalink</td>
<td align="center">覆盖文章网址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">keywords</td>
<td align="center">仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>分类和标签<br>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>
<p>分类方法的分歧<br>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure>
<p>会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>
<p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。</p>
<h1 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h1><p>使用 Hexo 生成静态文件快速而且简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate // 监视文件变动</span><br></pre></td></tr></table></figure>
<p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --watch // 完成后部署</span><br></pre></td></tr></table></figure>
<p>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --deploy</span><br><span class="line">$ hexo deploy --generate</span><br><span class="line"></span><br><span class="line">// 上面两个命令可以简写为</span><br><span class="line">$ hexo g -d</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-others/Hexo入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2016/11/22/others/Hexo%E5%85%A5%E9%97%A8/"
    >Hexo入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2016/11/22/others/Hexo%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2016-11-22T11:32:16.000Z" itemprop="datePublished">2016-11-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 Hexo 需要先安装下列应用程序：</p>
<ul>
<li>Node.js</li>
<li>Git</li>
</ul>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的配置信息。</p>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模板文件夹。新建文章时，Hexo 会根据<code>scaffold</code>来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果修改<code>scaffold/post.md</code>中的<code>Front-matter内</code>容，那么每次新建一篇文章时都会包含这个修改。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除<code>_posts</code>文件夹之外，开头命名为<code>_</code>(下划线)的文件&#x2F;文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到<code>public</code>文件夹，而其他文件会被拷贝过去。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>可以在<code>_config.yml</code>中修改大部分的配置。</p>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">title</td>
<td align="center">网站标题</td>
</tr>
<tr>
<td align="center">subtitle</td>
<td align="center">网站副标题</td>
</tr>
<tr>
<td align="center">description</td>
<td align="center">网站描述，主要用于SEO</td>
</tr>
<tr>
<td align="center">keywords</td>
<td align="center">网站的关键词。使用半角逗号, 分隔多个关键词。</td>
</tr>
<tr>
<td align="center">author</td>
<td align="center">您的名字</td>
</tr>
<tr>
<td align="center">language</td>
<td align="center">网站使用的语言</td>
</tr>
<tr>
<td align="center">timezone</td>
<td align="center">网站时区。默认使用电脑的时区。</td>
</tr>
</tbody></table>
<h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url</td>
<td align="center">网址</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">root</td>
<td align="center">网站根目录</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">permalink</td>
<td align="center">文章的永久链接格式</td>
<td align="center">:year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</td>
</tr>
<tr>
<td align="center">permalink_defaults</td>
<td align="center">永久链接中各部分的默认值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">pretty_urls</td>
<td align="center">改写 permalink 的值来美化 URL</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">pretty_urls.trailing_index</td>
<td align="center">是否在永久链接中保留尾部的 index.html，设置为 false 时去除</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">pretty_urls.trailing_html</td>
<td align="center">是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)</td>
<td align="center">true</td>
</tr>
</tbody></table>
<p>如果您的网站存放在子目录中，例如<code>http://yoursite.com/blog</code>，则请将您的 url 设为<code>http://yoursite.com/blog</code>并把 root 设为 &#x2F;blog&#x2F;。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.html</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: false</span><br><span class="line"># 此时页面的永久链接会变为 http://example.com/foo/bar/</span><br></pre></td></tr></table></figure>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">source_dir</td>
<td align="center">资源文件夹，这个文件夹用来存放内容。</td>
<td align="center">source</td>
</tr>
<tr>
<td align="center">public_dir</td>
<td align="center">公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td align="center">public</td>
</tr>
<tr>
<td align="center">tag_dir</td>
<td align="center">标签文件夹</td>
<td align="center">tags</td>
</tr>
<tr>
<td align="center">archive_dir</td>
<td align="center">归档文件夹</td>
<td align="center">archives</td>
</tr>
<tr>
<td align="center">category_dir</td>
<td align="center">分类文件夹</td>
<td align="center">categories</td>
</tr>
<tr>
<td align="center">code_dir</td>
<td align="center">Include code 文件夹，source_dir 下的子目录</td>
<td align="center">downloads&#x2F;code</td>
</tr>
<tr>
<td align="center">i18n_dir</td>
<td align="center">国际化（i18n）文件夹</td>
<td align="center">:lang</td>
</tr>
<tr>
<td align="center">skip_render</td>
<td align="center">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">skip_render: &quot;mypage/**/*&quot;</span><br><span class="line"># 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录</span><br><span class="line"># 你也可以用这种方法来跳过对指定文章文件的渲染</span><br><span class="line">skip_render: &quot;_posts/test-post.md&quot;</span><br><span class="line"># 这将会忽略对 &#x27;test-post.md&#x27; 的渲染</span><br></pre></td></tr></table></figure>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">new_post_name</td>
<td align="center">新文章的文件名称</td>
<td align="center">:title.md</td>
</tr>
<tr>
<td align="center">default_layout</td>
<td align="center">预设布局</td>
<td align="center">post</td>
</tr>
<tr>
<td align="center">auto_spacing</td>
<td align="center">在中文和英文之间加入空格</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">titlecase</td>
<td align="center">把标题转换为 title case</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">external_link</td>
<td align="center">在新标签中打开链接</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">external_link.enable</td>
<td align="center">在新标签中打开链接</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">external_link.field</td>
<td align="center">对整个网站（site）生效或仅对文章（post）生效</td>
<td align="center">site</td>
</tr>
<tr>
<td align="center">external_link.exclude</td>
<td align="center">需要排除的域名。主域名和子域名如 www 需分别配置</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">filename_case</td>
<td align="center">把文件名称转换为 (1) 小写或 (2) 大写</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">render_drafts</td>
<td align="center">显示草稿</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">post_asset_folder</td>
<td align="center">启动 Asset 文件夹</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">relative_link</td>
<td align="center">把链接改为与根目录的相对位址</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">future</td>
<td align="center">显示未来的文章</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">highlight</td>
<td align="center">代码块的设置</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">highlight.enable</td>
<td align="center">开启代码块高亮</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">highlight.auto_detect</td>
<td align="center">如果未指定语言，则启用自动检测</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">highlight.line_number</td>
<td align="center">显示行数</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">highlight.tab_replace</td>
<td align="center">用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</td>
<td align="center">‘’</td>
</tr>
<tr>
<td align="center">highlight.wrap</td>
<td align="center">Wrap the code block in &lt; table &gt;</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">highlight.hljs</td>
<td align="center">Use the hljs-* prefix for CSS classes</td>
<td align="center">false</td>
</tr>
</tbody></table>
<h2 id="相对地址"><a href="#相对地址" class="headerlink" title="相对地址"></a>相对地址</h2><p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为<code>example.com</code>，您有一篇文章名为<code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是绝对于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
<h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">default_category</td>
<td align="center">默认分类</td>
<td align="center">uncategorized</td>
</tr>
<tr>
<td align="center">category_map</td>
<td align="center">分类别名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">tag_map</td>
<td align="center">标签别名</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="日期-x2F-时间格式"><a href="#日期-x2F-时间格式" class="headerlink" title="日期 &#x2F; 时间格式"></a>日期 &#x2F; 时间格式</h2><p>Hexo使用 Moment.js 来解析和显示时间</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date_format</td>
<td align="center">日期格式</td>
<td align="center">YYYY-MM-DD</td>
</tr>
<tr>
<td align="center">time_format</td>
<td align="center">时间格式</td>
<td align="center">HH:mm:ss</td>
</tr>
<tr>
<td align="center">use_date_for_updated</td>
<td align="center">启用以后，如果 Front Matter 中没有指定 updated， post.updated 将会使用 date 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用</td>
<td align="center">true</td>
</tr>
</tbody></table>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">per_page</td>
<td align="center">每页显示的文章量 (0 &#x3D; 关闭分页功能)</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">pagination_dir</td>
<td align="center">分页目录</td>
<td align="center">page</td>
</tr>
</tbody></table>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">theme</td>
<td align="center">当前主题名称。值为false时禁用主题</td>
</tr>
<tr>
<td align="center">theme_config</td>
<td align="center">主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置</td>
</tr>
<tr>
<td align="center">deploy</td>
<td align="center">部署部分的设置</td>
</tr>
<tr>
<td align="center">meta_generator</td>
<td align="center">Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签</td>
</tr>
</tbody></table>
<h2 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h2><p>在 Hexo 配置文件中，通过设置<code>include/exclude</code>可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 glob 表达式 对目录和文件进行匹配。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">include</td>
<td align="center">Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。</td>
</tr>
<tr>
<td align="center">exclude</td>
<td align="center">Hexo 会忽略这些文件和目录</td>
</tr>
<tr>
<td align="center">ignore</td>
<td align="center">Ignore files&#x2F;folders</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Include/Exclude Files/Folders</span><br><span class="line">include:</span><br><span class="line">  - &quot;.nojekyll&quot;</span><br><span class="line">  # 包括 &#x27;source/css/_typing.css&#x27;</span><br><span class="line">  - &quot;css/_typing.css&quot;</span><br><span class="line">  # 包括 &#x27;source/_css/&#x27; 中的任何文件，但不包括子目录及其其中的文件。</span><br><span class="line">  - &quot;_css/*&quot;</span><br><span class="line">  # 包含 &#x27;source/_css/&#x27; 中的任何文件和子目录下的任何文件</span><br><span class="line">  - &quot;_css/**/*&quot;</span><br><span class="line"></span><br><span class="line">exclude:</span><br><span class="line">  # 不包括 &#x27;source/js/test.js&#x27;</span><br><span class="line">  - &quot;js/test.js&quot;</span><br><span class="line">  # 不包括 &#x27;source/js/&#x27; 中的文件、但包括子目录下的所有目录和文件</span><br><span class="line">  - &quot;js/*&quot;</span><br><span class="line">  # 不包括 &#x27;source/js/&#x27; 中的文件和子目录下的任何文件</span><br><span class="line">  - &quot;js/**/*&quot;</span><br><span class="line">  # 不包括 &#x27;source/js/&#x27; 目录下的所有文件名以 &#x27;test&#x27; 开头的文件，但包括其它文件和子目录下的单文件</span><br><span class="line">  - &quot;js/test*&quot;</span><br><span class="line">  # 不包括 &#x27;source/js/&#x27; 及其子目录中任何以 &#x27;test&#x27; 开头的文件</span><br><span class="line">  - &quot;js/**/test*&quot;</span><br><span class="line">  # 不要用 exclude 来忽略 &#x27;source/_posts/&#x27; 中的文件。你应该使用 &#x27;skip_render&#x27;，或者在要忽略的文件的文件名之前加一个下划线 &#x27;_&#x27;</span><br><span class="line">  # 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。</span><br><span class="line"></span><br><span class="line">ignore:</span><br><span class="line">  # Ignore any folder named &#x27;foo&#x27;.</span><br><span class="line">  - &quot;**/foo&quot;</span><br><span class="line">  # Ignore &#x27;foo&#x27; folder in &#x27;themes/&#x27; only.</span><br><span class="line">  - &quot;**/themes/*/foo&quot;</span><br><span class="line">  # Same as above, but applies to every subfolders of &#x27;themes/&#x27;.</span><br><span class="line">  - &quot;**/themes/**/foo&quot;</span><br></pre></td></tr></table></figure>
<p>列表中的每一项都必须用单引号或双引号包裹起来。</p>
<p>include 和 exclude 并不适用于 themes&#x2F; 目录下的文件。如果需要忽略 themes&#x2F; 目录下的部分文件或文件夹，可以使用 ignore 或在文件名之前添加下划线 _。</p>
<h1 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h1><p>可以在 hexo-cli 中使用 –config 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># use &#x27;custom.yml&#x27; in place of &#x27;_config.yml&#x27;</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># use &#x27;custom.yml&#x27; &amp; &#x27;custom2.json&#x27;, prioritizing &#x27;custom3.yml&#x27;, then &#x27;custom2.json&#x27;</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>
<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<p>例如，使用 –options 指定了两个自定义配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure>
<p>如果 custom.yml 中指定了 foo: bar，在 custom2.json 中指定了 “foo”: “dinosaur”，那么在 _multiconfig.yml 中你会得到 foo: dinosaur。</p>
<h1 id="覆盖主题配置"><a href="#覆盖主题配置" class="headerlink" title="覆盖主题配置"></a>覆盖主题配置</h1><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。<br>你可以在站点的 _config.yml 配置文件中配置你的主题，这样你就不需要 fork 一份主题并维护主题独立的配置文件。</p>
<p>以下是一个覆盖主题配置的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">theme_config:</span><br><span class="line">  bio: &quot;My awesome bio&quot;</span><br><span class="line"># themes/my-theme/_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br></pre></td></tr></table></figure>
<p>最终主题配置的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</span><br><span class="line">$ hexo init [folder]</span><br><span class="line">// 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。</span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line">// 如果标题包含空格的话，请使用引号括起来。</span><br><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me &quot;About me&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会创建一个<code>source/about/me.md</code>文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me</span><br></pre></td></tr></table></figure>
<p>此时 Hexo 会创建<code>source/_posts/about/me.md</code>，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 生成静态文件。</span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-d, –deploy</td>
<td align="center">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="center">-w, –watch</td>
<td align="center">监视文件变动</td>
</tr>
<tr>
<td align="center">-b, –bail</td>
<td align="center">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="center">-f, –force</td>
<td align="center">强制重新生成文件。Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。</td>
</tr>
<tr>
<td align="center">使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-c, –concurrency</td>
<td align="center">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 发表草稿</span><br><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server // 启动服务器，默认情况下，访问网址为： http://localhost:4000/。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-p, –port</td>
<td align="center">重设端口</td>
</tr>
<tr>
<td align="center">-s, –static</td>
<td align="center">只使用静态文件</td>
</tr>
<tr>
<td align="center">-l, –log</td>
<td align="center">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy // 部署网站。</span><br><span class="line">// 该命令可以简写为：</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-g, –generate</td>
<td align="center">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ... // 渲染文件。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-o, –output</td>
<td align="center">设置输出路径</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br><span class="line">// 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</span><br><span class="line"></span><br><span class="line">$ hexo list &lt;type&gt; // 列出网站资料。</span><br><span class="line">$ hexo version // 显示 Hexo 版本。</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/36/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="page-number" href="/page/36/">36</a><span class="page-number current">37</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>