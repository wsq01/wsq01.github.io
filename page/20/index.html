<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-java/基础/Java包（package）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/18/java/%E5%9F%BA%E7%A1%80/Java%E5%8C%85%EF%BC%88package%EF%BC%89/"
    >Java 包（package）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/18/java/%E5%9F%BA%E7%A1%80/Java%E5%8C%85%EF%BC%88package%EF%BC%89/" class="article-date">
  <time datetime="2020-09-18T03:23:14.000Z" itemprop="datePublished">2020-09-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>包允许将类组合成较小的单元（类似文件夹），它基本上隐藏了类，并避免了名称上的冲突。包允许在更广泛的范围内保护类、数据和方法。你可以在包内定义类，而在包外的代码不能访问该类。这使你的类相互之间有隐私，但不被其他世界所知。</p>
<p>包的 3 个作用如下：</p>
<ul>
<li>区分相同名称的类。</li>
<li>能够较好地管理大量的类。</li>
<li>控制访问范围。</li>
</ul>
<h1 id="包定义"><a href="#包定义" class="headerlink" title="包定义"></a>包定义</h1><p>Java 中使用<code>package</code>语句定义包，<code>package</code>语句应该放在源文件的第一行，在每个源文件中只能有一个包定义语句，并且<code>package</code>语句适用于所有类型（类、接口、枚举和注释）的文件。定义包语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package 包名;</span><br></pre></td></tr></table></figure>
<p>Java 包的命名规则如下：</p>
<ul>
<li>包名全部由小写字母（多个单词也全部小写）。</li>
<li>如果包名包含多个层次，每个层次用“.”分割。</li>
<li>包名一般由倒置的域名开头，比如<code>com.baidu</code>，不要有<code>www</code>。</li>
<li>自定义包不能<code>java</code>开头。</li>
</ul>
<p>注意：如果在源文件中没有定义包，那么类、接口、枚举和注释类型文件将会被放进一个无名的包中，也称为默认包。在实际企业开发中，通常不会把类定义在默认包下。</p>
<h1 id="包导入"><a href="#包导入" class="headerlink" title="包导入"></a>包导入</h1><p>如果使用不同包中的其它类，需要使用该类的全名（包名+类名）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example.<span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">example</span>.Test();</span><br></pre></td></tr></table></figure>
<p>其中，<code>example</code>是包名，<code>Test</code>是包中的类名，<code>test</code>是类的对象。</p>
<p>为了简化编程，Java 引入了<code>import</code>关键字，<code>import</code>可以向某个 Java 文件中导入指定包层次下的某个类或全部类。<code>import</code>语句位于<code>package</code>语句之后，类定义之前。一个 Java 源文件只能包含一个<code>package</code>语句，但可以包含多个<code>import</code>语句。</p>
<p>使用<code>import</code>导入单个类的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 包名+类名;</span><br></pre></td></tr></table></figure>
<p>使用<code>import</code>语句导入指定包下全部类的用法按如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import example.*;</span><br></pre></td></tr></table></figure>
<p>上面<code>import</code>语句中的星号（*）只能代表类，不能代表包，表明导入<code>example</code>包下的所有类。</p>
<p>提示：使用星号（*）可能会增加编译时间，特别是引入多个大包时，所以明确的导入你想要用到的类是一个好方法，需要注意的是使用星号对运行时间和类的大小没有影响。</p>
<p>通过使用<code>import</code>语句可以简化编程，但<code>import</code>语句并不是必需的，如果在类里使用其它类的全名，可以不使用<code>import</code>语句。</p>
<p>Java 默认为所有源文件导入<code>java.lang</code>包下的所有类，因此前面在 Java 程序中使用<code>String、System</code>类时都无须使用<code>import</code>语句来导入这些类。但对于<code>Arrays</code>类，其位于<code>java.util</code>包下，则必须使用<code>import</code>语句来导入该类。</p>
<p>在一些极端的情况下，<code>import</code>语句也帮不了我们，此时只能在源文件中使用类全名。例如，需要在程序中使用<code>java.sql</code>包下的类，也需要使用<code>java.util</code>包下的类，则可以使用如下两行<code>import</code>语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br></pre></td></tr></table></figure>
<p>如果接下来在程序中需要使用<code>Date</code>类，则会引起如下编译错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test.java:25:对Date的引用不明确，</span><br><span class="line">java.sql中的类java.sql.Date和java.util中的类java.util.Date都匹配</span><br></pre></td></tr></table></figure>
<p>上面错误提示：在<code>Test.java</code>文件的第 25 行使用了<code>Date</code>类，而<code>import</code>语句导入的<code>java.sql</code>和<code>java.util</code>包下都包含了<code>Date</code>类，系统不知道使用哪个包下的<code>Date</code>类。在这种情况下，如果需要指定包下的<code>Date</code>类，则只能使用该类的全名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了让引用更加明确，即使使用了 import 语句，也还是需要使用类的全名</span></span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date();</span><br></pre></td></tr></table></figure>
<h2 id="系统包"><a href="#系统包" class="headerlink" title="系统包"></a>系统包</h2><p>常用的系统包：</p>
<table>
<thead>
<tr>
<th align="center">包</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">java.lang</td>
<td align="center">Java 的核心类库，包含运行 Java 程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、异常处理和线程类等，系统默认加载这个包</td>
</tr>
<tr>
<td align="center">java.io</td>
<td align="center">Java 语言的标准输入&#x2F;输出类库，如基本输入&#x2F;输出流、文件输入&#x2F;输出、过滤输入&#x2F;输出流等</td>
</tr>
<tr>
<td align="center">java.util</td>
<td align="center">包含如处理时间的 Date 类，处理动态数组的 Vector 类，以及 Stack 和 HashTable 类</td>
</tr>
<tr>
<td align="center">java.awt</td>
<td align="center">构建图形用户界面（GUI）的类库，低级绘图操作 Graphics 类、图形界面组件和布局管理（如 Checkbox 类、Container 类、LayoutManger 接口等），以及用户界面交互控制和事件响应（如 Event 类）</td>
</tr>
<tr>
<td align="center">java.awt.image</td>
<td align="center">处理和操纵来自网上的图片的 Java 工具类库</td>
</tr>
<tr>
<td align="center">java.wat.peer</td>
<td align="center">很少在程序中直接用到，使得同一个 Java 程序在不同的软硬件平台上运行</td>
</tr>
<tr>
<td align="center">java.net</td>
<td align="center">实现网络功能的类库有 Socket 类、ServerSocket 类</td>
</tr>
<tr>
<td align="center">java.lang.reflect</td>
<td align="center">提供用于反射对象的工具</td>
</tr>
<tr>
<td align="center">java.util.zip</td>
<td align="center">实现文件压缩功能</td>
</tr>
<tr>
<td align="center">java.awt.datatransfer</td>
<td align="center">处理数据传输的工具类，包括剪贴板、字符串发送器等</td>
</tr>
<tr>
<td align="center">java.sql</td>
<td align="center">实现 JDBC 的类库</td>
</tr>
<tr>
<td align="center">java.rmi</td>
<td align="center">提供远程连接与载入的支持</td>
</tr>
<tr>
<td align="center">java. security</td>
<td align="center">提供安全性方面的有关支持</td>
</tr>
</tbody></table>
<h1 id="使用自定义包"><a href="#使用自定义包" class="headerlink" title="使用自定义包"></a>使用自定义包</h1><ol>
<li>创建一个名为<code>com.dao</code>的包。</li>
<li>向<code>com.dao</code>包中添加一个<code>Student</code>类，该类包含一个返回<code>String</code>类型数组的<code>GetAll()</code>方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String[] GetAll() &#123;</span><br><span class="line">    String[] namelist = &#123;<span class="string">&quot;李潘&quot;</span>,<span class="string">&quot;邓国良&quot;</span>,<span class="string">&quot;任玲玲&quot;</span>,<span class="string">&quot;许月月&quot;</span>,<span class="string">&quot;欧阳娜&quot;</span>,<span class="string">&quot;赵晓慧&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> namelist;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建<code>com.test</code>包，在该包里创建带<code>main()</code>方法的<code>Test</code>类。</li>
<li>在<code>main()</code>方法中遍历<code>Student</code>类的<code>GetAll()</code>方法中的元素内容，在遍历内容之前，使用<code>import</code>引入<code>com.dao</code>整个包。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> com.dao.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;学生信息如下：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String str:Student.GetAll()) &#123;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出结果如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">学生信息如下：</span><br><span class="line">李潘</span><br><span class="line">邓国良</span><br><span class="line">任玲玲</span><br><span class="line">许月月</span><br><span class="line">欧阳娜</span><br><span class="line">赵晓慧</span><br></pre></td></tr></table></figure></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java修饰符和关键字"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/17/java/%E5%9F%BA%E7%A1%80/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/"
    >Java 修饰符和关键字</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/17/java/%E5%9F%BA%E7%A1%80/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/" class="article-date">
  <time datetime="2020-09-17T10:03:24.000Z" itemprop="datePublished">2020-09-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h1><p>在 Java 语言中提供了多个作用域修饰符，其中常用的有<code>public、private、protected、final、abstract、static、transient</code>和<code>volatile</code>，这些修饰符有类修饰符、变量修饰符和方法修饰符。</p>
<p>通过使用访问控制修饰符来限制对对象私有属性的访问，可以获得 3 个重要的好处。</p>
<ul>
<li>防止对封装数据的未授权访问。</li>
<li>有助于保证数据完整性。</li>
<li>当类的私有实现细节必须改变时，可以限制发生在整个应用程序中的“连锁反应”。</li>
</ul>
<p>访问控制符是一组限定类、属性或方法是否可以被程序里的其他部分访问和调用的修饰符。类的访问控制符只能是空或者<code>public</code>，方法和属性的访问控制符有 4 个，分别是<code>public、 private、protected</code>和<code>friendly</code>，其中<code>friendly</code>是一种没有定义专门的访问控制符的默认情况。</p>
<table>
<thead>
<tr>
<th align="center">访问范围</th>
<th align="center">private</th>
<th align="center">friendly(默认)</th>
<th align="center">protected</th>
<th align="center">public</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一个类</td>
<td align="center">可访问</td>
<td align="center">可访问</td>
<td align="center">可访问</td>
<td align="center">可访问</td>
</tr>
<tr>
<td align="center">同一包中的其他类</td>
<td align="center">不可访问</td>
<td align="center">可访问</td>
<td align="center">可访问</td>
<td align="center">可访问</td>
</tr>
<tr>
<td align="center">不同包中的子类</td>
<td align="center">不可访问</td>
<td align="center">不可访问</td>
<td align="center">可访问</td>
<td align="center">可访问</td>
</tr>
<tr>
<td align="center">不同包中的非子类</td>
<td align="center">不可访问</td>
<td align="center">不可访问</td>
<td align="center">不可访问</td>
<td align="center">可访问</td>
</tr>
</tbody></table>
<ol>
<li><code>private</code><br>用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。因此，<code>private</code>修饰符具有最高的保护级别。</li>
<li><code>friendly</code>（默认）<br>如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（<code>package private</code>）。<br>同样，类内的成员如果没有访问控制符，也说明它们具有包访问性，或称为友元（<code>friend</code>）。定义在同一个文件夹中的所有类属于一个包，所以前面的程序要把用户自定义的类放在同一个文件夹中（Java 项目默认的包），以便不加修饰符也能运行。</li>
<li><code>protected</code><br>用保护访问控制符<code>protected</code>修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用<code>protected</code>修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</li>
<li><code>public</code><br>当一个类被声明为<code>public</code>时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用<code>import</code>语句引入<code>public</code>类，就可以访问和引用这个类。<br>类中被设定为<code>public</code>的方法是这个类对外的接口部分，避免了程序的其他部分直接去操作类内的数据，实际就是数据封装思想的体现。每个 Java 程序的主类都必须是<code>public</code>类，也是基于相同的原因。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="comment">// 姓名，其访问权限为默认(friendly)</span></span><br><span class="line">  String name;</span><br><span class="line">  <span class="comment">// 定义私有变量，身份证号码</span></span><br><span class="line">  <span class="keyword">private</span> String idNumber;</span><br><span class="line">  <span class="comment">// 定义受保护变量，学号</span></span><br><span class="line">  <span class="keyword">protected</span> String no;</span><br><span class="line">  <span class="comment">// 定义共有变量，邮箱</span></span><br><span class="line">  <span class="keyword">public</span> String email;</span><br><span class="line">  <span class="comment">// 定义共有方法，显示学生信息</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span><span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;，身份证号码：&quot;</span>+idNumber+<span class="string">&quot;，学号：&quot;</span>+no+<span class="string">&quot;，邮箱：&quot;</span>+email;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Student类对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="comment">// 向Student类对象中的属性赋值</span></span><br><span class="line">    stu.name = <span class="string">&quot;zhht&quot;</span>;</span><br><span class="line">    <span class="comment">// stu.idNumber=&quot;043765290763137806&quot;;</span></span><br><span class="line">    <span class="comment">// 这是不允许的。提示stu.idNumber是不可见的，必须注释掉才可运行</span></span><br><span class="line">    stu.no = <span class="string">&quot;20lil01637&quot;</span>;</span><br><span class="line">    stu.email = <span class="string">&quot;zhht@qq.com&quot;</span>;</span><br><span class="line">    System.out.println(stu.info());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看出，范围控制修饰符成功地限制了访问者访问不同修饰符的属性（成员变量），从而实现了数据的隐藏。</p>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>在类中，使用<code>static</code>修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。</p>
<p>静态成员不依赖于类的特定实例，被类的所有实例共享，就是说<code>static</code>修饰的方法或者变量不需要依赖于对象来进行访问，只要这个类被加载，Java 虚拟机就可以根据类名找到它们。</p>
<p>调用静态成员的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.静态成员</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>static</code>修饰的成员变量和方法，从属于类。</li>
<li>普通变量和方法从属于对象。</li>
<li>静态方法不能调用非静态成员，编译会报错。</li>
</ul>
<h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>类的成员变量可以分为以下两种：</p>
<ul>
<li>静态变量（或称为类变量），指被<code>static</code>修饰的成员变量。</li>
<li>实例变量，指没有被<code>static</code>修饰的成员变量。</li>
</ul>
<p>静态变量与实例变量的区别如下：</p>
<ol>
<li>静态变量</li>
</ol>
<ul>
<li>运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。</li>
<li>在类的内部，可以在任何方法内直接访问静态变量。</li>
<li>在其他类中，可以通过类名访问该类中的静态变量。</li>
</ul>
<ol start="2">
<li>实例变量</li>
</ol>
<ul>
<li>每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。</li>
<li>在类的内部，可以在非静态方法中直接访问实例变量。</li>
<li>在本类的静态方法或其他类中则需要通过类的实例对象进行访问。</li>
</ul>
<p>静态变量在类中的作用如下：</p>
<ul>
<li>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</li>
<li>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159256</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>创建一个带静态变量的类，然后在<code>main()</code>方法中访问该变量并输出结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticVar</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">    <span class="comment">// 直接访问str1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">accessVar1</span> <span class="operator">=</span> str1+str2;</span><br><span class="line">    System.out.println(<span class="string">&quot;第 1 次访问静态变量，结果为：&quot;</span>+accessVar1);</span><br><span class="line">    <span class="comment">// 通过类名访问str1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">accessVar2</span> <span class="operator">=</span> StaticVar.str1+str2;</span><br><span class="line">    System.out.println(<span class="string">&quot;第 2 次访问静态变量，结果为：&quot;</span>+accessVar2);</span><br><span class="line">    <span class="comment">// 通过对象svt1访问str1</span></span><br><span class="line">    <span class="type">StaticVar</span> <span class="variable">svt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticVar</span>();</span><br><span class="line">    svt1.str1 = svt1.str1+str2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessVar3</span> <span class="operator">=</span> svt1.str1;</span><br><span class="line">    System.out.println(<span class="string">&quot;第3次访向静态变量，结果为：&quot;</span>+accessVar3);</span><br><span class="line">    <span class="comment">// 通过对象svt2访问str1</span></span><br><span class="line">    <span class="type">StaticVar</span> <span class="variable">svt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticVar</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">accessVar4</span> <span class="operator">=</span> svt2.str1+str2;</span><br><span class="line">    System.out.println(<span class="string">&quot;第 4 次访问静态变量，结果为：&quot;</span>+accessVar4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序后的结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第 1 次访问静态变量，结果为：HelloWorld!</span><br><span class="line">第 2 次访问静态变量，结果为：HelloWorld!</span><br><span class="line">第 3 次访向静态变量，结果为：HelloWorld!</span><br><span class="line">第 4 次访问静态变量，结果为：HelloWorld!World!</span><br></pre></td></tr></table></figure>
<p>从运行结果可以看出，在类中定义静态的属性（成员变量），在<code>main()</code>方法中可以直接访问，也可以通过类名访问，还可以通过类的实例对象来访问。</p>
<p>注意：静态变量是被多个实例所共享的。</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>与成员变量类似，成员方法也可以分为以下两种：</p>
<ul>
<li>静态方法（或称为类方法），指被<code>static</code>修饰的成员方法。</li>
<li>实例方法，指没有被<code>static</code>修饰的成员方法。</li>
</ul>
<p>静态方法与实例方法的区别如下：</p>
<ul>
<li>静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用<code>this</code>关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和<code>this</code>关键字一样，<code>super</code>关键字也与类的特定实例相关，所以在静态方法中也不能使用<code>super</code>关键字。</li>
<li>在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。</li>
</ul>
<p>创建一个带静态变量的类，添加几个静态方法对静态变量的值进行修改，然后在<code>main()</code>方法中调用静态方法并输出结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 定义静态变量count</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method1</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="comment">// 实例方法method1</span></span><br><span class="line">    count++;    <span class="comment">// 访问静态变量count并赋值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;在静态方法 method1()中的 count=&quot;</span>+count);    <span class="comment">// 打印count</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="comment">// 静态方法method2</span></span><br><span class="line">    count += count;    <span class="comment">// 访问静态变量count并赋值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;在静态方法 method2()中的 count=&quot;</span>+count);    <span class="comment">// 打印count</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">PrintCount</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="comment">// 静态方法PrintCount</span></span><br><span class="line">    count += <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;在静态方法 PrintCount()中的 count=&quot;</span>+count);    <span class="comment">// 打印count</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StaticMethod</span> <span class="variable">sft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethod</span>();</span><br><span class="line">    <span class="comment">// 通过实例对象调用实例方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;method1() 方法返回值 intro1=&quot;</span>+sft.method1());</span><br><span class="line">    <span class="comment">// 直接调用静态方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;method2() 方法返回值 intro1=&quot;</span>+method2());</span><br><span class="line">    <span class="comment">// 通过类名调用静态方法，打印 count</span></span><br><span class="line">    StaticMethod.PrintCount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序后的结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在静态方法 method1()中的 count=2</span><br><span class="line">method1() 方法返回值 intro1=2</span><br><span class="line">在静态方法 method2()中的 count=4</span><br><span class="line">method2() 方法返回值 intro1=4</span><br><span class="line">在静态方法 PrintCount()中的 count=6</span><br></pre></td></tr></table></figure>
<p>在该程序中，静态变量<code>count</code>作为实例之间的共享数据，因此在不同的方法中调用<code>count</code>，值是不一样的。从该程序中可以看出，在静态方法<code>method1()</code>和<code>PrintCount()</code>中是不可以调用非静态方法<code>method1()</code>的，而在<code>method1()</code>方法中可以调用静态方法<code>method2()</code>和<code>PrintCount()</code>。</p>
<p>在访问非静态方法时，需要通过实例对象来访问，而在访问静态方法时，可以直接访问，也可以通过类名来访问，还可以通过实例化对象来访问。</p>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>静态代码块指 Java 类中的<code>static&#123; &#125;</code>代码块，主要用于初始化类，为类的静态变量赋初始值，提升程序性能。</p>
<p>静态代码块的特点如下：</p>
<ul>
<li>静态代码块类似于一个方法，但它不可以存在于任何方法体中。</li>
<li>静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块。 </li>
<li>Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在<code>static</code>代码块中进行。</li>
<li>如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。</li>
<li>静态代码块与静态方法一样，不能直接访问类的实例变量和实例方法，而需要通过类的实例对象来访问。</li>
</ul>
<p>编写一个 Java 类，在类中定义一个静态变量，然后使用静态代码块修改静态变量的值。最后在 main() 方法中进行测试和输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCode</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    count++;</span><br><span class="line">    System.out.println(<span class="string">&quot;非静态代码块 count=&quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态代码块1 count=&quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态代码块2 count=&quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;*************** StaticCode1 执行 ***************&quot;</span>);</span><br><span class="line">    <span class="type">StaticCode</span> <span class="variable">sct1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticCode</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;*************** StaticCode2 执行 ***************&quot;</span>);</span><br><span class="line">    <span class="type">StaticCode</span> <span class="variable">sct2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticCode</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述示例，为了说明静态代码块只被执行一次，特地添加了非静态代码块作为对比，并在主方法中创建了两个类的实例对象。上述示例的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">静态代码块1 count=1</span><br><span class="line">静态代码块2 count=2</span><br><span class="line">*************** StaticCode1 执行 ***************</span><br><span class="line">非静态代码块 count=3</span><br><span class="line">*************** StaticCode2 执行 ***************</span><br><span class="line">非静态代码块 count=4</span><br></pre></td></tr></table></figure>
<p>上述代码中<code>&#123; &#125;</code>代码块为非静态代码块，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。代码域中定义的变量都是局部的，只有域中的代码可以调用。 </p>
<h1 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h1><p><code>final</code>在 Java 中的意思是最终，表示对象是最终形态的，不可改变的意思。<code>final</code>应用于类、方法和变量时意义是不同的，但本质是一样的，都表示不可改变。</p>
<p>使用<code>final</code>关键字声明类、变量和方法需要注意以下几点：</p>
<ul>
<li><code>final</code>用在变量的前面表示变量的值不可以改变，此时该变量可以被称为常量。</li>
<li><code>final</code>用在方法的前面表示方法不可以被重写。</li>
<li><code>final</code>用在类的前面表示该类不能有子类，即该类不可以被继承。</li>
</ul>
<h2 id="final-修饰变量"><a href="#final-修饰变量" class="headerlink" title="final 修饰变量"></a>final 修饰变量</h2><p><code>final</code>修饰的变量即成为常量，只能赋值一次，但是<code>final</code>所修饰局部变量和成员变量有所不同。</p>
<ul>
<li><code>final</code>修饰的局部变量必须使用之前被赋值一次才能使用。</li>
<li><code>final</code>修饰的成员变量在声明时没有赋值的叫“空白<code>final</code>变量”。空白<code>final</code>变量必须在构造方法或静态代码块中初始化。</li>
</ul>
<blockquote>
<p>注意：<code>final</code>修饰的变量不能被赋值这种说法是错误的，严格的说法是，<code>final</code>修饰的变量不可被改变，一旦获得了初始值，该<code>final</code>变量的值就不能被重新赋值。</p>
</blockquote>
<p>当使用<code>final</code>修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。 但对于引用类型变量而言，它保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。</p>
<p>如果一个程序中的变量使用<code>public static final</code>声明，则此变量将称为全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final String SEX= &quot;女&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h2><p><code>final</code>修饰的方法不可被重写，如果出于某些原因，不希望子类重写父类的某个方法，则可以使用<code>final</code>修饰该方法。</p>
<p>Java 提供的<code>Object</code>类里就有一个<code>final</code>方法<code>getClass()</code>，因为 Java 不希望任何类重写这个方法，所以使用<code>final</code>把这个方法密封起来。但对于该类提供的<code>toString()</code>和<code>equals()</code>方法，都允许子类重写，因此没有使用<code>final</code>修饰它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalMethodTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">FinalMethodTest</span> &#123;</span><br><span class="line">  <span class="comment">// 下面方法定义将出现编译错误，不能重写final方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中父类是<code>FinalMethodTest</code>，该类里定义的<code>test()</code>方法是一个<code>final</code>方法，如果其子类试图重写该方法，将会引发编译错误。</p>
<p>对于一个<code>private</code>方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法——如果子类中定义一个与父类<code>private</code>方法有相同方法名、相同形参列表、相同返回值类型的方法，也不是方法重写，只是重新定义了一个新方法。因此，即使使用<code>final</code>修饰一个<code>private</code>访问权限的方法，依然可以在其子类中定义与该方法具有相同方法名、相同形参列表、相同返回值类型的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrivateFinalMethodTest</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">PrivateFinalMethodTest</span> &#123;</span><br><span class="line">  <span class="comment">// 下面的方法定义不会出现问题</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序没有任何问题，虽然子类和父类同样包含了同名的<code>void test()</code>方法，但子类并不是重写父类的方法，因此即使父类的<code>void test()</code>方法使用了<code>final</code>修饰，子类中依然可以定义<code>void test()</code>方法。</p>
<p><code>final</code>修饰的方法仅仅是不能被重写，并不是不能被重载，因此下面程序完全没有问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalOverload</span> &#123;</span><br><span class="line">  <span class="comment">// final 修饰的方法只是不能被重写，完全可以被重载</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String arg)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h2><p><code>final</code>修饰的类不能被继承。当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用<code>final</code>修饰这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;    <span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="final-修饰符使用总结"><a href="#final-修饰符使用总结" class="headerlink" title="final 修饰符使用总结"></a>final 修饰符使用总结</h2><ol>
<li><code>final</code>修饰类中的变量<br>表示该变量一旦被初始化便不可改变，这里不可改变的意思对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。其初始化可以在两个地方：一是其定义处，也就是说在<code>final</code>变量定义时直接给其赋值；二是在构造方法中。这两个地方只能选其一，要么在定义时给值，要么在构造方法中给值，不能同时既在定义时赋值，又在构造方法中赋予另外的值。</li>
<li><code>final</code>修饰类中的方法<br>说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个<code>final</code>方法只被实现一次。</li>
<li><code>final</code>修饰类<br>表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。</li>
</ol>
<p>对于<code>final</code>类中的成员，可以定义其为<code>final</code>，也可以不是<code>final</code>。而对于方法，由于所属类为<code>final</code>的关系，自然也就成了<code>final</code>型。也可以明确地给<code>final</code>类中的方法加上一个<code>final</code>，这显然没有意义。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java类和对象"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/13/java/%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"
    >Java 类和对象</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/13/java/%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2020-09-13T08:22:16.000Z" itemprop="datePublished">2020-09-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h1><p>Java 是面向对象的编程语言，对象就是面向对象程序设计的核心。所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：</p>
<ul>
<li>对象具有属性和行为。</li>
<li>对象具有变化的状态。</li>
<li>对象具有唯一性。</li>
<li>对象都是某个类别的实例。</li>
<li>一切皆为对象，真实世界中的所有事物都可以视为对象。</li>
</ul>
<p>例如，在真实世界的学校里，会有学生和老师等实体，学生有学号、姓名、所在班级等属性（数据），学生还有学习、提问、吃饭和走路等操作。学生只是抽象的描述，这个抽象的描述称为“类”。在学校里活动的是学生个体，即张同学、李同学等，这些具体的个体称为“对象”，“对象”也称为“实例”。</p>
<h1 id="面向对象的三大核心特性"><a href="#面向对象的三大核心特性" class="headerlink" title="面向对象的三大核心特性"></a>面向对象的三大核心特性</h1><p>面向对象程序设计有以下优点。</p>
<ul>
<li>可重用性：代码重复使用，减少代码量，提高开发效率。大核心特性（继承、封装和多态）都围绕这个核心。</li>
<li>可扩展性：指新的功能可以很容易地加入到系统中来，便于软件的修改。</li>
<li>可管理性：能够将功能与数据结合，方便管理。</li>
</ul>
<p>该开发模式之所以使程序设计更加完善和强大，主要是因为面向对象具有继承、封装和多态 3 个核心特性。</p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系。Java 只支持单继承。</p>
<p>使用这种层次形的分类方式，是为了将多个类的通用属性和方法提取出来，放在它们的父类中，然后只需要在子类中各自定义自己独有的属性和方法，并以继承的形式在父类中获取它们的通用属性和方法即可。</p>
<p>Java 语言是单继承的，即只能有一个父类，但 Java 可以实现多个接口，可以防止多继承所引起的冲突问题。</p>
<h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><p>封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。封装的目的在于保护信息，使用它的主要优点如下。</p>
<ul>
<li>保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。</li>
<li>隐藏细节信息，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。</li>
<li>有助于建立各个系统之间的松耦合关系，提高系统的独立性。当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。</li>
<li>提高软件的复用率，降低成本。每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。</li>
</ul>
<p>Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。</p>
<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p>定义一个类，需要使用<code>class</code>关键字、一个自定义的类名和一对表示程序体的大括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>][<span class="keyword">abstract</span>|<span class="keyword">final</span>]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;</span><br><span class="line">    <span class="comment">// 定义属性部分</span></span><br><span class="line">    &lt;property_type&gt;&lt;property1&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property2&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property3&gt;;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 定义方法部分</span></span><br><span class="line">    function1();</span><br><span class="line">    function2();</span><br><span class="line">    function3();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>》 提示：上述语法中，中括号<code>[]</code>中的部分表示可以省略，竖线<code>|</code>表示“或关系”，但是两个关键字不能同时出现。</p>
<p>上述语法中各关键字的描述如下。</p>
<ul>
<li><code>public</code>：表示“共有”的意思。如果使用<code>public</code>修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是<code>public</code>类，作为公共工具供其他类和程序使用的类应定义为<code>public</code>类。</li>
<li><code>abstract</code>：如果类被<code>abstract</code>修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用<code>abstract</code>修饰的方法）和具体方法（没有使用<code>abstract</code>修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。</li>
<li><code>final</code>：如果类被<code>final</code>修饰，则不允许被继承。</li>
<li><code>class</code>：声明类的关键字。</li>
<li><code>class_name</code>：类的名称。</li>
<li><code>extends</code>：表示继承其他类。</li>
<li><code>implements</code>：表示实现某些接口。</li>
<li><code>property_type</code>：表示成员变量的类型。</li>
<li><code>property</code>：表示成员变量名称。</li>
<li><code>function()</code>：表示成员方法名称。</li>
</ul>
<p>Java 类名的命名规则：</p>
<ul>
<li>类名应该以下划线（<code>_</code>）或字母开头，最好以字母开头。</li>
<li>第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。</li>
<li>类名不能为 Java 中的关键字，例如<code>boolean、this、int</code>等。</li>
<li>类名不能包含任何嵌入的空格或点号以及除了下划线（<code>_</code>）和美元符号（<code>$</code>）字符之外的特殊字符。</li>
</ul>
<p>创建一个新的类，就是创建一个新的数据类型。实例化一个类，就是得到类的一个对象。因此，对象就是一组变量和相关方法的集合，其中变量表明对象的状态和属性，方法表明对象所具有的行为。定义一个类的步骤如下所述。</p>
<ol>
<li>声明类。编写类的最外层框架，声明一个名称为<code>Person</code>的类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 类的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写类的属性。类中的数据和方法统称为类成员。其中，类的属性就是类的数据成员。通过在类的主体中定义变量来描述类所具有的特征（属性），这里声明的变量称为类的成员变量。</li>
<li>编写类的方法。类的方法描述了类所具有的行为，是类的方法成员。可以简单地把方法理解为独立完成某个功能的单元模块。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">()</span> &#123;   </span><br><span class="line">    <span class="comment">// 定义说话的方法</span></span><br><span class="line">    System.out.println(name+<span class="string">&quot;今年&quot;</span>+age+<span class="string">&quot;岁！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h1><p>在 Java 中类的成员变量定义了类的属性。声明成员变量的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[public|protected|private][static][final] &lt;type&gt; &lt;variable_name&gt;</span><br></pre></td></tr></table></figure>
<p>各参数的含义如下。</p>
<ul>
<li><code>public、protected、private</code>：用于表示成员变量的访问权限。</li>
<li><code>static</code>：表示该成员变量为类变量，也称为静态变量。</li>
<li><code>final</code>：表示将该成员变量声明为常量，其值无法更改。</li>
<li><code>type</code>：表示变量的类型。</li>
<li><code>variable_name</code>：表示变量名称。</li>
</ul>
<p>可以在声明成员变量的同时对其进行初始化，如果声明成员变量时没有对其初始化，则系统会使用默认值初始化成员变量。</p>
<p>初始化的默认值如下：</p>
<ul>
<li>整数型（<code>byte、short、int</code>和<code>long</code>）的基本类型变量的默认值为 0。</li>
<li>单精度浮点型（<code>float</code>）的基本类型变量的默认值为<code>0.0f</code>。</li>
<li>双精度浮点型（<code>double</code>）的基本类型变量的默认值为<code>0.0d</code>。</li>
<li>字符型（<code>char</code>）的基本类型变量的默认值为<code>\u0000</code>。</li>
<li>布尔型的基本类型变量的默认值为<code>false</code>。</li>
<li>数组引用类型的变量的默认值为<code>null</code>。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。</li>
</ul>
<p>定义类的成员变量的示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 性别：0表示女孩，1表示男孩</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h1><p>声明成员方法可以定义类的行为，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。类的各种功能操作都是用方法来实现的，属性只不过提供了相应的数据。一个完整的方法通常包括方法名称、方法主体、方法参数和方法返回值类型。</p>
<p>成员方法一旦被定义，便可以在程序中多次调用。声明成员方法的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  [<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>][<span class="keyword">static</span>] &lt;<span class="keyword">void</span>|return_type&gt; &lt;method_name&gt; ([paramList]) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中<code>return_type</code>是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。</p>
<p>除了这些，一个方法还可以没有返回值，即返回类型为<code>void</code>，像<code>main()</code>方法。<code>method_name</code>表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。</p>
<p><code>paramList</code>表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。</p>
<ul>
<li><code>public、private、protected</code>：表示成员方法的访问权限。</li>
<li><code>static</code>：表示限定该成员方法为静态方法。</li>
<li><code>final</code>：表示限定该成员方法不能被重写或重载。</li>
<li><code>abstract</code>：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> StringBuffer <span class="title function_">printInfo</span><span class="params">(Student st)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(<span class="string">&quot;学生姓名：&quot;</span>+st.Name+<span class="string">&quot;\n 学生年龄：&quot;</span>+st.Age+<span class="string">&quot;\n 学生性别：&quot;</span>+st.isSex());</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个名称为<code>printInfo</code>的方法，其返回值类型为<code>StringBuffer</code>（引用数据类型）。该方法需要传递一个<code>Student</code>类型的参数，最后需要将一个<code>StringBuffer</code>类型的数据返回。</p>
<h3 id="1-成员方法的返回值"><a href="#1-成员方法的返回值" class="headerlink" title="1. 成员方法的返回值"></a>1. 成员方法的返回值</h3><p>若方法有返回值，则在方法体中用<code>return</code>语句指明要返回的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return 表达式</span><br><span class="line">// 或者</span><br><span class="line">return (表达式)</span><br></pre></td></tr></table></figure>
<p>其中，表达式可以是常量、变量、对象等。表达式的数据类型必须与声明成员方法时给出的返回值类型一致。</p>
<h3 id="2-形参、实参及成员方法的调用"><a href="#2-形参、实参及成员方法的调用" class="headerlink" title="2. 形参、实参及成员方法的调用"></a>2. 形参、实参及成员方法的调用</h3><p>可以通过以下方式来调用成员方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodName(&#123;paramList&#125;)</span><br></pre></td></tr></table></figure>
<p>关于方法的参数，经常会提到形参与实参，形参是定义方法时参数列表中出现的参数，实参是调用方法时为方法传递的参数。</p>
<p>下面<code>retumMin()</code>方法中的<code>m</code>和<code>n</code>是形参，调用<code>retumMin()</code>方法时的<code>x</code>和<code>y</code>是实参。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">returnMin</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Math.min(m,n);    <span class="comment">// m和n是形参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t.returnMin(x,y);    <span class="comment">// x和y是实参</span></span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的形参和实参具有以下特点：</p>
<ul>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在方法内部有效，方法调用结束返回主调方法后则不能再使用该形参变量。</li>
<li>实参可以是常量、变量、表达式、方法等，无论实参是何种类型的量，在进行方法调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值、输入等办法使实参获得确定值。</li>
<li>实参和形参在数量、类型和顺序上应严格一致，否则会发生“类型不匹配” 的错误。</li>
<li>方法调用中发生的数据传送是单向的，即只能把实参的值传送绐形参，而不能把形参的值反向地传送给实参。因此在方法调用过程中，形参的值发生改变，而实参中的值不会变化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  x += <span class="number">30</span>;</span><br><span class="line">  System.out.println(<span class="string">&quot;形参 x 的值：&quot;</span>+x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">150</span>;</span><br><span class="line">  System.out.println(<span class="string">&quot;调用 add() 方法之前 x 的值：&quot;</span>+x);</span><br><span class="line">  <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t.add(x);</span><br><span class="line">  System.out.println(<span class="string">&quot;实参 x 的值：&quot;</span>+x);</span><br><span class="line">  System.out.println(<span class="string">&quot;调用 add() 方法的返回值：&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用 add() 方法之前 x 的值：150</span><br><span class="line">形参 x 的值：180</span><br><span class="line">实参 x 的值：150</span><br><span class="line">调用 add() 方法的返回值：180</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出，形参<code>x</code>值的改变，并没有影响实参<code>x</code>。</p>
<p>在调用成员方法时应注意以下 4 点：</p>
<ul>
<li>对无参成员方法来说，是没有实际参数列表的（即没有<code>paramList</code>），但方法名后的括号不能省略。</li>
<li>对带参数的成员方法来说，实参的个数、顺序以及它们的数据类型必须与形式参数的个数、顺序以及它们的数据类型保持一致，各个实参间用逗号分隔。实参名与形参名可以相同，也可以不同。</li>
<li>实参也可以是表达式，此时一定要注意使表达式的数据类型与形参的数据类型相同，或者使表达式的类型按 Java 类型转换规则达到形参指明的数据类型。</li>
<li>实参变量对形参变量的数据传递是“值传递”，即只能由实参传递给形参，而不能由形参传递给实参。程序中执行到调用成员方法时，Java 把实参值复制到一个临时的存储区（栈）中，形参的任何修改都在栈中进行，当退出该成员方法时，Java 自动清除栈中的内容。</li>
</ul>
<h3 id="3-方法体中的局部变量"><a href="#3-方法体中的局部变量" class="headerlink" title="3. 方法体中的局部变量"></a>3. 方法体中的局部变量</h3><p>在方法体内可以定义本方法所使用的变量，这种变量是局部变量。它的生存期与作用域是在本方法内，也就是说，局部变量只能在本方法内有效或可见，离开本方法则这些变量将被自动释放。</p>
<p>在方法体内定义变量时，变量前不能加修饰符。局部变量在使用前必须明确赋值，否则编译时会出错。另外，在一个方法内部，可以在复合语句（把多个语句用括号{}括起来组成的一个语句称复合语句）中定义变量，这些变量只在复合语句中有效。</p>
<h1 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h1><p><code>this</code>关键字可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。</p>
<h2 id="this-属性名"><a href="#this-属性名" class="headerlink" title="this.属性名"></a>this.属性名</h2><p>大部分时候，普通方法访问其他方法、成员变量时无须使用<code>this</code>前缀，但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用<code>this</code>前缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;    <span class="comment">// 教师名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> salary;    <span class="comment">// 工资</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中<code>name、salary</code>和<code>age</code>的作用域是<code>private</code>，因此在类外部无法对它们的值进行设置。为了解决这个问题，可以为<code>Teacher</code>类添加一个构造方法，然后在构造方法中传递参数进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建构造方法，为上面的3个属性赋初始值</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name,<span class="type">double</span> salary,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;    <span class="comment">// 设置教师名称</span></span><br><span class="line">  <span class="built_in">this</span>.salary = salary;    <span class="comment">// 设置教师工资</span></span><br><span class="line">  <span class="built_in">this</span>.age = age;    <span class="comment">// 设置教师年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Teacher</code>类的构造方法中使用了<code>this</code>关键字对属性<code>name、salary</code>和<code>age</code>赋值，<code>this</code>表示当前对象。<code>this.name=name</code>语句表示一个赋值语句，等号左边的<code>this.name</code>是指当前对象具有的变量<code>name</code>，等号右边的<code>name</code>表示参数传递过来的数值。</p>
<p>创建一个<code>main()</code>方法对<code>Teacher</code>类进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;王刚&quot;</span>,<span class="number">5000.0</span>,<span class="number">45</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;教师信息如下：&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;教师名称：&quot;</span>+teacher.name+<span class="string">&quot;\n教师工资：&quot;</span>+teacher.salary+<span class="string">&quot;\n教师年龄：&quot;</span>+teacher.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">教师信息如下：</span><br><span class="line">教师名称：王刚</span><br><span class="line">教师工资：5000.0</span><br><span class="line">教师年龄：45</span><br></pre></td></tr></table></figure>
<p>提示：当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。</p>
<h2 id="this-方法名"><a href="#this-方法名" class="headerlink" title="this.方法名"></a>this.方法名</h2><p><code>this</code>关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p>
<p>假设定义了一个<code>Dog</code>类，这个<code>Dog</code>对象的<code>run()</code>方法需要调用它的<code>jump()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一种定义Dog类方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="comment">// 定义一个jump()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;正在执行jump方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义一个run()方法，run()方法需要借助jump()方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    d.jump();</span><br><span class="line">    System.out.println(<span class="string">&quot;正在执行 run 方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式来定义这个<code>Dog</code>类，确实可以实现在<code>run()</code>方法中调用<code>jump()</code>方法。下面再提供一个程序来创建<code>Dog</code>对象，并调用该对象的<code>run()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建Dog对象</span></span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="comment">// 调用Dog对象的run()方法</span></span><br><span class="line">    dog.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中，一共产生了两个<code>Dog</code>对象，在<code>Dog</code>类的<code>run()</code>方法中，程序创建了一个<code>Dog</code>对象，并使用名为<code>d</code>的引用变量来指向该<code>Dog</code>对象。在<code>DogTest</code>的<code>main()</code>方法中，程序再次创建了一个<code>Dog</code>对象，并使用名为<code>dog</code>的引用变量来指向该<code>Dog</code>对象。</p>
<p>下面我们思考两个问题。</p>
<ol>
<li>在<code>run()</code>方法中调用<code>jump()</code>方法时是否一定需要一个<code>Dog</code>对象？<br>答案是肯定的，因为没有使用<code>static</code>修饰的成员变量和方法都必须使用对象来调用。</li>
<li>是否一定需要重新创建一个<code>Dog</code>对象？<br>不一定，因为当程序调用<code>run()</code>方法时，一定会提供一个<code>Dog</code>对象，这样就可以直接使用这个已经存在的<code>Dog</code>对象，而无须重新创建新的<code>Dog</code>对象了。因此需要在<code>run()</code>方法中获得调用该方法的对象，通过<code>this</code>关键字就可以满足这个要求。</li>
</ol>
<p><code>this</code>可以代表任何对象，当<code>this</code>出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的只能是当前类的实例。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，<code>this</code>就代表谁。</p>
<p>将前面的<code>Dog</code>类的<code>run()</code>方法改为如下形式会更加合适。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二种定义Dog类方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 定义一个run()方法，run()方法需要借助jump()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 使用this引用调用run()方法的对象</span></span><br><span class="line">  <span class="built_in">this</span>.jump();</span><br><span class="line">  System.out.println(<span class="string">&quot;正在执行run方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 允许对象的一个成员直接调用另一个成员，可以省略<code>this</code>前缀。也就是说，将上面的<code>run()</code>方法改为如下形式也完全正确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  jump();</span><br><span class="line">  System.out.println(<span class="string">&quot;正在执行run方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分时候，一个方法访问该类中定义的其他方法、成员变量时加不加<code>this</code>前缀的效果是完全一样的。</p>
<p>注意：对于<code>static</code>修饰的方法而言，可以使用类来直接调用该方法，如果在<code>static</code>修饰的方法中使用<code>this</code>关键字，则这个关键字就无法指向合适的对象。所以，<code>static</code>修饰的方法中不能使用<code>this</code>引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。</p>
<p>省略<code>this</code>前缀只是一种假象，虽然程序员省略了调用<code>jump()</code>方法之前的<code>this</code>，但实际上这个<code>this</code>依然是存在的。</p>
<h2 id="this-访问构造方法"><a href="#this-访问构造方法" class="headerlink" title="this()访问构造方法"></a>this()访问构造方法</h2><p><code>this()</code>用来访问本类的构造方法（构造方法是类的一种特殊方法，方法名称和类名相同，没有返回值）括号中可以有参数，如果有参数就是调用指定的有参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="comment">// 无参构造方法（没有参数的构造方法）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有参构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输出name和age</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    stu.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="comment">// 姓名：张三</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>this()</code>不能在普通方法中使用，只能写在构造方法中。在构造方法中使用时，必须是第一条语句。</p>
</blockquote>
<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>对象是对类的实例化。对象具有状态和行为，变量用来表明对象的状态，方法表明对象所具有的行为。Java 对象的生命周期包括创建、使用和清除，创建对象分显式创建与隐含创建两种情况。</p>
<h2 id="显式创建对象"><a href="#显式创建对象" class="headerlink" title="显式创建对象"></a>显式创建对象</h2><p>对象的显式创建方式有 4 种。</p>
<ol>
<li>使用<code>new</code>关键字创建对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = new 类名();</span><br></pre></td></tr></table></figure></li>
<li>调用<code>java.lang.Class</code>或者<code>java.lang.reflect.Constuctor</code>类的<code>newlnstance()</code>实例方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class Class 类对象名称 = java.lang.Class.forName(要实例化的类全称);</span><br><span class="line">类名 对象名 = (类名)Class类对象名称.newInstance();</span><br></pre></td></tr></table></figure>
调用<code>java.lang.Class</code>类中的<code>forName()</code>方法时，需要将要实例化的类的全称（比如<code>com.mxl.package.Student</code>）作为参数传递过去，然后再调用<code>java.lang.Class</code>类对象的<code>newInstance()</code>方法创建对象。</li>
<li>调用对象的<code>clone()</code>方法<br>该方法不常用，使用该方法创建对象时，要实例化的类必须继承<code>java.lang.Cloneable</code>接口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名对象名 = (类名)已创建好的类对象名.clone();</span><br></pre></td></tr></table></figure></li>
<li>调用<code>java.io.ObjectlnputStream</code>对象的<code>readObject()</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;   </span><br><span class="line">  <span class="comment">// 实现 Cloneable 接口</span></span><br><span class="line">  <span class="keyword">private</span> String Name;    <span class="comment">// 学生名字</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 学生年龄</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;    </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.Name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.Name = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;学生名字：&quot;</span>+Name+<span class="string">&quot;，年龄：&quot;</span>+age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;---------使用 new 关键字创建对象---------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用new关键字创建对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小刘&quot;</span>,<span class="number">22</span>);</span><br><span class="line">    System.out.println(student1);</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------调用 java.lang.Class 的 newInstance() 方法创建对象-----------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 java.lang.Class 的 newInstance() 方法创建对象</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student)c1.newInstance();</span><br><span class="line">    System.out.println(student2);</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------调用对象的 clone() 方法创建对象----------&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用对象的 clone() 方法创建对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student3</span> <span class="operator">=</span> (Student)student2.clone();</span><br><span class="line">    System.out.println(student3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上述示例的说明如下：</p>
<ul>
<li>使用<code>new</code>关键字或<code>Class</code>对象的<code>newInstance()</code>方法创建对象时，都会调用类的构造方法。</li>
<li>使用<code>Class</code>类的<code>newInstance()</code>方法创建对象时，会调用类的默认构造方法，即无参构造方法。</li>
<li>使用<code>Object</code>类的<code>clone()</code>方法创建对象时，不会调用类的构造方法，它会创建一个复制的对象，这个对象和原来的对象具有不同的内存地址，但它们的属性值相同。</li>
<li>如果类没有实现<code>Cloneable</code>接口，则<code>clone</code>。方法会抛出<code>java.lang.CloneNotSupportedException</code>异常，所以应该让类实现<code>Cloneable</code>接口。</li>
</ul>
<p>程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------使用 new 关键字创建对象---------</span><br><span class="line">学生名字：小刘，年龄：22</span><br><span class="line">-----------调用 java.lang.Class 的 newInstance() 方法创建对象-----------</span><br><span class="line">学生名字：name，年龄：0</span><br><span class="line">-------------------调用对象的done()方法创建对象----------</span><br><span class="line">学生名字：name，年龄：0</span><br></pre></td></tr></table></figure>
<h2 id="隐含创建对象"><a href="#隐含创建对象" class="headerlink" title="隐含创建对象"></a>隐含创建对象</h2><p>除了显式创建对象以外，在 Java 程序中还可以隐含地创建对象，例如下面几种情况。</p>
<ol>
<li><code>String strName = &quot;strValue&quot;</code>，其中的<code>strValue</code>就是一个<code>String</code>对象，由 Java 虚拟机隐含地创建。</li>
<li>字符串的“+”运算符运算的结果为一个新的<code>String</code>对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1+str2;  <span class="comment">// str3引用一个新的String对象</span></span><br></pre></td></tr></table></figure></li>
<li>当 Java 虚拟机加载一个类时，会隐含地创建描述这个类的<code>Class</code>实例。</li>
</ol>
<p>提示：类的加载是指把类的<code>.class</code>文件中的二进制数据读入内存中，把它存放在运行时数据区的方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。</p>
<p>无论釆用哪种方式创建对象，Java 虚拟机在创建一个对象时都包含以下步骤：</p>
<ul>
<li>给对象分配内存。</li>
<li>将对象的实例变量自动初始化为其变量类型的默认值。</li>
<li>初始化对象，给实例变量赋予正确的初始值。</li>
</ul>
<blockquote>
<p>注意：每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理。</p>
</blockquote>
<h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><p>每次<code>new</code>都相当于开辟了一个新的对象，并开辟了一个新的物理内存空间。如果一个对象只需要使用唯一的一次，就可以使用匿名对象，匿名对象还可以作为实际参数传递。</p>
<p>匿名对象就是没有明确的给出名字的对象，是对象的一种简写形式。一般匿名对象只使用一次，而且匿名对象只在堆内存中开辟空间，而不存在栈内存的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">  <span class="comment">// 定义构造方法，为属性初始化</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取信息的方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tell</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>).tell(); <span class="comment">// 匿名对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序运行结果为：</span></span><br><span class="line"><span class="comment">// 姓名：张三，年龄：30</span></span><br></pre></td></tr></table></figure>
<p>在以上程序的主方法中可以发现，直接使用了<code>new Person(&quot;张三&quot;,30)</code>语句，这实际上就是一个匿名对象，与之前声明的对象不同，此处没有任何栈内存引用它，所以此对象使用一次之后就等待被 GC（垃圾收集机制）回收。</p>
<p>匿名对象实际上就是个堆内存空间，对象不管是匿名的还是非匿名的，都必须在开辟堆空间之后才可以使用。</p>
<h1 id="访问对象的属性和行为"><a href="#访问对象的属性和行为" class="headerlink" title="访问对象的属性和行为"></a>访问对象的属性和行为</h1><p>每个对象都有自己的属性和行为，这些属性和行为在类中体现为成员变量和成员方法，其中成员变量对应对象的属性，成员方法对应对象的行为。</p>
<p>在 Java 中，要引用对象的属性和行为，需要使用点（.）操作符来访问。对象名在圆点左边，而成员变量或成员方法的名称在圆点的右边。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.属性(成员变量)    // 访问对象的属性</span><br><span class="line">对象名.成员方法名()    // 访问对象的方法</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();    <span class="comment">// 创建 Student 类的对象 stu</span></span><br><span class="line">stu.Name = <span class="string">&quot;李子文&quot;</span>;    <span class="comment">// 调用stu对象的Name属性并赋值</span></span><br><span class="line">stu.Sex = <span class="literal">true</span>;    <span class="comment">// 调用stu对象的Sex属性并赋值</span></span><br><span class="line">stu.Age = <span class="number">15</span>;    <span class="comment">// 调用stu对象的Age属性并赋值</span></span><br></pre></td></tr></table></figure>
<p>如果一个对象要被使用，则对象必须被实例化，如果一个对象没有被实例化而直接调用了对象中的属性或方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">stu.Name = <span class="string">&quot;李子文&quot;</span>;</span><br><span class="line">stu.Sex = <span class="literal">true</span>;</span><br><span class="line">stu.Age = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>则程序运行时会出现以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></pre></td></tr></table></figure>
<p>此异常是使用了未实例化的对象则肯定会出现此异常。</p>
<h1 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h1><p>对象使用完之后需要对其进行清除。对象的清除是指释放对象占用的内存。在创建对象时，用户必须使用<code>new</code>操作符为对象分配内存。不过，在清除对象时，由系统自动进行内存回收，不需要用户额外处理。</p>
<p>Java 语言的内存自动回收称为垃圾回收机制，简称 GC。垃圾回收机制是指 JVM 用于释放那些不再使用的对象所占用的内存。</p>
<p>Java 语言并不要求 JVM 有 GC，也没有规定 GC 如何工作。不过常用的 JVM 都有 GC，而且大多数 GC 都使用类似的算法管理内存和执行回收操作。</p>
<p>如果回收内存的任务由程序负责，也就是说必须在程序中显式地进行内存回收，这无疑会增加程序员的负担，而且存在很多弊端。Java 语言对象是由垃圾回收器收集然后释放，程序员不用关系释放的细节。</p>
<p>一个对象被当作垃圾回收的情况主要如下两种。</p>
<ol>
<li>对象的引用超过其作用范围。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();    <span class="comment">// 对象o的作用范围，超过这个范围对象将被视为垃圾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对象被赋值为<code>null</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  o = <span class="literal">null</span>;    <span class="comment">// 对象被赋值为null将被视为垃圾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在 Java 的<code>Object</code>类中还提供了一个<code>protected</code>类型的<code>finalize()</code>方法，因此任何 Java 类都可以覆盖这个方法，在这个方法中进行释放对象所占有的相关资源的操作。</li>
</ol>
<p>在 Java 虚拟机的堆区，每个对象都可能处于以下三种状态之一。</p>
<ol>
<li>可触及状态：当一个对象被创建后，只要程序中还有引用变量引用它，那么它就始终处于可触及状态。</li>
<li>可复活状态：当程序不再有任何引用变量引用该对象时，该对象就进入可复活状态。在这个状态下，垃圾回收器会准备释放它所占用的内存，在释放之前，会调用它及其他处于可复活状态的对象的<code>finalize()</code>方法，这些<code>finalize()</code>方法有可能使该对象重新转到可触及状态。</li>
<li>不可触及状态：当 Java 虚拟机执行完所有可复活对象的<code>finalize()</code>方法后，如果这些方法都没有使该对象转到可触及状态，垃圾回收器才会真正回收它占用的内存。</li>
</ol>
<p>注意：调用<code>System.gc()</code>或者<code>Runtime.gc()</code>方法也不能保证回收操作一定执行，它只是提高了 Java 垃圾回收器尽快回收垃圾的可能性。</p>
<h1 id="main-方法"><a href="#main-方法" class="headerlink" title="main()方法"></a>main()方法</h1><p><code>main()</code>方法是 Java 应用程序的入口方法，程序在运行的时候，第一个执行的方法就是<code>main()</code>方法。<code>main()</code>方法和其他的方法有很大的不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>main()</code>方法时应该注意如下几点：</p>
<ul>
<li>访问控制权限是公有的（<code>public</code>）。</li>
<li><code>main()</code>方法是静态的。如果要在<code>main()</code>方法中调用本类中的其他方法，则该方法也必须是静态的，否则需要先创建本类的实例对象，然后再通过对象调用成员方法。</li>
<li><code>main()</code>方法没有返回值，只能使用<code>void</code>。</li>
<li><code>main()</code>方法具有一个字符串数组参数，用来接收执行 Java 程序的命令行参数。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。</li>
<li>字符串中数组的名字（代码中的<code>args</code>）可以任意设置，但是根据习惯，这个字符串数组的名字一般和 Java 规范范例中<code>main()</code>参数名保持一致，命名为<code>args</code>，而方法中的其他内容都是固定不变的。</li>
<li><code>main()</code>方法定义必须是<code>public static void main(String[] 字符串数组参数名)</code>。</li>
<li>一个类只能有一个<code>main()</code>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Speak1</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你好!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Speak2</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Java!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Speak1();    // 错误调用</span></span><br><span class="line">    Speak2();    <span class="comment">// 可以直接调用静态方法Speak2()</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    t.Speak1();    <span class="comment">// 调用非静态方法，需要通过类的对象来调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面代码可以看出，在<code>main()</code>方法中只能直接调用静态方法，如果想调用非静态方法，需要将当前类实例化，然后通过类的对象来调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> args.length;    <span class="comment">// 获取参数数量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;一共有 &quot;</span>+n+<span class="string">&quot; 个参数&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">      <span class="comment">// 判断参数个数是否大于0</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        System.out.println(args[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javac TestMain.java</span><br><span class="line">java TestMain</span><br><span class="line">一共有 0 个参数</span><br><span class="line"></span><br><span class="line">java TestMain apple banana</span><br><span class="line">一共有 2 个参数</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line"></span><br><span class="line">java TestMain one two three four five six</span><br><span class="line">一共有 6 个参数</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br><span class="line">six</span><br></pre></td></tr></table></figure>
<p>由此可见，<code>main()</code>方法可以以字符串的形式接收命令行参数，然后在方法体内进行处理。</p>
<h1 id="方法的可变参数"><a href="#方法的可变参数" class="headerlink" title="方法的可变参数"></a>方法的可变参数</h1><p>在具体实际开发过程中，有时方法中参数的个数是不确定的。为了解决这个问题，引入了可变参数的概念。声明可变参数的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodName(&#123;paramList&#125;,paramType…paramName)</span><br></pre></td></tr></table></figure>
<p>其中，<code>methodName</code>表示方法名称；<code>paramList</code>表示方法的固定参数列表；<code>paramType</code>表示可变参数的类型；<code>…</code>是声明可变参数的标识；<code>paramName</code>表示可变参数名称。</p>
<p>注意：可变参数必须定义在参数列表的最后。<br>例 1<br>每次参加考试的人数是不固定的，但是每次考试完之后都需要打印出本次考试的总人数以及参加考试的学生名单。下面编写程序，使用方法的可变参数实现该功能，具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTestMethod</span> &#123;</span><br><span class="line">    <span class="comment">// 定义输出考试学生的人数及姓名的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String ...names)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> names.length;    <span class="comment">// 获取总个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;本次参加考试的有&quot;</span>+count+<span class="string">&quot;人，名单如下：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; names.length;i++) &#123;</span><br><span class="line">            System.out.println(names[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="type">StudentTestMethod</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentTestMethod</span>();</span><br><span class="line">        student.print(<span class="string">&quot;张强&quot;</span>,<span class="string">&quot;李成&quot;</span>,<span class="string">&quot;王勇&quot;</span>);    <span class="comment">// 传入3个值</span></span><br><span class="line">        student.print(<span class="string">&quot;马丽&quot;</span>,<span class="string">&quot;陈玲&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法是类的一种特殊方法，用来初始化类的一个新的对象，在创建对象（<code>new</code>运算符）之后自动调用。Java 中的每个类都有一个默认的构造方法，并且可以有一个以上的构造方法。</p>
<p>Java 构造方法有以下特点：</p>
<ul>
<li>方法名必须与类名相同</li>
<li>可以有 0 个、1 个或多个参数</li>
<li>没有任何返回值，包括<code>void</code></li>
<li>默认返回类型就是对象类型本身</li>
<li>只能与<code>new</code>运算符结合使用</li>
</ul>
<p>值得注意的是，如果为构造方法定义了返回值类型或使用 void 声明构造方法没有返回值，编译时不会出错，但 Java 会把这个所谓的构造方法当成普通方法来处理。</p>
<p>构造方法不是没有返回值吗？为什么不能用 void 声明呢？</p>
<p>简单的说，这是 Java 的语法规定。实际上，类的构造方法是有返回值的，当使用 new 关键字来调用构造方法时，构造方法返回该类的实例，可以把这个类的实例当成构造器的返回值，因此构造器的返回值类型总是当前类，无须定义返回值类型。但必须注意不要在构造方法里使用<code>return</code>来返回当前类的对象，因为构造方法的返回值是隐式的。</p>
<p>注意：构造方法不能被<code>static、final、synchronized、abstract</code>和<code>native</code>（类似于<code>abstract</code>）修饰。构造方法用于初始化一个新对象，所以用<code>static</code>修饰没有意义。构造方法不能被子类继承，所以用<code>final</code>和<code>abstract</code>修饰没有意义。多个线程不会同时创建内存地址相同的同一个对象，所以用<code>synchronized</code>修饰没有必要。</p>
<p>构造方法的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">class_name</span><span class="params">()</span>&#123;&#125;    <span class="comment">// 默认无参构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ciass_name</span><span class="params">([paramList])</span>&#123;&#125;    <span class="comment">// 定义构造方法</span></span><br><span class="line">  …</span><br><span class="line">  <span class="comment">// 类主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个类中，与类名相同的方法就是构造方法。每个类可以具有多个构造方法，但要求它们各自包含不同的方法参数。</p>
<p>构造方法主要有无参构造方法和有参构造方法两种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> m;  <span class="comment">// 定义私有变量</span></span><br><span class="line">  MyClass() &#123;</span><br><span class="line">    <span class="comment">// 定义无参的构造方法</span></span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  MyClass(<span class="type">int</span> m) &#123;</span><br><span class="line">    <span class="comment">// 定义有参的构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.m = m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个类中定义多个具有不同参数的同名方法，这就是方法的重载。这两个构造方法的名称都与类名相同，均为<code>MyClass</code>。在实例化该类时可以调用不同的构造方法进行初始化。</p>
<p>注意：类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。</p>
<blockquote>
<p>提示：无参数的构造方法也被称为<code>Nullary</code>构造方法。只有编译程序自动加入的构造方法，才称为默认构造函数。如果自行编写无参数、没有内容的构造函数，就不称为默认构造函数了（只是<code>Nullary</code>构造函数）。虽然只是名词定义，不过认证考试时要区别一下两者的不同。</p>
</blockquote>
<p>要在不同的条件下使用不同的初始化行为创建类的对象，这时候就需要在一个类中创建多个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String name;    <span class="comment">// 姓名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;    <span class="comment">// 年龄</span></span><br><span class="line">  <span class="comment">// 定义带有一个参数的构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义带有两个参数的构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name,<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;大家好！我是新来的员工，我叫&quot;</span>+name+<span class="string">&quot;，今年&quot;</span>+age+<span class="string">&quot;岁。&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWorker</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------带有一个参数的构造方法-----------&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用带有一个参数的构造方法</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">worker1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">    System.out.println(worker1);</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------带有两个参数的构造方法------------&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用带有两个参数的构造方法</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">worker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;李丽&quot;</span>,<span class="number">25</span>);</span><br><span class="line">    System.out.println(worker2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 Java 对象都是在堆中构造的，构造器总是伴随着<code>new</code>操作符一起使用。</p>
<p>输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-----------带有一个参数的构造方法-----------</span><br><span class="line">大家好！我是新来的员工，我叫张强，今年0岁。</span><br><span class="line">-----------带有两个参数的构造方法------------</span><br><span class="line">大家好！我是新来的员工，我叫李丽，今年25岁。</span><br></pre></td></tr></table></figure>
<p>通过调用带参数的构造方法，在创建对象时，一并完成了对象成员的初始化工作，简化了对象初始化的代码。</p>
<h1 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h1><p>析构方法与构造方法相反，当对象脱离其作用域时（例如对象所在的方法已调用完毕），系统自动执行析构方法。析构方法往往用来做清理垃圾碎片的工作，例如在建立对象时用<code>new</code>开辟了一片内存空间，应退出前在析构方法中将其释放。</p>
<p>在 Java 的<code>Object</code>类中还提供了一个<code>protected</code>类型的<code>finalize()</code>方法，因此任何 Java 类都可以覆盖这个方法，在这个方法中进行释放对象所占有的相关资源的操作。</p>
<p>对象的<code>finalize()</code>方法具有如下特点：</p>
<ul>
<li>垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。</li>
<li><code>finalize()</code>方法有可能使用对象复活，使对象恢复到可触及状态。</li>
<li>垃圾回收器在执行<code>finalize()</code>方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 对象的清理工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面通过一个例子来讲解析构方法的使用。该例子计算从类中实例化对象的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 计数器变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="built_in">this</span>.count++;    <span class="comment">// 创建实例时增加值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取计数器的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 析构方法</span></span><br><span class="line">    <span class="built_in">this</span>.count--;    <span class="comment">// 实例销毁时减少值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象销毁&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCounter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Counter</span> <span class="variable">cnt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();    <span class="comment">// 建立第一个实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数量：&quot;</span>+ cnt1.getCount());    <span class="comment">// 输出1</span></span><br><span class="line">    <span class="type">Counter</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();    <span class="comment">// 建立第二个实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数量：&quot;</span>+ cnt2.getCount());    <span class="comment">// 输出2</span></span><br><span class="line">    cnt2 = <span class="literal">null</span>;    <span class="comment">// 销毁实例2</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.gc();    <span class="comment">// 清理内存</span></span><br><span class="line">      Thread.currentThread().sleep(<span class="number">1000</span>);    <span class="comment">// 延时1000毫秒</span></span><br><span class="line">      System.out.println(<span class="string">&quot;数量：&quot;</span>+cnt1.getCount());    <span class="comment">// 输出1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数量：1</span><br><span class="line">数量：2</span><br><span class="line">对象销毁</span><br><span class="line">数量：1</span><br></pre></td></tr></table></figure>
<p>技巧：由于<code>finalize()</code>方法的不确定性，所以在程序中可以调用<code>System.gc()</code>或者<code>Runtime.gc()</code>方法提示垃圾回收器尽快执行垃圾回收操作。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/数据链路层——使用广播信道"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/"
    >数据链路层——使用广播信道</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/" class="article-date">
  <time datetime="2020-09-13T03:06:56.000Z" itemprop="datePublished">2020-09-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>广播通信可以进行一对多的通信。局域网使用的就是广播通信。</p>
<h1 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h1><p>局域网最主要的特点是：网络为一个单位所拥有；地理范围和站点数目均有限。</p>
<h2 id="局域网优点"><a href="#局域网优点" class="headerlink" title="局域网优点"></a>局域网优点</h2><p>局域网具有如下主要优点：</p>
<ul>
<li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li>
<li>提高了系统的可靠性、可用性和残存性。</li>
</ul>
<h2 id="局域网分类"><a href="#局域网分类" class="headerlink" title="局域网分类"></a>局域网分类</h2><p>局域网可按网络拓扑进行分类。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img1.png" class="">

<h2 id="共享信道"><a href="#共享信道" class="headerlink" title="共享信道"></a>共享信道</h2><p>共享信道带来的问题：</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img2.png" class="">

<p>共享信道要着重考虑的一个问题就是如何使众多用户能够合理而方便的共享通信媒体资源。这在技术上有两种方法：</p>
<ul>
<li>静态划分信道：频分复用、时分复用、波分复用、码分复用 </li>
<li>动态媒体接入控制（多点接入）：随机接入、受控接入，如多点线路探询，或轮询。</li>
</ul>
<h2 id="以太网的两个标准"><a href="#以太网的两个标准" class="headerlink" title="以太网的两个标准"></a>以太网的两个标准</h2><p>DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。IEEE 802.3 是第一个 IEEE 的以太网标准。数据率为<code>10MBit/s</code>。</p>
<p>DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网 。 </p>
<p>为了使数据链路层能更好地适应多种局域网标准，将局域网的数据链路层拆成两个子层：</p>
<ul>
<li>逻辑链路控制 LLC(<code>Logical Link Control</code>)子层；</li>
<li>媒体接入控制 MAC(<code>Medium Access Control</code>)子层。</li>
</ul>
<p>与接入到传输媒体有关的内容都放在 MAC 子层，而 LLC 子层则与传输媒体无关。</p>
<p>不管采用何种媒体和 MAC 子层的局域网，对 LLC 子层来说都是透明的。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img3.png" class="">

<p>由于 TCP&#x2F;IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了。</p>
<p>很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。</p>
<h2 id="适配器的作用"><a href="#适配器的作用" class="headerlink" title="适配器的作用"></a>适配器的作用</h2><p>网络接口板又称为通信适配器(<code>adapter</code>)或网络接口卡 NIC(<code>Network Interface Card</code>)，或“网卡”。计算机与外界局域网的连接是通过通信适配器进行的。</p>
<p>适配器的重要功能：</p>
<ul>
<li>进行串行&#x2F;并行转换。适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信是通过计算机主板上的 I&#x2F;O 总线以并行传输方式进行的。</li>
<li>对数据进行缓存。网络上的数据率和计算机总线上的数据率并不相同。</li>
<li>在计算机的操作系统安装设备驱动程序。这个驱动程序以后会告诉适配器应当从存储器的什么位置上把多长的数据块发送到局域网上，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来。</li>
<li>实现以太网协议。</li>
</ul>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img4.png" class="" title="计算机通过适配器和局域网进行通信">

<p>适配器在接收和发送各种帧时，不适用计算机的 CPU。</p>
<p>当适配器收到有差错的帧时，就把这个帧直接丢弃而不通知计算机。当适配器收到正确的帧时，他就使用过中断来通知计算机，并交付协议栈中的网络层。当计算机要发送 IP 数据报时，	就由协议栈把 IP 数据报向下交给适配器，组装成帧后发送到局域网。</p>
<p>通信适配器上面装有处理器和存储器（包括 ROM 和 RAM）。计算机的硬件地址就在适配器的 ROM 中，计算机的 IP 地址在计算机的存储器中。</p>
<h1 id="CSMA-x2F-CD-协议"><a href="#CSMA-x2F-CD-协议" class="headerlink" title="CSMA&#x2F;CD 协议"></a>CSMA&#x2F;CD 协议</h1><p>最初的以太网是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p>
<p>当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据。这种就是广播通信方式。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img5.png" class="">

<p>但我们并不总是要在局域网上进行一对多的广播通信。为了在总线上实现一对一通信，将接收站的硬件地址写入帧首部中的目的地址字段中。仅当数据帧中的目的地址与适配器的硬件地址一致时，才能接收这个数据帧。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img6.png" class="">

<p>总线也有缺点。若多台计算机或多个站点同时发送时，会产生发送碰撞或冲突，导致发送失败。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img7.png" class="">

<h2 id="以太网采取的两种重要的措施"><a href="#以太网采取的两种重要的措施" class="headerlink" title="以太网采取的两种重要的措施"></a>以太网采取的两种重要的措施</h2><p>为了通信的简便，以太网采取了两种重要的措施：</p>
<ol>
<li>采用较为灵活的无连接的工作方式</li>
</ol>
<p>不必先建立连接就可以直接发送数据。</p>
<p>适配器对发送的数据帧不进行编号，也不要求对方发回确认。</p>
<p>这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。</p>
<p>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</p>
<p>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</p>
<p>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img8.png" class="">

<ol start="2">
<li>以太网发送的数据都使用曼彻斯特编码</li>
</ol>
<p>曼彻斯特编码缺点是：它所占的频带宽度比原始的基带信号增加了一倍。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img9.png" class="">

<h2 id="CSMA-x2F-CD协议要点"><a href="#CSMA-x2F-CD协议要点" class="headerlink" title="CSMA&#x2F;CD协议要点"></a>CSMA&#x2F;CD协议要点</h2><p>总线上只要有一台计算机在发送数据，总线的传输资源就会被占用。因此，在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，使得所发送数据被破坏。因此，如何协调总线上各计算机的工作就是以太网要解决的重要问题。</p>
<p>以太网采用最简单的随机接入，但有很好的协议来减少冲突发生的概率。它使用的协议是载波监听多点接入&#x2F;碰撞检测(CSMA&#x2F;CD，Carrier Sense Multiple Access with Collision Detection)。</p>
<p>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。</p>
<p>“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p>
<p>总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</p>
<p>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</p>
<p>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</p>
<p>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</p>
<p>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</p>
<p>CSMA&#x2F;CD 协议工作流程</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img10.png" class="">

<p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img11.png" class="">

<p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突。</p>
<p>最先发送数据帧的站，在发送数据帧后至多经过时间 2τ（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。</p>
<p>以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。</p>
<p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<h2 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h2><p>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。<br>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。<br>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。 </p>
<h2 id="CSMA-x2F-CD-协议的要点"><a href="#CSMA-x2F-CD-协议的要点" class="headerlink" title="CSMA&#x2F;CD 协议的要点"></a>CSMA&#x2F;CD 协议的要点</h2><img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img13.png" class="">

<h1 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h1><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img14.png" class="">

<p>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(<code>hub</code>)。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img15.png" class="">

<p>1990 年，IEEE 制定出星形以太网 10BASE-T 的标准 802.3i。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img16.png" class="">

<p>星形以太网 10BASE-T 使用无屏蔽双绞线，采用星形拓扑。每个站需要用两对双绞线，分别用于发送和接收。双绞线的两端使用 RJ-45 插头。集线器使用了大规模集成电路芯片，因此集线器的可靠性提高。10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100m。</p>
<p>这种<code>10 Mbit/s</code>速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。 具有很高的性价比。</p>
<p>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</p>
<p>从此以太网的拓扑就从总线形变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。 </p>
<h2 id="集线器的一些特点"><a href="#集线器的一些特点" class="headerlink" title="集线器的一些特点"></a>集线器的一些特点</h2><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。</p>
<p>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA&#x2F;CD 协议，并共享逻辑上的总线。</p>
<p>集线器很像一个多接口的转发器，工作在物理层。</p>
<p>集线器采用了专门的芯片，进行自适应串音回波抵消，减少了近端串音。</p>
<p>具有三个接口的集线器</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img17.png" class="" title="具有三个接口的集线器">

<h1 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h1><h2 id="MAC-层的硬件地址"><a href="#MAC-层的硬件地址" class="headerlink" title="MAC 层的硬件地址"></a>MAC 层的硬件地址</h2><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</p>
<p>如果连接在局域网上的主机或路由器安装有多个适配器，那么这样的主机或路由器就有多个“地址”。更准确些说，这种 48 位“地址”应当是某个接口的标识符。</p>
<p>IEEE 的注册管理机构 RA 负责向厂家分配地址字段 6 个字节中的前三个字节 (即高位 24 位)，称为组织唯一标识符。</p>
<p>地址字段 6 个字节中的后三个字节 (即低位 24 位) 由厂家自行指派，称为扩展唯一标识符，必须保证生产出的适配器没有重复地址。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img21.png" class="">

<p>一个地址块可以生成 2<sup>24</sup> 个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是 EUI-48。</p>
<p>生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM，因此，MAC 地址也叫做硬件地址或物理地址。</p>
<p>“MAC 地址”实际上就是适配器地址或适配器标识符 EUI-48。</p>
<h3 id="单站地址，组地址，广播地址"><a href="#单站地址，组地址，广播地址" class="headerlink" title="单站地址，组地址，广播地址"></a>单站地址，组地址，广播地址</h3><p>IEEE 规定地址字段的第一字节的最低位为<code>I/G</code>位。<code>I/G</code>表示<code>Individual / Group</code>。</p>
<ul>
<li>当<code>I/G</code>位<code>= 0</code>时，地址字段表示一个单站地址。</li>
<li>当<code>I/G</code>位<code>= 1</code>时，表示组地址，用来进行多播（以前曾译为组播）。此时，IEEE 只分配地址字段前三个字节中的 23 位。</li>
<li>当<code>I/G</code>位分别为 0 和 1 时，一个地址块可分别生成 223 个单个站地址和 223 个组地址。</li>
<li>所有 48 位都为 1 时，为广播地址。只能作为目的地址使用。</li>
</ul>
<p>IEEE 把地址字段第一字节的最低第 2 位规定为<code>G/L</code>位，表示<code>Global / Local</code>。</p>
<ul>
<li>当<code>G/L</code>位<code>= 0</code>时，是全球管理（保证在全球没有相同的地址），厂商向 IEEE 购买的 OUI 都属于全球管理。</li>
<li>当<code>G/L</code>位<code>= 1</code>时，是本地管理，这时用户可任意分配网络上的地址。</li>
</ul>
<p>当路由器通过适配器连接到局域网时，适配器上的硬件地址就用来标志路由器的某个接口。路由器如果同时连接到两个网络上，那么它就需要两个适配器和两个硬件地址。</p>
<p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。</p>
<p>“发往本站的帧”包括以下三种帧： </p>
<ul>
<li>单播(<code>unicast</code>)帧（一对一），即收到的帧的 MAC 地址与本站的硬件地址相同。</li>
<li>广播(<code>broadcast</code>)帧（一对全体），即发送给局域网上所有站点的帧（全1的地址）。</li>
<li>多播(<code>multicast</code>)帧（一对多），即发送给本局域网上一部分站点的帧。</li>
</ul>
<p>所有的适配器都至少能够识别前两种帧，即能够识别单播地址和广播地址。有的适配器可用编程方法识别多播地址。只有目的地址才能使用广播地址和多播地址。</p>
<p>以混杂方式(<code>promiscuous mode</code>)工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。</p>
<p>混杂方式有时非常有用。例如网络维护和管理人员需要用这种方式来监听分析以太网上的流量。有一种网络工具叫嗅探器，就使用了设置为混杂方式的网络适配器。</p>
<h2 id="MAC-帧的格式"><a href="#MAC-帧的格式" class="headerlink" title="MAC 帧的格式"></a>MAC 帧的格式</h2><p>以太网 MAC 帧格式有两种标准：DIX Ethernet V2 标准、IEEE 的 802.3 标准。最常用的 MAC 帧是以太网 V2 的格式。</p>
<img src="/2020/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E4%BF%A1%E9%81%93/img22.png" class="">

<p>类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。</p>
<p>数据字段长度在46~1500字节。最小长度 64 字节 - 18 字节的首部和尾部 &#x3D; 数据字段的最小长度（46字节）。</p>
<p>当传输媒体的误码率为 1x10<sup>-8</sup> 时，MAC 子层可使未检测到的差错小于 1x10<sup>-14</sup>。</p>
<p>当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。 </p>
<p>为了达到比特同步，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节。</p>
<p>在帧的前面插入（硬件生成）的 8 字节中，第一个字段共 7 个字节，是前同步码，用来迅速实现 MAC 帧的比特同步。第二个字段 1 个字节是帧开始定界符，表示后面的信息就是 MAC 帧。</p>
<h3 id="无效的-MAC-帧"><a href="#无效的-MAC-帧" class="headerlink" title="无效的 MAC 帧:"></a>无效的 MAC 帧:</h3><ul>
<li>数据字段的长度与长度字段的值不一致；</li>
<li>帧的长度不是整数个字节；</li>
<li>用收到的帧检验序列 FCS 查出有差错；</li>
<li>数据字段的长度不在 46 ~ 1500 字节之间。有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li>
</ul>
<p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p>
<h3 id="IEEE-802-3-MAC-帧格式"><a href="#IEEE-802-3-MAC-帧格式" class="headerlink" title="IEEE 802.3 MAC 帧格式"></a>IEEE 802.3 MAC 帧格式</h3><p>与以太网 V2 MAC 帧格式相似，区别在于：</p>
<ul>
<li>IEEE 802.3 规定的 MAC 帧的第三个字段是“长度 &#x2F; 类型”。</li>
<li>当这个字段值大于 0x0600 时（相当于十进制的 1536），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。</li>
<li>当这个字段值小于 0x0600 时才表示“长度”。</li>
<li>当“长度&#x2F;类型”字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。</li>
</ul>
<p>帧间最小间隔为<code>9.6μs</code>，相当于<code>96 bit</code>的发送时间。一个站在检测到总线开始空闲后，还要等待<code>9.6μs</code>才能再次发送数据。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java数组"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/11/java/%E5%9F%BA%E7%A1%80/Java%E6%95%B0%E7%BB%84/"
    >Java 数组</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/11/java/%E5%9F%BA%E7%A1%80/Java%E6%95%B0%E7%BB%84/" class="article-date">
  <time datetime="2020-09-11T03:13:52.000Z" itemprop="datePublished">2020-09-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><p>当数组中每个元素都只带有一个下标时，这种数组就是“一维数组”。一维数组实质上是一组相同类型数据的线性集合，是数组中最简单的一种数组。</p>
<p>数组是引用数据类型，引用数据类型在使用之前一定要做两件事情：声明和初始化。</p>
<h2 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h2><p>为了在程序中使用一个数组，必须声明一个引用该数组的变量，并指明整个变量可以引用的数组类型。声明一维数组的语法格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName;    <span class="comment">// 数据类型[] 数组名;</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">type arrayName[];    <span class="comment">// 数据类型 数组名[];</span></span><br></pre></td></tr></table></figure>
<p>Java 更推荐采用第一种声明格式，因为第一种格式不仅具有更好的语意，而且具有更好的可读性。</p>
<p>以上两种格式都可以声明一个数组，其中的数据类型既可以是基本数据类型，也可以是引用数据类型。数组名可以是任意合法的变量名。声明数组就是要告诉计算机该数组中数据的类型是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] score;    <span class="comment">// 存储学生的成绩，类型为整型</span></span><br><span class="line"><span class="type">double</span>[] price;    <span class="comment">// 存储商品的价格，类型为浮点型</span></span><br><span class="line">String[] name;    <span class="comment">// 存储商品名称，类型为字符串型</span></span><br></pre></td></tr></table></figure>
<p>在声明数组时不需要规定数组的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int score[10];    // 这是错误的</span><br></pre></td></tr></table></figure>
<h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>声明了数组，只是得到了一个存放数组的变量，并没有为数组元素分配内存空间，不能使用。因此要为数组分配内存空间，这样数组的每一个元素才有一个空间进行存储。</p>
<p>简单地说，分配空间就是要告诉计算机在内存中为它分配几个连续的位置来存储数据。可以使用<code>new</code>关键字来给数组分配空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName = <span class="keyword">new</span> <span class="title class_">type</span>[size];    <span class="comment">// 数组名 = new 数据类型[数组长度];</span></span><br></pre></td></tr></table></figure>
<p>其中，数组长度就是数组中能存放的元素个数，显然应该为大于 0 的整数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">price = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">30</span>];</span><br><span class="line">name = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>
<p>这里的<code>score</code>是已经声明过的<code>int[]</code>类型的变量，当然也可以在声明数组时就给它分配空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> <span class="title class_">type</span>[size];    <span class="comment">// 数据类型[] 数组名 = new 数据类型[数组长度];</span></span><br></pre></td></tr></table></figure>
<p>例如，声明并分配一个长度为 5 的<code>int</code>类型数组<code>arr</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>执行后<code>arr</code>数组在内存中的格式如图所示。</p>
<img src="/2020/09/11/java/%E5%9F%BA%E7%A1%80/Java%E6%95%B0%E7%BB%84/1.jpg" class="" title="一维数组的内存格式">

<blockquote>
<p>注意：一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。</p>
</blockquote>
<p>尽管数组可以存储一组基本数据类型的元素，但是数组整体属于引用数据类型。当声明一个数组变量时，其实是创建了一个类型为“数据类型<code>[]</code>”（如<code>int[]、double[]、String[]</code>）的数组对象，它具有的方法和属性：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">clone()</td>
<td align="center">Object</td>
</tr>
<tr>
<td align="center">equals(Object obj)</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">getClass()</td>
<td align="center">Class&lt;?&gt;</td>
</tr>
<tr>
<td align="center">hashCode()</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">notify()</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">notify All()</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">toString()</td>
<td align="center">String</td>
</tr>
<tr>
<td align="center">wait()</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">wait(long timeout)</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">wait(long timeout,int nanos)</td>
<td align="center">void</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">int</td>
</tr>
</tbody></table>
<h2 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h2><p>Java 语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。</p>
<p>能不能只分配内存空间，不赋初始值呢？</p>
<p>不行，一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容为空，这个空也是一个值（<code>null</code>）。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种形式，一种由系统自动分配，另一种由程序员指定。</p>
<p>数组在初始化数组的同时，可以指定数组的大小，也可以分别初始化数组中的每一个元素。初始化数组有以下 3 种方式。</p>
<h3 id="1-使用-new-指定数组大小后进行初始化"><a href="#1-使用-new-指定数组大小后进行初始化" class="headerlink" title="1.使用 new 指定数组大小后进行初始化"></a>1.使用 new 指定数组大小后进行初始化</h3><p>使用<code>new</code>关键字创建数组，在创建时指定数组的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br></pre></td></tr></table></figure>
<p>创建数组之后，元素的值并不确定，需要为每一个数组的元素进行赋值，其下标从 0 开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] number = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">number[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">number[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">number[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">number[<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">number[<span class="number">4</span>] = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>如果只指定了数组的长度，那么系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值。</p>
<ul>
<li>数组元素的类型是基本类型中的整数类型（<code>byte、short、int</code>和<code>long</code>），则数组元素的值是 0。</li>
<li>数组元素的类型是基本类型中的浮点类型（<code>float、double</code>），则数组元素的值是 0.0。</li>
<li>数组元素的类型是基本类型中的字符类型（<code>char</code>），则数组元素的值是<code>\u0000</code>。</li>
<li>数组元素的类型是基本类型中的布尔类型（<code>boolean</code>），则数组元素的值是<code>false</code>。</li>
<li>数组元素的类型是引用类型（类、接口和数组），则数组元素的值是<code>null</code>。</li>
</ul>
<h3 id="2-使用-new-指定数组元素的值"><a href="#2-使用-new-指定数组元素的值" class="headerlink" title="2.使用 new 指定数组元素的值"></a>2.使用 new 指定数组元素的值</h3><p>使用上述方式初始化数组时，只有在为元素赋值时才确定值。可以不使用上述方式，而是在初始化时就已经确定值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = <span class="keyword">new</span> <span class="title class_">type</span>[]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,值 <span class="number">4</span>,• • •,值 n&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] number = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值，这样会造成代码错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] number = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">5</span>] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,​<span class="number">5</span>&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<h3 id="3-直接指定数组元素的值"><a href="#3-直接指定数组元素的值" class="headerlink" title="3.直接指定数组元素的值"></a>3.直接指定数组元素的值</h3><p>在上述两种方式的语法中，<code>type</code>可以省略，如果已经声明数组变量，那么直接使用这两种方式进行初始化。如果不想使用上述两种方式，那么可以不使用<code>new</code>直接指定数组元素的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] arrayName = &#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,...,值 n&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>使用这种方式时，数组的声明和初始化操作要同步，即不能省略数组变量的类型。如下的代码就是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] number;</span><br><span class="line">number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="获取单个元素"><a href="#获取单个元素" class="headerlink" title="获取单个元素"></a>获取单个元素</h2><p>获取单个元素是指获取数组中的一个元素。获取单个元素的方法非常简单，指定元素所在数组的下标即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[index];</span><br></pre></td></tr></table></figure>
<p>其中，<code>arrayName</code>表示数组变量，<code>index</code>表示下标，下标为 0 表示获取第一个元素，下标为<code>array.length-1</code>表示获取最后一个元素。当指定的下标值超出数组的总长度时，会拋出<code>ArraylndexOutOfBoundsException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;获取第一个元素：&quot;</span>+number[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取最后一个元素：&quot;</span>+number[number.length-<span class="number">1</span>]);</span><br><span class="line">System.out.println(<span class="string">&quot;获取第6个元素：&quot;</span>+number[<span class="number">5</span>]);</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//获取第一个元素：1</span></span><br><span class="line"><span class="comment">//获取最后一个元素：8</span></span><br><span class="line"><span class="comment">//java.lang.ArrayIndexOutOfBoundsException: 5</span></span><br></pre></td></tr></table></figure>
<h2 id="获取全部元素"><a href="#获取全部元素" class="headerlink" title="获取全部元素"></a>获取全部元素</h2><p>利用<code>for</code>循环语句遍历<code>number</code>数组中的全部元素，并将元素的值输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] number = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;number.length;i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个元素的值是：&quot;</span>+number[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用<code>for</code>语句，还可以使用<code>foreach</code>遍历数组中的元素，并将元素的值输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> val:number) &#123;</span><br><span class="line">  System.out.print(<span class="string">&quot;元素的值依次是：&quot;</span>+val+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h2><p>在 Java 中二维数组被看作数组的数组，即二维数组为一个特殊的一维数组，其每个元素又是一个一维数组。Java 并不直接支持二维数组，但是允许定义数组元素是一维数组的一维数组，以达到同样的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[][];    <span class="comment">// 数据类型 数组名[][];</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">type[][] arrayName;    <span class="comment">// 数据类型[][] 数组名;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>type</code>表示二维数组的类型，<code>arrayName</code>表示数组名称，第一个中括号表示行，第二个中括号表示列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] age;</span><br><span class="line"><span class="type">char</span>[][] sex;</span><br></pre></td></tr></table></figure>
<h2 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h2><p>二维数组可以初始化，和一维数组一样，可以通过 3 种方式来指定元素的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type[][] arrayName = <span class="keyword">new</span> <span class="title class_">type</span>[][]&#123;值 <span class="number">1</span>,值 <span class="number">2</span>,值 <span class="number">3</span>,…,值 n&#125;;    <span class="comment">// 在定义时初始化</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> <span class="title class_">type</span>[size1][size2];    <span class="comment">// 给定空间，在赋值</span></span><br><span class="line">type[][] arrayName = <span class="keyword">new</span> <span class="title class_">type</span>[size][];    <span class="comment">// 数组第二维长度为空，可变化</span></span><br></pre></td></tr></table></figure>
<p>使用第一种方式声明<code>int</code>类型的二维数组，然后初始化该二维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] temp = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个二行二列的二维数组<code>temp</code>，并对数组中的元素进行了初始化。</p>
<img src="/2020/09/11/java/%E5%9F%BA%E7%A1%80/Java%E6%95%B0%E7%BB%84/2.jpg" class="" title="二维数组内存结构">

<p>使用第二种方式声明<code>int</code>类型的二维数组，然后初始化该二维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>使用第三种方式声明<code>int</code>类型的二维数组，并且初始化数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][];</span><br></pre></td></tr></table></figure>
<h2 id="获取单个元素-1"><a href="#获取单个元素-1" class="headerlink" title="获取单个元素"></a>获取单个元素</h2><p>当需要获取二维数组中元素的值时，也可以使用下标来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName[i-1][j-1];</span><br></pre></td></tr></table></figure>
<p>其中，<code>arrayName</code>表示数组名称，<code>i</code>表示数组的行数，<code>j</code>表示数组的列数。例如，要获取第二行第二列元素的值，应该使用<code>temp[1][1]</code>来表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">double</span>[][] class_score = &#123;&#123;<span class="number">10.0</span>,<span class="number">99</span>,<span class="number">99</span>&#125;,&#123;<span class="number">100</span>,<span class="number">98</span>,<span class="number">97</span>&#125;,&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">99.5</span>&#125;,&#123;<span class="number">99.5</span>,<span class="number">99</span>,<span class="number">98.5</span>&#125;&#125;;</span><br><span class="line">  System.out.println(<span class="string">&quot;第二行第二列元素的值：&quot;</span>+class_score[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  System.out.println(<span class="string">&quot;第四行第一列元素的值：&quot;</span>+class_score[<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果如下：</span></span><br><span class="line">第二行第二列元素的值：<span class="number">98.0</span></span><br><span class="line">第四行第一列元素的值：<span class="number">99.5</span></span><br></pre></td></tr></table></figure>
<h2 id="获取全部元素-1"><a href="#获取全部元素-1" class="headerlink" title="获取全部元素"></a>获取全部元素</h2><p>在一维数组中直接使用数组的<code>length</code>属性获取数组元素的个数。而在二维数组中，直接使用<code>length</code>属性获取的是数组的行数，在指定的索引后加上<code>length</code>（如<code>array[0].length</code>）表示的是该行拥有多少个元素，即列数。</p>
<p>如果要获取二维数组中的全部元素，最简单、最常用的办法就是使用<code>for</code>语句。在一维数组全部输出时，我们使用一层<code>for</code>循环，而二维数组要想全部输出，则使用嵌套<code>for</code>循环（2 层<code>for</code>循环）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; class_score.length; i++) &#123; <span class="comment">// 遍历行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; class_score[i].length; j++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;class_score[&quot;</span> + i + <span class="string">&quot;][&quot;</span> + j + <span class="string">&quot;]=&quot;</span> + class_score[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码使用嵌套<code>for</code>循环语句输出二维数组。在输出二维数组时，第一个<code>for</code>循环语句表示以行进行循环，第二个<code>for</code>循环语句表示以列进行循环，这样就实现了获取二维数组中每个元素的值的功能。</p>
<p><code>for each</code>循环语句不能自动处理二维数组的每一个元素。它是按照行，也就是一维数组处理的。要想访问二维教组<code>a</code>的所有元素， 需要使用两个嵌套的循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">double</span>[] row : a) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> value : row) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span>[][] class_score = &#123; &#123; <span class="number">100</span>, <span class="number">99</span>, <span class="number">99</span> &#125;, &#123; <span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span> &#125;, &#123; <span class="number">100</span>, <span class="number">100</span>, <span class="number">99.5</span> &#125;, &#123; <span class="number">99.5</span>, <span class="number">99</span>, <span class="number">98.5</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span>[] row : class_score) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> value : row) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示：要想快速地打印一个二维数组的数据元素列表，可以调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.deepToString(arrayName));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.deepToString(class_score));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出格式为：</span></span><br><span class="line"><span class="comment">// [[100.0, 99.0, 99.0], [100.0, 98.0, 97.0], [100.0, 100.0, 99.5], [99.5, 99.0, 98.5]]</span></span><br></pre></td></tr></table></figure>
<h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>除了一维数组和二维数组外，Java 中还支持更多维的数组，如三维数组、四维数组和五维数组等，它们都属于多维数组。想要提高数组的维数，只要在声明数组时将索引与中括号再加一组即可，所以三维数组的声明为<code>int score[][][]</code>，而四维数组为<code>int score[][][][]</code>，以此类推。</p>
<p>三维数组有三个层次，可以将三维数组理解为一个一维数组，其内容的每个元素都是二维数组。依此类推，可以获取任意维数的数组。</p>
<h1 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h1><p>规则的 4×3 二维数组有 12 个元素，而不规则数组就不一定了。如下代码静态初始化了一个不规则数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">11</span>&#125;, &#123;<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>&#125;, &#123;<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>动态初始化不规则数组比较麻烦，不能使用<code>new int[4][3]</code>语句，而是先初始化高维数组，然后再分别逐个初始化低维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> intArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][]; <span class="comment">//先初始化高维数组为4</span></span><br><span class="line"><span class="comment">// 逐一初始化低维数组</span></span><br><span class="line">intArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">intArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">intArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">intArray[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>提示：下标越界异常（<code>ArrayIndexOutOfBoundsException</code>）是试图访问不存在的下标时引发的。例如一个一维<code>array</code>数组如果有 10 个元素，那么表达式<code>array[10]</code>就会发生下标越界异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> intArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][]; <span class="comment">// 先初始化高维数组为4</span></span><br><span class="line">        <span class="comment">// 逐一初始化低维数组</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        intArray[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        intArray[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        intArray[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// for循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; intArray[i].length; j++) &#123;</span><br><span class="line">                intArray[i][j] = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for-each循环遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : intArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> column : row) &#123;</span><br><span class="line">                System.out.print(column);</span><br><span class="line">                <span class="comment">// 在元素之间添加制表符，</span></span><br><span class="line">                System.out.print(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一行元素打印完成后换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intArray[<span class="number">0</span>][<span class="number">2</span>]); <span class="comment">// 发生运行期错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/数据链路层——点对点协议PPP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/"
    >数据链路层——点对点协议PPP</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/" class="article-date">
  <time datetime="2020-09-10T09:21:34.000Z" itemprop="datePublished">2020-09-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>数据链路层使用的信道主要有两种：点对点信道和广播信道。</p>
<p>对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 PPP(<code>Point-to-Point Protocol</code>)。</p>
<h1 id="PPP-协议的特点"><a href="#PPP-协议的特点" class="headerlink" title="PPP 协议的特点"></a>PPP 协议的特点</h1><p>互联网用户通常都要连接到某个 ISP 才能接入到互联网。PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<img src="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/img1.png" class="">

<h2 id="PPP-协议应满足的需求"><a href="#PPP-协议应满足的需求" class="headerlink" title="PPP 协议应满足的需求"></a>PPP 协议应满足的需求</h2><ul>
<li>简单 —— 这是首要的要求。</li>
<li>封装成帧 —— 必须规定特殊的字符作为帧定界符。</li>
<li>透明性 —— 必须保证数据传输的透明性。</li>
<li>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。</li>
<li>多种类型链路 —— 能够在多种类型的链路上运行。</li>
<li>差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li>
<li>检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态。</li>
<li>最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元  MTU 的标准默认值，促进各种实现之间的互操作性。</li>
<li>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li>
<li>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法。</li>
</ul>
<p>PPP 协议不需要的功能：纠错、流量控制、序号、多点线路、半双工或单工链路。</p>
<h2 id="PPP-协议的组成"><a href="#PPP-协议的组成" class="headerlink" title="PPP 协议的组成"></a>PPP 协议的组成</h2><p>PPP 协议有三个组成部分：</p>
<ul>
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li>链路控制协议 LCP(<code>Link Control Protocol</code>)。用来建立、配置和测试数据链路连接。</li>
<li>一套网络控制协议 NCP(<code>Network Control Protocol</code>)。</li>
</ul>
<h1 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h1><h2 id="各字段的意义"><a href="#各字段的意义" class="headerlink" title="各字段的意义"></a>各字段的意义</h2><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。</p>
<p>标志字段<code>F = 0x7E</code>。标志字段表示一个帧的开始或结束。标志字段就是 PPP 帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧。</p>
<p>地址字段 A 只置为<code>0xFF</code>。地址字段实际上并不起作用。</p>
<p>控制字段 C 通常置为<code>0x03</code>。</p>
<p>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</p>
<img src="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/img2.png" class="">

<p>透明传输问题：</p>
<ul>
<li>当 PPP 用在异步传输时，就使用一种特殊的字符填充法。</li>
<li>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充。</li>
</ul>
<h2 id="字符填充"><a href="#字符填充" class="headerlink" title="字符填充"></a>字符填充</h2><p>当信息字段中出现和标志字段一样的比特（<code>0x7E</code>）组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。</p>
<p>当 PPP 使用异步传输时，它把转义符定义为<code>0x7D</code>，并使用字节填充，填充方法：</p>
<ul>
<li>将信息字段中出现的每一个<code>0x7E</code>字节转变成为 2 字节序列 (<code>0x7D, 0x5E</code>)。 </li>
<li>若信息字段中出现一个<code>0x7D</code>的字节, 则将其转变成为 2 字节序列(<code>0x7D, 0x5D</code>)。</li>
<li>若信息字段中出现 ASCII 码的控制字符（即数值小于<code>0x20</code>的字符），则在该字符前面要加入一个<code>0x7D</code>字节，同时将该字符的编码加以改变。例如出现<code>0x03</code>，就要把它转变为(<code>0x7D, 0x23</code>)。</li>
</ul>
<img src="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/img3.png" class="">

<h2 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h2><p>PPP 协议用在 SONET&#x2F;SDH 链路时，使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。</p>
<p>零比特填充具体做法：</p>
<ul>
<li>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。保证在信息字段中不会出现6个连续1。</li>
<li>接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。</li>
</ul>
<img src="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/img4.png" class="">

<p>PPP 协议之所以不使用序号和确认机制是出于以下的考虑：</p>
<ul>
<li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li>
<li>在因特网环境下，PPP 的信息字段放入的数据是 IP  数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列 FCS 字段可保证无差错接受。</li>
</ul>
<h1 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h1><ul>
<li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li>
<li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧），以便建立 TCP 连接。</li>
<li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li>
<li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li>
</ul>
<p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p>
<img src="/2020/09/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEPPP/img5.png" class="">

<p>PPP 链路的起始状态和终止状态永远是链路静止状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。</p>
<p>当用户个人电脑通过调制解调器呼叫路由器时，路由器就能检测到调制解调器发出的载波信号。在双方建立的物理层连接后，PPP 就进入链路建立状态，其目的是建立链路层 LCP 连接。</p>
<p>这时 LCP 开始协商一些配置项，即发送 LCP 的配置请求帧。这是个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下响应中的一种：配置确认帧、配置否认帧、配置拒绝帧。</p>
<p>协商结束后双方就建立了 LCP 链路，接着就进入鉴别状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。</p>
<p>若使用口令鉴别协议 PAP(<code>Password Authentication Protocol</code>)，则需要发起通信的一方发送身份标识符和口令。如果需要更高的安全性，可以使用口令握手鉴别协议 CHAP(<code>Challenge-Handshake Authentication Protocol</code>)。鉴别成功，进入网络层协议状态。鉴别失败，转到链路终止状态。</p>
<p>在网络层协议状态，PPP 链路的两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤很重要，因为路由器能同时支持多种网络层协议。总之，PPP 协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信。</p>
<p>当网络层配置完毕后，链路就进入可进行数据通信的链路打开状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可以发送回送请求 LCP 分组和回送回答 LCP 分组，以检查链路的状态。</p>
<p>数据传输结束后，可以由链路的一端发出终止请求 LCP 分组请求终止链路连接，在收到对方发来的终止确认 LCP 分组后，转到链路终止状态。如果链路出现故障，也会从链路打开状态转到链路终止状态。当调制解调器的载波停止后，则回到链路静止状态。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/数据链路层——使用点对点信道"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/"
    >数据链路层——点对点信道</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/" class="article-date">
  <time datetime="2020-09-09T09:51:12.000Z" itemprop="datePublished">2020-09-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>数据链路层使用的信道主要有以下两种类型∶</p>
<ul>
<li>点对点信道。这种信道使用一对一的点对点通信方式。</li>
<li>广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li>
</ul>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img5.png" class="">

<p>两台主机通过互联网进行通信时数据链路层所处的地位。</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img1.png" class="">
<br>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img2.png" class="">
<br>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img3.png" class="">
<br>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img4.png" class="">

<h1 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h1><h2 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h2><p>链路是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要经过许多段这样的链路。可见一条链路只是一条通路的一个组成部分。</p>
<p>数据链路除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<p>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p>
<p>也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。物理链路就是上面所说的链路。逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。</p>
<p>点对点信道的数据链路层的协议数据单元叫帧。数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。</p>
<p>在这种三层模型中，不管在哪一段链路上的通信(主机和路由器之间或两个路由器之间)，我们都看成是结点和结点的通信，而每个结点只有下三层——网络层、数据链路层和物理层。</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img6.png" class="">

<p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p>
<ol>
<li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li>
<li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li>
<li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li>
</ol>
<p>数据链路层不必考虑物理层如何实现比特传输的细节。甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方。</p>
<h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><p>数据链路层协议有许多种，但有三个基本问题则是共同的。这三个基本问题是：封装成帧、透明传输、差错控制。</p>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</p>
<p>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p>
<p>网络层的 IP 数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。</p>
<p>一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。首部和尾部的一个重要作用就是进行帧定界。此外，首部和尾部还包括许多必要的控制信息。</p>
<p>在发送帧时，是从帧首部开始发送的。</p>
<p>每一种链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元 MTU(<code>Maximum Transfer Unit</code>)。</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img7.png" class="">

<h3 id="用控制字符进行帧定界的方法举例"><a href="#用控制字符进行帧定界的方法举例" class="headerlink" title="用控制字符进行帧定界的方法举例"></a>用控制字符进行帧定界的方法举例</h3><p>当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的帧定界符。</p>
<p>ASCII 码是 7 位编码，一共可组合成 128 个不同的 ASCII 码，其中可打印的有 95 个，而不可打印的控制字符有 33 个。</p>
<p>控制字符 SOH(<code>Start Of Header</code>) 放在一帧的最前面，表示帧的首部开始。另一个控制字符 EOT(<code>End Of Transmission</code>) 表示帧的结束。</p>
<p>SOH 和 EOT 都是控制字符的名称。它们的十六进制编码分别是01(二进制是00000001)和04(二进制是00000100)。</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img8.png" class="">

<p>当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发送完一个帧时突然出故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。由于使用了帧定界符，接收端就知道前面收到的数据是个不完整的帧（只有首部开始符 SOH 而没有传输结束符 EOT），必须丢弃。而后面收到的数据有明确的帧定界符（SOH 和 EOT），因此这是一个完整的帧，应当收下。</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img9.png" class="">

<p>“在数据链路层透明传送数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。</p>
<p>解决方法：字节填充(<code>byte stuffing</code>) 或字符填充(<code>character stuffing</code>)。</p>
<p>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B，二进制是000110011)。</p>
<p>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</p>
<p>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 </p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img10.png" class="">

<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>在传输过程中可能会产生比特差错：1 可能会变成 0，而 0 也可能变成 1。这就叫做比特差错。比特差错是传输差错中的一种。</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img11.png" class="">

<p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER(<code>Bit Error Rate</code>)。例如 BER &#x3D; 10<sup>-10</sup> 时，表示平均每传送 10<sup>10</sup> 个比特就会出现 1 个比特的差错。</p>
<p>误码率与信噪比有很大的关系。提高信噪比就可以减小误码率。</p>
<p>实际的通信链路并非是理想的，不可能使误码率下降到 0。为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</p>
<p>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC(<code>Cyclic Redundancy Check</code>) 的检错技术。</p>
<h3 id="循环冗余检验的原理"><a href="#循环冗余检验的原理" class="headerlink" title="循环冗余检验的原理"></a>循环冗余检验的原理</h3><p>在发送端，先把数据（<code>M</code>）划分为组。假定每组<code>k</code>个比特。</p>
<p>在每组<code>M</code>后面再添加供差错检测用的<code>n</code>位冗余码，构成一个帧然后一起发送出去。</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img12.png" class="">

<p>冗余码的计算：</p>
<ul>
<li>用二进制的模 2 运算进行 2<sup>n</sup> 乘<code>M</code>的运算，这相当于在<code>M</code>后面添加<code>n</code>个 0。</li>
<li>得到的(<code>k + n</code>)位的数除以事先选定好的长度为(<code>n + 1</code>)位的除数<code>P</code>，得出商是<code>Q</code>而余数是<code>R</code>，余数<code>R</code>比除数<code>P</code>少 1 位，即<code>R</code>是<code>n</code>位。 </li>
<li>将余数<code>R</code>作为冗余码拼接在数据<code>M</code>后面，一起发送出去。</li>
</ul>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img13.png" class="">

<p>接收端对收到的每一帧进行 CRC 检验：把收到的每一个帧都除以同样的除数<code>P</code>（模2运算），然后检查得到的余数<code>R</code>。</p>
<ol>
<li>若得出的余数<code>R = 0</code>，则判定这个帧没有差错，就接受。</li>
<li>若余数<code>R ≠ 0</code>，则判定这个帧有差错，就丢弃。</li>
</ol>
<p>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。</p>
<p>只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。</p>
<h3 id="冗余码的计算举例"><a href="#冗余码的计算举例" class="headerlink" title="冗余码的计算举例"></a>冗余码的计算举例</h3><p>现在<code>k = 6, M = 101001</code>。设<code>n = 3</code>, 除数<code>P = 1101</code>，被除数是 2<sup>n</sup>M &#x3D; 101001000。</p>
<p>模 2 运算的结果是：商<code>Q = 110101</code>，余数<code>R = 001</code>。</p>
<p>把余数<code>R</code>作为冗余码添加在数据<code>M</code>的后面发送出去。发送的数据是：2<sup>n</sup>M + R，即：101001001，共(<code>k + n</code>)位。</p>
<p>循环冗余检验的原理说明</p>
<img src="/2020/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93/img14.png" class="">

<h3 id="帧检验序列-FCS"><a href="#帧检验序列-FCS" class="headerlink" title="帧检验序列 FCS"></a>帧检验序列 FCS</h3><p>在数据后面添加上的冗余码称为帧检验序列 FCS(<code>Frame Check Sequence</code>)。</p>
<p>循环冗余检验 CRC 和帧检验序列 FCS 并不等同。CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 </p>
<p>应当注意，仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受。“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。单纯使用 CRC 差错检测技术不能实现“无差错传输”或“可靠传输”。</p>
<p>应当明确，“无比特差错”与“无传输差错”是不同的概念。在数据链路层使用 CRC 检验，能够实现无比特差错的传输，但这还不是可靠传输。要做到“无差错传输”（即发送什么就收到什么）就必须再加上确认和重传机制。 </p>
<p>数据链路层协议都不是可靠传输的协议。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java内置包装类"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/09/java/%E5%9F%BA%E7%A1%80/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"
    >Java 内置包装类</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/09/java/%E5%9F%BA%E7%A1%80/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/" class="article-date">
  <time datetime="2020-09-09T09:51:12.000Z" itemprop="datePublished">2020-09-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="包装类、装箱和拆箱"><a href="#包装类、装箱和拆箱" class="headerlink" title="包装类、装箱和拆箱"></a>包装类、装箱和拆箱</h1><p>在 Java 的设计中提倡一种思想，即一切皆对象。但是从数据类型的划分中，我们知道 Java 中的数据类型分为基本数据类型和引用数据类型，但是基本数据类型怎么能够称为对象呢？于是 Java 为每种基本数据类型分别设计了对应的类，称之为包装类。</p>
<p>包装类和基本数据类型的关系：</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>基本数据类型转换为包装类的过程称为装箱，例如把<code>int</code>包装成<code>Integer</code>类的对象；包装类变为基本数据类型的过程称为拆箱，例如把<code>Integer</code>类的对象重新简化为<code>int</code>。</p>
<p>在进行基本数据类型和对应的包装类转换时，系统将自动进行装箱及拆箱操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> m;  <span class="comment">// 自动装箱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj;  <span class="comment">// 自动拆箱</span></span><br><span class="line">    System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">  </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;obj等价于obj1返回结果为&quot;</span> + obj.equals(obj1));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = 500</span><br><span class="line">obj等价于obj1返回结果为true</span><br></pre></td></tr></table></figure>
<h2 id="包装类的应用"><a href="#包装类的应用" class="headerlink" title="包装类的应用"></a>包装类的应用</h2><h3 id="实现-int-和-Integer-的相互转换"><a href="#实现-int-和-Integer-的相互转换" class="headerlink" title="实现 int 和 Integer 的相互转换"></a>实现 int 和 Integer 的相互转换</h3><p>可以通过<code>Integer</code>类的构造方法将<code>int</code>装箱，通过<code>Integer</code>类的<code>intValue</code>方法将<code>Integer</code>拆箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(m);  <span class="comment">// 手动装箱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj.intValue();  <span class="comment">// 手动拆箱</span></span><br><span class="line">    System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">500</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;obj等价于obj1的返回结果为&quot;</span> + obj.equals(obj1));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = 500</span><br><span class="line">obj等价于obj1的返回结果为true</span><br></pre></td></tr></table></figure>
<h3 id="将字符串转换为数值类型"><a href="#将字符串转换为数值类型" class="headerlink" title="将字符串转换为数值类型"></a>将字符串转换为数值类型</h3><p>在<code>Integer</code>和<code>Float</code>类中分别提供了以下两种方法：</p>
<ol>
<li><code>Integer</code>类（<code>String</code>转<code>int</code>型）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int parseInt(String s);</span><br></pre></td></tr></table></figure>
<code>s</code>为要转换的字符串。</li>
<li><code>Float</code>类（<code>String</code>转<code>float</code>型）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float parseFloat(String s)</span><br></pre></td></tr></table></figure>
注意：使用以上两种方法时，字符串中的数据必须由数字组成，否则转换时会出现程序错误。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;30&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;30.3&quot;</span>;</span><br><span class="line">    <span class="comment">// 将字符串变为int型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">    <span class="comment">// 将字符串变为float型</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> Float.parseFloat(str2);</span><br><span class="line">    System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;；f = &quot;</span> + f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = 30；f = 30.3</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="将整数转换为字符串"><a href="#将整数转换为字符串" class="headerlink" title="将整数转换为字符串"></a>将整数转换为字符串</h3><p><code>Integer</code>类有一个静态的<code>toString()</code>方法，可以将整数转换为字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(m);</span><br><span class="line">    System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = 500</span><br></pre></td></tr></table></figure>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p><code>Object</code>是 Java 类库中的一个特殊类，也是所有类的父类。也就是说，Java 允许把任何类型的对象赋给<code>Object</code>类型的变量。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是<code>Object</code>类。因此，以下两个类表示的含义是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;…&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Java 所有的类都是<code>Object</code>类的子类，所以任何 Java 对象都可以调用<code>Object</code>类的方法。</p>
<p><code>Object</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Object clone()</td>
<td align="center">创建与该对象的类相同的新对象</td>
</tr>
<tr>
<td align="center">boolean equals(Object)</td>
<td align="center">比较两对象是否相等</td>
</tr>
<tr>
<td align="center">void finalize()</td>
<td align="center">当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法</td>
</tr>
<tr>
<td align="center">Class getClass()</td>
<td align="center">返回一个对象运行时的实例类</td>
</tr>
<tr>
<td align="center">int hashCode()</td>
<td align="center">返回该对象的散列码值</td>
</tr>
<tr>
<td align="center">void notify()</td>
<td align="center">激活等待在该对象的监视器上的一个线程</td>
</tr>
<tr>
<td align="center">void notifyAll()</td>
<td align="center">激活等待在该对象的监视器上的全部线程</td>
</tr>
<tr>
<td align="center">String toString()</td>
<td align="center">返回该对象的字符串表示</td>
</tr>
<tr>
<td align="center">void wait()</td>
<td align="center">在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td>
</tr>
</tbody></table>
<h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h2><p><code>toString()</code>方法返回该对象的字符串，当程序输出一个对象或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的<code>toString()</code>方法返回该对象的字符串表示。</p>
<p><code>Object</code>类的<code>toString()</code>方法返回“运行时类名@十六进制哈希码”格式的字符串，但很多类都重写了<code>Object</code>类的<code>toString()</code>方法，用于返回可以表述该对象信息的字符串。</p>
<blockquote>
<p>哈希码（<code>hashCode</code>），每个 Java 对象都有哈希码属性，哈希码可以用来标识对象，提高对象在集合操作中的执行效率。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Demo类，实际上继承Object类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo01</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>(); <span class="comment">// 实例化Demo对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;不加toString()输出：&quot;</span> + d);</span><br><span class="line">    System.out.println(<span class="string">&quot;加上toString()输出：&quot;</span> + d.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不加toString()输出：Demo@15db9742</span><br><span class="line">加上toString()输出：Demo@15db9742</span><br></pre></td></tr></table></figure>
<p>以上的程序是随机输出了一些地址信息，从程序的运行结果可以清楚的发现，加和不加<code>toString()</code>的最终输出结果是一样的，也就是说对象输出时一定会调用<code>Object</code>类中的<code>toString()</code>方法打印内容。所以利用此特性就可以通过<code>toString()</code>取得一些对象的信息，如下面代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;：年龄&quot;</span> + <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>);<span class="comment">// 实例化Person对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象信息：&quot;</span> + per);<span class="comment">// 打印对象调用toString()方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象信息：姓名：张三：年龄30</span><br></pre></td></tr></table></figure>
<h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h2><p><code>==</code>运算符是比较两个引用变量是否指向同一个实例，<code>equals()</code>方法是比较两个对象的内容是否相等，通常字符串的比较只是关心内容是否相等。</p>
<p>其使用格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj.equals(Object o);</span><br></pre></td></tr></table></figure>
<p>其中，<code>obj</code>表示要进行比较的一个对象，<code>o</code>表示另一个对象。</p>
<h2 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass() 方法"></a>getClass() 方法</h2><p><code>getClass()</code>方法返回对象所属的类，是一个<code>Class</code>对象。通过<code>Class</code>对象可以获取该类的各种信息，包括类名、父类以及它所实现接口的名字等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassInfo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取类名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;类名：&quot;</span> + obj.getClass().getName());</span><br><span class="line">    <span class="comment">// 获取父类名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;父类：&quot;</span> + obj.getClass().getSuperclass().getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;实现的接口有：&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取实现的接口并输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; obj.getClass().getInterfaces().length; i++) &#123;</span><br><span class="line">      System.out.println(obj.getClass().getInterfaces()[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">strObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">    printClassInfo(strObj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类名：java.lang.String</span><br><span class="line">父类：java.lang.Object</span><br><span class="line">实现的接口有：</span><br><span class="line">interface java.io.Serializable</span><br><span class="line">interface java.lang.Comparable</span><br><span class="line">interface java.lang.CharSequence</span><br></pre></td></tr></table></figure>
<h2 id="接收任意引用类型的对象"><a href="#接收任意引用类型的对象" class="headerlink" title="接收任意引用类型的对象"></a>接收任意引用类型的对象</h2><p>既然<code>Object</code>类是所有对象的父类，则所有的对象都可以向<code>Object</code>进行转换，在这其中也包含了数组和接口类型，即一切的引用数据类型都可以使用<code>Object</code>进行接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World!!!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo04</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 为接口实例化</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="comment">// 对象向上转型</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> a;</span><br><span class="line">    <span class="comment">// 对象向下转型</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">x</span> <span class="operator">=</span> (A) obj;</span><br><span class="line">    System.out.println(x.getInfo());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure>
<p>通过以上代码可以发现，虽然接口不能继承一个类，但是依然是<code>Object</code>类的子类，因为接口本身是引用数据类型，所以可以进行向上转型操作。</p>
<p>同理，也可以使用<code>Object</code>接收一个数组，因为数组本身也是引用数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectDemo05</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">// 使用object接收数组</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> temp;</span><br><span class="line">    <span class="comment">// 传递数组引用</span></span><br><span class="line">    print(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断对象的类型</span></span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> <span class="type">int</span>[]) &#123;</span><br><span class="line">      <span class="comment">// 向下转型</span></span><br><span class="line">      <span class="type">int</span> x[] = (<span class="type">int</span>[]) o;</span><br><span class="line">      <span class="comment">// 循环输出</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; x.length; i++) &#123;</span><br><span class="line">        System.out.print(x[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 7 9</span><br></pre></td></tr></table></figure>
<p>以上程序使用<code>Object</code>接收一个整型数组，因为数组本身属于引用数据类型，所以可以使用<code>Object</code>接收数组内容，在输出时通过<code>instanceof</code>判断类型是否是一个整型数组，然后进行输出操作。</p>
<p>提示：因为<code>Object</code>类可以接收任意的引用数据类型，所以在很多的类库设计上都采用<code>Object</code>作为方法的参数，这样操作起来会比较方便。</p>
<h1 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h1><p><code>Integer</code>类在对象中包装了一个基本类型<code>int</code>的值。<code>Integer</code>类对象包含一个<code>int</code>类型的字段。此外，该类提供了多个方法，能在<code>int</code>类型和<code>String</code>类型之间互相转换，还提供了处理<code>int</code>类型时非常有用的其他一些常量和方法。</p>
<h2 id="Integer-类的构造方法"><a href="#Integer-类的构造方法" class="headerlink" title="Integer 类的构造方法"></a>Integer 类的构造方法</h2><p><code>Integer</code>类中的构造方法有以下两个：</p>
<ul>
<li><code>Integer(int value)</code>：构造一个新分配的<code>Integer</code>对象，它表示指定的<code>int</code>值。</li>
<li><code>Integer(String s)</code>：构造一个新分配的<code>Integer</code>对象，它表示<code>String</code>参数所指示的<code>int</code>值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);    <span class="comment">// 以 int 型变量作为参数创建 Integer 对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;100&quot;</span>);    <span class="comment">// 以 String 型变量作为参数创建 Integer 对象</span></span><br></pre></td></tr></table></figure>
<h2 id="Integer-类的常用方法"><a href="#Integer-类的常用方法" class="headerlink" title="Integer 类的常用方法"></a>Integer 类的常用方法</h2><p><code>Integer</code>类中的常用方法：</p>
<p>| 方法	返回值	功能<br>| :–: | :–: | :–: |<br>| byteValue()                       | byte    | 以 byte 类型返回该 Integer 的值 |<br>| shortValue()                      | short   | 以 short 类型返回该 Integer 的值 |<br>| intValue()                        | int     | 以 int 类型返回该 Integer 的值 |<br>| toString()                        | String	| 返回一个表示该 Integer 值的 String 对象 |<br>| equals(Object obj)                | boolean	| 比较此对象与指定对象是否相等 |<br>| compareTo(Integeranotherlnteger)  | int     | 在数字上比较两个 Integer 对象，如相等，则返回 0；<br>如调用对象的数值小于 anotherlnteger 的数值，则返回负值；<br>如调用对象的数值大于 anotherlnteger 的数值，则返回正值 |<br>| valueOf(String s)                 | Integer	| 返回保存指定的 String 值的 Integer 对象 |<br>| parseInt(String s)                | int     | 将数字字符串转换为 int 数值 |</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;456&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);    <span class="comment">// 将字符串转换为int类型的数值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">789</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(i);    <span class="comment">// 将int类型的数值转换为字符串</span></span><br></pre></td></tr></table></figure>
<p>注意：在实现将字符串转换为 int 类型数值的过程中，如果字符串中包含非数值类型的字符，则程序执行将出现异常。<br>例 1<br>编写一个程序，在程序中创建一个 String 类型变量，然后将它转换为二进制、八进制、十进制和十六进制输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toString(num); <span class="comment">// 将数字转换成字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> Integer.toBinaryString(num); <span class="comment">// 将数字转换成二进制</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> Integer.toHexString(num); <span class="comment">// 将数字转换成八进制</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> Integer.toOctalString(num); <span class="comment">// 将数字转换成十六进制</span></span><br><span class="line">    System.out.println(str + <span class="string">&quot;的二进制数是：&quot;</span> + str1);</span><br><span class="line">    System.out.println(str + <span class="string">&quot;的八进制数是：&quot;</span> + str3);</span><br><span class="line">    System.out.println(str + <span class="string">&quot;的十进制数是：&quot;</span> + str);</span><br><span class="line">    System.out.println(str + <span class="string">&quot;的十六进制数是：&quot;</span> + str2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">40的二进制数是：101000</span><br><span class="line">40的八进制数是：50</span><br><span class="line">40的十进制数是：40</span><br><span class="line">40的十六进制数是：28</span><br></pre></td></tr></table></figure>
<h2 id="Integer-类的常量"><a href="#Integer-类的常量" class="headerlink" title="Integer 类的常量"></a>Integer 类的常量</h2><p><code>Integer</code>类包含以下 4 个常量。</p>
<ul>
<li><code>MAX_VALUE</code>：值为 231-1 的常量，它表示<code>int</code>类型能够表示的最大值。</li>
<li><code>MIN_VALUE</code>：值为 -231 的常量，它表示<code>int</code>类型能够表示的最小值。</li>
<li><code>SIZE</code>：用来以二进制补码形式表示<code>int</code>值的比特位数。</li>
<li><code>TYPE</code>：表示基本类型<code>int</code>的<code>Class</code>实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max_value</span> <span class="operator">=</span> Integer.MAX_VALUE;    <span class="comment">// 获取 int 类型可取的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min_value</span> <span class="operator">=</span> Integer.MIN_VALUE;    <span class="comment">// 获取 int 类型可取的最小值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> Integer.SIZE;    <span class="comment">// 获取 int 类型的二进制位</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Integer.TYPE;    <span class="comment">// 获取基本类型 int 的 Class 实例</span></span><br></pre></td></tr></table></figure>
<h1 id="Float类"><a href="#Float类" class="headerlink" title="Float类"></a>Float类</h1><p><code>Float</code>类在对象中包装了一个基本类型<code>float</code>的值。<code>Float</code>类对象包含一个<code>float</code>类型的字段。此外，该类提供了多个方法，能在<code>float</code>类型与<code>String</code>类型之间互相转换，同时还提供了处理<code>float</code>类型时比较常用的常量和方法。</p>
<h2 id="Float-类的构造方法"><a href="#Float-类的构造方法" class="headerlink" title="Float 类的构造方法"></a>Float 类的构造方法</h2><p><code>Float</code>类中的构造方法有以下 3 个。</p>
<ul>
<li><code>Float(double value)</code>：构造一个新分配的<code>Float</code>对象，它表示转换为<code>float</code>类型的参数。</li>
<li><code>Float(float value)</code>：构造一个新分配的<code>Float</code>对象，它表示基本的<code>float</code>参数。</li>
<li><code>Float(String s)</code>：构造一个新分配的<code>Float</code>对象，它表示<code>String</code>参数所指示的<code>float</code>值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Float</span> <span class="variable">float1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">3.14145</span>);    <span class="comment">// 以 double 类型的变量作为参数创建 Float 对象</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">float2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">6.5</span>);    <span class="comment">// 以 float 类型的变量作为参数创建 Float 对象</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">float3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Float</span>(<span class="string">&quot;3.1415&quot;</span>);    <span class="comment">// 以 String 类型的变量作为参数创建 Float 对象</span></span><br></pre></td></tr></table></figure>
<p><code>Float</code>类中的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byteValue()</td>
<td align="center">byte</td>
<td align="center">以 byte 类型返回该 Float 的值</td>
</tr>
<tr>
<td align="center">doubleValue()</td>
<td align="center">double</td>
<td align="center">以 double 类型返回该 Float 的值</td>
</tr>
<tr>
<td align="center">floatValue()</td>
<td align="center">float</td>
<td align="center">以 float 类型返回该 Float 的值</td>
</tr>
<tr>
<td align="center">intValue()</td>
<td align="center">int</td>
<td align="center">以 int 类型返回该 Float 的值（强制转换为 int 类型）</td>
</tr>
<tr>
<td align="center">longValue()</td>
<td align="center">long</td>
<td align="center">以 long 类型返回该 Float 的值（强制转换为 long 类型）</td>
</tr>
<tr>
<td align="center">shortValue()</td>
<td align="center">short</td>
<td align="center">以 short 类型返回该 Float 的值（强制转换为 short 类型）</td>
</tr>
<tr>
<td align="center">isNaN()</td>
<td align="center">boolean</td>
<td align="center">如果此 Float 值是一个非数字值，则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">isNaN(float v)</td>
<td align="center">boolean</td>
<td align="center">如果指定的参数是一个非数字值，则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">toString()</td>
<td align="center">String</td>
<td align="center">返回一个表示该 Float 值的 String 对象</td>
</tr>
<tr>
<td align="center">valueOf(String s)</td>
<td align="center">Float</td>
<td align="center">返回保存指定的 String 值的 Float 对象</td>
</tr>
<tr>
<td align="center">parseFloat(String s)</td>
<td align="center">float</td>
<td align="center">将数字字符串转换为 float 数值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;456.7&quot;</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">num</span> <span class="operator">=</span> Float.parseFloat(str);    <span class="comment">// 将字符串转换为 float 类型的数值</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">123.4f</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Float.toString(f);    <span class="comment">// 将 float 类型的数值转换为字符串</span></span><br></pre></td></tr></table></figure>
<p>注意：在实现将字符串转换为<code>float</code>类型数值的过程中，如果字符串中包含非数值类型的字符，则程序执行将出现异常。</p>
<h2 id="Float-类的常用常量"><a href="#Float-类的常用常量" class="headerlink" title="Float 类的常用常量"></a>Float 类的常用常量</h2><p>在<code>Float</code>类中包含了很多常量，其中较为常用的常量如下。</p>
<ul>
<li><code>MAX_VALUE</code>：值为<code>1.4E38</code>的常量，它表示<code>float</code>类型能够表示的最大值。</li>
<li><code>MIN_VALUE</code>：值为<code>3.4E-45</code>的常量，它表示<code>float</code>类型能够表示的最小值。</li>
<li><code>MAX_EXPONENT</code>：有限<code>float</code>变量可能具有的最大指数。</li>
<li><code>MIN_EXPONENT</code>：标准化<code>float</code>变量可能具有的最小指数。</li>
<li><code>MIN_NORMAL</code>：保存<code>float</code>类型数值的最小标准值的常量，即 2-126。</li>
<li><code>NaN</code>：保存<code>float</code>类型的非数字值的常量。</li>
<li><code>SIZE</code>：用来以二进制补码形式表示<code>float</code>值的比特位数。</li>
<li><code>TYPE</code>：表示基本类型<code>float</code>的<code>Class</code>实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">max_value</span> <span class="operator">=</span> Float.MAX_VALUE;    <span class="comment">// 获取 float 类型可取的最大值</span></span><br><span class="line"><span class="type">float</span> <span class="variable">min_value</span> <span class="operator">=</span> Float.MIN_VALUE;    <span class="comment">// 获取 float 类型可取的最小值</span></span><br><span class="line"><span class="type">float</span> <span class="variable">min_normal</span> <span class="operator">=</span> Float.MIN_NORMAL;    <span class="comment">// 获取 float 类型可取的最小标准值</span></span><br><span class="line"><span class="type">float</span> <span class="variable">size</span> <span class="operator">=</span> Float.SIZE;    <span class="comment">// 获取 float 类型的二进制位</span></span><br></pre></td></tr></table></figure>
<h1 id="Double类"><a href="#Double类" class="headerlink" title="Double类"></a>Double类</h1><p><code>Double</code>类在对象中包装了一个基本类型<code>double</code>的值。<code>Double</code>类对象包含一个<code>double</code>类型的字段。此外，该类还提供了多个方法，可以将<code>double</code>类型与<code>String</code>类型相互转换，同时 还提供了处理<code>double</code>类型时比较常用的常量和方法。</p>
<h2 id="Double-类的构造方法"><a href="#Double-类的构造方法" class="headerlink" title="Double 类的构造方法"></a>Double 类的构造方法</h2><p><code>Double</code>类中的构造方法有如下两个。</p>
<ul>
<li><code>Double(double value)</code>：构造一个新分配的<code>Double</code>对象，它表示转换为<code>double</code>类型的参数。</li>
<li><code>Double(String s)</code>：构造一个新分配的<code>Double</code>对象，它表示<code>String</code>参数所指示的<code>double</code>值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Double</span> <span class="variable">double1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">5.456</span>);    <span class="comment">// 以 double 类型的变量作为参数创建 Double 对象</span></span><br><span class="line"><span class="type">Double</span> <span class="variable">double2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="string">&quot;5.456&quot;</span>);       <span class="comment">// 以 String 类型的变量作为参数创建 Double 对象</span></span><br></pre></td></tr></table></figure>
<h2 id="Double-类的常用方法"><a href="#Double-类的常用方法" class="headerlink" title="Double 类的常用方法"></a>Double 类的常用方法</h2><p><code>Double</code>类中的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byteValue()</td>
<td align="center">byte</td>
<td align="center">以 byte 类型返回该 Double 的值</td>
</tr>
<tr>
<td align="center">doubleValue()</td>
<td align="center">double</td>
<td align="center">以 double 类型返回该 Double 的值</td>
</tr>
<tr>
<td align="center">fioatValue()</td>
<td align="center">float</td>
<td align="center">以 float 类型返回该 Double 的值</td>
</tr>
<tr>
<td align="center">intValue()</td>
<td align="center">int</td>
<td align="center">以 int 类型返回该 Double 的值（强制转换为 int 类型）</td>
</tr>
<tr>
<td align="center">longValue()</td>
<td align="center">long</td>
<td align="center">以 long 类型返回该 Double 的值（强制转换为 long 类型）</td>
</tr>
<tr>
<td align="center">shortValue()</td>
<td align="center">short</td>
<td align="center">以 short 类型返回该 Double 的值（强制转换为 short 类型）</td>
</tr>
<tr>
<td align="center">isNaN()</td>
<td align="center">boolean</td>
<td align="center">如果此 Double 值是一个非数字值，则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">isNaN(double v)</td>
<td align="center">boolean</td>
<td align="center">如果指定的参数是一个非数字值，则返回 true，否则返回 false</td>
</tr>
<tr>
<td align="center">toString()</td>
<td align="center">String</td>
<td align="center">返回一个表示该 Double 值的 String 对象</td>
</tr>
<tr>
<td align="center">valueOf(String s)</td>
<td align="center">Double</td>
<td align="center">返回保存指定的 String 值的 Double 对象</td>
</tr>
<tr>
<td align="center">parseDouble(String s)</td>
<td align="center">double</td>
<td align="center">将数字字符串转换为 Double 数值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;56.7809&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> Double.parseDouble(str);    <span class="comment">// 将字符串转换为 double 类型的数值</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">56.7809</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Double.toString(d);    <span class="comment">// 将double类型的数值转换为字符串</span></span><br></pre></td></tr></table></figure>
<p>在将字符串转换为<code>double</code>类型的数值的过程中，如果字符串中包含非数值类型的字符，则程序执行将出现异常。</p>
<h2 id="Double-类的常用常量"><a href="#Double-类的常用常量" class="headerlink" title="Double 类的常用常量"></a>Double 类的常用常量</h2><p>在<code>Double</code>类中包含了很多常量，其中较为常用的常量如下。</p>
<ul>
<li><code>MAX_VALUE</code>：值为<code>1.8E308</code>的常量，它表示<code>double</code>类型的最大正有限值的常量。</li>
<li><code>MIN_VALUE</code>：值为<code>4.9E-324</code>的常量，它表示<code>double</code>类型数据能够保持的最小正非零值的常量。</li>
<li><code>NaN</code>：保存<code>double</code>类型的非数字值的常量。</li>
<li><code>NEGATIVE_INFINITY</code>：保持<code>double</code>类型的负无穷大的常量。</li>
<li><code>POSITIVE_INFINITY</code>：保持<code>double</code>类型的正无穷大的常量。</li>
<li><code>SIZE</code>：用秦以二进制补码形式表示<code>double</code>值的比特位数。</li>
<li><code>TYPE</code>：表示基本类型<code>double</code>的<code>Class</code>实例。</li>
</ul>
<h1 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h1><p><code>Number</code>是一个抽象类，也是一个超类（即父类）。<code>Number</code>类属于<code>java.lang</code>包，所有的包装类（如<code>Double、Float、Byte、Short、Integer</code>以及<code>Long</code>）都是抽象类<code>Number</code>的子类。</p>
<p><code>Number</code>类定义了一些抽象方法，以各种不同数字格式返回对象的值。如<code>xxxValue()</code>方法，它将<code>Number</code>对象转换为<code>xxx</code>数据类型的值并返回。这些方法如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte byteValue();</td>
<td align="center">返回 byte 类型的值</td>
</tr>
<tr>
<td align="center">double doubleValue();</td>
<td align="center">返回 double 类型的值</td>
</tr>
<tr>
<td align="center">float floatValue();</td>
<td align="center">返回 float 类型的值</td>
</tr>
<tr>
<td align="center">int intValue();</td>
<td align="center">返回 int 类型的值</td>
</tr>
<tr>
<td align="center">long longValue();</td>
<td align="center">返回 long 类型的值</td>
</tr>
<tr>
<td align="center">short shortValue();</td>
<td align="center">返回 short 类型的值</td>
</tr>
</tbody></table>
<p>抽象类不能直接实例化，而是必须实例化其具体的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Number</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">12.5</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;返回 double 类型的值：&quot;</span> + num.doubleValue());</span><br><span class="line">System.out.println(<span class="string">&quot;返回 int 类型的值：&quot;</span> + num.intValue());</span><br><span class="line">System.out.println(<span class="string">&quot;返回 float 类型的值：&quot;</span> + num.floatValue());</span><br></pre></td></tr></table></figure>
<p>执行上述代码，输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回 double 类型的值：12.5</span><br><span class="line">返回 int 类型的值：12</span><br><span class="line">返回 float 类型的值：12.5</span><br></pre></td></tr></table></figure>
<h1 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h1><p><code>Character</code>类是字符数据类型<code>char</code>的包装类。<code>Character</code>类的对象包含类型为<code>char</code>的单个字段，这样能把基本数据类型当对象来处理，其常用方法如表所示。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void Character(char value)</td>
<td align="center">构造一个新分配的 Character 对象，用以表示指定的 char 值</td>
</tr>
<tr>
<td align="center">char charValue()</td>
<td align="center">返回此 Character 对象的值，此对象表示基本 char 值</td>
</tr>
<tr>
<td align="center">int compareTo(Character anotherCharacter)</td>
<td align="center">根据数字比较两个 Character 对象</td>
</tr>
<tr>
<td align="center">boolean equals(Character anotherCharacter)</td>
<td align="center">将此对象与指定对象比较，当且仅当参数不是 null，而是一个与此对象包含相同 char 值的 Character 对象时， 结果才是 true</td>
</tr>
<tr>
<td align="center">boolean isDigit(char ch)</td>
<td align="center">确定指定字符是否为数字，如果通过 Character. getType(ch) 提供的字符的常规类别类型为 DECIMAL_DIGIT_NUMBER，则字符为数字</td>
</tr>
<tr>
<td align="center">boolean isLetter(int codePoint)</td>
<td align="center">确定指定字符（Unicode 代码点）是否为字母</td>
</tr>
<tr>
<td align="center">boolean isLetterOrDigit(int codePoint)</td>
<td align="center">确定指定字符（Unicode 代码点）是否为字母或数字</td>
</tr>
<tr>
<td align="center">boolean isLowerCase(char ch)</td>
<td align="center">确定指定字符是否为小写字母</td>
</tr>
<tr>
<td align="center">boolean isUpperCase(char ch)</td>
<td align="center">确定指定字符是否为大写字母</td>
</tr>
<tr>
<td align="center">char toLowerCase(char ch)</td>
<td align="center">使用来自 UnicodeData 文件的大小写映射信息将字符参数转换为小写</td>
</tr>
<tr>
<td align="center">char toUpperCase(char ch)</td>
<td align="center">使用来自 UnicodeData 文件的大小写映射信息将字符参数转换为大写</td>
</tr>
</tbody></table>
<p>可以从<code>char</code>值中创建一个<code>Character</code>对象。例如，下列语句为字符<code>S</code>创建了一个<code>Character</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;S&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>CompareTo()</code>方法将这个字符与其他字符比较，并且返回一个整型数组，这个值是两个字符比较后的标准代码差值。当且仅当两个字符相同时，<code>equals()</code>方法的返回值才为<code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Character</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> character.compareTo(<span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;V&#x27;</span>));</span><br><span class="line">System.out.println(result1);    <span class="comment">// 输出：0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> character.compareTo(<span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">System.out.println(resuit2);    <span class="comment">// 输出：-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result3</span> <span class="operator">=</span> character.compareTo(<span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">System.out.println(result3);    <span class="comment">// 输出：-2</span></span><br></pre></td></tr></table></figure>
<h1 id="Boolean类"><a href="#Boolean类" class="headerlink" title="Boolean类"></a>Boolean类</h1><p><code>Boolean</code>类将基本类型为<code>boolean</code>的值包装在一个对象中。一个<code>Boolean</code>类的对象只包含一个类型为<code>boolean</code>的字段。此外，此类还为<code>boolean</code>和<code>String</code>的相互转换提供了很多方法，并提供了处理<code>boolean</code>时非常有用的其他一些常用方法。</p>
<h2 id="Boolean-类的构造方法"><a href="#Boolean-类的构造方法" class="headerlink" title="Boolean 类的构造方法"></a>Boolean 类的构造方法</h2><p><code>Boolean</code>类有以下两种构造形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean(<span class="type">boolean</span> boolValue);</span><br><span class="line">Boolean(String boolString);</span><br></pre></td></tr></table></figure>
<p>其中<code>boolValue</code>必须是<code>true</code>或<code>false</code>（不区分大小写），<code>boolString</code>包含字符串<code>true</code>（不区分大小写），那么新的<code>Boolean</code>对象将包含<code>true</code>；否则将包含<code>false</code>。</p>
<h2 id="Boolean-类的常用方法"><a href="#Boolean-类的常用方法" class="headerlink" title="Boolean 类的常用方法"></a>Boolean 类的常用方法</h2><p>在<code>Boolean</code>类内部包含了一些和<code>Boolean</code>操作有关的方法。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">booleanValue()</td>
<td align="center">boolean</td>
<td align="center">将 Boolean 对象的值以对应的 boolean 值返回</td>
</tr>
<tr>
<td align="center">equals(Object obj)</td>
<td align="center">boolean</td>
<td align="center">判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，且与调用该方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true</td>
</tr>
<tr>
<td align="center">parseBoolean(String s)</td>
<td align="center">boolean</td>
<td align="center">将字符串参数解析为 boolean 值</td>
</tr>
<tr>
<td align="center">toString()</td>
<td align="center">string</td>
<td align="center">返回表示该 boolean 值的 String 对象</td>
</tr>
<tr>
<td align="center">valueOf(String s)</td>
<td align="center">boolean</td>
<td align="center">返回一个用指定的字符串表示的 boolean 值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test05</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;b1 转换为 boolean 值是：&quot;</span> + b1);</span><br><span class="line">    System.out.println(<span class="string">&quot;b2 转换为 boolean 值是：&quot;</span> + b2);</span><br><span class="line">    System.out.println(<span class="string">&quot;b3 转换为 boolean 值是：&quot;</span> + b3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b1 转换为 boolean 值是：true</span><br><span class="line">b2 转换为 boolean 值是：false</span><br><span class="line">b3 转换为 boolean 值是：true</span><br></pre></td></tr></table></figure>
<h2 id="Boolean-类的常用常量"><a href="#Boolean-类的常用常量" class="headerlink" title="Boolean 类的常用常量"></a>Boolean 类的常用常量</h2><p>在<code>Boolean</code>类中包含了很多的常量，其中较为常用的常量如下。</p>
<ul>
<li><code>TRUE</code>：对应基值<code>true</code>的<code>Boolean</code>对象。</li>
<li><code>FALSE</code>：对应基值<code>false</code>的<code>Boolean</code>对象。</li>
<li><code>TYPE</code>：表示基本类型<code>boolean</code>的<code>Class</code>对象。</li>
</ul>
<h1 id="Byte类"><a href="#Byte类" class="headerlink" title="Byte类"></a>Byte类</h1><p><code>Byte</code>类将基本类型为<code>byte</code>的值包装在一个对象中。一个<code>Byte</code>类的对象只包含一个类型为<code>byte</code>的字段。此外，该类还为<code>byte</code>和<code>String</code>的相互转换提供了方法，并提供了一些处理<code>byte</code>时非常有用的常量和方法。</p>
<h2 id="Byte-类的构造方法"><a href="#Byte-类的构造方法" class="headerlink" title="Byte 类的构造方法"></a>Byte 类的构造方法</h2><p><code>Byte</code>类提供了两个构造方法来创建<code>Byte</code>对象。</p>
<ol>
<li><code>Byte(byte value)</code><br>通过这种方法创建的<code>Byte</code>对象，可以表示指定的<code>byte</code>值。例如，下面的示例将 5 作为<code>byte</code>类型变量，然后再创建<code>Byte</code>对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">my_byte</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Byte</span>(my_byte);</span><br></pre></td></tr></table></figure></li>
<li><code>Byte(String s)</code><br>通过这个方法创建的<code>Byte</code>对象，可表示<code>String</code>参数所指定的<code>byte</code>值。例如，下面的示例将 5 作为<code>String</code>类型变量，然后再创建<code>Byte</code>对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">my_byte</span> <span class="operator">=</span> <span class="string">&quot;5&quot;</span>;</span><br><span class="line"><span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Byte</span>(my_byte);</span><br></pre></td></tr></table></figure>
注意：必须使用数值型的<code>String</code>变量作为参数才能创建成功，否则会抛出<code>NumberFormatException</code>异常。</li>
</ol>
<h2 id="Byte-类的常用方法"><a href="#Byte-类的常用方法" class="headerlink" title="Byte 类的常用方法"></a>Byte 类的常用方法</h2><p>在<code>Byte</code>类内部包含了一些和<code>Byte</code>操作有关的方法。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byteValue()</td>
<td align="center">byte</td>
<td align="center">以一个 byte 值返回 Byte 对象</td>
</tr>
<tr>
<td align="center">compareTo(Byte bytel)</td>
<td align="center">int</td>
<td align="center">在数字上比较两个 Byte 对象</td>
</tr>
<tr>
<td align="center">doubleValue()	double	以一个 double 值返回此 Byte 的值</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">intValue()</td>
<td align="center">int</td>
<td align="center">以一个 int 值返回此 Byte 的值</td>
</tr>
<tr>
<td align="center">parseByte(String s)</td>
<td align="center">byte</td>
<td align="center">将 String 型参数解析成等价的 byte 形式</td>
</tr>
<tr>
<td align="center">toStringO</td>
<td align="center">String</td>
<td align="center">返回表示此 byte 值的 String 对象</td>
</tr>
<tr>
<td align="center">valueOf(String s)</td>
<td align="center">Byte</td>
<td align="center">返回一个保持指定 String 所给出的值的 Byte 对象</td>
</tr>
<tr>
<td align="center">equals(Object obj)</td>
<td align="center">boolean</td>
<td align="center">将此对象与指定对象比较，如果调用该方法的对象与 obj 相等 则返回 true，否则返回 false</td>
</tr>
</tbody></table>
<h2 id="Byte-类的常用常量"><a href="#Byte-类的常用常量" class="headerlink" title="Byte 类的常用常量"></a>Byte 类的常用常量</h2><p>在<code>Byte</code>类中包含了很多的常量，其中较为常用的常量如下。</p>
<ul>
<li><code>MIN_VALUE</code>：<code>byte</code>类可取的最小值。</li>
<li><code>MAX_VALUE</code>：<code>byte</code>类可取的最大值。</li>
<li><code>SIZE</code>：用于以二进制补码形式表示的<code>byte</code>值的位数。</li>
<li><code>TYPE</code>：表示基本类<code>byte</code>的<code>Class</code>实例。</li>
</ul>
<h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><p><code>System</code>类位于<code>java.lang</code>包，代表当前 Java 程序的运行平台，系统级的很多属性和控制方法都放置在该类的内部。由于该类的构造方法是<code>private</code>的，所以无法创建该类的对象，也就是无法实例化该类。</p>
<p><code>System</code>类提供了一些类变量和类方法，允许直接通过<code>System</code>类来调用这些类变量和类方法。</p>
<h2 id="System-类的成员变量"><a href="#System-类的成员变量" class="headerlink" title="System 类的成员变量"></a>System 类的成员变量</h2><p><code>System</code>类有 3 个静态成员变量，分别是<code>PrintStream out、InputStream in</code>和<code>PrintStream err</code>。</p>
<ol>
<li><code>PrintStream out</code><br>标准输出流。此流已打开并准备接收输出数据。通常，此流对应于显示器输出或者由主机环境或用户指定的另一个输出目标。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(data);</span><br></pre></td></tr></table></figure>
其中，<code>println</code>方法是属于流类<code>PrintStream</code>的方法，而不是<code>System</code>中的方法。</li>
<li><code>InputStream in</code><br>标准输入流。此流已打开并准备提供输入数据。通常，此流对应于键盘输入或者由主机环境或用户指定的另一个输入源。</li>
<li><code>PrintStream err</code><br>标准的错误输出流。其语法与<code>System.out</code>类似，不需要提供参数就可输出错误信息。也可以用来输出用户指定的其他信息，包括变量的值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test06</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入字符，按回车键结束输入:&quot;</span>);</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      c = System.in.read();    <span class="comment">// 读取输入的字符</span></span><br><span class="line">      <span class="keyword">while</span>(c != <span class="string">&#x27;\r&#x27;</span>) &#123;    <span class="comment">// 判断输入的字符是不是回车</span></span><br><span class="line">        System.out.print((<span class="type">char</span>) c);    <span class="comment">// 输出字符</span></span><br><span class="line">        c = System.in.read();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">      System.out.println(e.toString());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.err.println();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，<code>System.in.read()</code>语句读入一个字符，<code>read()</code>方法是<code>InputStream</code>类拥有的方法。变量<code>c</code>必须用<code>int</code>类型而不能用<code>char</code>类型，否则会因为丢失精度而导致编译失败。</p>
<p>以上的程序如果输入汉字将不能正常输出。如果要正常输出汉字，需要把<code>System.in</code>声明为<code>InputStreamReader</code>类型的实例，最终在<code>try</code>语句块中的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in, <span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line">c = in.read();</span><br><span class="line"><span class="keyword">while</span>(c != <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">  System.out.print((<span class="type">char</span>) c);</span><br><span class="line">  c = in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，语句<code>InputStreamReader in=new InputStreamReader(System.in,&quot;GB2312&quot;)</code>声明一个新对象<code>in</code>，它从<code>Reader</code>继承而来，此时就可以读入完整的<code>Unicode</code>码，显示正常的汉字。</p>
<h2 id="System-类的成员方法"><a href="#System-类的成员方法" class="headerlink" title="System 类的成员方法"></a>System 类的成员方法</h2><p><code>System</code>类中提供了一些系统级的操作方法，常用的方法有<code>arraycopy()、currentTimeMillis()、exit()、gc()</code>和<code>getProperty()</code>。</p>
<h3 id="1-arraycopy-方法"><a href="#1-arraycopy-方法" class="headerlink" title="1. arraycopy() 方法"></a>1. arraycopy() 方法</h3><p>该方法的作用是数组复制，即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。该方法的具体定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,<span class="type">int</span> srcPos,Object dest,<span class="type">int</span> destPos,<span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>src</code>表示源数组，<code>srcPos</code>表示从源数组中复制的起始位置，<code>dest</code>表示目标数组，<code>destPos</code>表示要复制到的目标数组的起始位置，<code>length</code>表示复制的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_arrayCopy</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] srcArray = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span>[] destArray = &#123;<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">    System.arraycopy(srcArray,<span class="number">1</span>,destArray,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;源数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; srcArray.length;i++) &#123;</span><br><span class="line">      System.out.println(srcArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;目标数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; destArray.length;j++) &#123;</span><br><span class="line">      System.out.println(destArray[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码，将数组 srcArray 中，从下标 1 开始的数据复制到数组<code>destArray</code>从下标 1 开始的位置，总共复制两个。也就是将<code>srcArray[1]</code>复制给<code>destArray[1]</code>，将<code>srcArray[2]</code>复制给<code>destArray[2]</code>。这样经过复制之后，数组<code>srcArray</code>中的元素不发生变化，而数组<code>destArray</code>中的元素将变为<code>E、B、C、 H</code>，下面为输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源数组：</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">目标数组：</span><br><span class="line">E</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">H</span><br></pre></td></tr></table></figure>
<h3 id="2-currentTimeMillis-方法"><a href="#2-currentTimeMillis-方法" class="headerlink" title="2. currentTimeMillis() 方法"></a>2. currentTimeMillis() 方法</h3><p>该方法的作用是返回当前的计算机时间，时间的格式为当前计算机时间与 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒所差的毫秒数。一般用它来测试程序的执行时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure>
<p>上述语句将获得一个长整型的数字，该数字就是以差值表达的当前时间。</p>
<p>使用<code>currentTimeMillis()</code>方法来显示时间不够直观，但是可以很方便地进行时间计算。例如，计算程序运行需要的时间就可以使用如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_currentTimeMillis</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100000000</span>;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序执行时间&quot;</span> + time + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-exit-方法"><a href="#3-exit-方法" class="headerlink" title="3. exit() 方法"></a>3. exit() 方法</h3><p>该方法的作用是终止当前正在运行的 Java 虚拟机，具体的定义格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>status</code>的值为 0 时表示正常退出，非零时表示异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
<h3 id="4-gc-方法"><a href="#4-gc-方法" class="headerlink" title="4. gc() 方法"></a>4. gc() 方法</h3><p>该方法的作用是请求系统进行垃圾回收，完成内存中的垃圾清除。至于系统是否立刻回收，取决于系统中垃圾回收算法的实现以及系统执行时的情况。定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h3 id="5-getProperty-方法"><a href="#5-getProperty-方法" class="headerlink" title="5. getProperty() 方法"></a>5. getProperty() 方法</h3><p>该方法的作用是获得系统中属性名为 key 的属性对应的值，具体的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure>
<p>系统中常见的属性名以及属性的说明：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">java.version</td>
<td align="center">Java 运行时环境版本</td>
</tr>
<tr>
<td align="center">java.home</td>
<td align="center">Java 安装目录</td>
</tr>
<tr>
<td align="center">os.name</td>
<td align="center">操作系统的名称</td>
</tr>
<tr>
<td align="center">os.version</td>
<td align="center">操作系统的版本</td>
</tr>
<tr>
<td align="center">user.name</td>
<td align="center">用户的账户名称</td>
</tr>
<tr>
<td align="center">user.home</td>
<td align="center">用户的主目录</td>
</tr>
<tr>
<td align="center">user.dir	用户的当前工作目录</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">System_getProperty</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">jversion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">oName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Java 运行时环境版本：&quot;</span>+jversion);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前操作系统是：&quot;</span>+oName);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前用户是：&quot;</span>+user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该程序，输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java 运行时环境版本：1.6.0_26</span><br><span class="line">当前操作系统是：Windows 7</span><br><span class="line">当前用户是：Administrator</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-计算机网络/物理层——宽带接入技术"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E2%80%94%E2%80%94%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/"
    >物理层——宽带接入技术</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E2%80%94%E2%80%94%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/" class="article-date">
  <time datetime="2020-09-07T04:21:42.000Z" itemprop="datePublished">2020-09-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>用户要连接到互联网，必须先连接到某个 ISP，以便获得上网所需的 IP 地址。</p>
<p>在互联网的发展初期，用户都是利用电话的用户线通过调制解调器连接到 ISP 的，电话用户线接入到互联网的速率最高仅达到<code>56 kbit/s</code>。</p>
<p>下行速率达到<code>25 Mbit/s</code>，上行速率达到<code>3 Mbit/s</code>就是宽带。</p>
<p>从宽带接入的媒体来看，可以划分为两大类：有线宽带接入、无线宽带接入。</p>
<h1 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h1><p>非对称数字用户线 ADSL(<code>Asymmetric Digital Subscriber Line</code>) 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</p>
<p>标准模拟电话信号的频带被限制在<code>300~3400 Hz</code>的范围内，但用户线本身实际可通过的信号频率超过<code>1 MHz</code>。</p>
<p>ADSL 技术就把<code>0~4 kHz</code>低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。</p>
<p>DSL 就是数字用户线(<code>Digital Subscriber Line</code>)的缩写。</p>
<p>DSL 的几种类型：</p>
<ul>
<li>ADSL(<code>Asymmetric Digital Subscriber Line</code>)：非对称数字用户线</li>
<li>HDSL(<code>High speed DSL</code>)：高速数字用户线，使用1对线或2对线的对称DSL</li>
<li>SDSL(<code>Single-line DSL</code>)：1 对线的数字用户线</li>
<li>VDSL(<code>Very high speed DSL</code>)：甚高速数字用户线</li>
<li>DSL(<code>Digital Subscriber Line</code>) ：数字用户线</li>
<li>RADSL(<code>Rate-Adaptive DSL</code>)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率</li>
</ul>
<h2 id="ADSL-的传输距离"><a href="#ADSL-的传输距离" class="headerlink" title="ADSL 的传输距离"></a>ADSL 的传输距离</h2><p>ADSL 的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。</p>
<p>ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</p>
<p>例如：0.5 毫米线径的用户线，传输速率为<code>1.5~2.0 Mbit/s</code>时可传送<code>5.5km</code>，但当传输速率提高到<code>6.1 Mbit/s</code>时，传输距离就缩短为<code>3.7km</code>。如果把用户线的线径减小到 0.4 毫米，那么在<code>6.1 Mbit/s</code>的传输速率下就只能传送<code>2.7km</code>。</p>
<h2 id="ADSL-的特点"><a href="#ADSL-的特点" class="headerlink" title="ADSL 的特点"></a>ADSL 的特点</h2><p>上行和下行带宽做成不对称的。由于用户在上网时主要是从互联网下载各种文档，而向互联网发送的信息量一般都不太大，因此下行（从ISP到用户）带宽都远远大于上行。</p>
<p>上行指从用户到 ISP，而下行指从 ISP 到用户。</p>
<h2 id="DMT-技术"><a href="#DMT-技术" class="headerlink" title="DMT 技术"></a>DMT 技术</h2><p>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。调制解调器的实现有很多，我国目前采用的方案是离散多音调 DMT (<code>Discrete Multi-Tone</code>)调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。</p>
<p>DMT 调制技术采用频分复用的方法，把<code>40 kHz</code>以上一直到<code>1.1 MHz</code>的高端频谱划分为许多子信道，其中 25 个子信道用于上行信道，而 249 个子信道用于下行信道。</p>
<p>每个子信道占据<code>4 kHz</code>带宽（严格讲是<code>4.3125 kHz</code>），并使用不同的载波（即不同的音调）进行数字调制。这种做法相当于在一对用户线上使用许多小的调制解调器并行地传送数据。</p>
<h2 id="DMT-技术的频谱分布"><a href="#DMT-技术的频谱分布" class="headerlink" title="DMT 技术的频谱分布"></a>DMT 技术的频谱分布</h2><img src="/2020/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E2%80%94%E2%80%94%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/img16.png" class="" title="DMT 技术的频谱分布">

<h2 id="ADSL-的数据率"><a href="#ADSL-的数据率" class="headerlink" title="ADSL 的数据率"></a>ADSL 的数据率</h2><p>由于用户线的具体条件往往相差很大（距离、线径、受到相邻用户线的干扰程度等都不同），因此 ADSL 采用自适应调制技术使用户线能够传送尽可能高的数据率。</p>
<p>当 ADSL 启动时，用户线两端的 ADSL 调制解调器就测试可用的频率、各子信道受到的干扰情况，以及在每一个频率上测试信号的传输质量。</p>
<p>ADSL 不能保证固定的数据率。对于质量很差的用户线甚至无法开通 ADSL。</p>
<p>通常下行数据率在<code>32 kbit/s</code>到<code>6.4 Mbit/s</code>之间，而上行数据率在<code>32 kbit/s</code>到<code>640 kbit/s</code>之间。</p>
<h2 id="ADSL-的组成"><a href="#ADSL-的组成" class="headerlink" title="ADSL 的组成"></a>ADSL 的组成</h2><img src="/2020/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E2%80%94%E2%80%94%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/img17.png" class="">

<p>ADSL 调制解调器有两个插口，较大的一个是 RJ-45 插口，用来和计算机相连。较小的是 RJ-11 插口，用来和电话分离器相连。</p>
<p>ADSL 借助于在用户线两端安装的 ADSL 调制解调器对数字信号进行了调制，使得调制后的数字信号的频谱适合在原来的用户线上传输，用户线本身并没有发生变化。</p>
<h2 id="第二代-ADSL"><a href="#第二代-ADSL" class="headerlink" title="第二代 ADSL"></a>第二代 ADSL</h2><p>包括 ADSL2（G.992.3 和 G.992.4）和 ADSL2+（G.992.5）。</p>
<p>通过提高调制效率得到了更高的数据率。</p>
<ul>
<li>ADSL2 要求至少应支持下行<code>8 Mbit/s</code>、上行<code>800 kbit/s</code>的速率。</li>
<li>ADSL2+ 则将频谱范围从<code>1.1 MHz</code>扩展至<code>2.2 MHz</code>，下行速率可达<code>16 Mbit/s</code>（最大传输速率可达<code>25 Mbit/s</code>），而上行速率可达<code>800 kbit/s</code>。</li>
</ul>
<p>采用了无缝速率自适应技术 SRA(<code>Seamless Rate Adaptation</code>)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率。</p>
<p>改善了线路质量评测和故障定位功能，这对提高网络的运行维护水平具有非常重要的意义。</p>
<h1 id="光纤同轴混合网（HFC网）"><a href="#光纤同轴混合网（HFC网）" class="headerlink" title="光纤同轴混合网（HFC网）"></a>光纤同轴混合网（HFC网）</h1><p>HFC(<code>Hybrid Fiber Coax</code>)网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</p>
<p>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</p>
<p>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。</p>
<p>HFC 网对 CATV 网进行了改造。HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</p>
<p>在模拟光纤中采用光的振幅调制AM，这比使用数字光纤更为经济。</p>
<p>模拟光纤从头端连接到光纤结点(<code>fiber node</code>)，即光分配结点 ODN(<code>Optical Distribution Node</code>)。在光纤结点光信号被转换为电信号。在光纤结点以下就是同轴电缆。</p>
<img src="/2020/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E2%80%94%E2%80%94%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/img18.png" class="">

<p>HFC 网具有双向传输功能，扩展了传输频带。</p>
<img src="/2020/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E2%80%94%E2%80%94%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/img19.png" class="">

<p>每个家庭要安装一个用户接口盒。用户接口盒 UIB(<code>User Interface Box</code>)要提供三种连接，即：</p>
<ul>
<li>使用同轴电缆连接到机顶盒，然后再连接到用户的电视机。</li>
<li>使用双绞线连接到用户的电话机。</li>
<li>使用电缆调制解调器连接到用户的计算机。</li>
</ul>
<h2 id="电缆调制解调器-Cable-Modem"><a href="#电缆调制解调器-Cable-Modem" class="headerlink" title="电缆调制解调器 (Cable Modem)"></a>电缆调制解调器 (Cable Modem)</h2><p>电缆调制解调器是为 HFC 网而使用的调制解调器。电缆调制解调器最大的特点就是传输速率高。</p>
<ul>
<li>下行速率一般在<code>3 ~ 10 Mbit/s</code>之间，最高可达<code>30 Mbit/s</code>。</li>
<li>上行速率一般为<code>0.2 ~ 2 Mbit/s</code>，最高可达<code>10 Mbit/s</code>。</li>
</ul>
<p>电缆调制解调器比在普通电话线上使用的调制解调器要复杂得多，并且不是成对使用，而是只安装在用户端。 </p>
<h1 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h1><p>FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。<br>FTTx 表示<code>Fiber To The…</code>（光纤到…），例如：</p>
<ul>
<li>光纤到户 FTTH(<code>Fiber To The Home</code>)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。</li>
<li>光纤到大楼 FTTB(<code>Fiber To The Building</code>)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li>
<li>光纤到路边 FTTC(<code>Fiber To The Curb</code>)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。</li>
</ul>
<h2 id="无源光网络-PON-Passive-Optical-Network"><a href="#无源光网络-PON-Passive-Optical-Network" class="headerlink" title="无源光网络 PON (Passive Optical Network)"></a>无源光网络 PON (Passive Optical Network)</h2><img src="/2020/09/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82%E2%80%94%E2%80%94%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF/img20.png" class="">

<p>光配线网 ODN(<code>Optical Distribution Node</code>)是在光纤和用户之间的转换装置，使用户能够共享一根光纤干线。</p>
<p>无源表明在光配线网中无须配备电源，因此基本上不用维护，长期运营成本和管理成本都很低。无源的光配线网常称为无源光网络 PON。</p>
<p>光线路终端 OLT(<code>Optical Line Terminal</code>)是连接到光纤干线的终端设备。OLT 把收到的下行数据发往无源的1:N光分路器，然后用广播方式向所有用户端的光网络单元 ONU(<code>Optical Network Unit</code>) 发送。每个 ONU 根据特有的标识只接收发送给自己的数据，然后转换为电信号发往用户家中。</p>
<p>当 ONU 发送上行数据时，先把电信号转换为光信号，光分路器把各 ONU 发来的上行数据汇总后，以 TDMA 方式发往 OLT，而发送时间和长度都由 OLT集中控制，以便有序的共享光纤主干。</p>
<p>光配线网采用波分复用，上行和下行分别使用不同的波长。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-java/基础/Java时间日期的处理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/06/java/%E5%9F%BA%E7%A1%80/Java%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/"
    >Java 时间日期的处理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/09/06/java/%E5%9F%BA%E7%A1%80/Java%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%9A%84%E5%A4%84%E7%90%86/" class="article-date">
  <time datetime="2020-09-06T11:33:52.000Z" itemprop="datePublished">2020-09-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>在 Java 中获取当前时间，可以使用<code>java.util.Date</code>类和<code>java.util.Calendar</code>类完成。其中，<code>Date</code>类主要封装了系统的日期和时间的信息，<code>Calendar</code>类则会根据系统的日历来解释<code>Date</code>对象。</p>
<h1 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h1><p><code>Date</code>类表示系统特定的时间戳，可以精确到毫秒。<code>Date</code>对象表示时间的默认顺序是星期、月、日、小时、分、秒、年。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>Date</code>类有两个构造方法。</p>
<ul>
<li><code>Date()</code>：此种形式表示分配<code>Date</code>对象并初始化此对象，以表示分配它的时间（精确到毫秒），使用该构造方法创建的对象可以获取本地的当前时间。</li>
<li><code>Date(long date)</code>：此种形式表示从 GMT 时间（格林尼治时间）1970 年 1 月 1 日 0 时 0 分 0 秒开始经过参数<code>date</code>指定的毫秒数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();    <span class="comment">// 调用无参数构造函数</span></span><br><span class="line">System.out.println(date1.toString());    <span class="comment">// 输出：Wed May 18 21:24:40 CST 2016</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">60000</span>);    <span class="comment">// 调用含有一个long类型参数的构造函数</span></span><br><span class="line">System.out.println(date2);    <span class="comment">// 输出：Thu Jan 0108:01:00 CST 1970</span></span><br></pre></td></tr></table></figure>
<p><code>Date</code>类的无参数构造方法获取的是系统当前的时间，显示的顺序为星期、月、日、小时、分、秒、年。</p>
<p><code>Date</code>类带<code>long</code>类型参数的构造方法获取的是距离 GMT 指定毫秒数的时间，60000 毫秒是一分钟，而 GMT（格林尼治标准时间）与 CST（中央标准时间）相差 8 小时，也就是说 1970 年 1 月 1 日 00:00:00 GMT 与 1970 年 1 月 1 日 08:00:00 CST 表示的是同一时间。 因此距离 1970 年 1 月 1 日 00:00:00 CST 一分钟的时间为 1970 年 1 月 1 日 00:01:00 CST，即使用<code>Date</code>对象表示为<code>Thu Jan 01 08:01:00 CST 1970</code>。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>Date</code>类中的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean after(Date when)</td>
<td align="center">判断此日期是否在指定日期之后</td>
</tr>
<tr>
<td align="center">boolean before(Date when)</td>
<td align="center">判断此日期是否在指定日期之前</td>
</tr>
<tr>
<td align="center">int compareTo(Date anotherDate)</td>
<td align="center">比较两个日期的顺序</td>
</tr>
<tr>
<td align="center">boolean equals(Object obj)</td>
<td align="center">比较两个日期的相等性</td>
</tr>
<tr>
<td align="center">long getTime()</td>
<td align="center">返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此 Date 对象表示的毫秒数</td>
</tr>
<tr>
<td align="center">String toString()</td>
<td align="center">把此 Date 对象转换为以下形式的 String: dow mon dd hh:mm:ss zzz yyyy。其中 dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及 Sat)</td>
</tr>
</tbody></table>
<h2 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h2><p><code>Calendar</code>类是一个抽象类，它为特定瞬间与<code>YEAR、MONTH、DAY_OF—MONTH、HOUR</code>等日历字段之间的转换提供了一些方法，并为操作日历字段（如获得下星期的日期） 提供了一些方法。</p>
<p>创建<code>Calendar</code>对象不能使用<code>new</code>关键字，因为<code>Calendar</code>类是一个抽象类，但是它提供了一个<code>getInstance()</code>方法来获得<code>Calendar</code>类的对象。<code>getInstance()</code>方法返回一个<code>Calendar</code>对象，其日历字段已由当前日期和时间初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p>当创建了一个<code>Calendar</code>对象后，就可以通过<code>Calendar</code>对象中的一些方法来处理日期、时间。<code>Calendar</code>类的常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void add(int field, int amount)</td>
<td align="center">根据日历的规则，为给定的日历字段 field 添加或减去指定的时间量 amount</td>
</tr>
<tr>
<td align="center">boolean after(Object when)</td>
<td align="center">判断此 Calendar 表示的时间是否在指定时间 when 之后，并返回判断结果</td>
</tr>
<tr>
<td align="center">boolean before(Object when)</td>
<td align="center">判断此 Calendar 表示的时间是否在指定时间 when 之前，并返回判断结果</td>
</tr>
<tr>
<td align="center">void clear()</td>
<td align="center">清空 Calendar 中的日期时间值</td>
</tr>
<tr>
<td align="center">int compareTo(Calendar anotherCalendar)</td>
<td align="center">比较两个 Calendar 对象表示的时间值（从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒至现在的毫秒偏移量），大则返回 1，小则返 回 -1，相等返回 0</td>
</tr>
<tr>
<td align="center">int get(int field)</td>
<td align="center">返回指定日历字段的值</td>
</tr>
<tr>
<td align="center">int getActualMaximum(int field)</td>
<td align="center">返回指定日历字段可能拥有的最大值</td>
</tr>
<tr>
<td align="center">int getActualMinimum(int field)</td>
<td align="center">返回指定日历字段可能拥有的最小值</td>
</tr>
<tr>
<td align="center">int getFirstDayOfWeek()</td>
<td align="center">获取一星期的第一天。根据不同的国家地区，返回不同的值</td>
</tr>
<tr>
<td align="center">static Calendar getInstance()</td>
<td align="center">使用默认时区和语言坏境获得一个日历</td>
</tr>
<tr>
<td align="center">static Calendar getInstance(TimeZone zone)</td>
<td align="center">使用指定时区和默认语言环境获得一个日历</td>
</tr>
<tr>
<td align="center">static Calendar getInstance(<br>TimeZone zone, Locale aLocale)</td>
<td align="center">使用指定时区和语言环境获得一个日历</td>
</tr>
<tr>
<td align="center">Date getTime()</td>
<td align="center">返回一个表示此 Calendar 时间值（从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒至现在的毫秒偏移量）的 Date 对象</td>
</tr>
<tr>
<td align="center">long getTimeInMillis()</td>
<td align="center">返回此 Calendar 的时间值，以毫秒为单位</td>
</tr>
<tr>
<td align="center">void set(int field, int value)</td>
<td align="center">为指定的日历字段设置给定值</td>
</tr>
<tr>
<td align="center">void set(int year, int month, int date)</td>
<td align="center">设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值</td>
</tr>
<tr>
<td align="center">void set(int year, int month, int date,<br> int hourOfDay, int minute, int second)</td>
<td align="center">设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、 MINUTE 和 SECOND 的值</td>
</tr>
<tr>
<td align="center">void setFirstDayOfWeek(int value)</td>
<td align="center">设置一星期的第一天是哪一天</td>
</tr>
<tr>
<td align="center">void setTimeInMillis(long millis)</td>
<td align="center">用给定的 long 值设置此 Calendar 的当前时间值</td>
</tr>
</tbody></table>
<p><code>Calendar</code>对象可以调用<code>set()</code>方法将日历翻到任何一个时间，当参数<code>year</code>取负数时表示公元前。<code>Calendar</code>对象调用<code>get()</code>方法可以获取有关年、月、日等时间信息，参数<code>field</code>的有效值由<code>Calendar</code>静态常量指定。</p>
<p><code>Calendar</code>类中定义了许多常量，分别表示不同的意义。</p>
<ul>
<li><code>Calendar.YEAR</code>：年份。</li>
<li><code>Calendar.MONTH</code>：月份。</li>
<li><code>Calendar.DATE</code>：日期。</li>
<li><code>Calendar.DAY_OF_MONTH</code>：日期，和上面的字段意义完全相同。</li>
<li><code>Calendar.HOUR</code>：12小时制的小时。</li>
<li><code>Calendar.HOUR_OF_DAY</code>：24 小时制的小时。</li>
<li><code>Calendar.MINUTE</code>：分钟。</li>
<li><code>Calendar.SECOND</code>：秒。</li>
<li><code>Calendar.DAY_OF_WEEK</code>：星期几。</li>
</ul>
<p>例如，要获取当前月份可用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> Calendar.getInstance().get(Calendar.MONTH);</span><br></pre></td></tr></table></figure>
<p>如果整型变量<code>month</code>的值是 0，表示当前日历是在 1 月份；如果值是 11，则表示当前日历在 12 月份。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance(); <span class="comment">// 如果不设置时间，则默认为当前时间</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// 将系统当前时间赋值给 Calendar 对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;现在时刻：&quot;</span> + calendar.getTime()); <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR); <span class="comment">// 获取当前年份</span></span><br><span class="line">System.out.println(<span class="string">&quot;现在是&quot;</span> + year + <span class="string">&quot;年&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 获取当前月份（月份从 0 开始，所以加 1）</span></span><br><span class="line">System.out.print(month + <span class="string">&quot;月&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DATE); <span class="comment">// 获取日</span></span><br><span class="line">System.out.print(day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>; <span class="comment">// 获取今天星期几（以星期日为第一天）</span></span><br><span class="line">System.out.print(<span class="string">&quot;星期&quot;</span> + week);</span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> calendar.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获取当前小时数（24 小时制）</span></span><br><span class="line">System.out.print(hour + <span class="string">&quot;时&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> calendar.get(Calendar.MINUTE); <span class="comment">// 获取当前分钟</span></span><br><span class="line">System.out.print(minute + <span class="string">&quot;分&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> calendar.get(Calendar.SECOND); <span class="comment">// 获取当前秒数</span></span><br><span class="line">System.out.print(second + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">millisecond</span> <span class="operator">=</span> calendar.get(Calendar.MILLISECOND); <span class="comment">// 获取毫秒数</span></span><br><span class="line">System.out.print(millisecond + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">// 获取今天是本月第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是本月的第 &quot;</span> + dayOfMonth + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfWeekInMonth</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH); <span class="comment">// 获取今天是本月第几周</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是本月第 &quot;</span> + dayOfWeekInMonth + <span class="string">&quot; 周&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">many</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_YEAR); <span class="comment">// 获取今天是今年第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是今年第 &quot;</span> + many + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">2012</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">// 设置年月日，时分秒将默认采用当前值</span></span><br><span class="line">System.out.println(<span class="string">&quot;设置日期为 2012-8-8 后的时间：&quot;</span> + c.getTime()); <span class="comment">// 输出时间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">1</span>); <span class="comment">// 实际的calendar对象所表示的日期为2016年6月1日</span></span><br><span class="line">        <span class="comment">// 判断2016年6月1日为一周中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] title = &#123; <span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span> &#125;; <span class="comment">// 存放曰历的头部</span></span><br><span class="line">        <span class="type">int</span> daysArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>][<span class="number">7</span>];<span class="comment">// 存放日历的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">daysInMonth</span> <span class="operator">=</span> <span class="number">31</span>; <span class="comment">// 该月的天数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 自动增长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充第一周的日期数据，即日历中的第一行</span></span><br><span class="line">            daysArray[<span class="number">0</span>][i] = day++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充其他周的日历数据，控制行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前day表示的是本月最后一天，则停止向数组中继续赋值</span></span><br><span class="line">                <span class="keyword">if</span> (day &gt; daysInMonth) &#123;</span><br><span class="line">                    i = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                daysArray[i][j] = day++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------2016 年 6 月--------------------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; title.length; i++) &#123;</span><br><span class="line">            System.out.print(title[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出二元数组daysArray中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (daysArray[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果到月末，则完成显示日历的任务，停止该方法的执行</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(daysArray[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>Calendar</code>类所表示的时间月份是<code>set()</code>方法中表示月份的参数值 +1，因此<code>Calendar</code>类的实际时间为 2016 年 6 月 1 日。在下面的代码中分别获取 6 月 1 日为本周中的第几天，以便在相应的星期下开始输出 6 月份的日历。程序中的<code>daysArray</code>是一个二元数组，该二元数组控制了日历的格式输出，第一个子数组控制日历的行，第二个子数组控制曰历的列，即可输出二元数组中的每一个元素。</p>
<p>运行程序，执行结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------------------2016 年 6 月--------------------</span><br><span class="line"></span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">   1 2 3 4</span><br><span class="line">5 6 7 8 9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29 30 31 </span><br></pre></td></tr></table></figure>
<h1 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h1><p>格式化日期表示将日期&#x2F;时间格式转换为预先定义的日期&#x2F;时间格式。例如将日期<code>Fri May 18 15:46:24 CST2016</code>格式转换为<code>2016-5-18 15:46:24 星期五</code>的格式。</p>
<p>在 Java 中，可以使用<code>DateFormat</code>类和<code>SimpleDateFormat</code>类来格式化日期。</p>
<h2 id="DateFormat-类"><a href="#DateFormat-类" class="headerlink" title="DateFormat 类"></a>DateFormat 类</h2><p><code>DateFormat</code>是日期&#x2F;时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期&#x2F;时间格式化子类（如<code>SimpleDateFormat</code>）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p>
<p>在创建<code>DateFormat</code>对象时不能使用<code>new</code>关键字，而应该使用<code>DateFormat</code>类中的静态方法<code>getDateInstance()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> DateFormat.getDatelnstance();</span><br></pre></td></tr></table></figure>
<p>在创建了一个<code>DateFormat</code>对象后，可以调用该对象中的方法来对日期&#x2F;时间进行格式化。<code>DateFormat</code>类中常用方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String format(Date date)</td>
<td align="center">将 Date 格式化日期&#x2F;时间字符串</td>
</tr>
<tr>
<td align="center">Calendar getCalendar()</td>
<td align="center">获取与此日期&#x2F;时间格式相关联的日历</td>
</tr>
<tr>
<td align="center">static DateFormat getDateInstance()</td>
<td align="center">获取具有默认格式化风格和默认语言环境的日期格式</td>
</tr>
<tr>
<td align="center">static DateFormat getDateInstance(int style)</td>
<td align="center">获取具有指定格式化风格和默认语言环境的日期格式</td>
</tr>
<tr>
<td align="center">static DateFormat getDateInstance(int style, Locale locale)</td>
<td align="center">获取具有指定格式化风格和指定语言环境的日期格式</td>
</tr>
<tr>
<td align="center">static DateFormat getDateTimeInstance()</td>
<td align="center">获取具有默认格式化风格和默认语言环境的日期&#x2F;时间格式</td>
</tr>
<tr>
<td align="center">static DateFormat getDateTimeInstance(<br>int dateStyle,int timeStyle)</td>
<td align="center">获取具有指定日期&#x2F;时间格式化风格和默认语言环境的日期&#x2F;时间格式</td>
</tr>
<tr>
<td align="center">static DateFormat getDateTimeInstance(<br>int dateStyle,int timeStyle,Locale locale)</td>
<td align="center">获取具有指定日期&#x2F;时间格式化风格和指定语言环境的日期&#x2F;时间格式</td>
</tr>
<tr>
<td align="center">static DateFormat getTimeInstance()</td>
<td align="center">获取具有默认格式化风格和默认语言环境的时间格式</td>
</tr>
<tr>
<td align="center">static DateFormat getTimeInstance(int style)</td>
<td align="center">获取具有指定格式化风格和默认语言环境的时间格式</td>
</tr>
<tr>
<td align="center">static DateFormat getTimeInstance(<br>int style, Locale locale)</td>
<td align="center">获取具有指定格式化风格和指定语言环境的时间格式</td>
</tr>
<tr>
<td align="center">void setCalendar(Calendar newCalendar)</td>
<td align="center">为此格式设置日历</td>
</tr>
<tr>
<td align="center">Date parse(String source)</td>
<td align="center">将给定的字符串解析成日期&#x2F;时间</td>
</tr>
</tbody></table>
<p>格式化样式主要通过<code>DateFormat</code>常量设置。将不同的常量传入到表所示的方法中，以控制结果的长度。<code>DateFormat</code>类的常量如下。</p>
<ul>
<li><code>SHORT</code>：完全为数字，如 12.5.10 或 5:30pm。</li>
<li><code>MEDIUM</code>：较长，如 May 10，2016。</li>
<li><code>LONG</code>：更长，如 May 12，2016 或 11:15:32am。</li>
<li><code>FULL</code>：是完全指定，如<code>Tuesday、May 10、2012 AD</code>或<code>11:l5:42am CST</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的日期</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df1</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df2</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df3</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df4</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的时间</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df5</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df6</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df7</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df8</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"><span class="comment">// 将不同格式化风格的日期格式化为日期字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">date1</span> <span class="operator">=</span> df1.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">date2</span> <span class="operator">=</span> df2.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">date3</span> <span class="operator">=</span> df3.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">date4</span> <span class="operator">=</span> df4.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// 将不同格式化风格的时间格式化为时间字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">time1</span> <span class="operator">=</span> df5.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">time2</span> <span class="operator">=</span> df6.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">time3</span> <span class="operator">=</span> df7.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">time4</span> <span class="operator">=</span> df8.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">// 输出日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;SHORT：&quot;</span> + date1 + <span class="string">&quot; &quot;</span> + time1);</span><br><span class="line">System.out.println(<span class="string">&quot;FULL：&quot;</span> + date2 + <span class="string">&quot; &quot;</span> + time2);</span><br><span class="line">System.out.println(<span class="string">&quot;MEDIUM：&quot;</span> + date3 + <span class="string">&quot; &quot;</span> + time3);</span><br><span class="line">System.out.println(<span class="string">&quot;LONG：&quot;</span> + date4 + <span class="string">&quot; &quot;</span> + time4);</span><br></pre></td></tr></table></figure>
<p>运行该段代码，输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br></pre></td></tr></table></figure>
<h2 id="SimpleDateFormat-类"><a href="#SimpleDateFormat-类" class="headerlink" title="SimpleDateFormat 类"></a>SimpleDateFormat 类</h2><p>如果使用<code>DateFormat</code>类格式化日期&#x2F;时间并不能满足要求，那么就需要使用<code>DateFormat</code>类的子类——<code>SimpleDateFormat</code>。</p>
<p><code>SimpleDateFormat</code>是一个以与语言环境有关的方式来格式化和解析日期的具体类，它允许进行格式化（日期→文本）、解析（文本→日期）和规范化。<code>SimpleDateFormat</code>使得可以选择任何用户定义的日期&#x2F;时间格式的模式。</p>
<p><code>SimpleDateFormat</code>类主要有如下 3 种构造方法。</p>
<ul>
<li><code>SimpleDateFormat()</code>：用默认的格式和默认的语言环境构造<code>SimpleDateFormat</code>。</li>
<li><code>SimpleDateFormat(String pattern)</code>：用指定的格式和默认的语言环境构造<code>SimpleDateFormat</code>。</li>
<li><code>SimpleDateFormat(String pattern,Locale locale)</code>：用指定的格式和指定的语言环境构造<code>SimpleDateFormat</code>。</li>
</ul>
<p><code>SimpleDateFormat</code>自定义格式中常用的字母及含义：</p>
<table>
<thead>
<tr>
<th align="center">字母</th>
<th align="center">含义</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y</td>
<td align="center">年份。一般用 yy 表示两位年份，yyyy 表示 4 位年份	使用 yy 表示的年扮，如 11；</td>
<td align="center">使用 yyyy 表示的年份，如 2011</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">月份。一般用 MM 表示月份，如果使用 MMM，则会根据语言环境显示不同语言的月份</td>
<td align="center">使用 MM 表示的月份，如 05；使用 MMM 表示月份，在 Locale.CHINA 语言环境下，如“十月”；在 Locale.US 语言环境下，如 Oct</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">月份中的天数。一般用 dd 表示天数</td>
<td align="center">使用 dd 表示的天数，如 10</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">年份中的天数。表示当天是当年的第几天， 用 D 表示</td>
<td align="center">使用 D 表示的年份中的天数，如 295</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">星期几。用 E 表示，会根据语言环境的不同， 显示不同语言的星期几</td>
<td align="center">使用 E 表示星期几，在 Locale.CHINA 语言环境下，如“星期四”；在 Locale.US 语言环境下，如 Thu</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">一天中的小时数（0~23)。一般用 HH 表示小时数</td>
<td align="center">使用 HH 表示的小时数，如 18</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">一天中的小时数（1~12)。一般使用 hh 表示小时数</td>
<td align="center">使用 hh 表示的小时数，如 10 (注意 10 有可能是 10 点，也可能是 22 点）</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">分钟数。一般使用 mm 表示分钟数</td>
<td align="center">使用 mm 表示的分钟数，如 29</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">秒数。一般使用 ss 表示秒数</td>
<td align="center">使用 ss 表示的秒数，如 38</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">毫秒数。一般使用 SSS 表示毫秒数</td>
<td align="center">使用 SSS 表示的毫秒数，如 156</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 创建一个Date对象，获取当前时间</span></span><br><span class="line">        <span class="comment">// 指定格式化格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今天是 &quot;</span> + <span class="string">&quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;</span>);</span><br><span class="line">        System.out.println(f.format(now)); <span class="comment">// 将当前时间袼式化为指定的格式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line">今天是 <span class="number">2018</span> 年 <span class="number">10</span> 月 <span class="number">15</span> 日 星期一 09 点 <span class="number">26</span> 分 <span class="number">23</span> 秒</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/19/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/21/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>