<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/wsq01/"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover5.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">学海无涯</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-前端/js/进阶/JS代码片段(Object、Function)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/05/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(Object%E3%80%81Function)/"
    >JS代码片段(Object、Function)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/10/05/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(Object%E3%80%81Function)/" class="article-date">
  <time datetime="2019-10-05T11:21:45.000Z" itemprop="datePublished">2019-10-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="deepClone"><a href="#deepClone" class="headerlink" title="deepClone"></a>deepClone</h2><p>创建对象的深度克隆。<br>使用递归。使用<code>object.assign()</code>和空对象创建原始对象的浅克隆。使用<code>object.keys()</code>和<code>array.prototype.foreach()</code>确定需要深度克隆哪些键值对。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = obj =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(clone).<span class="title function_">forEach</span>(</span><br><span class="line">    <span class="function"><span class="params">key</span> =&gt;</span> (clone[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepClone</span>(obj[key]) : obj[key])</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) &amp;&amp; obj.<span class="property">length</span></span><br><span class="line">    ? (clone.<span class="property">length</span> = obj.<span class="property">length</span>) &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">from</span>(clone)</span><br><span class="line">    : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)</span><br><span class="line">      ? <span class="title class_">Array</span>.<span class="title function_">from</span>(obj)</span><br><span class="line">      : clone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">obj</span>: &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">deepClone</span>(a); <span class="comment">// a !== b, a.obj !== b.obj</span></span><br></pre></td></tr></table></figure>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>对两个值进行深入比较，以确定它们是否等效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">equals</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">Date</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> a.<span class="title function_">getTime</span>() === b.<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">if</span> (!a || !b || (<span class="keyword">typeof</span> a !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> b !== <span class="string">&#x27;object&#x27;</span>)) <span class="keyword">return</span> a === b;</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">null</span> || a === <span class="literal">undefined</span> || b === <span class="literal">null</span> || b === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property"><span class="keyword">prototype</span></span> !== b.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(a);</span><br><span class="line">  <span class="keyword">if</span> (keys.<span class="property">length</span> !== <span class="title class_">Object</span>.<span class="title function_">keys</span>(b).<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> keys.<span class="title function_">every</span>(<span class="function"><span class="params">k</span> =&gt;</span> <span class="title function_">equals</span>(a[k], b[k]));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">equals</span>(&#123; <span class="attr">a</span>: [<span class="number">2</span>, &#123; <span class="attr">e</span>: <span class="number">3</span> &#125;], <span class="attr">b</span>: [<span class="number">4</span>], <span class="attr">c</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">a</span>: [<span class="number">2</span>, &#123; <span class="attr">e</span>: <span class="number">3</span> &#125;], <span class="attr">b</span>: [<span class="number">4</span>], <span class="attr">c</span>: <span class="string">&#x27;foo&#x27;</span> &#125;); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="flattenObject"><a href="#flattenObject" class="headerlink" title="flattenObject"></a>flattenObject</h2><p>扁平化对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">flattenObject</span> = (<span class="params">obj, prefix = <span class="string">&#x27;&#x27;</span></span>) =&gt;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pre = prefix.<span class="property">length</span> ? prefix + <span class="string">&#x27;.&#x27;</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[k] === <span class="string">&#x27;object&#x27;</span>) <span class="title class_">Object</span>.<span class="title function_">assign</span>(acc, <span class="title function_">flattenObject</span>(obj[k], pre + k));</span><br><span class="line">    <span class="keyword">else</span> acc[pre + k] = obj[k];</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">flattenObject</span>(&#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;, <span class="attr">d</span>: <span class="number">1</span> &#125;); <span class="comment">// &#123; &#x27;a.b.c&#x27;: 1, d: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="objectToQueryString"><a href="#objectToQueryString" class="headerlink" title="objectToQueryString"></a>objectToQueryString</h2><p>将对象转换为查询字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">objectToQueryString</span> = queryParameters =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> queryParameters</span><br><span class="line">    ? <span class="title class_">Object</span>.<span class="title function_">entries</span>(queryParameters).<span class="title function_">reduce</span>(<span class="function">(<span class="params">queryString, [key, val], index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> symbol = queryString.<span class="property">length</span> === <span class="number">0</span> ? <span class="string">&#x27;?&#x27;</span> : <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">      queryString += <span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span> ? <span class="string">`<span class="subst">$&#123;symbol&#125;</span><span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;val&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> queryString;</span><br><span class="line">    &#125;, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">objectToQueryString</span>(&#123; <span class="attr">page</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">size</span>: <span class="string">&#x27;2kg&#x27;</span>, <span class="attr">key</span>: <span class="literal">undefined</span> &#125;); <span class="comment">// &#x27;?page=1&amp;size=2kg&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h2><p>从对象中选取与给定键对应的键值对。<br>使用<code>array.prototype.reduce()</code>将筛选&#x2F;选取的键转换回具有相应键值对的对象（如果该键存在于对象中）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">pick</span> = (<span class="params">obj, arr</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> (curr <span class="keyword">in</span> obj &amp;&amp; (acc[curr] = obj[curr]), acc), &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">pick</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]); <span class="comment">// &#123; &#x27;a&#x27;: 1, &#x27;c&#x27;: 3 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="renameKeys"><a href="#renameKeys" class="headerlink" title="renameKeys"></a>renameKeys</h2><p>用提供的值替换多个对象键的名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">renameKeys</span> = (<span class="params">keysMap, obj</span>) =&gt;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc, key</span>) =&gt;</span> (&#123;</span><br><span class="line">      ...acc,</span><br><span class="line">      ...&#123; [keysMap[key] || key]: obj[key] &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bobo&#x27;</span>, <span class="attr">job</span>: <span class="string">&#x27;Front-End Master&#x27;</span>, <span class="attr">shoeSize</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="title function_">renameKeys</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;firstName&#x27;</span>, <span class="attr">job</span>: <span class="string">&#x27;passion&#x27;</span> &#125;, obj); <span class="comment">// &#123; firstName: &#x27;Bobo&#x27;, passion: &#x27;Front-End Master&#x27;, shoeSize: 100 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="shallowClone"><a href="#shallowClone" class="headerlink" title="shallowClone"></a>shallowClone</h2><p>创建一个对象的浅拷贝。<br>使用<code>Object.assign()</code>和一个空对象(<code>&#123;&#125;</code>)来创建原始对象的浅拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shallowClone</span> = obj =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="literal">true</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">shallowClone</span>(a); <span class="comment">// a !== b</span></span><br></pre></td></tr></table></figure>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>获取数组，对象或字符串的大小。<br>获取<code>val</code>（<code>array</code>，<code>object</code>或<code>string</code>）的类型。 对于数组使用<code>length</code>属性。 对于对象，使用<code>length</code>或<code>size</code>如果可用的话，或者对象的键的数量。对于字符串，使用根据<code>val</code>创建的<code>Blob</code>对象的<code>size</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">size</span> = val =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">isArray</span>(val)</span><br><span class="line">    ? val.<span class="property">length</span></span><br><span class="line">    : val &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">      ? val.<span class="property">size</span> || val.<span class="property">length</span> || <span class="title class_">Object</span>.<span class="title function_">keys</span>(val).<span class="property">length</span></span><br><span class="line">      : <span class="keyword">typeof</span> val === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">        ? <span class="keyword">new</span> <span class="title class_">Blob</span>([val]).<span class="property">size</span></span><br><span class="line">        : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">size</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">size</span>(<span class="string">&#x27;size&#x27;</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">size</span>(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span>, <span class="attr">three</span>: <span class="number">3</span> &#125;); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="unflattenObject"><a href="#unflattenObject" class="headerlink" title="unflattenObject"></a>unflattenObject</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unflattenObject</span> = obj =&gt;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k.<span class="title function_">indexOf</span>(<span class="string">&#x27;.&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> keys = k.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">        acc,</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">parse</span>(</span><br><span class="line">          <span class="string">&#x27;&#123;&#x27;</span> +</span><br><span class="line">            keys.<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (i !== keys.<span class="property">length</span> - <span class="number">1</span> ? <span class="string">`&quot;<span class="subst">$&#123;v&#125;</span>&quot;:&#123;`</span> : <span class="string">`&quot;<span class="subst">$&#123;v&#125;</span>&quot;:`</span>)).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">            obj[k] +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>.<span class="title function_">repeat</span>(keys.<span class="property">length</span>)</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> acc[k] = obj[k];</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">unflattenObject</span>(&#123; <span class="string">&#x27;a.b.c&#x27;</span>: <span class="number">1</span>, <span class="attr">d</span>: <span class="number">1</span> &#125;); <span class="comment">// &#123; a: &#123; b: &#123; c: 1 &#125; &#125;, d: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h2 id="curry"><a href="#curry" class="headerlink" title="curry"></a>curry</h2><p>柯里化一个函数。<br>使用递归。 如果提供的参数(<code>args</code>)数量足够，调用传递函数<code>fn</code>。否则返回一个柯里化后的函数 fn ，期望剩下的参数。如果你想柯里化一个接受可变参数数量的函数(可变参数数量的函数，例如 Math.min() )，你可以选择将参数个数传递给第二个参数 arity。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">curry</span> = (<span class="params">fn, arity = fn.length, ...args</span>) =&gt;</span><br><span class="line">  arity &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, arity, ...args);</span><br><span class="line"></span><br><span class="line"><span class="title function_">curry</span>(<span class="title class_">Math</span>.<span class="property">pow</span>)(<span class="number">2</span>)(<span class="number">10</span>); <span class="comment">// 1024</span></span><br><span class="line"><span class="title function_">curry</span>(<span class="title class_">Math</span>.<span class="property">min</span>, <span class="number">3</span>)(<span class="number">10</span>)(<span class="number">50</span>)(<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><p>确保函数只被调用一次。<br>使用一个闭包，使用一个成为<code>called</code>的标志，并在第一次调用该函数时将其设置为<code>rue</code>，以防止它被再次调用。 为了允许函数改变它的<code>this</code>上下文（比如在一个事件监听器中），必须使用<code>function</code>关键字，并且提供的函数必须应用上下文。 允许使用<code>rest</code>（剩余）&#x2F;<code>spread</code>（展开） (<code>...</code>) 运算符为函数提供任意数量的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">once</span> = fn =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">    called = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startApp = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, event); <span class="comment">// document.body, MouseEvent</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">once</span>(startApp));</span><br><span class="line"><span class="comment">// only runs `startApp` once upon click</span></span><br></pre></td></tr></table></figure>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>延迟异步函数的执行。<br>延迟执行<code>async</code>函数的一部分，通过把它放到<code>sleep</code>状态，返回一个<code>Promise</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sleep</span> = ms =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleepyWork</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I&#x27;m going to sleep for 1 second.&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I woke up after 1 second.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h2><p>节流。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, wait</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> inThrottle, lastFn, lastTime;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>,</span><br><span class="line">      args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inThrottle) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      lastTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      inThrottle = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(lastFn);</span><br><span class="line">      lastFn = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - lastTime &gt;= wait) &#123;</span><br><span class="line">          fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">          lastTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="title class_">Math</span>.<span class="title function_">max</span>(wait - (<span class="title class_">Date</span>.<span class="title function_">now</span>() - lastTime), <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;resize&#x27;</span>,</span><br><span class="line">  <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  &#125;, <span class="number">250</span>)</span><br><span class="line">); <span class="comment">// Will log the window dimensions at most every 250ms</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS代码片段(Math、Date)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/02/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(Math%E3%80%81Date)/"
    >JS代码片段(Math、Date)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/10/02/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(Math%E3%80%81Date)/" class="article-date">
  <time datetime="2019-10-02T07:11:41.000Z" itemprop="datePublished">2019-10-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="average"><a href="#average" class="headerlink" title="average"></a>average</h2><p>返回两个或两个以上数字的的平均值。<br>使用<code>Array.reduce()</code>将每个值累加到初始值0的累加器， 除以数组长度<code>length</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">average</span> = (<span class="params">...nums</span>) =&gt; nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>) / nums.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">average</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">average</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="averageBy"><a href="#averageBy" class="headerlink" title="averageBy"></a>averageBy</h2><p>使用提供的函数将每个元素映射到一个值后，返回一个数组的平均值。<br>使用<code>Array.map()</code>将每个元素映射到由<code>fn</code>返回的值，<code>Array.reduce()</code>将每个值累加到累加器，用0作为累加器的初始值，再除以数组的<code>length</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">averageBy</span> = (<span class="params">arr, fn</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">map</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? fn : <span class="function"><span class="params">val</span> =&gt;</span> val[fn]).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>) /</span><br><span class="line">  arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">averageBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="function"><span class="params">o</span> =&gt;</span> o.<span class="property">n</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">averageBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="string">&#x27;n&#x27;</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="clampNumber"><a href="#clampNumber" class="headerlink" title="clampNumber"></a>clampNumber</h2><p>返回由边界值<code>a</code>和<code>b</code>限定范围内的<code>num</code>。<br>如果<code>num</code>在限定范围内，则返回<code>num</code>。 否则，返回范围内最接近的数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">clampNumber</span> = (<span class="params">num, a, b</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(num, <span class="title class_">Math</span>.<span class="title function_">max</span>(a, b)), <span class="title class_">Math</span>.<span class="title function_">min</span>(a, b));</span><br><span class="line"></span><br><span class="line"><span class="title function_">clampNumber</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">clampNumber</span>(<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">5</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h2 id="digitize"><a href="#digitize" class="headerlink" title="digitize"></a>digitize</h2><p>将数字转换为数字数组。<br>将数字转换为字符串，使用展开运算符 (<code>...</code>) 构建一个数组。 使用<code>Array.map()</code>和<code>parseInt()</code>将每个值转换为整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">digitize</span> = n =&gt; [...<span class="string">`<span class="subst">$&#123;n&#125;</span>`</span>].<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">parseInt</span>(i));</span><br><span class="line"></span><br><span class="line"><span class="title function_">digitize</span>(<span class="number">123</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="distance"><a href="#distance" class="headerlink" title="distance"></a>distance</h2><p>返回两点之间的欧氏距离。<br>使用<code>Math.hypot()</code>计算两点之间的欧氏距离( <code>Euclidean distance</code>)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">distance</span> = (<span class="params">x0, y0, x1, y1</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">hypot</span>(x1 - x0, y1 - y0);</span><br><span class="line"></span><br><span class="line"><span class="title function_">distance</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 2.23606797749979</span></span><br></pre></td></tr></table></figure>
<h2 id="factorial"><a href="#factorial" class="headerlink" title="factorial"></a>factorial</h2><p>计算一个数字的阶乘。<br>使用递归。如果<code>n</code>小于或等于1 ，则返回1 。否则返回<code>n</code>和<code>n - 1</code>的阶乘。如果<code>n</code>是负数，则会引发异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">factorial</span> = n =&gt;</span><br><span class="line">  n &lt; <span class="number">0</span></span><br><span class="line">    ? (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Negative numbers are not allowed!&#x27;</span>);</span><br><span class="line">    &#125;)()</span><br><span class="line">    : n &lt;= <span class="number">1</span></span><br><span class="line">      ? <span class="number">1</span></span><br><span class="line">      : n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">6</span>); <span class="comment">// 720</span></span><br></pre></td></tr></table></figure>
<h2 id="fibonacci"><a href="#fibonacci" class="headerlink" title="fibonacci"></a>fibonacci</h2><p>生成一个包含斐波纳契数组，直到该数组有第<code>n</code>元素。<br>创建一个指定长度的空数组，初始化前两个值( 0和1 )。使用<code>Array.reduce()</code>向数组中添加值，该值是最后两个值的和，前两个值除外。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fibonacci</span> = n =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;).<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc, val, i</span>) =&gt;</span> acc.<span class="title function_">concat</span>(i &gt; <span class="number">1</span> ? acc[i - <span class="number">1</span>] + acc[i - <span class="number">2</span>] : i),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="title function_">fibonacci</span>(<span class="number">6</span>); <span class="comment">// [0, 1, 1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h2><p>计算两个或两个以上数字&#x2F;数字数组的最大公约数。<br>内部的<code>_gcd</code>函数使用递归。基本情况是，当<code>y</code>等于0的情况下，返回<code>x</code>。否则，返回<code>y</code>的最大公约数和<code>x / y</code>的其余数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">gcd</span> = (<span class="params">...arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">_gcd</span> = (<span class="params">x, y</span>) =&gt; (!y ? x : <span class="title function_">gcd</span>(y, x % y));</span><br><span class="line">  <span class="keyword">return</span> [...arr].<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">_gcd</span>(a, b));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">gcd</span>(<span class="number">8</span>, <span class="number">36</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">gcd</span>(...[<span class="number">12</span>, <span class="number">8</span>, <span class="number">32</span>]); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h2 id="geometricProgression"><a href="#geometricProgression" class="headerlink" title="geometricProgression"></a>geometricProgression</h2><p>初始化一个包含指定范围中数字的数组，包含<code>start</code>和<code>end</code>，两个元素之间的比例是<code>step</code>（后一个数是前一个数的<code>step</code>倍）。 如果<code>step</code>等于1则返回一个错误。<br>使用<code>Array.from()</code>，<code>Math.log()</code>和<code>Math.floor()</code>来创建一个所需长度的数组，使用<code>Array.map()</code>来填充所需的值。省略第二个参数<code>start</code>，使用默认值1。省略第三个参数<code>step</code>，使用默认值2。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">geometricProgression</span> = (<span class="params">end, start = <span class="number">1</span>, step = <span class="number">2</span></span>) =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">log</span>(end / start) / <span class="title class_">Math</span>.<span class="title function_">log</span>(step)) + <span class="number">1</span> &#125;).<span class="title function_">map</span>(</span><br><span class="line">    <span class="function">(<span class="params">v, i</span>) =&gt;</span> start * step ** i</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="title function_">geometricProgression</span>(<span class="number">256</span>); <span class="comment">// [1, 2, 4, 8, 16, 32, 64, 128, 256]</span></span><br><span class="line"><span class="title function_">geometricProgression</span>(<span class="number">256</span>, <span class="number">3</span>); <span class="comment">// [3, 6, 12, 24, 48, 96, 192]</span></span><br><span class="line"><span class="title function_">geometricProgression</span>(<span class="number">256</span>, <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// [1, 4, 16, 64, 256]</span></span><br></pre></td></tr></table></figure>
<h2 id="inRange"><a href="#inRange" class="headerlink" title="inRange"></a>inRange</h2><p>检查给定的数字是否在给定范围内。<br>使用算术比较来检查给定的数字是否在指定的范围内。如果没有指定第三个参数<code>end</code>，则范围被认为是从0到<code>start</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">inRange</span> = (<span class="params">n, start, end = <span class="literal">null</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (end &amp;&amp; start &gt; end) [end, start] = [start, end];</span><br><span class="line">  <span class="keyword">return</span> end == <span class="literal">null</span> ? n &gt;= <span class="number">0</span> &amp;&amp; n &lt; start : n &gt;= start &amp;&amp; n &lt; end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inRange</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">inRange</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">inRange</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">inRange</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="isDivisible"><a href="#isDivisible" class="headerlink" title="isDivisible"></a>isDivisible</h2><p>检查第一个数字参数是否可被第二个数字整除。<br>使用模运算符(<code>%</code>)来检查余数是否等于0 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isDivisible</span> = (<span class="params">dividend, divisor</span>) =&gt; dividend % divisor === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isDivisible</span>(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="isEven"><a href="#isEven" class="headerlink" title="isEven"></a>isEven</h2><p>如果给定的数字是偶数，则返回<code>true</code>，否则返回<code>false</code>。<br>使用模运算符(<code>%</code>)来检查数字是奇数还是偶数。如果数字是偶数，则返回<code>true</code>，如果是奇数，则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isEven</span> = num =&gt; num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isEven</span>(<span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="isPrime"><a href="#isPrime" class="headerlink" title="isPrime"></a>isPrime</h2><p>检查提供的整数是否为素数。<br>检查数字从2到给定数字的平方根。如果它们中的任何一个可以整除给定的数字，则返回<code>false</code>，否则返回<code>true</code>，除非数字小于2。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isPrime</span> = num =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> boundary = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(num));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt;= boundary; i++) <span class="keyword">if</span> (num % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> num &gt;= <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isPrime</span>(<span class="number">11</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="lcm"><a href="#lcm" class="headerlink" title="lcm"></a>lcm</h2><p>返回两个或两个以上数字的最小公倍数。<br>使用最大公约数（GCD）公式和<code>lcm(x,y) = x * y / gcd(x,y)</code>来确定最小公倍数。 GCD公式使用递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">lcm</span> = (<span class="params">...arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">gcd</span> = (<span class="params">x, y</span>) =&gt; (!y ? x : <span class="title function_">gcd</span>(y, x % y));</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">_lcm</span> = (<span class="params">x, y</span>) =&gt; (x * y) / <span class="title function_">gcd</span>(x, y);</span><br><span class="line">  <span class="keyword">return</span> [...arr].<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">_lcm</span>(a, b));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">lcm</span>(<span class="number">12</span>, <span class="number">7</span>); <span class="comment">// 84</span></span><br><span class="line"><span class="title function_">lcm</span>(...[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>
<h2 id="maxBy"><a href="#maxBy" class="headerlink" title="maxBy"></a>maxBy</h2><p>使用提供的函数将每个元素映射到一个值后，然后返回数组的最大值。<br>使用<code>Array.map()</code>将每个元素映射到由<code>fn</code>，然后用<code>Math.max()</code>返回的值来获取最大值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxBy</span> = (<span class="params">arr, fn</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr.<span class="title function_">map</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? fn : <span class="function"><span class="params">val</span> =&gt;</span> val[fn]));</span><br><span class="line"></span><br><span class="line"><span class="title function_">maxBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="function"><span class="params">o</span> =&gt;</span> o.<span class="property">n</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="title function_">maxBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="string">&#x27;n&#x27;</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h2 id="median"><a href="#median" class="headerlink" title="median"></a>median</h2><p>返回数字数组的中值。<br>找到数字数组的中间值，使用 <code>Array.sort()</code>对值进行排序。 如果<code>length</code>是奇数，则返回中间值数字，否则返回两个中间值数值的平均值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">median</span> = arr =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>),</span><br><span class="line">    nums = [...arr].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="property">length</span> % <span class="number">2</span> !== <span class="number">0</span> ? nums[mid] : (nums[mid - <span class="number">1</span>] + nums[mid]) / <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">median</span>([<span class="number">5</span>, <span class="number">6</span>, <span class="number">50</span>, <span class="number">1</span>, -<span class="number">5</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="minBy"><a href="#minBy" class="headerlink" title="minBy"></a>minBy</h2><p>使用提供的函数将每个元素映射到一个值后，然后返回数组的最小值。<br>使用<code>Array.map()</code>将每个元素映射到由<code>fn</code>，然后用<code>Math.min()</code>返回的值来获取最小值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">minBy</span> = (<span class="params">arr, fn</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">min</span>(...arr.<span class="title function_">map</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? fn : <span class="function"><span class="params">val</span> =&gt;</span> val[fn]));</span><br><span class="line"></span><br><span class="line"><span class="title function_">minBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="function"><span class="params">o</span> =&gt;</span> o.<span class="property">n</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">minBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="string">&#x27;n&#x27;</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="percentile"><a href="#percentile" class="headerlink" title="percentile"></a>percentile</h2><p>使用百分比表示给定数组中有多少个数字小于或等于给定值。<br>使用<code>Array.reduce()</code>来计算有多少个数字小于等于该值，并用百分比表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">percentile</span> = (<span class="params">arr, val</span>) =&gt;</span><br><span class="line">  (<span class="number">100</span> * arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, v</span>) =&gt;</span> acc + (v &lt; val ? <span class="number">1</span> : <span class="number">0</span>) + (v === val ? <span class="number">0.5</span> : <span class="number">0</span>), <span class="number">0</span>)) / arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">percentile</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], <span class="number">6</span>); <span class="comment">// 55</span></span><br></pre></td></tr></table></figure>
<h2 id="powerset"><a href="#powerset" class="headerlink" title="powerset"></a>powerset</h2><p>返回给定数组的<code>powerset</code>(幂集)。<br>使用<code>Array.reduce()</code>与<code>Array.map()</code>结合来遍历元素，并将其组合成一个包含所有排列组合的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">powerset</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a.<span class="title function_">concat</span>(a.<span class="title function_">map</span>(<span class="function"><span class="params">r</span> =&gt;</span> [v].<span class="title function_">concat</span>(r))), [[]]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">powerset</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// [[], [1], [2], [2, 1]]</span></span><br></pre></td></tr></table></figure>
<h2 id="randomIntArrayInRange"><a href="#randomIntArrayInRange" class="headerlink" title="randomIntArrayInRange"></a>randomIntArrayInRange</h2><p>返回指定范围内<code>n</code>个随机整数的数组。<br>使用<code>array.from()</code>创建一个特定长度的空数组<code>math.random()</code>，生成一个随机数并将其映射到所需的范围，使用<code>math.floor()</code>将其设置为整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">randomIntArrayInRange</span> = (<span class="params">min, max, n = <span class="number">1</span></span>) =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;, <span class="function">() =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>)) + min);</span><br><span class="line"></span><br><span class="line"><span class="title function_">randomIntArrayInRange</span>(<span class="number">12</span>, <span class="number">35</span>, <span class="number">10</span>); <span class="comment">// [ 34, 14, 27, 17, 30, 27, 20, 26, 21, 14 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="randomIntegerInRange"><a href="#randomIntegerInRange" class="headerlink" title="randomIntegerInRange"></a>randomIntegerInRange</h2><p>返回指定范围内的随机整数。<br>使用<code>Math.random()</code>生成一个随机数并将其映射到所需的范围，使用<code>Math.floor()</code>使其成为一个整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">randomIntegerInRange</span> = (<span class="params">min, max</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line"></span><br><span class="line"><span class="title function_">randomIntegerInRange</span>(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="randomNumberInRange"><a href="#randomNumberInRange" class="headerlink" title="randomNumberInRange"></a>randomNumberInRange</h2><p>返回指定范围内的一个随机数。<br>使用<code>Math.random()</code>生成一个随机值，使用乘法将其映射到所需的范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">randomNumberInRange</span> = (<span class="params">min, max</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min) + min;</span><br><span class="line"></span><br><span class="line"><span class="title function_">randomNumberInRange</span>(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 6.0211363285087005</span></span><br></pre></td></tr></table></figure>
<h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><p>将数字四舍五入到指定的小数位数。<br>使用<code>Math.round()</code>和模板字面量将数字四舍五入为指定的小数位数。 省略第二个参数<code>decimals</code>，数字将被四舍五入到一个整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">round</span> = (<span class="params">n, decimals = <span class="number">0</span></span>) =&gt; <span class="title class_">Number</span>(<span class="string">`<span class="subst">$&#123;<span class="built_in">Math</span>.round(<span class="string">`<span class="subst">$&#123;n&#125;</span>e<span class="subst">$&#123;decimals&#125;</span>`</span>)&#125;</span>e-<span class="subst">$&#123;decimals&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">round</span>(<span class="number">1.005</span>, <span class="number">2</span>); <span class="comment">// 1.01</span></span><br></pre></td></tr></table></figure>
<h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p>返回两个或两个以上数字&#x2F;数字数组中元素之和。<br>使用<code>Array.reduce()</code>将每个值添加到累加器，并且累加器初始值为0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">...arr</span>) =&gt; [...arr].<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">sum</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h2 id="sumBy"><a href="#sumBy" class="headerlink" title="sumBy"></a>sumBy</h2><p>使用提供的函数将每个元素映射到一个值之后，然后返回数组的和。<br>使用<code>Array.map()</code>将每个元素映射到由<code>fn</code>返回的值，<code>Array.reduce()</code>将每个值添加到一个累加器，并且累加器初始值为0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sumBy</span> = (<span class="params">arr, fn</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">map</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? fn : <span class="function"><span class="params">val</span> =&gt;</span> val[fn]).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sumBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="function"><span class="params">o</span> =&gt;</span> o.<span class="property">n</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="title function_">sumBy</span>([&#123; <span class="attr">n</span>: <span class="number">4</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">8</span> &#125;, &#123; <span class="attr">n</span>: <span class="number">6</span> &#125;], <span class="string">&#x27;n&#x27;</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h2 id="toSafeInteger"><a href="#toSafeInteger" class="headerlink" title="toSafeInteger"></a>toSafeInteger</h2><p>将值转换为安全整数。<br>使用<code>Math.max()</code>和<code>Math.min()</code>来找到最接近的安全值。 使用<code>Math.round()</code>转换为一个整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">toSafeInteger</span> = num =&gt;</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(num, <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>), <span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span>));</span><br><span class="line"></span><br><span class="line"><span class="title function_">toSafeInteger</span>(<span class="string">&#x27;3.2&#x27;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">toSafeInteger</span>(<span class="title class_">Infinity</span>); <span class="comment">// 9007199254740991</span></span><br></pre></td></tr></table></figure>
<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><h2 id="formatDuration"><a href="#formatDuration" class="headerlink" title="formatDuration"></a>formatDuration</h2><p>返回给定毫秒数的可读格式。<br>用适当的值来划分<code>ms</code>，以获得<code>day，hour，minute，second</code>和<code>millisecond</code>的适当值。通过<code>Array.filter()</code>使用<code>Object.entries()</code>只保留非零值。使用<code>Array.map()</code>为每个值创建字符串，并且适当复数化。使用<code>String.join(&#39;, &#39;)</code>将这些值组合成一个字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">formatDuration</span> = ms =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ms &lt; <span class="number">0</span>) ms = -ms;</span><br><span class="line">  <span class="keyword">const</span> time = &#123;</span><br><span class="line">    <span class="attr">day</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(ms / <span class="number">86400000</span>),</span><br><span class="line">    <span class="attr">hour</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(ms / <span class="number">3600000</span>) % <span class="number">24</span>,</span><br><span class="line">    <span class="attr">minute</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(ms / <span class="number">60000</span>) % <span class="number">60</span>,</span><br><span class="line">    <span class="attr">second</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(ms / <span class="number">1000</span>) % <span class="number">60</span>,</span><br><span class="line">    <span class="attr">millisecond</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(ms) % <span class="number">1000</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(time)</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function"><span class="params">val</span> =&gt;</span> val[<span class="number">1</span>] !== <span class="number">0</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">[key, val]</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;val&#125;</span> <span class="subst">$&#123;key&#125;</span><span class="subst">$&#123;val !== <span class="number">1</span> ? <span class="string">&#x27;s&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>)</span><br><span class="line">    .<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">formatDuration</span>(<span class="number">1001</span>); <span class="comment">// &#x27;1 second, 1 millisecond&#x27;</span></span><br><span class="line"><span class="title function_">formatDuration</span>(<span class="number">34325055574</span>); </span><br><span class="line"><span class="comment">// &#x27;397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="getColonTimeFromDate"><a href="#getColonTimeFromDate" class="headerlink" title="getColonTimeFromDate"></a>getColonTimeFromDate</h2><p>从日期对象返回格式为<code>hh:mm:ss</code>的字符串。<br>使用<code>date.prototype.toTimeString()</code>和<code>string.prototype.slice()</code>获取给定日期对象的<code>hh:mm:ss</code>部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getColonTimeFromDate</span> = date =&gt; date.<span class="title function_">toTimeString</span>().<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">getColonTimeFromDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// &quot;08:38:00&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="getDaysDiffBetweenDates"><a href="#getDaysDiffBetweenDates" class="headerlink" title="getDaysDiffBetweenDates"></a>getDaysDiffBetweenDates</h2><p>返回两个日期之间相差的天数。<br>计算<code>Date</code>对象之间的差异(以天为单位)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getDaysDiffBetweenDates</span> = (<span class="params">dateInitial, dateFinal</span>) =&gt;</span><br><span class="line">  (dateFinal - dateInitial) / (<span class="number">1000</span> * <span class="number">3600</span> * <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">getDaysDiffBetweenDates</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2017-12-13&#x27;</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2017-12-22&#x27;</span>)); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h2 id="isSameDate"><a href="#isSameDate" class="headerlink" title="isSameDate"></a>isSameDate</h2><p>判断两个日期是否相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isSameDate</span> = (<span class="params">dateA, dateB</span>) =&gt; dateA.<span class="title function_">toISOString</span>() === dateB.<span class="title function_">toISOString</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">isSameDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">20</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="isBeforeDate"><a href="#isBeforeDate" class="headerlink" title="isBeforeDate"></a>isBeforeDate</h2><p>检查一个日期是否在另一个日期之前。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isBeforeDate</span> = (<span class="params">dateA, dateB</span>) =&gt; dateA &lt; dateB;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isBeforeDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">20</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">21</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="isAfterDate"><a href="#isAfterDate" class="headerlink" title="isAfterDate"></a>isAfterDate</h2><p>检查一个日期是否在另一个日期之后。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isAfterDate</span> = (<span class="params">dateA, dateB</span>) =&gt; dateA &gt; dateB;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isAfterDate</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">21</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="isWeekend"><a href="#isWeekend" class="headerlink" title="isWeekend"></a>isWeekend</h2><p>判断特定的日期是否是周六日</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isWeekend</span> = (<span class="params">t = <span class="keyword">new</span> <span class="built_in">Date</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> t.<span class="title function_">getDay</span>() % <span class="number">6</span> === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isWeekend</span>()</span><br></pre></td></tr></table></figure>
<h2 id="isWeekday"><a href="#isWeekday" class="headerlink" title="isWeekday"></a>isWeekday</h2><p>判断是否是工作日</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isWeekday</span> = (<span class="params">t = <span class="keyword">new</span> <span class="built_in">Date</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> t.<span class="title function_">getDay</span>() % <span class="number">6</span> !== <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">isWeekday</span>()</span><br></pre></td></tr></table></figure>
<h2 id="tomorrow"><a href="#tomorrow" class="headerlink" title="tomorrow"></a>tomorrow</h2><p>以字符串形式返回明天日期表示。<br>使用<code>new Date()</code>获取今天的日期，加上86400000秒（24小时），使用<code>Date.toISOString()</code>将<code>Date</code>对象转换为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">tomorrow</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  t.<span class="title function_">setDate</span>(t.<span class="title function_">getDate</span>() + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> t.<span class="title function_">toISOString</span>().<span class="title function_">split</span>(<span class="string">&#x27;T&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">tomorrow</span>(); <span class="comment">// 2020-10-18</span></span><br></pre></td></tr></table></figure>
<h2 id="yesterday"><a href="#yesterday" class="headerlink" title="yesterday"></a>yesterday</h2><p>返回昨天的日期。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">yesterday</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  t.<span class="title function_">setDate</span>(t.<span class="title function_">getDate</span>() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> t.<span class="title function_">toISOString</span>().<span class="title function_">split</span>(<span class="string">&#x27;T&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">yesterday</span>() <span class="comment">// // 2020-10-17</span></span><br></pre></td></tr></table></figure>
<h2 id="maxDate"><a href="#maxDate" class="headerlink" title="maxDate"></a>maxDate</h2><p>返回给定日期中的最大日期。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxDate</span> = dates =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...dates));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2017</span>, <span class="number">4</span>, <span class="number">13</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">12</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>, <span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">];</span><br><span class="line"><span class="title function_">maxDate</span>(array); <span class="comment">// 2018-03-11T22:00:00.000Z</span></span><br></pre></td></tr></table></figure>
<h2 id="minDate"><a href="#minDate" class="headerlink" title="minDate"></a>minDate</h2><p>返回给定日期中的最小日期</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">minDate</span> = dates =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(...dates));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2017</span>, <span class="number">4</span>, <span class="number">13</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">12</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>, <span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line">];</span><br><span class="line"><span class="title function_">minDate</span>(array); <span class="comment">// 2016-01-08T22:00:00.000Z</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS 防抖和节流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/09/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%20%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"
    >JS防抖和节流</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/09/09/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%20%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/" class="article-date">
  <time datetime="2019-09-09T11:38:18.000Z" itemprop="datePublished">2019-09-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>事件的触发权很多时候都属于用户，有些情况下会产生问题：</p>
<ul>
<li>向后台发送数据，用户频繁触发，对服务器造成压力</li>
<li>一些浏览器事件：<code>window.onresize</code>、<code>window.mousemove</code>等，触发的频率非常高，会造成浏览器性能问题</li>
</ul>
<p>如果碰到这些问题，那就需要用到函数节流和防抖了。</p>
<h1 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h1><p>函数节流：一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。<br>有个需要频繁触发函数，出于优化性能角度，在规定时间内，只让函数触发的第一次生效，后面不生效。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h4 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h4><p>其原理是用时间戳来判断是否已到回调该执行时间，记录上次执行的时间戳，然后每次触发<code>scroll</code>事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经到达 规定时间段，如果是，则执行，并更新上次执行的时间戳，如此循环。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录上一次函数触发的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback, wait = <span class="number">800</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记录当前函数触发的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    <span class="keyword">if</span> (now - last &gt; wait) &#123;</span><br><span class="line">      <span class="title function_">callback</span>()</span><br><span class="line">      last = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scroll事件被触发了&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>()) &#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h4><p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/3534846-15d3f2fb17430362?imageMogr2/auto-orient/strip"></p>
<p>上例中用到了闭包的特性–可以使变量<code>lastTime</code>的值长期保存在内存中。</p>
<h2 id="函数节流的应用场景"><a href="#函数节流的应用场景" class="headerlink" title="函数节流的应用场景"></a>函数节流的应用场景</h2><p>需要间隔一定时间触发回调来控制函数调用频率：</p>
<ul>
<li>DOM 元素的拖拽功能实现（<code>mousemove</code>）</li>
<li>搜索联想（<code>keyup</code>）</li>
<li>计算鼠标移动的距离（<code>mousemove</code>）</li>
<li>Canvas 模拟画板功能（<code>mousemove</code>）</li>
<li>射击游戏的<code>mousedown/keydown</code>事件（单位时间只能发射一颗子弹）</li>
<li>监听滚动事件判断是否到页面底部自动加载更多：给<code>scroll</code>加了<code>debounce</code>后，只有用户停止滚动后，才会判断是否到了页面底部；如果是<code>throttle</code>的话，只要页面滚动就会间隔一段时间判断一次</li>
</ul>
<h1 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h1><p>函数防抖：一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。</p>
<h2 id="如何实现-1"><a href="#如何实现-1" class="headerlink" title="如何实现"></a>如何实现</h2><p>其原理就是第一次调用函数，创建一个定时器，在指定的时间间隔之后运行代码。当第二次调用该函数时，它会清除前一次的定时器并设置另一个。如果前一个定时器已经执行过了，这个操作就没有任何意义。然而，如果前一个定时器尚未执行，其实就是将其替换为一个新的定时器，然后延迟一定时间再执行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&#x27;btn&#x27;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件被触发&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="title function_">debounce</span>(bindClick, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="keyword">const</span> debounce = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录上一次的延时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback, wait = <span class="number">800</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除上一次延时器</span></span><br><span class="line">    timer &amp;&amp; <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(callback, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加载数据&#x27;</span>) &#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们在<code>onclick</code>事件中使用<code>console.log(this)</code>，在不使用<code>debounce</code>函数的时候，<code>this</code>指向<code>button</code>按钮。但是如果使用<code>debounce</code>函数，<code>this</code>就会指向<code>Window</code>对象！所以我们需要将<code>this</code>指向正确的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="comment">// 记录上一次的延时器</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除上一次延时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 在事件处理函数中会提供事件对象<code>event</code>，我们修改下<code>bindClick</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们不使用<code>debouce</code>函数，会打印<code>Event</code>对象，但是在<code>debounce</code>函数中，会打印<code>undefined</code>，所以我们需要在<code>debounce</code>函数里处理下参数问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="comment">// 记录上一次的延时器</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 清除上一次延时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/40b8a595e6b9d4c3bd9e7e13546671792b994c23/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31312f32312f313637333661353432636131373039393f773d36363726683d31363026663d67696626733d3738323031"><img src="https://upload-images.jianshu.io/upload_images/3534846-ff82b940cfa30285?imageMogr2/auto-orient/strip"></a> </p>
<p>上例中也用到了闭包的特性–可以使变量<code>timer</code>的值长期保存在内存中。</p>
<h2 id="函数防抖的应用场景"><a href="#函数防抖的应用场景" class="headerlink" title="函数防抖的应用场景"></a>函数防抖的应用场景</h2><p>对于连续的事件响应我们只需要执行一次回调：</p>
<ul>
<li>每次<code>resize/scroll</code>触发统计事件</li>
<li>文本输入的验证（连续输入文字后发送AJAX请求进行验证，验证一次就好）</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>函数节流和函数去抖的核心其实就是限制某一个方法被频繁触发，而一个方法之所以会被频繁触发，大多数情况下是因为DOM事件的监听回调，而这也是函数节流以及防抖多数情况下的应用场景。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS 代码片段(Array)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/06/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%20%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(Array)/"
    >JS代码片段(Array)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/09/06/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%20%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5(Array)/" class="article-date">
  <time datetime="2019-09-06T11:08:18.000Z" itemprop="datePublished">2019-09-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>函数封装了<code>every</code>函数，判断条件默认为元素转为<code>boolean</code>值，如果都为<code>true</code>，则返回<code>true</code>。否则，返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">all</span> = (<span class="params">arr, fn = <span class="built_in">Boolean</span></span>) =&gt; arr.<span class="title function_">every</span>(fn);</span><br><span class="line"></span><br><span class="line"><span class="title function_">all</span>([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">all</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="allEqual"><a href="#allEqual" class="headerlink" title="allEqual"></a>allEqual</h2><p>检查数组中的所有元素是否相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">allEqual</span> = arr =&gt; arr.<span class="title function_">every</span>(<span class="function"><span class="params">val</span> =&gt;</span> val === arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">allEqual</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">allEqual</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>检查数组中的所有元素是否基于<code>fn</code>返回<code>true</code>。只要数组元素有一个转为<code>true</code>，则返回<code>true</code>。省略第二个参数<code>fn</code>，将布尔值用作默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">any</span> = (<span class="params">arr, fn = <span class="built_in">Boolean</span></span>) =&gt; arr.<span class="title function_">some</span>(fn);</span><br><span class="line"></span><br><span class="line"><span class="title function_">any</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>], <span class="function"><span class="params">x</span> =&gt;</span> x &gt;= <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">any</span>([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="arrayMax"><a href="#arrayMax" class="headerlink" title="arrayMax"></a>arrayMax</h2><p>返回数组中的最大值。<br><code>Math.max()</code>返回参数中最大的值。如果没有参数，返回<code>-Infinity</code>。如果有某个参数为<code>NaN</code>，或是不能转换成数字的非数字值，则返回<code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">arrayMax</span> = arr =&gt; <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr);</span><br><span class="line"><span class="title function_">arrayMax</span>([<span class="number">10</span>, <span class="number">1</span>, <span class="number">5</span>]) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h2 id="arrayMin"><a href="#arrayMin" class="headerlink" title="arrayMin"></a>arrayMin</h2><p>返回数组中的最小值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">arrayMin</span> = arr =&gt; <span class="title class_">Math</span>.<span class="title function_">min</span>(...arr);</span><br><span class="line"><span class="title function_">arrayMin</span>([<span class="number">10</span>, <span class="number">1</span>, <span class="number">5</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>把一个数组分块成指定大小的小数组。<br>使用<code>Array.from()</code>创建一个新的数组，它的长度与将要生成的<code>chunk</code>(块) 数量相匹配。 使用<code>Array.slice()</code>将新数组的每个元素映射到长度为<code>size</code>的<code>chunk</code>中。 如果原始数组不能均匀分割，最后的<code>chunk</code>将包含剩余的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">chunk</span> = (<span class="params">arr, size</span>) =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>(arr.<span class="property">length</span> / size) &#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span></span><br><span class="line">    arr.<span class="title function_">slice</span>(i * size, i * size + size)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="title function_">chunk</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">2</span>); <span class="comment">// [[1,2],[3,4],[5]]</span></span><br></pre></td></tr></table></figure>
<h2 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h2><p>过滤掉数组中所有假值元素。<br>使用<code>Array.filter()</code>过滤掉数组中所有假值元素(<code>false, null, 0, &quot;&quot;, undefined, NaN</code>)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compact</span> = arr =&gt; arr.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">compact</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span> * <span class="number">23</span>, <span class="title class_">NaN</span>, <span class="string">&#x27;s&#x27;</span>, <span class="number">34</span>]);</span><br><span class="line"><span class="comment">// [ 1, 2, 3, &#x27;a&#x27;, &#x27;s&#x27;, 34 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="countOccurrences"><a href="#countOccurrences" class="headerlink" title="countOccurrences"></a>countOccurrences</h2><p>计数数组中某个值的出现次数。<br>使用<code>Array.reduce()</code>在每次遇到数组中的特定值时递增计数器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countOccurrences</span> = (<span class="params">arr, val</span>) =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, v</span>) =&gt;</span> (v === val ? a + <span class="number">1</span> : a), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">countOccurrences</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="deepFlatten"><a href="#deepFlatten" class="headerlink" title="deepFlatten"></a>deepFlatten</h2><p>深度平铺数组。<br>使用递归。 通过空数组(<code>[]</code>) 使用<code>Array.concat()</code>，结合展开运算符(<code>...</code>) 来平铺数组。 递归平铺每个数组元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepFlatten</span> = arr =&gt; [].<span class="title function_">concat</span>(...arr.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(v) ? <span class="title function_">deepFlatten</span>(v) : v));</span><br><span class="line"></span><br><span class="line"><span class="title function_">deepFlatten</span>([<span class="number">1</span>, [<span class="number">2</span>], [[<span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>]); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>其他方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepFlatten</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">while</span>(arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    arr = [].<span class="title function_">contact</span>(...arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">deepFlatten</span>([<span class="number">1</span>, [<span class="number">2</span>], [[<span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>]); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 flat()</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h2><p>返回两个数组之间的差异。<br>根据数组<code>b</code>创建一个<code>Set</code>对象，然后在数组<code>a</code>上使用<code>Array.filter()</code>方法，过滤出数组<code>b</code>中不包含的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">difference</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(b);</span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !s.<span class="title function_">has</span>(x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">difference</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
<h2 id="differenceWith"><a href="#differenceWith" class="headerlink" title="differenceWith"></a>differenceWith</h2><p>过滤出数组中比较函数不返回<code>true</code>的所有值。 类似于<code>difference</code>，除了接受一个<code>comparator</code>（比较函数）。<br>使用<code>Array.filter()</code>和<code>Array.findIndex()</code>来查找合适的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">differenceWith</span> = (<span class="params">arr, val, comp</span>) =&gt; arr.<span class="title function_">filter</span>(<span class="function"><span class="params">a</span> =&gt;</span> val.<span class="title function_">findIndex</span>(<span class="function"><span class="params">b</span> =&gt;</span> <span class="title function_">comp</span>(a, b)) === -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">differenceWith</span>([<span class="number">1</span>, <span class="number">1.2</span>, <span class="number">1.5</span>, <span class="number">3</span>, <span class="number">0</span>], [<span class="number">1.9</span>, <span class="number">3</span>, <span class="number">0</span>], <span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">round</span>(a) === <span class="title class_">Math</span>.<span class="title function_">round</span>(b)); <span class="comment">// [1, 1.2]</span></span><br></pre></td></tr></table></figure>
<h2 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h2><p>从数组开头删除<code>n</code>位元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">drop</span> = (<span class="params">arr, n = <span class="number">1</span></span>) =&gt; arr.<span class="title function_">slice</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="title function_">drop</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [2,3]</span></span><br><span class="line"><span class="title function_">drop</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="title function_">drop</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">42</span>); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="dropRight"><a href="#dropRight" class="headerlink" title="dropRight"></a>dropRight</h2><p>返回从右开始删除<code>n</code>个元素的新数组。<br>检查<code>n</code>是否小于给定数组的长度，并且使用<code>Array.slice()</code>来从右开始删除指定数量的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dropRight</span> = (<span class="params">arr, n = <span class="number">1</span></span>) =&gt; arr.<span class="title function_">slice</span>(<span class="number">0</span>, -n);</span><br><span class="line"></span><br><span class="line"><span class="title function_">dropRight</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [1,2]</span></span><br><span class="line"><span class="title function_">dropRight</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>); <span class="comment">// [1]</span></span><br><span class="line"><span class="title function_">dropRight</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">42</span>); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="dropWhile"><a href="#dropWhile" class="headerlink" title="dropWhile"></a>dropWhile</h2><p>从数组左边开始删除元素，判断条件为<code>func</code>。一直删除到数组左边直至遇到能让<code>func</code>变为<code>true</code>的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dropWhile</span> = (<span class="params">arr, func</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; !<span class="title function_">func</span>(arr[<span class="number">0</span>])) arr = arr.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="dropRightWhile"><a href="#dropRightWhile" class="headerlink" title="dropRightWhile"></a>dropRightWhile</h2><p>从数组右边开始删除元素，判断条件为<code>func</code>。一直删除到数组右边直至遇到能让<code>func</code>变为<code>true</code>的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">dropRightWhile</span> = (<span class="params">arr, func</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> rightIndex = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (rightIndex-- &amp;&amp; !<span class="title function_">func</span>(arr[rightIndex]));</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">slice</span>(<span class="number">0</span>, rightIndex + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dropRightWhile</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">3</span>); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h2 id="everyNth"><a href="#everyNth" class="headerlink" title="everyNth"></a>everyNth</h2><p>返回数组中的每个第<code>n</code>个元素。<br>使用<code>Array.filter()</code>创建一个包含给定数组的每个第<code>n</code>个元素的新数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">everyNth</span> = (<span class="params">arr, nth</span>) =&gt; arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">e, i</span>) =&gt;</span> i % nth === nth - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">everyNth</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">2</span>); <span class="comment">// [ 2, 4, 6 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="filterFalsy"><a href="#filterFalsy" class="headerlink" title="filterFalsy"></a>filterFalsy</h2><p>去除数组中能转换为<code>false</code>的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">filterFalsy</span> = arr =&gt; arr.<span class="title function_">filter</span>(<span class="title class_">Boolean</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">filterFalsy</span>([<span class="string">&#x27;&#x27;</span>, <span class="literal">true</span>, &#123;&#125;, <span class="literal">false</span>, <span class="string">&#x27;sample&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>]); <span class="comment">// [true, &#123;&#125;, &#x27;sample&#x27;, 1]</span></span><br></pre></td></tr></table></figure>
<h2 id="filterNonUnique"><a href="#filterNonUnique" class="headerlink" title="filterNonUnique"></a>filterNonUnique</h2><p>去掉数组中的非唯一值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">filterNonUnique</span> = arr =&gt; arr.<span class="title function_">filter</span>(<span class="function"><span class="params">i</span> =&gt;</span> arr.<span class="title function_">indexOf</span>(i) === arr.<span class="title function_">lastIndexOf</span>(i));</span><br><span class="line"></span><br><span class="line"><span class="title function_">filterNonUnique</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="filterNonUniqueBy"><a href="#filterNonUniqueBy" class="headerlink" title="filterNonUniqueBy"></a>filterNonUniqueBy</h2><p>扩展了<code>filterNonUnique</code>方法，通过方法<code>fn</code>进行判断。<code>fn</code>四个参数是比较两个元素的值和索引（方便<code>fn</code>方法的扩展）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i === j) === <span class="title function_">fn</span>(v, x, i, j)</span><br></pre></td></tr></table></figure>
<p>注意<code>arr.every()</code>，当数组内所有索引和值比较过，都为<code>true</code>，那个元素才是独一无二的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">filterNonUniqueBy</span> = (<span class="params">arr, fn</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> arr.<span class="title function_">every</span>(<span class="function">(<span class="params">x, j</span>) =&gt;</span> (i === j) === <span class="title function_">fn</span>(v, x, i, j)));</span><br><span class="line"></span><br><span class="line"><span class="title function_">filterNonUniqueBy</span>(</span><br><span class="line">  [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">value</span>: <span class="string">&#x27;a&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="string">&#x27;b&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">value</span>: <span class="string">&#x27;c&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="string">&#x27;d&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">value</span>: <span class="string">&#x27;e&#x27;</span> &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> == b.<span class="property">id</span></span><br><span class="line">); <span class="comment">// [ &#123; id: 2, value: &#x27;c&#x27; &#125; ]</span></span><br></pre></td></tr></table></figure>
<h2 id="findLast"><a href="#findLast" class="headerlink" title="findLast"></a>findLast</h2><p>寻找数组最后一个能满足<code>fn</code>的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">findLast</span> = (<span class="params">arr, fn</span>) =&gt; arr.<span class="title function_">filter</span>(fn).<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">findLast</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="findLastIndex"><a href="#findLastIndex" class="headerlink" title="findLastIndex"></a>findLastIndex</h2><p>寻找数组最后一个能满足<code>fn</code>的元素的索引。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">findLastIndex</span> = (<span class="params">arr, fn</span>) =&gt;</span><br><span class="line">  arr</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">val, i</span>) =&gt;</span> [i, val])</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">[i, val]</span>) =&gt;</span> <span class="title function_">fn</span>(val, i, arr))</span><br><span class="line">    .<span class="title function_">pop</span>()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">findLastIndex</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// 2 (index of the value 3)</span></span><br></pre></td></tr></table></figure>
<h2 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h2><p>根据指定的<code>depth</code>平铺数组。<br>每次递归，使<code>depth</code>减1 。使用<code>Array.reduce()</code>和<code>Array.concat()</code>来合并元素或数组。默认情况下， <code>depth</code>等于1时停递归。省略第二个参数<code>depth</code>，只能平铺1层的深度 (单层平铺)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">arr, depth = <span class="number">1</span></span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a.<span class="title function_">concat</span>(depth &gt; <span class="number">1</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(v) ? <span class="title function_">flatten</span>(v, depth - <span class="number">1</span>) : v), []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">flatten</span>([<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="title function_">flatten</span>([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>], <span class="number">7</span>], <span class="number">8</span>], <span class="number">2</span>); <span class="comment">// [1, 2, 3, [4, 5], 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p>ES6方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>() <span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="forEachRight"><a href="#forEachRight" class="headerlink" title="forEachRight"></a>forEachRight</h2><p>从数组的最后一个元素开始，为每个数组元素执行一次提供的函数。<br>使用<code>Array.slice(0)</code>克隆给定的数组，<code>Array.reverse()</code>反转数组，<code>Array.forEach()</code>遍历这个反向数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">forEachRight</span> = (<span class="params">arr, callback</span>) =&gt;</span><br><span class="line">  arr</span><br><span class="line">    .<span class="title function_">slice</span>(<span class="number">0</span>)</span><br><span class="line">    .<span class="title function_">reverse</span>()</span><br><span class="line">    .<span class="title function_">forEach</span>(callback);</span><br><span class="line"></span><br><span class="line"><span class="title function_">forEachRight</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">val</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(val)); <span class="comment">// &#x27;4&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><p>根据给定的函数对数组元素进行分组。<br>使用<code>Array.map()</code>将数组的值映射到函数或属性名称。使用<code>Array.reduce()</code>来创建一个对象，其中的<code>key</code>是从映射结果中产生。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">groupBy</span> = (<span class="params">arr, fn</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">map</span>(<span class="keyword">typeof</span> fn === <span class="string">&#x27;function&#x27;</span> ? fn : <span class="function"><span class="params">val</span> =&gt;</span> val[fn]).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val, i</span>) =&gt;</span> &#123;</span><br><span class="line">    acc[val] = (acc[val] || []).<span class="title function_">concat</span>(arr[i]);</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">groupBy</span>([<span class="number">6.1</span>, <span class="number">4.2</span>, <span class="number">6.3</span>], <span class="title class_">Math</span>.<span class="property">floor</span>); <span class="comment">// &#123;4: [4.2], 6: [6.1, 6.3]&#125;</span></span><br><span class="line"><span class="title function_">groupBy</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], <span class="string">&#x27;length&#x27;</span>); <span class="comment">// &#123;3: [&#x27;one&#x27;, &#x27;two&#x27;], 5: [&#x27;three&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>获取数组的第一个元素。<br>使用<code>arr[0]</code>返回传递数组的第一个元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">head</span> = arr =&gt; arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">head</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="indexOfAll"><a href="#indexOfAll" class="headerlink" title="indexOfAll"></a>indexOfAll</h2><p>返回数组中所有<code>val</code>的索引。 如果<code>val</code>从不出现，则返回<code>[]</code>。<br>使用<code>Array.forEach()</code>循环元素和<code>Array.push()</code>来存储匹配元素的索引。返回索引数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">indexOfAll</span> = (<span class="params">arr, val</span>) =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, el, i</span>) =&gt;</span> (el === val ? [...acc, i] : acc), []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">indexOfAll</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>); <span class="comment">// [0,3]</span></span><br><span class="line"><span class="title function_">indexOfAll</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h2><p>返回一个数组中除了最后一个元素以外的所有元素。<br>使用<code>arr.slice(0,-1)</code>返回排除了最后一个元素的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initial</span> = arr =&gt; arr.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">initial</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>
<h2 id="initialize2DArray"><a href="#initialize2DArray" class="headerlink" title="initialize2DArray"></a>initialize2DArray</h2><p>初始化一个给定行数和列数，及值的二维数组。<br>使用<code>Array.map()</code>生成<code>h</code>行，其中每个行都是一个长度为<code>w</code>的新数组。 如果未提供值<code>val</code>，则默认为<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initialize2DArray</span> = (<span class="params">w, h, val = <span class="literal">null</span></span>) =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: h &#125;).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: w &#125;).<span class="title function_">fill</span>(val));</span><br><span class="line"></span><br><span class="line"><span class="title function_">initialize2DArray</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>); <span class="comment">// [[0,0], [0,0]]</span></span><br></pre></td></tr></table></figure>
<h2 id="initializeArrayWithRange"><a href="#initializeArrayWithRange" class="headerlink" title="initializeArrayWithRange"></a>initializeArrayWithRange</h2><p>初始化一个数组，该数组包含指定范围内的数字，包括<code>start</code>和<code>end</code>，数字间隔为<code>step</code>。<br>使用<code>Array.from(Math.ceil((end+1-start)/step))</code>创建一个所需长度的数组（元素的数量等于 (<code>end-start)/step</code>或者<code>(end+1-start)/step</code>包括<code>end</code>）， 用<code>Array.map()</code>填充在这个范围内要求的值。你可以省略<code>start</code>来使用默认值0。 您可以省略<code>step</code>使用默认值1 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">initializeArrayWithRange</span> = (<span class="params">end, start = <span class="number">0</span>, step = <span class="number">1</span></span>) =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="title class_">Math</span>.<span class="title function_">ceil</span>((end - start + <span class="number">1</span>) / step) &#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i * step + start);</span><br><span class="line"></span><br><span class="line"><span class="title function_">initializeArrayWithRange</span>(<span class="number">5</span>); <span class="comment">// [0,1,2,3,4,5]</span></span><br><span class="line"><span class="title function_">initializeArrayWithRange</span>(<span class="number">7</span>, <span class="number">3</span>); <span class="comment">// [3,4,5,6,7]</span></span><br><span class="line"><span class="title function_">initializeArrayWithRange</span>(<span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// [0,2,4,6,8]</span></span><br></pre></td></tr></table></figure>
<h2 id="initializeArrayWithValues"><a href="#initializeArrayWithValues" class="headerlink" title="initializeArrayWithValues"></a>initializeArrayWithValues</h2><p>使用指定的值初始化和填充数组。<br>使用<code>Array(n)</code>创建所需长度的数组，使用<code>fill(v)</code>以填充所需的值。你可以忽略<code>val</code>，使用默认值0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const initializeArrayWithValues = (n, val = 0) =&gt; Array(n).fill(val);</span><br><span class="line"></span><br><span class="line">initializeArrayWithValues(5, 2); // [2, 2, 2, 2, 2]</span><br></pre></td></tr></table></figure>
<h2 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h2><p>返回两个数组中都存在的元素列表。<br>根据数组 <code>b</code>创建一个<code>Set</code>对象，然后在数组<code>a</code>上使用<code>Array.filter()</code>方法，只保留数组<code>b</code>中也包含的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">intersection</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(b);</span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> s.<span class="title function_">has</span>(x));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">intersection</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]); <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>将数组的所有元素拼接成一个字符串并返回此字符串。 使用分隔符和结束分隔符。<br>使用<code>Array.reduce()</code>将元素拼接成一个字符串。 省略第二个参数<code>separator</code>，则默认使用分隔符<code>,</code>。 省略第三个参数<code>end</code>，默认使用与<code>separator</code>相同的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">join</span> = (<span class="params">arr, separator = <span class="string">&#x27;,&#x27;</span>, end = separator</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc, val, i</span>) =&gt;</span></span><br><span class="line">      i === arr.<span class="property">length</span> - <span class="number">2</span></span><br><span class="line">        ? acc + val + end</span><br><span class="line">        : i === arr.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">          ? acc + val</span><br><span class="line">          : acc + val + separator,</span><br><span class="line">    <span class="string">&#x27;&#x27;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="title function_">join</span>([<span class="string">&#x27;pen&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pen&#x27;</span>], <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>); <span class="comment">// &quot;pen,pineapple,apple&amp;pen&quot;</span></span><br><span class="line"><span class="title function_">join</span>([<span class="string">&#x27;pen&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pen&#x27;</span>], <span class="string">&#x27;,&#x27;</span>); <span class="comment">// &quot;pen,pineapple,apple,pen&quot;</span></span><br><span class="line"><span class="title function_">join</span>([<span class="string">&#x27;pen&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pen&#x27;</span>]); <span class="comment">// &quot;pen,pineapple,apple,pen&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>返回数组中的最后一个元素。<br>使用<code>arr.length - 1</code>来计算给定数组的最后一个元素的索引并返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">last</span> = arr =&gt; arr[arr.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">last</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="longestItem"><a href="#longestItem" class="headerlink" title="longestItem"></a>longestItem</h2><p>获取任何数量的可迭代对象或具有<code>length</code>属性的对象，并返回最长的一个。<br>使用<code>Array.sort()</code>按<code>length</code>对所有参数进行排序，返回第一个（最长）元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">longestItem</span> = (<span class="params">...vals</span>) =&gt; vals.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, x</span>) =&gt;</span> (x.<span class="property">length</span> &gt; a.<span class="property">length</span> ? x : a));</span><br><span class="line"></span><br><span class="line"><span class="title function_">longestItem</span>(<span class="string">&#x27;this&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;testcase&#x27;</span>); <span class="comment">// &#x27;testcase&#x27;</span></span><br><span class="line"><span class="title function_">longestItem</span>(...[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>]); <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line"><span class="title function_">longestItem</span>(...[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>], <span class="string">&#x27;abcd&#x27;</span>); <span class="comment">// &#x27;abcd&#x27;</span></span><br><span class="line"><span class="title function_">longestItem</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="title function_">longestItem</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;foobar&#x27;</span>); <span class="comment">// &#x27;foobar&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="mapObject"><a href="#mapObject" class="headerlink" title="mapObject"></a>mapObject</h2><p>使用一个函数将数组的值映射到对象，其键值对中，原始值作为键，映射值作为值。<br>使用一个匿名的内部函数作用域来声明一个<code>undefined</code>的内存空间，使用闭包来存储返回值。 使用一个新的<code>Array</code>来存储带有函数映射的数组和一个逗号运算符来返回第二个步骤，而不需要从一个上下文移动到另一个上下文（由于闭包和操作顺序）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapObject</span> = (<span class="params">arr, fn</span>) =&gt;</span><br><span class="line">  (<span class="function"><span class="params">a</span> =&gt;</span> (</span><br><span class="line">    (a = [arr, arr.<span class="title function_">map</span>(fn)]), a[<span class="number">0</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val, ind</span>) =&gt;</span> ((acc[val] = a[<span class="number">1</span>][ind]), acc), &#123;&#125;)</span><br><span class="line">  ))();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">squareIt</span> = arr =&gt; <span class="title function_">mapObject</span>(arr, <span class="function"><span class="params">a</span> =&gt;</span> a * a);</span><br><span class="line"><span class="title function_">squareIt</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// &#123; 1: 1, 2: 4, 3: 9 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="maxN"><a href="#maxN" class="headerlink" title="maxN"></a>maxN</h2><p>从提供的数组中返回<code>n</code>个最大元素。如果<code>n</code>大于或等于提供的数组长度，则返回原数组（按降序排列）。<br>结合使用<code>Array.sort()</code>与展开操作符(<code>...</code>) ，创建一个数组的浅克隆，并按降序排列。使用<code>Array.slice()</code>以获得指定的元素个数。 忽略第二个参数<code>n</code>，默认获取单个元素（以数组的形式）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxN</span> = (<span class="params">arr, n = <span class="number">1</span></span>) =&gt; [...arr].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a).<span class="title function_">slice</span>(<span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="title function_">maxN</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [3]</span></span><br><span class="line"><span class="title function_">maxN</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>); <span class="comment">// [3,2]</span></span><br></pre></td></tr></table></figure>
<h2 id="minN"><a href="#minN" class="headerlink" title="minN"></a>minN</h2><p>从提供的数组中返回<code>n</code>个最小元素。如果<code>n</code>大于或等于提供的数组长度，则返回原数组（按降序排列）。<br>结合使用<code>Array.sort()</code>与展开操作符(<code>...</code>) ，创建一个数组的浅克隆，并按降序排列。使用<code>Array.slice()</code>以获得指定的元素个数。 忽略第二个参数<code>n</code>，默认获取单个元素（以数组的形式）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">minN</span> = (<span class="params">arr, n = <span class="number">1</span></span>) =&gt; [...arr].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b).<span class="title function_">slice</span>(<span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="title function_">minN</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [1]</span></span><br><span class="line"><span class="title function_">minN</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>); <span class="comment">// [1,2]</span></span><br></pre></td></tr></table></figure>
<h2 id="nthElement"><a href="#nthElement" class="headerlink" title="nthElement"></a>nthElement</h2><p>返回数组的第<code>n</code>个元素。<br>使用<code>Array.slice()</code>获取数组的第<code>n</code>个元素。如果索引超出范围，则返回<code>[]</code>。省略第二个参数<code>n</code>，将得到数组的第一个元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">nthElement</span> = (<span class="params">arr, n = <span class="number">0</span></span>) =&gt; (n === -<span class="number">1</span> ? arr.<span class="title function_">slice</span>(n) : arr.<span class="title function_">slice</span>(n, n + <span class="number">1</span>))[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">nthElement</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">1</span>); <span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"><span class="title function_">nthElement</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], -<span class="number">3</span>); <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><p>根据所提供的函数对每个元素进行迭代，将这些元素分成两个数组。<br>使用<code>Array.reduce()</code>创建两个数组的数组。 使用<code>Array.push()</code>将<code>fn</code>返回为<code>true</code>的元素添加到第一个数组，而<code>fn</code>返回<code>false</code>的元素到第二个元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">partition</span> = (<span class="params">arr, fn</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc, val, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">      acc[<span class="title function_">fn</span>(val, i, arr) ? <span class="number">0</span> : <span class="number">1</span>].<span class="title function_">push</span>(val);</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,</span><br><span class="line">    [[], []]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> users = [&#123; <span class="attr">user</span>: <span class="string">&#x27;barney&#x27;</span>, <span class="attr">age</span>: <span class="number">36</span>, <span class="attr">active</span>: <span class="literal">false</span> &#125;, &#123; <span class="attr">user</span>: <span class="string">&#x27;fred&#x27;</span>, <span class="attr">age</span>: <span class="number">40</span>, <span class="attr">active</span>: <span class="literal">true</span> &#125;];</span><br><span class="line"><span class="title function_">partition</span>(users, <span class="function"><span class="params">o</span> =&gt;</span> o.<span class="property">active</span>); </span><br><span class="line"><span class="comment">// [[&#123; &#x27;user&#x27;: &#x27;fred&#x27;, &#x27;age&#x27;: 40, &#x27;active&#x27;: true &#125;],[&#123; &#x27;user&#x27;: &#x27;barney&#x27;, &#x27;age&#x27;: 36, &#x27;active&#x27;: false &#125;]]</span></span><br></pre></td></tr></table></figure>
<h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>改变原始数组，过滤掉指定的值。<br>使用<code>Array.filter()</code>和<code>Array.includes()</code>来剔除指定的值。使用<code>Array.length = 0</code>将数组中的长度重置为零，并且通过<code>Array.push()</code>只使用<code>pulled</code>值重新填充数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">pull</span> = (<span class="params">arr, ...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> argState = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(args[<span class="number">0</span>]) ? args[<span class="number">0</span>] : args;</span><br><span class="line">  <span class="keyword">let</span> pulled = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> !argState.<span class="title function_">includes</span>(v));</span><br><span class="line">  arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  pulled.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> arr.<span class="title function_">push</span>(v));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="title function_">pull</span>(myArray, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">// myArray = [ &#x27;b&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h2 id="pullAtIndex"><a href="#pullAtIndex" class="headerlink" title="pullAtIndex"></a>pullAtIndex</h2><p>改变原始数组，过滤掉指定索引的值。<br>使用<code>Array.filter()</code>和<code>Array.includes()</code>来剔除指定的值。使用<code>Array.length = 0</code>将数组中的长度重置为零，并且通过<code>Array.push()</code>只使用<code>pulled</code>值重新填充数组。使用<code>Array.push()</code>来跟踪<code>pulled</code>值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">pullAtIndex</span> = (<span class="params">arr, pullArr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> removed = [];</span><br><span class="line">  <span class="keyword">let</span> pulled = arr</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (pullArr.<span class="title function_">includes</span>(i) ? removed.<span class="title function_">push</span>(v) : v))</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> !pullArr.<span class="title function_">includes</span>(i));</span><br><span class="line">  arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  pulled.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> arr.<span class="title function_">push</span>(v));</span><br><span class="line">  <span class="keyword">return</span> removed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> pulled = <span class="title function_">pullAtIndex</span>(myArray, [<span class="number">1</span>, <span class="number">3</span>]); <span class="comment">// myArray = [ &#x27;a&#x27;, &#x27;c&#x27; ] , pulled = [ &#x27;b&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h2 id="pullAtValue"><a href="#pullAtValue" class="headerlink" title="pullAtValue"></a>pullAtValue</h2><p>改变原始数组，过滤出指定的值。 返回删除的元素。<br>使用<code>Array.filter()</code>和<code>Array.includes()</code>来剔除指定的值。使用<code>Array.length = 0</code>将数组中的长度重置为零， 并且通过<code>Array.push()</code>只使用<code>pulled</code>值重新填充数组。使用<code>Array.push()</code>来跟踪<code>pulled</code>值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">pullAtValue</span> = (<span class="params">arr, pullArr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> removed = [],</span><br><span class="line">    pushToRemove = arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> (pullArr.<span class="title function_">includes</span>(v) ? removed.<span class="title function_">push</span>(v) : v)),</span><br><span class="line">    mutateTo = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> !pullArr.<span class="title function_">includes</span>(v));</span><br><span class="line">  arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  mutateTo.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> arr.<span class="title function_">push</span>(v));</span><br><span class="line">  <span class="keyword">return</span> removed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> pulled = <span class="title function_">pullAtValue</span>(myArray, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]); <span class="comment">// myArray = [ &#x27;a&#x27;, &#x27;c&#x27; ] , pulled = [ &#x27;b&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h2 id="reducedFilter"><a href="#reducedFilter" class="headerlink" title="reducedFilter"></a>reducedFilter</h2><p>根据条件过滤一个对象数组，同时过滤掉未指定的键（<code>key</code>）。<br>使用<code>Array.filter()</code>根据断言<code>fn</code>过滤数组，以便返回条件为真值（<code>truthy</code>）的对象。在过滤出来的数组上，使用<code>Array.map()</code>和<code>Array.reduce()</code>返回新的对象来过滤掉<code>keys</code>参数中未提供的键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reducedFilter</span> = (<span class="params">data, keys, fn</span>) =&gt;</span><br><span class="line">  data.<span class="title function_">filter</span>(fn).<span class="title function_">map</span>(<span class="function"><span class="params">el</span> =&gt;</span></span><br><span class="line">    keys.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, key</span>) =&gt;</span> &#123;</span><br><span class="line">      acc[key] = el[key];</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;john&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;mike&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">50</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title function_">reducedFilter</span>(data, [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>], <span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">age</span> &gt; <span class="number">24</span>); <span class="comment">// [&#123; id: 2, name: &#x27;mike&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>从数组中移除给定函数返回<code>false</code>的元素。<br>使用<code>Array.filter()</code>和<code>Array.reduce()</code>来查找返回真值的数组元素，使用<code>Array.splice()</code>来移除元素。<code>func</code>有三个参数<code>(value, index, array)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">remove</span> = (<span class="params">arr, func</span>) =&gt;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)</span><br><span class="line">    ? arr.<span class="title function_">filter</span>(func).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> &#123;</span><br><span class="line">      arr.<span class="title function_">splice</span>(arr.<span class="title function_">indexOf</span>(val), <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> acc.<span class="title function_">concat</span>(val);</span><br><span class="line">    &#125;, [])</span><br><span class="line">    : [];</span><br><span class="line"></span><br><span class="line"><span class="title function_">remove</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>); <span class="comment">// [2, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><p>从数组中随机返回一个元素。<br>使用<code>Math.random()</code>生成一个随机数，乘以<code>length</code>，并使用<code>Math.floor()</code>舍去小数获得到最接近的整数。这个方法也适用于字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sample</span> = arr =&gt; arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * arr.<span class="property">length</span>)];</span><br><span class="line"></span><br><span class="line"><span class="title function_">sample</span>([<span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h2 id="sampleSize"><a href="#sampleSize" class="headerlink" title="sampleSize"></a>sampleSize</h2><p>从<code>array</code>中获取<code>n</code>个唯一键随机元素。<br>使用<code>Fisher-Yates</code>（洗牌算法）对数组进行打乱。使用<code>Array.slice()</code>获取第一个<code>n</code>元素。 省略第二个参数，<code>n</code>从数组中随机取得1个元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sampleSize</span> = (<span class="params">[...arr], n = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> m = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (m) &#123;</span><br><span class="line">    <span class="keyword">const</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m--);</span><br><span class="line">    [arr[m], arr[i]] = [arr[i], arr[m]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">slice</span>(<span class="number">0</span>, n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sampleSize</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>); <span class="comment">// [3,1]</span></span><br><span class="line"><span class="title function_">sampleSize</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>); <span class="comment">// [2,3,1]</span></span><br></pre></td></tr></table></figure>
<h2 id="shank"><a href="#shank" class="headerlink" title="shank"></a>shank</h2><p>与<code>array.prototype.splice()</code>具有相同的功能，但返回新数组而不是改变原始数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shank</span> = (<span class="params">arr, index = <span class="number">0</span>, delCount = <span class="number">0</span>, ...elements</span>) =&gt;</span><br><span class="line">  arr</span><br><span class="line">    .<span class="title function_">slice</span>(<span class="number">0</span>, index)</span><br><span class="line">    .<span class="title function_">concat</span>(elements)</span><br><span class="line">    .<span class="title function_">concat</span>(arr.<span class="title function_">slice</span>(index + delCount));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;alpha&#x27;</span>, <span class="string">&#x27;bravo&#x27;</span>, <span class="string">&#x27;charlie&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> namesAndDelta = <span class="title function_">shank</span>(names, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;delta&#x27;</span>); <span class="comment">// [ &#x27;alpha&#x27;, &#x27;delta&#x27;, &#x27;bravo&#x27;, &#x27;charlie&#x27; ]</span></span><br><span class="line"><span class="keyword">const</span> namesNoBravo = <span class="title function_">shank</span>(names, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// [ &#x27;alpha&#x27;, &#x27;charlie&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names); <span class="comment">// [&#x27;alpha&#x27;, &#x27;bravo&#x27;, &#x27;charlie&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h2><p>随机排列指定数组的值，返回一个新的数组。<br>使用<code>Fisher-Yates</code>算法对数组元素进行重新排序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shuffle</span> = (<span class="params">[...arr]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> m = arr.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (m) &#123;</span><br><span class="line">    <span class="keyword">const</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m--);</span><br><span class="line">    [arr[m], arr[i]] = [arr[i], arr[m]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_">shuffle</span>(foo); <span class="comment">// [2, 3, 1], foo = [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="similarity"><a href="#similarity" class="headerlink" title="similarity"></a>similarity</h2><p>返回存在于两个数组中的元素数组。<br>使用<code>Array.filter()</code>移除不在<code>values</code>中的值，使用<code>Array.includes()</code>确定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v));</span><br><span class="line"></span><br><span class="line">similarity([1, 2, 3], [1, 2, 4]); // [1, 2]</span><br></pre></td></tr></table></figure>
<h2 id="symmetricDifference"><a href="#symmetricDifference" class="headerlink" title="symmetricDifference"></a>symmetricDifference</h2><p>返回两个数组之间的差集。<br>根据每个数组创建一个<code>Set</code>，然后在每个数组上使用<code>Array.filter()</code>，只保留另一个数组不包含的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">symmetricDifference</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sA = <span class="keyword">new</span> <span class="title class_">Set</span>(a),</span><br><span class="line">    sB = <span class="keyword">new</span> <span class="title class_">Set</span>(b);</span><br><span class="line">  <span class="keyword">return</span> [...a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !sB.<span class="title function_">has</span>(x)), ...b.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !sA.<span class="title function_">has</span>(x))];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">symmetricDifference</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]); <span class="comment">// [3, 4]</span></span><br><span class="line"><span class="title function_">symmetricDifference</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]); <span class="comment">// [2, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="symmetricDifferenceBy"><a href="#symmetricDifferenceBy" class="headerlink" title="symmetricDifferenceBy"></a>symmetricDifferenceBy</h2><p>将提供的函数应用于两个数组的每个数组元素后，返回两个数组之间的差集。<br>通过对每个数组的元素应用<code>fn</code>创建一个集合，然后对每个元素使用<code>array.prototype.filter()</code>来只保留不包含在另一个数组中的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">symmetricDifferenceBy</span> = (<span class="params">a, b, fn</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sA = <span class="keyword">new</span> <span class="title class_">Set</span>(a.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">fn</span>(v))),</span><br><span class="line">    sB = <span class="keyword">new</span> <span class="title class_">Set</span>(b.<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">fn</span>(v)));</span><br><span class="line">  <span class="keyword">return</span> [...a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !sB.<span class="title function_">has</span>(<span class="title function_">fn</span>(x))), ...b.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !sA.<span class="title function_">has</span>(<span class="title function_">fn</span>(x)))];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">symmetricDifferenceBy</span>([<span class="number">2.1</span>, <span class="number">1.2</span>], [<span class="number">2.3</span>, <span class="number">3.4</span>], <span class="title class_">Math</span>.<span class="property">floor</span>); <span class="comment">// [ 1.2, 3.4 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>返回剔除第一个元素后的数组。<br>如果数组的<code>length</code>大于1，则返回<code>arr.slice(1)</code>，否则返回整个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">tail</span> = arr =&gt; (arr.<span class="property">length</span> &gt; <span class="number">1</span> ? arr.<span class="title function_">slice</span>(<span class="number">1</span>) : arr);</span><br><span class="line"></span><br><span class="line"><span class="title function_">tail</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [2,3]</span></span><br><span class="line"><span class="title function_">tail</span>([<span class="number">1</span>]); <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><p>从一个给定的数组中创建一个前<code>n</code>个元素的数组。<br>使用<code>Array.slice()</code>创建一个数组包含第一个元素开始，到<code>n</code>个元素结束的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">take</span> = (<span class="params">arr, n = <span class="number">1</span></span>) =&gt; arr.<span class="title function_">slice</span>(<span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="title function_">take</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">5</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="title function_">take</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<h2 id="takeRight"><a href="#takeRight" class="headerlink" title="takeRight"></a>takeRight</h2><p>从一个给定的数组中创建一个后<code>n</code>个元素的数组。<br>使用<code>Array.slice()</code>来创建一个从第<code>n</code>个元素开始至末尾的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">takeRight</span> = (<span class="params">arr, n = <span class="number">1</span></span>) =&gt; arr.<span class="title function_">slice</span>(arr.<span class="property">length</span> - n, arr.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">takeRight</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>); <span class="comment">// [ 2, 3 ]</span></span><br><span class="line"><span class="title function_">takeRight</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
<h2 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h2><p>移除数组中的元素，直到传递的函数返回<code>true</code>。返回删除的元素。<br>循环数组，使用<code>for…of</code>循环<code>array.prototype.entries()</code>，直到函数返回的值为<code>true</code>。使用<code>array.prototype.slice()</code>返回删除的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">takeWhile</span> = (<span class="params">arr, func</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, val] <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) <span class="keyword">if</span> (<span class="title function_">func</span>(val)) <span class="keyword">return</span> arr.<span class="title function_">slice</span>(<span class="number">0</span>, i);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">takeWhile</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">n</span> =&gt;</span> n &gt;= <span class="number">3</span>); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h2 id="takeRightWhile"><a href="#takeRightWhile" class="headerlink" title="takeRightWhile"></a>takeRightWhile</h2><p>从数组末尾移除元素，直到传递的函数返回<code>true</code>。返回删除的元素。<br>使用<code>array.prototype.reducceright()</code>循环数组，并在函数返回错误值时累积元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">takeRightWhile</span> = (<span class="params">arr, func</span>) =&gt;</span><br><span class="line">  arr.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">acc, el</span>) =&gt;</span> (<span class="title function_">func</span>(el) ? acc : [el, ...acc]), []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">takeRightWhile</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">3</span>); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure>
<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>返回两个数组中任何一个中存在的每个元素一次。<br>创建一个包含A和B所有值的集合，并转换为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">union</span> = (<span class="params">a, b</span>) =&gt; <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]));</span><br><span class="line"></span><br><span class="line"><span class="title function_">union</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]); <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<h2 id="unionBy"><a href="#unionBy" class="headerlink" title="unionBy"></a>unionBy</h2><p>将提供的函数应用于两个数组的每个数组元素之后，返回两个数组中任何一个数组中存在的每个元素一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unionBy</span> = (<span class="params">a, b, fn</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(a.<span class="title function_">map</span>(fn));</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !s.<span class="title function_">has</span>(<span class="title function_">fn</span>(x)))]));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">unionBy</span>([<span class="number">2.1</span>], [<span class="number">1.2</span>, <span class="number">2.3</span>], <span class="title class_">Math</span>.<span class="property">floor</span>); <span class="comment">// [2.1, 1.2]</span></span><br></pre></td></tr></table></figure>
<h2 id="uniqueElements"><a href="#uniqueElements" class="headerlink" title="uniqueElements"></a>uniqueElements</h2><p>返回数组的所有唯一值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">uniqueElements</span> = arr =&gt; [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"></span><br><span class="line"><span class="title function_">uniqueElements</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="without"><a href="#without" class="headerlink" title="without"></a>without</h2><p>从数组中排除给定值。<br>使用<code>Array.filter()</code>创建一个不包括所有给定值的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">without</span> = (<span class="params">arr, ...args</span>) =&gt; arr.<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> !args.<span class="title function_">includes</span>(v));</span><br><span class="line"></span><br><span class="line"><span class="title function_">without</span>([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
<h2 id="xProd"><a href="#xProd" class="headerlink" title="xProd"></a>xProd</h2><p>通过从数组中创建每个可能的对，从提供的两个数组中创建一个新数组。<br>使用<code>array.prototype.reduce()、array.prototype.map()</code>和<code>array.prototype.concat()</code>从两个数组的元素中生成每个可能的对，并将它们保存在一个数组中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">xProd</span> = (<span class="params">a, b</span>) =&gt; a.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc.<span class="title function_">concat</span>(b.<span class="title function_">map</span>(<span class="function"><span class="params">y</span> =&gt;</span> [x, y])), []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">xProd</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]); <span class="comment">// [[1, &#x27;a&#x27;], [1, &#x27;b&#x27;], [2, &#x27;a&#x27;], [2, &#x27;b&#x27;]]</span></span><br></pre></td></tr></table></figure>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>创建一组元素，根据原始数组中的位置进行分组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">zip</span> = (<span class="params">...arrays</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arrays.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="property">length</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: maxLength &#125;).<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: arrays.<span class="property">length</span> &#125;, <span class="function">(<span class="params">_, k</span>) =&gt;</span> arrays[k][i]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">zip</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="literal">true</span>, <span class="literal">false</span>]); <span class="comment">// [[&#x27;a&#x27;, 1, true], [&#x27;b&#x27;, 2, false]]</span></span><br><span class="line"><span class="title function_">zip</span>([<span class="string">&#x27;a&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="literal">true</span>, <span class="literal">false</span>]); <span class="comment">// [[&#x27;a&#x27;, 1, true], [undefined, 2, false]]</span></span><br></pre></td></tr></table></figure>
<h2 id="zipObject"><a href="#zipObject" class="headerlink" title="zipObject"></a>zipObject</h2><p>给定一个有效属性标识符数组和一个值数组，返回一个将属性与值关联的对象。<br>由于一个对象可以有未定义的值，但不存在未定义的属性，该属性数组用于使用<code>Array.reduce()</code>来决定结果对象的结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">zipObject</span> = (<span class="params">props, values</span>) =&gt;</span><br><span class="line">  props.<span class="title function_">reduce</span>(<span class="function">(<span class="params">obj, prop, index</span>) =&gt;</span> ((obj[prop] = values[index]), obj), &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">zipObject</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// &#123;a: 1, b: 2, c: undefined&#125;</span></span><br><span class="line"><span class="title function_">zipObject</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/ES6/ES6 ArrayBuffer"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/07/17/%E5%89%8D%E7%AB%AF/ES6/ES6%20ArrayBuffer/"
    >ES6 ArrayBuffer</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/07/17/%E5%89%8D%E7%AB%AF/ES6/ES6%20ArrayBuffer/" class="article-date">
  <time datetime="2019-07-17T03:55:09.000Z" itemprop="datePublished">2019-07-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/ES6/">ES6</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>
<p>这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 JavaScript 脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像 C 语言那样，直接操作字节，将 4 个字节的 32 位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。</p>
<p>二进制数组就是在这种背景下诞生的。它很像 C 语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了 JavaScript 处理二进制数据的能力，使得开发者有可能通过 JavaScript 与操作系统的原生接口进行二进制通信。</p>
<p>二进制数组由三类对象组成。</p>
<ul>
<li><code>ArrayBuffer</code>对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</li>
<li><code>TypedArray</code>视图：共包括 9 种类型的视图，比如<code>Uint8Array</code>（无符号 8 位整数）数组视图, <code>Int16Array</code>（16 位整数）数组视图, <code>Float32Array</code>（32 位浮点数）数组视图等等。</li>
<li><code>DataView</code>视图：可以自定义复合格式的视图，比如第一个字节是<code>Uint8</code>（无符号 8 位整数）、第二、三个字节是<code>Int16</code>（16 位整数）、第四个字节开始是<code>Float32</code>（32 位浮点数）等等，此外还可以自定义字节序。</li>
</ul>
<p>简单说，<code>ArrayBuffer</code>对象代表原始的二进制数据，<code>TypedArray</code>视图用来读写简单类型的二进制数据，<code>DataView</code>视图用来读写复杂类型的二进制数据。</p>
<p><code>TypedArray</code>视图支持的数据类型一共有 9 种（<code>DataView</code>视图支持除<code>Uint8C</code>以外的其他 8 种）。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">字节长度</th>
<th align="center">含义</th>
<th align="center">对应的 C 语言类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Int8</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">位带符号整数</td>
</tr>
<tr>
<td align="center">Uint8</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">位不带符号整数</td>
</tr>
<tr>
<td align="center">Uint8C</td>
<td align="center">1</td>
<td align="center">8</td>
<td align="center">位不带符号整数（自动过滤溢出）</td>
</tr>
<tr>
<td align="center">Int16</td>
<td align="center">2</td>
<td align="center">16</td>
<td align="center">位带符号整数</td>
</tr>
<tr>
<td align="center">Uint16</td>
<td align="center">2</td>
<td align="center">16</td>
<td align="center">位不带符号整数</td>
</tr>
<tr>
<td align="center">Int32</td>
<td align="center">4</td>
<td align="center">32</td>
<td align="center">位带符号整数</td>
</tr>
<tr>
<td align="center">Uint32</td>
<td align="center">4</td>
<td align="center">32</td>
<td align="center">位不带符号的整数</td>
</tr>
<tr>
<td align="center">Float32</td>
<td align="center">4</td>
<td align="center">32</td>
<td align="center">位浮点数</td>
</tr>
<tr>
<td align="center">Float64</td>
<td align="center">8</td>
<td align="center">64</td>
<td align="center">位浮点数</td>
</tr>
</tbody></table>
<p>注意，二进制数组并不是真正的数组，而是类似数组的对象。</p>
<p>很多浏览器操作的 API，用到了二进制数组操作二进制数据，下面是其中的几个。</p>
<ul>
<li>Canvas</li>
<li>Fetch API</li>
<li>File API</li>
<li>WebSockets</li>
<li>XMLHttpRequest</li>
</ul>
<h1 id="ArrayBuffer-对象"><a href="#ArrayBuffer-对象" class="headerlink" title="ArrayBuffer 对象"></a>ArrayBuffer 对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>ArrayBuffer</code>对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p>
<p><code>ArrayBuffer</code>也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码生成了一段 32 字节的内存区域，每个字节的值默认都是 0。可以看到，<code>ArrayBuffer</code>构造函数的参数是所需要的内存大小（单位字节）。</p>
<p>为了读写这段内容，需要为它指定视图。<code>DataView</code>视图的创建，需要提供<code>ArrayBuffer</code>对象实例作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>);</span><br><span class="line"><span class="keyword">const</span> dataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line">dataView.<span class="title function_">getUint8</span>(<span class="number">0</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码对一段 32 字节的内存，建立<code>DataView</code>视图，然后以不带符号的 8 位整数格式，从头读取 8 位二进制数据，结果得到 0，因为原始内存的<code>ArrayBuffer</code>对象，默认所有位都是 0。</p>
<p>另一种<code>TypedArray</code>视图，与<code>DataView</code>视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x1 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buffer);</span><br><span class="line">x1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> x2 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(buffer);</span><br><span class="line">x2[<span class="number">0</span>]  = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">x1[<span class="number">0</span>] <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码对同一段内存，分别建立两种视图：32 位带符号整数（<code>Int32Array</code>构造函数）和 8 位不带符号整数（<code>Uint8Array</code>构造函数）。由于两个视图对应的是同一段内存，一个视图修改底层内存，会影响到另一个视图。</p>
<p><code>TypedArray</code>视图的构造函数，除了接受<code>ArrayBuffer</code>实例作为参数，还可以接受普通数组作为参数，直接分配内存生成底层的<code>ArrayBuffer</code>实例，并同时完成对这段内存的赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typedArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line">typedArray.<span class="property">length</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">typedArray[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">typedArray <span class="comment">// [5, 1, 2]</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>TypedArray</code>视图的<code>Uint8Array</code>构造函数，新建一个不带符号的 8 位整数视图。可以看到，<code>Uint8Array</code>直接使用普通数组作为参数，对底层内存的赋值同时完成。</p>
<h2 id="ArrayBuffer-prototype-byteLength"><a href="#ArrayBuffer-prototype-byteLength" class="headerlink" title="ArrayBuffer.prototype.byteLength"></a>ArrayBuffer.prototype.byteLength</h2><p><code>ArrayBuffer</code>实例的<code>byteLength</code>属性，返回所分配的内存区域的字节长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">32</span>);</span><br><span class="line">buffer.<span class="property">byteLength</span> <span class="comment">// 32</span></span><br></pre></td></tr></table></figure>
<p>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buffer.<span class="property">byteLength</span> === n) &#123;</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ArrayBuffer-prototype-slice"><a href="#ArrayBuffer-prototype-slice" class="headerlink" title="ArrayBuffer.prototype.slice()"></a>ArrayBuffer.prototype.slice()</h2><p><code>ArrayBuffer</code>实例有一个<code>slice</code>方法，允许将内存区域的一部分，拷贝生成一个新的<code>ArrayBuffer</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> newBuffer = buffer.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码拷贝<code>buffer</code>对象的前 3 个字节（从 0 开始，到第 3 个字节前面结束），生成一个新的<code>ArrayBuffer</code>对象。<code>slice</code>方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个<code>ArrayBuffer</code>对象拷贝过去。</p>
<p><code>slice</code>方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原<code>ArrayBuffer</code>对象的结尾。</p>
<p>除了<code>slice</code>方法，<code>ArrayBuffer</code>对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>
<h2 id="ArrayBuffer-isView"><a href="#ArrayBuffer-isView" class="headerlink" title="ArrayBuffer.isView()"></a>ArrayBuffer.isView()</h2><p><code>ArrayBuffer</code>有一个静态方法<code>isView</code>，返回一个布尔值，表示参数是否为<code>ArrayBuffer</code>的视图实例。这个方法大致相当于判断参数，是否为<code>TypedArray</code>实例或<code>DataView</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="title class_">ArrayBuffer</span>.<span class="title function_">isView</span>(buffer) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buffer);</span><br><span class="line"><span class="title class_">ArrayBuffer</span>.<span class="title function_">isView</span>(v) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="TypedArray-视图"><a href="#TypedArray-视图" class="headerlink" title="TypedArray 视图"></a>TypedArray 视图</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><code>ArrayBuffer</code>对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（<code>view</code>）。<code>ArrayBuffer</code>有两种视图，一种是<code>TypedArray</code>视图，另一种是<code>DataView</code>视图。前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。</p>
<p>目前，<code>TypedArray</code>视图一共包括 9 种类型，每一种视图都是一种构造函数。</p>
<ul>
<li><code>Int8Array</code>：8 位有符号整数，长度 1 个字节。</li>
<li><code>Uint8Array</code>：8 位无符号整数，长度 1 个字节。</li>
<li><code>Uint8ClampedArray</code>：8 位无符号整数，长度 1 个字节，溢出处理不同。</li>
<li><code>Int16Array</code>：16 位有符号整数，长度 2 个字节。</li>
<li><code>Uint16Array</code>：16 位无符号整数，长度 2 个字节。</li>
<li><code>Int32Array</code>：32 位有符号整数，长度 4 个字节。</li>
<li><code>Uint32Array</code>：32 位无符号整数，长度 4 个字节。</li>
<li><code>Float32Array</code>：32 位浮点数，长度 4 个字节。</li>
<li><code>Float64Array</code>：64 位浮点数，长度 8 个字节。</li>
</ul>
<p>这 9 个构造函数生成的数组，统称为<code>TypedArray</code>视图。它们很像普通数组，都有<code>length</code>属性，都能用方括号运算符（<code>[]</code>）获取单个元素，所有数组的方法，在它们上面都能使用。普通数组与<code>TypedArray</code>数组的差异主要在以下方面。</p>
<ul>
<li><code>TypedArray</code>数组的所有成员，都是同一种类型。</li>
<li><code>TypedArray</code>数组的成员是连续的，不会有空位。</li>
<li><code>TypedArray</code>数组成员的默认值为 0。比如，<code>new Array(10)</code>返回一个普通数组，里面没有任何成员，只是 10 个空位；<code>new Uint8Array(10)</code>返回一个 * <code>TypedArray</code>数组，里面 10 个成员都是 0。</li>
<li><code>TypedArray</code>数组只是一层视图，本身不储存数据，它的数据都储存在底层的<code>ArrayBuffer</code>对象之中，要获取底层对象必须使用<code>buffer</code>属性。</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>TypedArray</code>数组提供 9 种构造函数，用来生成相应类型的数组实例。</p>
<p>构造函数有多种用法。</p>
<h3 id="1-TypedArray-buffer-byteOffset-x3D-0-length"><a href="#1-TypedArray-buffer-byteOffset-x3D-0-length" class="headerlink" title="1.TypedArray(buffer, byteOffset&#x3D;0, length?)"></a>1.TypedArray(buffer, byteOffset&#x3D;0, length?)</h3><p>同一个<code>ArrayBuffer</code>对象之上，可以根据不同的数据类型，建立多个视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个8字节的ArrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾</span></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾</span></span><br><span class="line"><span class="keyword">const</span> v2 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(b, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指向b的Int16视图，开始于字节2，长度为2</span></span><br><span class="line"><span class="keyword">const</span> v3 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码在一段长度为 8 个字节的内存（b）之上，生成了三个视图：<code>v1、v2</code>和<code>v3</code>。</p>
<p>视图的构造函数可以接受三个参数：</p>
<ul>
<li>第一个参数（必需）：视图对应的底层<code>ArrayBuffer</code>对象。</li>
<li>第二个参数（可选）：视图开始的字节序号，默认从 0 开始。</li>
<li>第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。</li>
</ul>
<p>因此，<code>v1、v2</code>和<code>v3</code>是重叠的：v1[0]是一个 32 位整数，指向字节 0 ～字节 3；<code>v2[0]</code>是一个 8 位无符号整数，指向字节 2；<code>v3[0]</code>是一个 16 位整数，指向字节 2 ～字节 3。只要任何一个视图对内存有所修改，就会在另外两个视图上反应出来。</p>
<p>注意，<code>byteOffset</code>必须与所要建立的数据类型一致，否则会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> i16 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(buffer, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，新生成一个 8 个字节的<code>ArrayBuffer</code>对象，然后在这个对象的第一个字节，建立带符号的 16 位整数视图，结果报错。因为，带符号的 16 位整数需要两个字节，所以<code>byteOffset</code>参数必须能够被 2 整除。</p>
<p>如果想从任意字节开始解读<code>ArrayBuffer</code>对象，必须使用<code>DataView</code>视图，因为<code>TypedArray</code>视图只提供 9 种固定的解读格式。</p>
<h3 id="2-TypedArray-length"><a href="#2-TypedArray-length" class="headerlink" title="2.TypedArray(length)"></a>2.TypedArray(length)</h3><p>视图还可以不通过<code>ArrayBuffer</code>对象，直接分配内存而生成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f64a = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(<span class="number">8</span>);</span><br><span class="line">f64a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">f64a[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">f64a[<span class="number">2</span>] = f64a[<span class="number">0</span>] + f64a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码生成一个 8 个成员的<code>Float64Array</code>数组（共 64 字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p>
<h3 id="3-TypedArray-typedArray"><a href="#3-TypedArray-typedArray" class="headerlink" title="3.TypedArray(typedArray)"></a>3.TypedArray(typedArray)</h3><p><code>TypedArray</code>数组的构造函数，可以接受另一个<code>TypedArray</code>实例作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typedArray = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(<span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Int8Array</code>构造函数接受一个<code>Uint8Array</code>实例作为参数。</p>
<p>注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Int8Array</span>([<span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(x);</span><br><span class="line">x[<span class="number">0</span>] <span class="comment">// 1</span></span><br><span class="line">y[<span class="number">0</span>] <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">y[<span class="number">0</span>] <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>y</code>是以数组<code>x</code>为模板而生成的，当<code>x</code>变动的时候，<code>y</code>并没有变动。</p>
<p>如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="title class_">Int8Array</span>([<span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(x.<span class="property">buffer</span>);</span><br><span class="line">x[<span class="number">0</span>] <span class="comment">// 1</span></span><br><span class="line">y[<span class="number">0</span>] <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">y[<span class="number">0</span>] <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="4-TypedArray-arrayLikeObject"><a href="#4-TypedArray-arrayLikeObject" class="headerlink" title="4.TypedArray(arrayLikeObject)"></a>4.TypedArray(arrayLikeObject)</h3><p>构造函数的参数也可以是一个普通数组，然后直接生成<code>TypedArray</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typedArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
<p>注意，这时<code>TypedArray</code>视图会重新开辟内存，不会在原数组的内存上建立视图。</p>
<p>上面代码从一个普通的数组，生成一个 8 位无符号整数的<code>TypedArray</code>实例。</p>
<p><code>TypedArray</code>数组也可以转换回普通数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalArray = [...typedArray];</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> normalArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(typedArray);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> normalArray = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(typedArray);</span><br></pre></td></tr></table></figure>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>普通数组的操作方法和属性，对<code>TypedArray</code>数组完全适用。</p>
<ul>
<li><code>TypedArray.prototype.copyWithin(target, start[, end = this.length])</code></li>
<li><code>TypedArray.prototype.entries()</code></li>
<li><code>TypedArray.prototype.every(callbackfn, thisArg?)</code></li>
<li><code>TypedArray.prototype.fill(value, start=0, end=this.length)</code></li>
<li><code>TypedArray.prototype.filter(callbackfn, thisArg?)</code></li>
<li><code>TypedArray.prototype.find(predicate, thisArg?)</code></li>
<li><code>TypedArray.prototype.findIndex(predicate, thisArg?)</code></li>
<li><code>TypedArray.prototype.forEach(callbackfn, thisArg?)</code></li>
<li><code>TypedArray.prototype.indexOf(searchElement, fromIndex=0)</code></li>
<li><code>TypedArray.prototype.join(separator)</code></li>
<li><code>TypedArray.prototype.keys()</code></li>
<li><code>TypedArray.prototype.lastIndexOf(searchElement, fromIndex?)</code></li>
<li><code>TypedArray.prototype.map(callbackfn, thisArg?)</code></li>
<li><code>TypedArray.prototype.reduce(callbackfn, initialValue?)</code></li>
<li><code>TypedArray.prototype.reduceRight(callbackfn, initialValue?)</code></li>
<li><code>TypedArray.prototype.reverse()</code></li>
<li><code>TypedArray.prototype.slice(start=0, end=this.length)</code></li>
<li><code>TypedArray.prototype.some(callbackfn, thisArg?)</code></li>
<li><code>TypedArray.prototype.sort(comparefn)</code></li>
<li><code>TypedArray.prototype.toLocaleString(reserved1?, reserved2?)</code></li>
<li><code>TypedArray.prototype.toString()</code></li>
<li><code>TypedArray.prototype.values()</code></li>
</ul>
<p>注意，<code>TypedArray</code>数组没有<code>concat</code>方法。如果想要合并多个<code>TypedArray</code>数组，可以用下面这个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">concatenate</span>(<span class="params">resultConstructor, ...arrays</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> totalLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> arr <span class="keyword">of</span> arrays) &#123;</span><br><span class="line">    totalLength += arr.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="title function_">resultConstructor</span>(totalLength);</span><br><span class="line">  <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> arr <span class="keyword">of</span> arrays) &#123;</span><br><span class="line">    result.<span class="title function_">set</span>(arr, offset);</span><br><span class="line">    offset += arr.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">concatenate</span>(<span class="title class_">Uint8Array</span>, <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">// Uint8Array [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>另外，<code>TypedArray</code>数组与普通数组一样，部署了<code>Iterator</code>接口，所以可以被遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ui8 = <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> byte <span class="keyword">of</span> ui8) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(byte);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>字节序指的是数值在内存中的表示方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> int32View = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; int32View.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  int32View[i] = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码生成一个 16 字节的<code>ArrayBuffer</code>对象，然后在它的基础上，建立了一个 32 位整数的视图。由于每个 32 位整数占据 4 个字节，所以一共可以写入 4 个整数，依次为 0，2，4，6。</p>
<p>如果在这段数据上接着建立一个 16 位整数的视图，则可以读出完全不一样的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> int16View = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; int16View.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Entry &quot;</span> + i + <span class="string">&quot;: &quot;</span> + int16View[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Entry 0: 0</span></span><br><span class="line"><span class="comment">// Entry 1: 0</span></span><br><span class="line"><span class="comment">// Entry 2: 2</span></span><br><span class="line"><span class="comment">// Entry 3: 0</span></span><br><span class="line"><span class="comment">// Entry 4: 4</span></span><br><span class="line"><span class="comment">// Entry 5: 0</span></span><br><span class="line"><span class="comment">// Entry 6: 6</span></span><br><span class="line"><span class="comment">// Entry 7: 0</span></span><br></pre></td></tr></table></figure>
<p>由于每个 16 位整数占据 2 个字节，所以整个<code>ArrayBuffer</code>对象现在分成 8 段。然后，由于 x86 体系的计算机都采用小端字节序（<code>little endian</code>），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。</p>
<p>比如，一个占据四个字节的 16 进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以<code>TypedArray</code>数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。</p>
<p>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，<code>TypedArray</code>数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript 引入<code>DataView</code>对象，可以设定字节序。</p>
<p>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]</span></span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(buffer);</span><br><span class="line">v1[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">v1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">v1[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">v1[<span class="number">3</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uInt16View = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算机采用小端字节序</span></span><br><span class="line"><span class="comment">// 所以头两个字节等于258</span></span><br><span class="line"><span class="keyword">if</span> (uInt16View[<span class="number">0</span>] === <span class="number">258</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;OK&#x27;</span>); <span class="comment">// &quot;OK&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算</span></span><br><span class="line">uInt16View[<span class="number">0</span>] = <span class="number">255</span>;    <span class="comment">// 字节变为[0xFF, 0x00, 0x03, 0x07]</span></span><br><span class="line">uInt16View[<span class="number">0</span>] = <span class="number">0xff05</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x03, 0x07]</span></span><br><span class="line">uInt16View[<span class="number">1</span>] = <span class="number">0x0210</span>; <span class="comment">// 字节变为[0x05, 0xFF, 0x10, 0x02]</span></span><br></pre></td></tr></table></figure>
<p>下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">BIG_ENDIAN</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;BIG_ENDIAN&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LITTLE_ENDIAN</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;LITTLE_ENDIAN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPlatformEndianness</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr32 = <span class="title class_">Uint32Array</span>.<span class="title function_">of</span>(<span class="number">0x12345678</span>);</span><br><span class="line">  <span class="keyword">let</span> arr8 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(arr32.<span class="property">buffer</span>);</span><br><span class="line">  <span class="keyword">switch</span> ((arr8[<span class="number">0</span>]*<span class="number">0x1000000</span>) + (arr8[<span class="number">1</span>]*<span class="number">0x10000</span>) + (arr8[<span class="number">2</span>]*<span class="number">0x100</span>) + (arr8[<span class="number">3</span>])) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x12345678</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">BIG_ENDIAN</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x78563412</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">LITTLE_ENDIAN</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unknown endianness&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，与普通数组相比，<code>TypedArray</code>数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p>
<h2 id="BYTES-PER-ELEMENT-属性"><a href="#BYTES-PER-ELEMENT-属性" class="headerlink" title="BYTES_PER_ELEMENT 属性"></a>BYTES_PER_ELEMENT 属性</h2><p>每一种视图的构造函数，都有一个<code>BYTES_PER_ELEMENT</code>属性，表示这种数据类型占据的字节数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Int8Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Uint8Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Uint8ClampedArray</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Int16Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Uint16Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Int32Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Uint32Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Float32Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Float64Array</span>.<span class="property">BYTES_PER_ELEMENT</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>这个属性在<code>TypedArray</code>实例上也能获取，即有<code>TypedArray.prototype.BYTES_PER_ELEMENT</code>。</p>
<h2 id="ArrayBuffer-与字符串的互相转换"><a href="#ArrayBuffer-与字符串的互相转换" class="headerlink" title="ArrayBuffer 与字符串的互相转换"></a>ArrayBuffer 与字符串的互相转换</h2><p><code>ArrayBuffer</code>和字符串的相互转换，使用原生<code>TextEncoder</code>和<code>TextDecoder</code>方法。为了便于说明用法，下面的代码都按照<code>TypeScript</code>的用法，给出了类型签名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert ArrayBuffer/TypedArray to String via TextDecoder</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ab2str</span>(<span class="params"></span></span><br><span class="line"><span class="params">  input: <span class="built_in">ArrayBuffer</span> | <span class="built_in">Uint8Array</span> | <span class="built_in">Int8Array</span> | <span class="built_in">Uint16Array</span> | <span class="built_in">Int16Array</span> | <span class="built_in">Uint32Array</span> | <span class="built_in">Int32Array</span>,</span></span><br><span class="line"><span class="params">  outputEncoding: string = <span class="string">&#x27;utf8&#x27;</span>,</span></span><br><span class="line"><span class="params"></span>): string &#123;</span><br><span class="line">  <span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">TextDecoder</span>(outputEncoding)</span><br><span class="line">  <span class="keyword">return</span> decoder.<span class="title function_">decode</span>(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert String to ArrayBuffer via TextEncoder</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">str2ab</span>(<span class="params">input: string</span>): <span class="title class_">ArrayBuffer</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> view = <span class="title function_">str2Uint8Array</span>(input)</span><br><span class="line">  <span class="keyword">return</span> view.<span class="property">buffer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Convert String to Uint8Array */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">str2Uint8Array</span>(<span class="params">input: string</span>): <span class="title class_">Uint8Array</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> encoder = <span class="keyword">new</span> <span class="title class_">TextEncoder</span>()</span><br><span class="line">  <span class="keyword">const</span> view = encoder.<span class="title function_">encode</span>(input)</span><br><span class="line">  <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>ab2str()</code>的第二个参数<code>outputEncoding</code>给出了输出编码的编码，一般保持默认值（utf-8）。</p>
<h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。比如，8 位视图只能容纳一个 8 位的二进制值，如果放入一个 9 位的值，就会溢出。</p>
<p><code>TypedArray</code>数组的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uint8 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">uint8[<span class="number">0</span>] = <span class="number">256</span>;</span><br><span class="line">uint8[<span class="number">0</span>] <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">uint8[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">uint8[<span class="number">0</span>] <span class="comment">// 255</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>uint8</code>是一个 8 位视图，而 256 的二进制形式是一个 9 位的值100000000，这时就会发生溢出。根据规则，只会保留后 8 位，即00000000。<code>uint8</code>视图的解释规则是无符号的 8 位整数，所以00000000就是0。</p>
<p>负数在计算机内部采用“2 的补码”表示，也就是说，将对应的正数值进行否运算，然后加1。比如，-1对应的正值是1，进行否运算以后，得到11111110，再加上1就是补码形式11111111。uint8按照无符号的 8 位整数解释11111111，返回结果就是255。</p>
<p>一个简单转换规则，可以这样表示。</p>
<p>正向溢出（<code>overflow</code>）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值，再减去 1。<br>负向溢出（<code>underflow</code>）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余值的绝对值，再加上 1。<br>上面的“余值”就是模运算的结果，即 JavaScript 里面的%运算符的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> % <span class="number">4</span> <span class="comment">// 0</span></span><br><span class="line"><span class="number">12</span> % <span class="number">5</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，12 除以 4 是没有余值的，而除以 5 会得到余值 2。</p>
<p>请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> int8 = <span class="keyword">new</span> <span class="title class_">Int8Array</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">int8[<span class="number">0</span>] = <span class="number">128</span>;</span><br><span class="line">int8[<span class="number">0</span>] <span class="comment">// -128</span></span><br><span class="line"></span><br><span class="line">int8[<span class="number">0</span>] = -<span class="number">129</span>;</span><br><span class="line">int8[<span class="number">0</span>] <span class="comment">// 127</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>int8</code>是一个带符号的 8 位整数视图，它的最大值是 127，最小值是-128。输入值为128时，相当于正向溢出1，根据“最小值加上余值（128 除以 127 的余值是 1），再减去 1”的规则，就会返回-128；输入值为-129时，相当于负向溢出1，根据“最大值减去余值的绝对值（-129 除以-128 的余值的绝对值是 1），再加上 1”的规则，就会返回127。</p>
<p><code>Uint8ClampedArray</code>视图的溢出规则，与上面的规则不同。它规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即 255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uint8c = <span class="keyword">new</span> <span class="title class_">Uint8ClampedArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">uint8c[<span class="number">0</span>] = <span class="number">256</span>;</span><br><span class="line">uint8c[<span class="number">0</span>] <span class="comment">// 255</span></span><br><span class="line"></span><br><span class="line">uint8c[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">uint8c[<span class="number">0</span>] <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>uint8C</code>是一个<code>Uint8ClampedArray</code>视图，正向溢出时都返回 255，负向溢出都返回 0。</p>
<h2 id="TypedArray-prototype-buffer"><a href="#TypedArray-prototype-buffer" class="headerlink" title="TypedArray.prototype.buffer"></a>TypedArray.prototype.buffer</h2><p><code>TypedArray</code>实例的<code>buffer</code>属性，返回整段内存区域对应的<code>ArrayBuffer</code>对象。该属性为只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(a.<span class="property">buffer</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>a</code>视图对象和<code>b</code>视图对象，对应同一个<code>ArrayBuffer</code>对象，即同一段内存。</p>
<h2 id="TypedArray-prototype-byteLength，TypedArray-prototype-byteOffset"><a href="#TypedArray-prototype-byteLength，TypedArray-prototype-byteOffset" class="headerlink" title="TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset"></a>TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset</h2><p><code>byteLength</code>属性返回<code>TypedArray</code>数组占据的内存长度，单位为字节。<code>byteOffset</code>属性返回<code>TypedArray</code>数组从底层<code>ArrayBuffer</code>对象的哪个字节开始。这两个属性都是只读属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(b);</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(b, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(b, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">v1.<span class="property">byteLength</span> <span class="comment">// 8</span></span><br><span class="line">v2.<span class="property">byteLength</span> <span class="comment">// 6</span></span><br><span class="line">v3.<span class="property">byteLength</span> <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">v1.<span class="property">byteOffset</span> <span class="comment">// 0</span></span><br><span class="line">v2.<span class="property">byteOffset</span> <span class="comment">// 2</span></span><br><span class="line">v3.<span class="property">byteOffset</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="TypedArray-prototype-length"><a href="#TypedArray-prototype-length" class="headerlink" title="TypedArray.prototype.length"></a>TypedArray.prototype.length</h2><p><code>length</code>属性表示<code>TypedArray</code>数组含有多少个成员。注意将<code>length</code>属性和<code>byteLength</code>属性区分，前者是成员长度，后者是字节长度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Int16Array</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">a.<span class="property">length</span> <span class="comment">// 8</span></span><br><span class="line">a.<span class="property">byteLength</span> <span class="comment">// 16</span></span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">set</span>()</span><br></pre></td></tr></table></figure>
<p><code>TypedArray</code>数组的<code>set</code>方法用于复制数组（普通数组或<code>TypedArray</code>数组），也就是将一段内容完全复制到另一段内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">b.<span class="title function_">set</span>(a);</span><br></pre></td></tr></table></figure>
<p>上面代码复制<code>a</code>数组的内容到<code>b</code>数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。</p>
<p><code>set</code>方法还可以接受第二个参数，表示从<code>b</code>对象的哪一个成员开始复制a对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">b.<span class="title function_">set</span>(a, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码的b数组比a数组多两个成员，所以从<code>b[2]</code>开始复制。</p>
<h2 id="TypedArray-prototype-subarray"><a href="#TypedArray-prototype-subarray" class="headerlink" title="TypedArray.prototype.subarray()"></a>TypedArray.prototype.subarray()</h2><p><code>subarray</code>方法是对于<code>TypedArray</code>数组的一部分，再建立一个新的视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">subarray</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">a.<span class="property">byteLength</span> <span class="comment">// 16</span></span><br><span class="line">b.<span class="property">byteLength</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>subarray</code>方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的<code>a.subarray(2,3)</code>，意味着<code>b</code>只包含<code>a[2]</code>一个成员，字节长度为 2。</p>
<h2 id="TypedArray-prototype-slice"><a href="#TypedArray-prototype-slice" class="headerlink" title="TypedArray.prototype.slice()"></a>TypedArray.prototype.slice()</h2><p><code>TypeArray</code>实例的<code>slice</code>方法，可以返回一个指定位置的新的<code>TypedArray</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ui8 = <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ui8.<span class="title function_">slice</span>(-<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Uint8Array [ 2 ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>ui8</code>是 8 位无符号整数数组视图的一个实例。它的<code>slice</code>方法可以从当前视图之中，返回一个新的视图实例。</p>
<p><code>slice</code>方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即 -1 为倒数第一个位置，-2 表示倒数第二个位置，以此类推。</p>
<h2 id="TypedArray-of"><a href="#TypedArray-of" class="headerlink" title="TypedArray.of()"></a>TypedArray.of()</h2><p><code>TypedArray</code>数组的所有构造函数，都有一个静态方法of，用于将参数转为一个<code>TypedArray</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Float32Array</span>.<span class="title function_">of</span>(<span class="number">0.151</span>, -<span class="number">8</span>, <span class="number">3.7</span>)</span><br><span class="line"><span class="comment">// Float32Array [ 0.151, -8, 3.7 ]</span></span><br></pre></td></tr></table></figure>
<p>下面三种方法都会生成同样一个<code>TypedArray</code>数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> tarr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> tarr = <span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="keyword">let</span> tarr = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">3</span>);</span><br><span class="line">tarr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">tarr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">tarr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="title class_">TypedArray</span>.<span class="title function_">from</span>()</span><br></pre></td></tr></table></figure>
<p>静态方法<code>from</code>接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的<code>TypedArray</code>实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Uint16Array</span>.<span class="title function_">from</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">// Uint16Array [ 0, 1, 2 ]</span></span><br></pre></td></tr></table></figure>
<p>这个方法还可以将一种<code>TypedArray</code>实例，转为另一种。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ui16 = <span class="title class_">Uint16Array</span>.<span class="title function_">from</span>(<span class="title class_">Uint8Array</span>.<span class="title function_">of</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">ui16 <span class="keyword">instanceof</span> <span class="title class_">Uint16Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>from</code>方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似<code>map</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Int8Array</span>.<span class="title function_">of</span>(<span class="number">127</span>, <span class="number">126</span>, <span class="number">125</span>).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">2</span> * x)</span><br><span class="line"><span class="comment">// Int8Array [ -2, -4, -6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Int16Array</span>.<span class="title function_">from</span>(<span class="title class_">Int8Array</span>.<span class="title function_">of</span>(<span class="number">127</span>, <span class="number">126</span>, <span class="number">125</span>), <span class="function"><span class="params">x</span> =&gt;</span> <span class="number">2</span> * x)</span><br><span class="line"><span class="comment">// Int16Array [ 254, 252, 250 ]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>from</code>方法没有发生溢出，这说明遍历不是针对原来的 8 位整数数组。也就是说，<code>from</code>会将第一个参数指定的<code>TypedArray</code>数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式。</p>
<h1 id="复合视图"><a href="#复合视图" class="headerlink" title="复合视图"></a>复合视图</h1><p>由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idView = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(buffer, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> usernameView = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(buffer, <span class="number">4</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> amountDueView = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(buffer, <span class="number">20</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码将一个 24 字节长度的<code>ArrayBuffer</code>对象，分成三个部分：</p>
<ul>
<li>字节 0 到字节 3：1 个 32 位无符号整数</li>
<li>字节 4 到字节 19：16 个 8 位整数</li>
<li>字节 20 到字节 23：1 个 32 位浮点数</li>
</ul>
<p>这种数据结构可以用如下的 C 语言描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct someStruct &#123;</span><br><span class="line">  unsigned long id;</span><br><span class="line">  char username[<span class="number">16</span>];</span><br><span class="line">  float amountDue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="DataView-视图"><a href="#DataView-视图" class="headerlink" title="DataView 视图"></a>DataView 视图</h1><p>如果一段数据包括多种类型（比如服务器传来的 HTTP 数据），这时除了建立<code>ArrayBuffer</code>对象的复合视图以外，还可以通过<code>DataView</code>视图进行操作。</p>
<p><code>DataView</code>视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，<code>ArrayBuffer</code>对象的各种<code>TypedArray</code>视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而<code>DataView</code>视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>
<p><code>DataView</code>视图本身也是构造函数，接受一个<code>ArrayBuffer</code>对象作为参数，生成视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DataView</span>(<span class="title class_">ArrayBuffer</span> buffer [, 字节起始位置 [, 长度]]);</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">const</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br></pre></td></tr></table></figure>
<p><code>DataView</code>实例有以下属性，含义与<code>TypedArray</code>实例的同名方法相同。</p>
<ul>
<li><p><code>DataView.prototype.buffer</code>：返回对应的<code>ArrayBuffer</code>对象</p>
</li>
<li><p><code>DataView.prototype.byteLength</code>：返回占据的内存字节长度</p>
</li>
<li><p><code>DataView.prototype.byteOffset</code>：返回当前视图从对应的<code>ArrayBuffer</code>对象的哪个字节开始<br>DataView实例提供 8 个方法读取内存。</p>
</li>
<li><p><code>getInt8</code>：读取 1 个字节，返回一个 8 位整数。</p>
</li>
<li><p><code>getUint8</code>：读取 1 个字节，返回一个无符号的 8 位整数。</p>
</li>
<li><p><code>getInt16</code>：读取 2 个字节，返回一个 16 位整数。</p>
</li>
<li><p><code>getUint16</code>：读取 2 个字节，返回一个无符号的 16 位整数。</p>
</li>
<li><p><code>getInt32</code>：读取 4 个字节，返回一个 32 位整数。</p>
</li>
<li><p><code>getUint32</code>：读取 4 个字节，返回一个无符号的 32 位整数。</p>
</li>
<li><p><code>getFloat32</code>：读取 4 个字节，返回一个 32 位浮点数。</p>
</li>
<li><p><code>getFloat64</code>：读取 8 个字节，返回一个 64 位浮点数。</p>
</li>
</ul>
<p>这一系列<code>get</code>方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">const</span> dv = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第1个字节读取一个8位无符号整数</span></span><br><span class="line"><span class="keyword">const</span> v1 = dv.<span class="title function_">getUint8</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第2个字节读取一个16位无符号整数</span></span><br><span class="line"><span class="keyword">const</span> v2 = dv.<span class="title function_">getUint16</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从第4个字节读取一个16位无符号整数</span></span><br><span class="line"><span class="keyword">const</span> v3 = dv.<span class="title function_">getUint16</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码读取了<code>ArrayBuffer</code>对象的前 5 个字节，其中有一个 8 位整数和两个十六位整数。</p>
<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，<code>DataView</code>的<code>get</code>方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在<code>get</code>方法的第二个参数指定true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小端字节序</span></span><br><span class="line"><span class="keyword">const</span> v1 = dv.<span class="title function_">getUint16</span>(<span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端字节序</span></span><br><span class="line"><span class="keyword">const</span> v2 = dv.<span class="title function_">getUint16</span>(<span class="number">3</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端字节序</span></span><br><span class="line"><span class="keyword">const</span> v3 = dv.<span class="title function_">getUint16</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>DataView 视图提供 8 个方法写入内存。</p>
<ul>
<li><code>setInt8</code>：写入 1 个字节的 8 位整数。</li>
<li><code>setUint8</code>：写入 1 个字节的 8 位无符号整数。</li>
<li><code>setInt16</code>：写入 2 个字节的 16 位整数。</li>
<li><code>setUint16</code>：写入 2 个字节的 16 位无符号整数。</li>
<li><code>setInt32</code>：写入 4 个字节的 32 位整数。</li>
<li><code>setUint32</code>：写入 4 个字节的 32 位无符号整数。</li>
<li><code>setFloat32</code>：写入 4 个字节的 32 位浮点数。</li>
<li><code>setFloat64</code>：写入 8 个字节的 64 位浮点数。</li>
</ul>
<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，<code>false</code>或者<code>undefined</code>表示使用大端字节序写入，true表示使用小端字节序写入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在第1个字节，以大端字节序写入值为25的32位整数</span></span><br><span class="line">dv.<span class="title function_">setInt32</span>(<span class="number">0</span>, <span class="number">25</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第5个字节，以大端字节序写入值为25的32位整数</span></span><br><span class="line">dv.<span class="title function_">setInt32</span>(<span class="number">4</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第9个字节，以小端字节序写入值为2.5的32位浮点数</span></span><br><span class="line">dv.<span class="title function_">setFloat32</span>(<span class="number">8</span>, <span class="number">2.5</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> littleEndian = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer).<span class="title function_">setInt16</span>(<span class="number">0</span>, <span class="number">256</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Int16Array</span>(buffer)[<span class="number">0</span>] === <span class="number">256</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果返回true，就是小端字节序；如果返回false，就是大端字节序。</p>
<h1 id="二进制数组的应用"><a href="#二进制数组的应用" class="headerlink" title="二进制数组的应用"></a>二进制数组的应用</h1><p>大量的 Web API 用到了<code>ArrayBuffer</code>对象和它的视图对象。</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>传统上，服务器通过 AJAX 操作只能返回文本数据，即<code>responseType</code>属性默认为<code>text</code>。<code>XMLHttpRequest</code>第二版<code>XHR2</code>允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（<code>responseType</code>）设为<code>arraybuffer</code>；如果不知道，就设为<code>blob</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, someUrl);</span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arrayBuffer = xhr.<span class="property">response</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>
<p>如果知道传回来的是 32 位整数，可以像下面这样处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">readyState</span> === <span class="number">4</span> ) &#123;</span><br><span class="line">    <span class="keyword">const</span> arrayResponse = xhr.<span class="property">response</span>;</span><br><span class="line">    <span class="keyword">const</span> dataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(arrayResponse);</span><br><span class="line">    <span class="keyword">const</span> ints = <span class="keyword">new</span> <span class="title class_">Uint32Array</span>(dataView.<span class="property">byteLength</span> / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    xhrDiv.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;#00FF00&quot;</span>;</span><br><span class="line">    xhrDiv.<span class="property">innerText</span> = <span class="string">&quot;Array is &quot;</span> + ints.<span class="property">length</span> + <span class="string">&quot;uints long&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>网页Canvas元素输出的二进制像素数据，就是<code>TypedArray</code>数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imageData = ctx.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line"><span class="keyword">const</span> uint8ClampedArray = imageData.<span class="property">data</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，上面代码的<code>uint8ClampedArray</code>虽然是一个<code>TypedArray</code>数组，但是它的视图类型是一种针对Canvas元素的专有类型<code>Uint8ClampedArray</code>。这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的 8 位整数，即只能取值 0 ～ 255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。</p>
<p>举例来说，如果把像素的颜色值设为<code>Uint8Array</code>类型，那么乘以一个<code>gamma</code>值的时候，就必须这样计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u8[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">255</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, u8[i] * gamma));</span><br></pre></td></tr></table></figure>
<p>因为<code>Uint8Array</code>类型对于大于 255 的运算结果（比如0xFF+1），会自动变为0x00，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。如果将颜色值设为<code>Uint8ClampedArray</code>类型，计算就简化许多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixels[i] *= gamma;</span><br></pre></td></tr></table></figure>
<p><code>Uint8ClampedArray</code>类型确保将小于 0 的值设为 0，将大于 255 的值设为 255。注意，IE 10 不支持该类型。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket可以通过<code>ArrayBuffer</code>，发送或接收二进制数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://127.0.0.1:8081&#x27;</span>);</span><br><span class="line">socket.<span class="property">binaryType</span> = <span class="string">&#x27;arraybuffer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait until socket is open</span></span><br><span class="line">socket.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// Send binary data</span></span><br><span class="line">  <span class="keyword">const</span> typedArray = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="number">4</span>);</span><br><span class="line">  socket.<span class="title function_">send</span>(typedArray.<span class="property">buffer</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive binary data</span></span><br><span class="line">socket.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arrayBuffer = event.<span class="property">data</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h2><p>Fetch API 取回的数据，就是<code>ArrayBuffer</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">arrayBuffer</span>()</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">arrayBuffer</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h2><p>如果知道一个文件的二进制数据类型，也可以将这个文件读取为<code>ArrayBuffer</code>对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arrayBuffer = reader.<span class="property">result</span>;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面以处理<code>bmp</code>文件为例。假定<code>file</code>变量是一个指向<code>bmp</code>文件的文件对象，首先读取文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, processimage, <span class="literal">false</span>);</span><br><span class="line">reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br></pre></td></tr></table></figure>
<p>然后，定义处理图像的回调函数：先在二进制数据之上建立一个<code>DataView</code>视图，再建立一个<code>bitmap</code>对象，用于存放处理后的数据，最后将图像展示在Canvas元素之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">processimage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> buffer = e.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="keyword">const</span> datav = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);</span><br><span class="line">  <span class="keyword">const</span> bitmap = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 具体的处理步骤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体处理图像数据时，先处理<code>bmp</code>的文件头。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bitmap.<span class="property">fileheader</span> = &#123;&#125;;</span><br><span class="line">bitmap.<span class="property">fileheader</span>.<span class="property">bfType</span> = datav.<span class="title function_">getUint16</span>(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">fileheader</span>.<span class="property">bfSize</span> = datav.<span class="title function_">getUint32</span>(<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">fileheader</span>.<span class="property">bfReserved1</span> = datav.<span class="title function_">getUint16</span>(<span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">fileheader</span>.<span class="property">bfReserved2</span> = datav.<span class="title function_">getUint16</span>(<span class="number">8</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">fileheader</span>.<span class="property">bfOffBits</span> = datav.<span class="title function_">getUint32</span>(<span class="number">10</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>接着处理图像元信息部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bitmap.<span class="property">infoheader</span> = &#123;&#125;;</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biSize</span> = datav.<span class="title function_">getUint32</span>(<span class="number">14</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biWidth</span> = datav.<span class="title function_">getUint32</span>(<span class="number">18</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biHeight</span> = datav.<span class="title function_">getUint32</span>(<span class="number">22</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biPlanes</span> = datav.<span class="title function_">getUint16</span>(<span class="number">26</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biBitCount</span> = datav.<span class="title function_">getUint16</span>(<span class="number">28</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biCompression</span> = datav.<span class="title function_">getUint32</span>(<span class="number">30</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biSizeImage</span> = datav.<span class="title function_">getUint32</span>(<span class="number">34</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biXPelsPerMeter</span> = datav.<span class="title function_">getUint32</span>(<span class="number">38</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biYPelsPerMeter</span> = datav.<span class="title function_">getUint32</span>(<span class="number">42</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biClrUsed</span> = datav.<span class="title function_">getUint32</span>(<span class="number">46</span>, <span class="literal">true</span>);</span><br><span class="line">bitmap.<span class="property">infoheader</span>.<span class="property">biClrImportant</span> = datav.<span class="title function_">getUint32</span>(<span class="number">50</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>最后处理图像本身的像素信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = bitmap.<span class="property">fileheader</span>.<span class="property">bfOffBits</span>;</span><br><span class="line">bitmap.<span class="property">pixels</span> = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(buffer, start);</span><br></pre></td></tr></table></figure>
<p>至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在Canvas网页元素之中。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS匿名函数与自执行"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/07/15/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E8%87%AA%E6%89%A7%E8%A1%8C/"
    >JS匿名函数与自执行</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/07/15/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E8%87%AA%E6%89%A7%E8%A1%8C/" class="article-date">
  <time datetime="2019-07-15T09:08:16.000Z" itemprop="datePublished">2019-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>匿名函数：就是没有函数名的函数。</p>
<p>声明一个匿名函数，并马上调用这个匿名函数就叫做匿名立即执行函数。</p>
<h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>首先, 要清楚函数语句和表达式的区别。<br><code>function</code>这个关键字，既可以当做语句，也可以当做表达式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免解析上的歧义，JS引擎规定，如果<code>function</code>出现在行首，一律解析成语句。因此JS引擎看到行首是<code>function</code>关键字以后，认为这一段都是函数定义。让JS引擎将其理解为一个表达式，最简单的处理就是将其放在一个圆括号里。</p>
<p>像如下的代码所示，就是一个匿名立即执行函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>立即执行函数，还有一些其他的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;())</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;)()</span><br><span class="line">!<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;()</span><br><span class="line">+<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;()</span><br><span class="line">-<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;()</span><br><span class="line">~<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;()</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;()</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">alert</span>(<span class="string">&quot;我是匿名函数&quot;</span>)&#125;()</span><br></pre></td></tr></table></figure>
<p><code>+ ! - ~ void</code>等操作符的作用是将函数转换为表达式。</p>
<h2 id="括号的意义"><a href="#括号的意义" class="headerlink" title="括号的意义"></a>括号的意义</h2><p>包住<code>function()&#123;&#125;</code>的括号是把<code>function()&#123;&#125;</code>转化成一个可执行的表达式，方便执行。<br>第二个括号的作用就是执行表达式。</p>
<p>当js执行<code>function() &#123;&#125;()</code>时, 由于<code>function() &#123;&#125;</code>在”预编译”阶段已经被解释过, js会跳过<code>function()&#123;&#125;</code>, 试图去执行<code>()</code>, 故会报错。</p>
<p>当js执行<code>(function &#123;&#125;)()</code>时, 由于<code>(function &#123;&#125;)</code>是表达式, js会去对它求解得到返回值, 由于返回值是一个函数, 故而遇到<code>()</code>时, 便会被执行。</p>
<h1 id="立即执行函数的参数"><a href="#立即执行函数的参数" class="headerlink" title="立即执行函数的参数"></a>立即执行函数的参数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line">  <span class="comment">//代码中可以使用j</span></span><br><span class="line">&#125;)(i)</span><br></pre></td></tr></table></figure>
<p>如果立即执行函数中需要全局变量，全局变量会被作为一个参数传递给立即执行函数。<br>上例中的<code>i</code>就是一个全局变量，<code>i</code>代表的是实参，<code>j</code>是i在立即执行函数中的形参。</p>
<h1 id="立即执行函数的作用"><a href="#立即执行函数的作用" class="headerlink" title="立即执行函数的作用"></a>立即执行函数的作用</h1><p>立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/JS深拷贝和浅拷贝"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/07/15/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"
    >JS深拷贝和浅拷贝</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/07/15/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time datetime="2019-07-15T09:08:16.000Z" itemprop="datePublished">2019-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据分为基本数据类型(<code>String</code>，<code>Number</code>，<code>Boolean</code>，<code>Null</code>，<code>Undefined</code>，<code>Symbol</code>)和对象数据类型。</p>
<ul>
<li>基本数据类型的特点：直接存储在栈(<code>stack</code>)中的数据</li>
<li>引用数据类型的特点：<strong>存储的是该对象在栈中引用，真实的数据存放在堆内存里</strong></li>
</ul>
<p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3534846-b71d714f367d14c7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h1><p>深拷贝和浅拷贝是只针对<code>Object</code>和<code>Array</code>这样的引用数据类型的。<br>深拷贝和浅拷贝的示意图大致如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3534846-162d55fd3baeaa8f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
<h1 id="赋值和浅拷贝的区别"><a href="#赋值和浅拷贝的区别" class="headerlink" title="赋值和浅拷贝的区别"></a>赋值和浅拷贝的区别</h1><p>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象的在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</p>
<p>浅拷贝是按位拷贝对象，<strong>它会创建一个新对象</strong>，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p>
<p>我们先来看两个例子，对比赋值与浅拷贝会对原对象带来哪些改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象赋值</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;    </span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>,    </span><br><span class="line">  <span class="string">&#x27;age&#x27;</span> :  <span class="string">&#x27;18&#x27;</span>,    </span><br><span class="line">  <span class="string">&#x27;language&#x27;</span> : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj2.<span class="property">language</span>[<span class="number">1</span>] = [<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>, obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj2&#x27;</span>, obj2)</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3534846-a36719bccb28b4ea?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;    </span><br><span class="line">  <span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;age&#x27;</span> :  <span class="string">&#x27;18&#x27;</span>,    </span><br><span class="line">  <span class="string">&#x27;language&#x27;</span> : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="title function_">shallowCopy</span>(obj1);</span><br><span class="line">obj3.<span class="property">name</span> = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">obj3.<span class="property">language</span>[<span class="number">1</span>] = [<span class="string">&quot;二&quot;</span>,<span class="string">&quot;三&quot;</span>]; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">src</span>) &#123;    </span><br><span class="line">  <span class="keyword">var</span> dst = &#123;&#125;;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (src.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">      dst[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj3&#x27;</span>,obj3)</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3534846-3ad34a6707bd2483?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>上面例子中，<code>obj1</code>是原始数据，<code>obj2</code>是赋值操作得到，而<code>obj3</code>浅拷贝得到。我们可以很清晰看到对原始数据的影响，具体请看下表：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3534846-4797068d8de133aa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h1><h2 id="1、Object-assign"><a href="#1、Object-assign" class="headerlink" title="1、Object.assign()"></a>1、Object.assign()</h2><p><code>Object.assign()</code>方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是<code>Object.assign()</code>进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: &#123;<span class="attr">a</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">b</span>: <span class="number">39</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> initalObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">initalObj.<span class="property">a</span>.<span class="property">a</span> = <span class="string">&quot;wade&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">a</span>.<span class="property">a</span>); <span class="comment">//wade</span></span><br></pre></td></tr></table></figure>
<p>注意：当<code>object</code>只有一层的时候，是深拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">username</span>: <span class="string">&#x27;kobe&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">obj2.<span class="property">username</span> = <span class="string">&#x27;wade&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">//&#123;username: &quot;kobe&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="2、Array-prototype-concat"><a href="#2、Array-prototype-concat" class="headerlink" title="2、Array.prototype.concat()"></a>2、Array.prototype.concat()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;    </span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;kobe&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">concat</span>();    </span><br><span class="line">arr2[<span class="number">2</span>].<span class="property">username</span> = <span class="string">&#x27;wade&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>
<p>修改新对象会改到原对象：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3534846-8065f72d7ab4eec9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="3、Array-prototype-slice"><a href="#3、Array-prototype-slice" class="headerlink" title="3、Array.prototype.slice()"></a>3、Array.prototype.slice()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.<span class="title function_">slice</span>();</span><br><span class="line">arr3[<span class="number">2</span>].<span class="property">username</span> = <span class="string">&#x27;wade&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>
<p>同样修改新对象会改到原对象：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3534846-c5930a7f1b762e6b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>关于Array的<code>slice</code>和<code>concat</code>方法的补充说明：Array的<code>slice</code>和<code>concat</code>方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。<br>原数组的元素会按照下述规则拷贝：</p>
<ul>
<li>如果该元素是个对象引用(不是实际的对象)，<code>slice</code>会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。</li>
<li>对于字符串、数字及布尔值来说（不是<code>String</code>、<code>Number</code>或者<code>Boolean</code>对象），<code>slice</code>会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.<span class="title function_">slice</span>();</span><br><span class="line">arr3[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr, arr3);</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3534846-3163efd685bda110?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h1 id="五、深拷贝的实现方式"><a href="#五、深拷贝的实现方式" class="headerlink" title="五、深拷贝的实现方式"></a>五、深拷贝的实现方式</h1><h3 id="1、JSON-parse-JSON-stringify"><a href="#1、JSON-parse-JSON-stringify" class="headerlink" title="1、JSON.parse(JSON.stringify())"></a>1、JSON.parse(JSON.stringify())</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));</span><br><span class="line">arr4[<span class="number">2</span>].<span class="property">username</span> = <span class="string">&#x27;duncan&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr, arr4);</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3534846-87acfa35bcffe5d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>原理： 用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse()</code>把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>
<p>这种方法虽然可以实现数组或对象深拷贝，但不能处理函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27; kobe&#x27;</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr));</span><br><span class="line">arr4[<span class="number">2</span>].<span class="property">username</span> = <span class="string">&#x27;duncan&#x27;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr, arr4);</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/3534846-c808f47a5e63a2fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这是因为<code>JSON.stringify()</code>方法是将一个JavaScript值(对象或者数组)转换为一个JSON字符串，不能接受函数。</p>
<h2 id="2、手写递归方法"><a href="#2、手写递归方法" class="headerlink" title="2、手写递归方法"></a>2、手写递归方法</h2><p>递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简便方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params"> obj </span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> target = <span class="title class_">Array</span>.<span class="title function_">isArray</span>( obj ) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="keyword">typeof</span> obj[ k ] === <span class="string">&#x27;object&#x27;</span> ? target[ k ] = <span class="title function_">deepClone</span>(obj[ k ]) : target[ k ] = obj[ k ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = obj =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(clone).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    clone[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepClone</span>(obj[key]) : obj[key]</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) &amp;&amp; obj.<span class="property">length</span> ? (clone.<span class="property">length</span> = obj.<span class="property">length</span>) &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">from</span>(clone) : <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? <span class="title class_">Array</span>.<span class="title function_">from</span>(obj) : clone;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/ES6/ES6 Set和Map数据结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/07/13/%E5%89%8D%E7%AB%AF/ES6/ES6%20Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
    >ES6 Set和Map数据结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/07/13/%E5%89%8D%E7%AB%AF/ES6/ES6%20Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2019-07-13T13:51:09.000Z" itemprop="datePublished">2019-07-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/ES6/">ES6</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>Set</code>数据结构类似于数组，但是成员的值都是唯一的，没有重复的值。<br><code>Set</code>本身是一个构造函数，用来生成<code>Set</code>数据结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">x</span> =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 2 3 5 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码通过<code>add</code>方法向<code>Set</code>结构加入成员，结果表明<code>Set</code>结构不会添加重复的值。<br><code>Set</code>函数可以接受一个数组（或者具有<code>iterable</code>接口的其他数据结构）作为参数，用来初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set] <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.<span class="property">size</span> <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span>=&gt;</span>set.<span class="title function_">add</span>(div));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br></pre></td></tr></table></figure>
<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure>
<p>向<code>Set</code>加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。<code>Set</code>内部判断两个值是否不同，使用的算法类似于精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line">set.<span class="title function_">add</span>(a);</span><br><span class="line">set.<span class="title function_">add</span>(b);</span><br><span class="line">set <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码向<code>Set</code>实例添加了两个<code>NaN</code>，但是只能加入一个。这表明，在<code>Set</code>内部，两个<code>NaN</code>是相等。<br>另外，两个对象总是不相等的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 1</span></span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h2><p><code>Set</code>结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p><code>Set</code>实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。四个操作方法：</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回<code>Set</code>结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line">s.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = &#123;</span><br><span class="line">  <span class="string">&#x27;width&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;height&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (properties[someName]) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">properties.<span class="title function_">add</span>(<span class="string">&#x27;width&#x27;</span>);</span><br><span class="line">properties.<span class="title function_">add</span>(<span class="string">&#x27;height&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (properties.<span class="title function_">has</span>(someName)) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Array.from</code>方法可以将<code>Set</code>结构转为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(items);</span><br></pre></td></tr></table></figure>
<p>这就提供了去除数组重复成员的另一种方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h2><p><code>Set</code>结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用<code>Set</code>保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<h4 id="1-keys-values-entries"><a href="#1-keys-values-entries" class="headerlink" title="(1)keys(),values(),entries()"></a>(1)keys(),values(),entries()</h4><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象。由于<code>Set</code>结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。<br><code>Set</code>结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === <span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">values</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历<code>Set</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure>
<h4 id="2-forEach"><a href="#2-forEach" class="headerlink" title="(2)forEach()"></a>(2)forEach()</h4><p><code>Set</code>结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，<code>Set</code>结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。<br>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。<br>(3)遍历的应用<br>扩展运算符（…）内部使用<code>for...of</code>循环，所以也可以用于<code>Set</code>结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符和<code>Set</code>结构相结合，就可以去除数组的重复成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure>
<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于<code>Set</code>了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此使用<code>Set</code>可以很容易地实现并集、交集和差集。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果想在遍历操作中，同步改变原来的<code>Set</code>结构，目前没有直接的方法，但有两种变通方法。一种是利用原<code>Set</code>结构映射出一个新的结构，然后赋值给原来的<code>Set</code>结构；另一种是利用<code>Array.from</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p><code>WeakSet</code>结构与<code>Set</code>类似，也是不重复的值的集合。但是，它与<code>Set</code>有两个区别。<br>首先，<code>WeakSet</code>的成员只能是对象，而不能是其他类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">ws.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.<span class="title function_">add</span>(<span class="title class_">Symbol</span>())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>其次，<code>WeakSet</code>中的对象都是弱引用，即垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于<code>WeakSet</code>之中。<br>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。<code>WeakSet</code>里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，<code>WeakSet</code>适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在<code>WeakSet</code>里面的引用就会自动消失。<br>由于上面这个特点，<code>WeakSet</code>的成员是不适合引用的，因为它会随时消失。另外，由于<code>WeakSet</code>内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此ES6规定<code>WeakSet</code>不可遍历。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>WeakSet</code>是一个构造函数，可以使用<code>new</code>命令，创建<code>WeakSet</code>数据结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure>
<p>作为构造函数，<code>WeakSet </code>可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有<code>Iterable</code>接口的对象，都可以作为<code>WeakSet</code>的参数。）该数组的所有成员，都会自动成为<code>WeakSet</code>实例对象的成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，是<code>a</code>数组的成员成为<code>WeakSet</code>的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(b);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组<code>b</code>的成员不是对象，加入<code>WeaKSet</code>就会报错。<br><code>WeakSet</code>结构有以下三个方法。</p>
<ul>
<li><code>WeakSet.prototype.add(value)</code>：向<code>WeakSet</code>实例添加一个新成员。</li>
<li><code>WeakSet.prototype.delete(value)</code>：清除<code>WeakSet</code>实例的指定成员。</li>
<li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在<code>WeakSet</code>实例之中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">ws.<span class="title function_">add</span>(<span class="variable language_">window</span>);</span><br><span class="line">ws.<span class="title function_">add</span>(obj);</span><br><span class="line">ws.<span class="title function_">has</span>(<span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line">ws.<span class="title function_">has</span>(foo);    <span class="comment">// false</span></span><br><span class="line">ws.<span class="title function_">delete</span>(<span class="variable language_">window</span>);</span><br><span class="line">ws.<span class="title function_">has</span>(<span class="variable language_">window</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="title class_">WeakSet</span> 没有size属性，没有办法遍历它的成员。</span><br><span class="line">ws.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">ws.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line">ws.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WeakSet has &#x27;</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。<br><code>WeakSet</code>不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。<code>WeakSet</code>的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。<br>下面是<code>WeakSet</code>的另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    foos.<span class="title function_">add</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Foo.prototype.method 只能在Foo的实例上调用！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 <code>WeakSet</code>的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h2><p>JavaScript的对象，本质上是键值对的集合，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line">data[element] = <span class="string">&#x27;metadata&#x27;</span>;</span><br><span class="line">data[<span class="string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="comment">// &quot;metadata&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码原意是将一个DOM节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。<br>为了解决这个问题，ES6提供了<code>Map</code>数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，<code>Object</code>结构提供了“字符串—值”的对应，<code>Map</code>结构提供了“值—值”的对应，是一种更完善的<code>Hash</code>结构实现。如果你需要“键值对”的数据结构，<code>Map</code>比<code>Object</code>更合适。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line">m.<span class="title function_">set</span>(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.<span class="title function_">get</span>(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line">m.<span class="title function_">has</span>(o) <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">delete</span>(o) <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用<code>Map</code>结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。<br>上面的例子展示了如何向<code>Map</code>添加成员。作为构造函数，<code>Map</code>也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在新建<code>Map</code>实例时，就指定了两个键<code>name</code>和<code>title</code>。<br><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">items.<span class="title function_">forEach</span>(</span><br><span class="line">  <span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.<span class="title function_">set</span>(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>事实上，不仅仅是数组，任何具有<code>Iterator</code>接口、且每个成员都是一个双元素的数组的数据结构都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的<code>Map</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>(set);</span><br><span class="line">m1.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>(m2);</span><br><span class="line">m3.<span class="title function_">get</span>(<span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，我们分别使用<code>Set</code>对象和<code>Map</code>对象，当作<code>Map</code>构造函数的参数，结果都生成了新的<code>Map</code>对象。<br>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;aaa&#x27;</span>).<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="number">1</span>) <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">get</span>(<span class="string">&#x27;asfddfsasadf&#x27;</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>注意，只有对同一个对象的引用，<code>Map</code>结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.<span class="title function_">get</span>([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。<br>同理，同样的值的两个实例，在<code>Map</code>结构中被视为两个键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">map.<span class="title function_">set</span>(k1, <span class="number">111</span>).<span class="title function_">set</span>(k2, <span class="number">222</span>);</span><br><span class="line">map.<span class="title function_">get</span>(k1) <span class="comment">// 111</span></span><br><span class="line">map.<span class="title function_">get</span>(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在<code>Map</code>结构中被视为两个键。<br>由上可知，<code>Map</code>的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（<code>clash</code>）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。<br>如果<code>Map</code>的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，<code>Map</code>将其视为一个键，比如0和-0就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但<code>Map</code>将其视为同一个键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(-<span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;true&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="title class_">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h2 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h2><p><code>Map</code>结构的实例有以下属性和操作方法。</p>
<h4 id="1-size属性"><a href="#1-size属性" class="headerlink" title="(1)size属性"></a>(1)size属性</h4><p><code>size</code>属性返回<code>Map</code>结构的成员总数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="2-set-key-value"><a href="#2-set-key-value" class="headerlink" title="(2)set(key, value)"></a>(2)set(key, value)</h4><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个<code>Map</code>结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br></pre></td></tr></table></figure>
<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="3-get-key"><a href="#3-get-key" class="headerlink" title="(3)get(key)"></a>(3)get(key)</h4><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.<span class="title function_">set</span>(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line">m.<span class="title function_">get</span>(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure>
<h4 id="4-has-key"><a href="#4-has-key" class="headerlink" title="(4)has(key)"></a>(4)has(key)</h4><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前<code>Map</code>对象之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="5-delete-key"><a href="#5-delete-key" class="headerlink" title="(5)delete(key)"></a>(5)delete(key)</h4><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="6-clear"><a href="#6-clear" class="headerlink" title="(6)clear()"></a>(6)clear()</h4><p><code>clear</code>方法清除所有成员，没有返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><p><code>Map</code>结构原生提供三个遍历器生成函数和一个遍历方法。<br><code>keys()</code>：返回键名的遍历器。<br><code>values()</code>：返回键值的遍历器。<br><code>entries()</code>：返回所有成员的遍历器。<br><code>forEach()</code>：遍历<code>Map</code>的所有成员。<br>需要特别注意的是，<code>Map</code>的遍历顺序就是插入顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码最后的那个例子，表示<code>Map</code>结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === map.<span class="property">entries</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Map</code>结构转为数组结构，比较快速的方法是使用扩展运算符（…）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line">[...map.<span class="title function_">keys</span>()] <span class="comment">// [1, 2, 3]</span></span><br><span class="line">[...map.<span class="title function_">values</span>()] <span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line">[...map.<span class="title function_">entries</span>()] <span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line">[...map] <span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure>
<p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现<code>Map</code>的遍历和过滤（<code>Map</code>本身没有<code>map</code>和<code>filter</code>方法）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>此外，<code>Map</code>还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  <span class="attr">report</span>: <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">report</span>(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>
<h2 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h2><h4 id="1-Map转为数组"><a href="#1-Map转为数组" class="headerlink" title="(1)Map转为数组"></a>(1)Map转为数组</h4><p><code>Map</code>转为数组最方便的方法，就是使用扩展运算符(<code>...</code>)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">  .<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-数组转为Map"><a href="#2-数组转为Map" class="headerlink" title="(2)数组转为Map"></a>(2)数组转为Map</h4><p>将数组传入<code>Map</code>构造函数，就可以转为<code>Map</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-Map转为对象"><a href="#3-Map转为对象" class="headerlink" title="(3)Map转为对象"></a>(3)Map转为对象</h4><p>如果所有<code>Map</code>的键都是字符串，它可以无损地转为对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToObj</span>(myMap) <span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<h4 id="4-对象转为Map"><a href="#4-对象转为Map" class="headerlink" title="(4)对象转为Map"></a>(4)对象转为Map</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    strMap.<span class="title function_">set</span>(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">objToStrMap</span>(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-Map转为JSON"><a href="#5-Map转为JSON" class="headerlink" title="(5)Map转为JSON"></a>(5)Map转为JSON</h4><p><code>Map</code>转为JSON要区分两种情况。一种情况是，<code>Map</code>的键名都是字符串，这时可以选择转为对象JSON。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToJson</span>(myMap) <span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>另一种情况是，<code>Map</code>的键名有非字符串，这时可以选择转为数组JSON。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line"><span class="title function_">mapToArrayJson</span>(myMap)</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="6-JSON转为Map"><a href="#6-JSON转为Map" class="headerlink" title="(6)JSON转为Map"></a>(6)JSON转为Map</h4><p>JSON 转为<code>Map</code>，正常情况下，所有键名都是字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为<code>Map</code>。这往往是<code>Map</code>转为数组JSON的逆操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><h2 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h2><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap可以使用set方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.<span class="title function_">set</span>(key, <span class="number">2</span>);</span><br><span class="line">wm1.<span class="title function_">get</span>(key) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// WeakMap也可以接受一个数组作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.<span class="title function_">get</span>(k2) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>WeakMap</code>与<code>Map</code>的区别有两点。<br>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>
<p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。<br><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">  [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。<br>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要e1和e2的时候必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。<br><code>WeakMap</code>就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，<code>WeakMap</code>里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。<br>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用<code>WeakMap</code>。一个典型应用场景是，在网页的DOM元素上添加数据，就可以使用<code>WeakMap</code>结构。当该DOM元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line">wm.<span class="title function_">set</span>(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.<span class="title function_">get</span>(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，先新建一个<code>Weakmap</code>实例。然后，将一个DOM节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在<code>WeakMap</code>里面。这时，<code>WeakMap</code>里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。<br>也就是说，上面的DOM节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。<code>Weakmap</code>保存的这个键值对，也会自动消失。<br>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。<br>注意，<code>WeakMap</code>弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm.<span class="title function_">set</span>(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在<code>WeakMap</code>外部消除了<code>obj</code>的引用，<code>WeakMap</code>内部的引用依然存在。</p>
<h2 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h2><p><code>WeakMap</code>与<code>Map</code>在API上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">wm.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line">wm.<span class="property">clear</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="WeakMap的用途"><a href="#WeakMap的用途" class="headerlink" title="WeakMap的用途"></a>WeakMap的用途</h2><p><code>WeakMap</code>应用的典型场合就是DOM节点作为键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">myWeakmap.<span class="title function_">set</span>(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line">myElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.<span class="title function_">get</span>(myElement);</span><br><span class="line">  logoData.<span class="property">timesClicked</span>++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>myElement</code>是一个DOM节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在<code>WeakMap</code>里，对应的键名就是<code>myElement</code>。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。<br><code>WeakMap</code>的另一个用处是部署私有属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">    _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">    _action.<span class="title function_">set</span>(<span class="variable language_">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.<span class="title function_">get</span>(<span class="variable language_">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Countdown</span>(<span class="number">2</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>));</span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/js/进阶/前端网络知识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/07/11/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"
    >前端网络知识</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/07/11/%E5%89%8D%E7%AB%AF/js/%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2019-07-11T04:42:51.000Z" itemprop="datePublished">2019-07-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/JS/">JS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>HTTP协议是<code>Hyper Text Transfer Protocol</code>（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP是基于TCP&#x2F;IP协议通信协议来传递数据（HTML文件, 图片文件, 查询结果等）。它不涉及数据包传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-a792b6e4d3c3dc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="Http的特点"><a href="#Http的特点" class="headerlink" title="Http的特点"></a>Http的特点</h2><ol>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：<strong>HTTP协议是无状态的，HTTP 协议自身不对请求和响应之间的通信状态进行保存。任何两次请求之间都没有依赖关系。</strong>直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的。协议本身并不保留之前一切的请求或 响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。</li>
</ol>
<h2 id="Http报文"><a href="#Http报文" class="headerlink" title="Http报文"></a>Http报文</h2><p>Http报文包括请求报文和响应报文两大部分，其中请求报文由请求行（request line）、请求头（header）、空行和请求体四个部分组成。而响应报文由状态行、响应头部、空行和响应体四个部分组成。接下来我们了解下请求报文的各个部分及其作用。</p>
<h4 id="1-请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本。"><a href="#1-请求行，用来说明请求类型-要访问的资源以及所使用的HTTP版本。" class="headerlink" title="1.请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。"></a>1.请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  /chapter17/user.html HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>POST代表请求方法，<code>/chapter17/user.html</code>表示URI，<code>HTTP/1.1</code>代表协议和协议的版本。</p>
<h4 id="2-请求头由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。"><a href="#2-请求头由关键字-x2F-值对组成，每行一对，关键字和值用英文冒号“-”分隔。" class="headerlink" title="2.请求头由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。"></a>2.请求头由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。</h4><p>请求头部通知服务器有关于客户端请求的信息。它包含许多有关的客户端环境和请求正文的有用信息。其中比如：<br><code>Host</code>表示主机名，虚拟主机；<br><code>Connection</code>，<code>HTTP/1.1</code>增加的，使用<code>keepalive</code>，即持久连接，一个连接可以发多个请求；<br><code>User-Agent</code>，请求发出者，兼容性以及定制化需求。</p>
<h4 id="3-最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。"><a href="#3-最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。" class="headerlink" title="3.最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。"></a>3.最后一个请求头之后是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。</h4><h4 id="4-请求体，可以承载多个请求参数的数据"><a href="#4-请求体，可以承载多个请求参数的数据" class="headerlink" title="4.请求体，可以承载多个请求参数的数据"></a>4.请求体，可以承载多个请求参数的数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=tom&amp;password=1234&amp;realName=tomson</span><br></pre></td></tr></table></figure>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>GET请求指定的页面信息，并返回实体主体。<br>HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<br>PUT从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE请求服务器删除指定的页面。</p>
<h2 id="GET与POST区别"><a href="#GET与POST区别" class="headerlink" title="GET与POST区别"></a>GET与POST区别</h2><p>GET在浏览器回退时是无害的，而POST会再次提交请求<br>GET请求会被浏览器主动缓存，而POST不会，除非手动设置<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留<br>GET请求在URL中传送的参数是有长度限制的，而POST没有限制<br>GET参数通过URL传递，POST放在<code>Request body</code>中</p>
<h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现<br>* 5xx：服务器端错误–服务器未能实现合法的请求</li>
</ul>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><h4 id="为什么需要持久连接"><a href="#为什么需要持久连接" class="headerlink" title="为什么需要持久连接"></a>为什么需要持久连接</h4><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的 普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请 求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的 开销。</p>
<h4 id="持久连接的特点"><a href="#持久连接的特点" class="headerlink" title="持久连接的特点"></a>持久连接的特点</h4><p>为解决上述 TCP 连接的问题，HTTP&#x2F;1.1 和一部分的 HTTP&#x2F;1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<br>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外， 减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。<br>在 HTTP&#x2F;1.1 中，所有的连接默认都是持久连接，但在 HTTP&#x2F;1.0 内并未标准化。虽然有一部分服务器通过非 标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需 要支持持久连接。</p>
<h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p>持久连接使得多数请求以管线化（<code>pipelining</code>）方式发送成为可能。从前发送请求后需等待并收到响应，才能 发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。<br>这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。通俗地讲，请求打包一次传输过去，响应打包一次传递回来。管线化的前提是在持久连接下。<br>假如当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。 而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。客户端需要请求这十个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求，以此类推，而管道机制则是允许浏览器同时发出这十个请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>
<h1 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h1><h2 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h2><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。<br>HTTPS主要作用是：</p>
<ol>
<li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</li>
<li>对网站服务器进行真实身份认证。</li>
</ol>
<h2 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h2><p>在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。<br>HTTP协议存在的哪些问题：</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听<br>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。<br>HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。</li>
<li>无法证明报文的完整性，所以可能遭篡改<br>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br>换句话说，没有任何办法确认，发出的请求&#x2F;响应和接收到的请求&#x2F;响应是前后相同的。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装<br>HTTP协议中的请求和响应不会对通信方进行确认。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）</li>
</ul>
<p>HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。<br>反观HTTPS协议，它比HTTP协议相比多了以下优势:</p>
<ul>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>数据完整性：内容传输经过完整性校验</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ul>
<h2 id="HTTPS如何解决HTTP上述问题"><a href="#HTTPS如何解决HTTP上述问题" class="headerlink" title="HTTPS如何解决HTTP上述问题?"></a>HTTPS如何解决HTTP上述问题?</h2><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p>
<p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。<br>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后即是HTTPS。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-9589146c9097ab77?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>HTTPS 协议的主要功能基本都依赖于 TLS&#x2F;SSL 协议，TLS&#x2F;SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，<strong>其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-c872f010b6cc06cf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="1-解决内容可能被窃听的问题——加密"><a href="#1-解决内容可能被窃听的问题——加密" class="headerlink" title="1.解决内容可能被窃听的问题——加密"></a>1.解决内容可能被窃听的问题——加密</h4><p>方法1.对称加密<br>这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。</p>
<p>以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<p>方法2.非对称加密<br>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br>非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。</p>
<p>这种方式有以下缺点：<br>公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；<br>公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；<br>使用非对称加密在数据加密解密过程需要消耗一定时间，降低了数据传输效率；</p>
<p>方法3.对称加密+非对称加密(HTTPS采用这种方式)<br>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式。</p>
<p>具体做法是：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。</p>
<h4 id="2-解决报文可能遭篡改问题——数字签名"><a href="#2-解决报文可能遭篡改问题——数字签名" class="headerlink" title="2.解决报文可能遭篡改问题——数字签名"></a>2.解决报文可能遭篡改问题——数字签名</h4><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。<br>数字签名有两种功效：</p>
<ul>
<li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li>
<li>数字签名能确定消息的完整性,证明数据是否未被篡改过。</li>
</ul>
<p>数字签名如何生成:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-f33722cfae61447f?imageMogr2/auto-orient/strip%7CimageView2/2/w/600"></p>
<p>将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。<br>校验数字签名流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3534846-a4d42cc6eace3ce6?imageMogr2/auto-orient/strip%7CimageView2/2/w/600"></p>
<p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</p>
<p>假设消息传递在Kobe，James两人之间发生。James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。</p>
<p>此时就需要引入了<strong>证书颁发机构</strong>（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。</p>
<h4 id="3-解决通信方身份可能被伪装的问题——数字证书"><a href="#3-解决通信方身份可能被伪装的问题——数字证书" class="headerlink" title="3.解决通信方身份可能被伪装的问题——数字证书"></a>3.解决通信方身份可能被伪装的问题——数字证书</h4><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。<br>我们来介绍一下数字证书认证机构的业务流程：</p>
<ul>
<li>服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li>
<li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li>
<li>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</li>
<li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li>
<li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li>
<li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li>
</ul>
<h2 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/3534846-a9d70ccff8bf0f24?imageMogr2/auto-orient/strip%7CimageView2/2/w/640"></p>
<ol>
<li>Client发起一个HTTPS的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。</li>
<li>Server把事先配置好的公钥证书返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li>
<li>Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li>
<li>Server使用对称密钥加密“明文内容A”，发送给Client。</li>
<li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li>
<li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</li>
</ol>
<h2 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h2><ul>
<li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li>
<li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li>
<li>HTTPS需要用到SSL证书，而HTTP不用;</li>
<li>HTTPS标准端口443，HTTP标准端口80;</li>
<li>HTTPS基于传输层，HTTP基于应用层;</li>
<li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示。</li>
</ul>
<h2 id="为何不所有的网站都使用HTTPS"><a href="#为何不所有的网站都使用HTTPS" class="headerlink" title="为何不所有的网站都使用HTTPS"></a>为何不所有的网站都使用HTTPS</h2><p>既然HTTPS那么安全可靠，那为何不所有的Web网站都使用HTTPS？<br>首先，很多人还是会觉得HTTPS实施有门槛，这个门槛在于需要权威CA颁发的SSL证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。</p>
<p>其次，HTTPS普遍认为性能消耗要大于HTTP，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在SLB或CDN，来解决此问题。</p>
<p>除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-前端/ES6/ES6 Module的加载实现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/07/11/%E5%89%8D%E7%AB%AF/ES6/ES6%20Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"
    >ES6 Module的加载实现</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/07/11/%E5%89%8D%E7%AB%AF/ES6/ES6%20Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2019-07-11T03:02:24.000Z" itemprop="datePublished">2019-07-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a> / <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/ES6/">ES6</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h1><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>HTML网页中，浏览器通过<code>&lt;script&gt;</code>标签加载JavaScript脚本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// module code</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;!-- 外部脚本 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于浏览器脚本的默认语言是JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。<br>默认情况下，浏览器是同步加载JavaScript脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。<br>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载，下面就是两种异步加载的语法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;path/to/myModule.js&quot;</span> defer&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。<br><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，<code>defer</code>是渲染完再执行，<code>async</code>是下载完就执行。另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p>
<h2 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h2><p>浏览器加载ES6模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;./foo.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。<br>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。<br><code>&lt;script&gt;</code>标签的<code>async</code>属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> src=<span class="string">&quot;./foo.js&quot;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。<br>ES6模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对URL或相对URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>下面是一个示例模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === <span class="variable language_">window</span>.<span class="property">x</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在ES6模块之中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="variable language_">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<h1 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h1><p>ES6模块与CommonJS模块完全不同。它们有两个重大差异。</p>
<ul>
<li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用</li>
<li>CommonJS模块是运行时加载，ES6模块是编译时输出接口</li>
</ul>
<p>第二个差异是因为CommonJS加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。<br>CommonJS模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>);  <span class="comment">// 3</span></span><br><span class="line">mod.<span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">counter</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node main.<span class="property">js</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>ES6模块的运行机制与CommonJS不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<br>因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>再举一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(foo), <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了500毫秒，又变为等于<code>baz</code>。<br>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node m2.js</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。<br>由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; obj &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line">obj.<span class="property">prop</span> = <span class="number">123</span>; <span class="comment">// OK</span></span><br><span class="line">obj = &#123;&#125;; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sum</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sum</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br></pre></td></tr></table></figure>
<p>上面的脚本<code>mod.js</code>，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.<span class="title function_">add</span>();</span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;c&#125; <span class="keyword">from</span> <span class="string">&#x27;./mod&#x27;</span>;</span><br><span class="line">c.<span class="title function_">show</span>();</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./x&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./y&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>现在执行<code>main.js</code>，输出的是1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node main.js</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>c</code>的同一个实例。</p>
<h1 id="Node加载"><a href="#Node加载" class="headerlink" title="Node加载"></a>Node加载</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Node对ES6模块的处理比较麻烦，因为它有自己的CommonJS模块格式，与ES6模块格式是不兼容的。目前的解决方案是，将两者分开，ES6模块和CommonJS采用各自的加载方案。<br>Node要求ES6模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，那么就必须采用<code>.mjs</code>后缀名。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。<br>目前，这项功能还在试验阶段。安装Node v8.5.0或以上版本，要用<code>--experimental-modules</code>参数才能打开该功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules my-app.mjs</span><br></pre></td></tr></table></figure>
<p>为了与浏览器的<code>import</code>加载规则相同，Node的<code>.mjs</code>文件支持URL路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo?query=1&#x27;</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node会按URL规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有:、%、#、?等特殊字符，最好对这些字符进行转义。<br>目前，Node的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议），不支持加载远程模块。<br>如果模块名不含路径，那么<code>import</code>命令会去<code>node_modules</code>目录寻找这个模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;abc/123&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果模块名包含路径，那么<code>import</code>命令会按照路径去寻找这个名字的脚本文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;file:///etc/config/app.json&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo?search&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../bar&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;/baz&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果脚本文件省略了后缀名，比如<code>import &#39;./foo&#39;</code>，Node会依次尝试四个后缀名：<code>./foo.mjs</code>、<code>./foo.js</code>、<code>./foo.json</code>、<code>./foo.node</code>。如果这些脚本文件都不存在，Node就会去加载<code>./foo/package.json</code>的<code>main</code>字段指定的脚本。如果<code>./foo/package.json</code>不存在或者没有<code>main</code>字段，那么就会依次加载<code>./foo/index.mjs</code>、<code>./foo/index.js</code>、<code>./foo/index.json</code>、<code>./foo/index.node</code>。如果以上四个文件还是都不存在，就会抛出错误。<br>最后，Node的<code>import</code>命令是异步加载，这一点与浏览器的处理方法相同。</p>
<h2 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h2><p>ES6模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node规定ES6模块之中不能使用CommonJS模块的特有的一些内部变量。<br>首先，就是<code>this</code>关键字。ES6模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。<br>其次，以下这些顶层变量在ES6模块之中都是不存在的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arguments</span><br><span class="line">require</span><br><span class="line">module</span><br><span class="line">exports</span><br><span class="line">__filename</span><br><span class="line">__dirname</span><br></pre></td></tr></table></figure>
<p>如果你一定要使用这些变量，有一个变通方法，就是写一个CommonJS模块输出这些变量，然后再用 ES6模块加载这个CommonJS模块。但是这样一来，该ES6模块就不能直接用于浏览器环境了，所以不推荐这样做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expose.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;__dirname&#125;;</span><br><span class="line"><span class="comment">// use.mjs</span></span><br><span class="line"><span class="keyword">import</span> expose <span class="keyword">from</span> <span class="string">&#x27;./expose.js&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;__dirname&#125; = expose;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>expose.js</code>是一个CommonJS模块，输出变量<code>__dirname</code>，该变量在ES6模块之中不存在。ES6模块加载<code>expose.js</code>，就可以得到<code>__dirname</code>。</p>
<h2 id="ES6模块加载CommonJS模块"><a href="#ES6模块加载CommonJS模块" class="headerlink" title="ES6模块加载CommonJS模块"></a>ES6模块加载CommonJS模块</h2><p>CommonJS模块的输出都定义在<code>module.exports</code>这个属性上面。Node的<code>import</code>命令加载CommonJS模块，Node会自动将<code>module.exports</code>属性，当作模块的默认输出，即等同于<code>export default xxx</code>。<br>下面是一个CommonJS模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>import</code>命令加载上面的模块，<code>module.exports</code>会被视为默认输出，即<code>import</code>命令实际上输入的是这样一个对象<code>&#123; default: module.exports &#125;</code>。<br>所以，一共有三种写法，可以拿到CommonJS模块的<code>module.exports</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">import</span> baz <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: &#x27;hello&#x27;, bar: &#x27;world&#x27;&#125;;</span></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> baz&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="comment">// baz = &#123;foo: &#x27;hello&#x27;, bar: &#x27;world&#x27;&#125;;</span></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> baz <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="comment">// baz = &#123;</span></span><br><span class="line"><span class="comment">//   get default() &#123;return module.exports;&#125;,</span></span><br><span class="line"><span class="comment">//   get foo() &#123;return this.default.foo&#125;.bind(baz),</span></span><br><span class="line"><span class="comment">//   get bar() &#123;return this.default.bar&#125;.bind(baz)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第三种写法，可以通过<code>baz.default</code>拿到<code>module.exports</code>。<code>foo</code>属性和<code>bar</code>属性就是可以通过这种方法拿到了<code>module.exports</code>。<br>下面是一些例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="comment">// foo = null;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="comment">// bar = &#123; default:null &#125;;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>es.js</code>采用第二种写法时，要通过<code>bar.default</code>这样的写法，才能拿到<code>module.exports</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">two</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./c&#x27;</span>;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bar <span class="keyword">from</span> <span class="string">&#x27;./c&#x27;</span>;</span><br><span class="line">bar.<span class="title function_">default</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// throws, bar is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>bar</code>本身是一个对象，不能当作函数调用，只能通过<code>bar.default</code>调用。<br>CommonJS模块的输出缓存机制，在ES6加载方式下依然有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="params">_</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，对于加载<code>foo.js</code>的脚本，<code>module.exports</code>将一直是123，而不会变成<code>null</code>。<br>由于ES6模块是编译时确定输出接口，CommonJS模块是运行时确定输出接口，所以采用<code>import</code>命令加载CommonJS模块时，不允许采用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不正确</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面的写法不正确，因为<code>fs</code>是CommonJS格式，只有在运行时才能确定<code>readFile</code>接口，而<code>import</code>命令要求编译时就确定这个接口。解决方法就是改为整体输入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法一</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> app = express.<span class="title function_">default</span>();</span><br><span class="line"><span class="comment">// 正确的写法二</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br></pre></td></tr></table></figure>
<h2 id="CommonJS模块加载ES6模块"><a href="#CommonJS模块加载ES6模块" class="headerlink" title="CommonJS模块加载ES6模块"></a>CommonJS模块加载ES6模块</h2><p>CommonJS模块加载ES6模块，不能使用<code>require</code>命令，而要使用<code>import()</code>函数。ES6模块的所有输出接口，会成为输入对象的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.mjs</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123; <span class="attr">bar</span>: <span class="string">&#x27;my-default&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./es.mjs&#x27;</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//   get default() &#123;</span></span><br><span class="line"><span class="comment">//     ...</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(es_namespace.<span class="property">default</span>);</span><br><span class="line"><span class="comment">// &#123; bar:&#x27;my-default&#x27; &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>default</code>接口变成了<code>es_namespace.default</code>属性。<br>下面是另一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = &#123; <span class="attr">bar</span>:<span class="string">&#x27;my-default&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">c</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">const</span> es_namespace = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./es&#x27;</span>);</span><br><span class="line"><span class="comment">// es_namespace = &#123;</span></span><br><span class="line"><span class="comment">//   get foo() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get bar() &#123;return foo;&#125;</span></span><br><span class="line"><span class="comment">//   get f() &#123;return f;&#125;</span></span><br><span class="line"><span class="comment">//   get c() &#123;return c;&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h1><p>循环加载指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>通常，循环加载表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。<br>目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<h2 id="CommonJS模块的加载原理"><a href="#CommonJS模块的加载原理" class="headerlink" title="CommonJS模块的加载原理"></a>CommonJS模块的加载原理</h2><p>CommonJS的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">exports</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是Node内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。<br>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p>
<h2 id="CommonJS模块的循环加载"><a href="#CommonJS模块的循环加载" class="headerlink" title="CommonJS模块的循环加载"></a>CommonJS模块的循环加载</h2><p>CommonJS模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.<span class="property">done</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.<span class="property">done</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。<br><code>a.js</code>已经执行的部分，只有一行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>因此，对于<code>b.js</code>来说，它从a.js只输入一个变量<code>done</code>，值为<code>false</code>。<br>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="property">done</span>, b.<span class="property">done</span>);</span><br></pre></td></tr></table></figure>
<p>执行<code>main.js</code>，运行结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = false</span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = true</span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=true, b.done=true</span><br></pre></td></tr></table></figure>
<p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>总之，CommonJS输入的是被输出值的拷贝，不是引用。<br>另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).<span class="property">foo</span>; <span class="comment">// 危险的写法</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">good</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">foo</span>(<span class="string">&#x27;good&#x27;</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bad</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">foo</span>(<span class="string">&#x27;bad&#x27;</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p>
<h2 id="ES6模块的循环加载"><a href="#ES6模块的循环加载" class="headerlink" title="ES6模块的循环加载"></a>ES6模块的循环加载</h2><p>ES6处理循环加载与CommonJS有本质的不同。ES6模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>
<p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？<br>让我们一行行来看，ES6循环加载是怎么处理的。首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。<br>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>());</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure>
<p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>());</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。<br>我们再来看ES6模块加载器SystemJS给出的一个例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">&#x27;./odd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">even</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || <span class="title function_">odd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">&#x27;./even&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">odd</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; <span class="title function_">even</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于0，就会减去1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。<br>运行上面这段代码，结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; import * as m from &#x27;./even.js&#x27;;</span><br><span class="line">&gt; m.even(10);</span><br><span class="line">true</span><br><span class="line">&gt; m.counter</span><br><span class="line">6</span><br><span class="line">&gt; m.even(20)</span><br><span class="line">true</span><br><span class="line">&gt; m.counter</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<p>上面代码中，参数<code>n</code>从10变为0的过程中，<code>even()</code>一共会执行6次，所以变量<code>counter</code>等于6。第二次调用<code>even()</code>时，参数<code>n</code>从20变为0，<code>even()</code>一共会执行11次，加上前面的6次，所以变量<code>counter</code>等于17。<br>这个例子要是改写成CommonJS，就根本无法执行，会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">&#x27;./odd&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">counter</span> = counter;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">even</span> = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || <span class="title function_">odd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">&#x27;./even&#x27;</span>).<span class="property">even</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; <span class="title function_">even</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n-1)</code>就会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(&#x27;./even&#x27;);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a function</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/30/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="page-number" href="/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/page/32/">32</a><a class="page-number" href="/page/33/">33</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" href="/page/32/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>