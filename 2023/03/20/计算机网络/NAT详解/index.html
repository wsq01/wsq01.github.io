<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>NAT详解 |  学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-计算机网络/NAT详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  NAT详解
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2023-03-20T08:51:33.000Z" itemprop="datePublished">2023-03-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">6.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">23 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>IP 地址分为公网地址和私有地址。公网地址由 IANA 统一分配，用于连接互联网；私有地址可以自由分配，用于私有网络内部通信。</p>
<p>随着互联网用户的快速增长，2019 年 11 月 25 日全球的公网 IPv4 地址已耗尽。在 IPv4 地址耗尽前，使用 NAT（<code>Network Address Translation</code>）技术解决 IPv4 地址不够用的问题，并持续至今。</p>
<p>NAT 技术就是将私有地址转换成公网地址，使私有网络中的主机可以通过少量公网地址访问互联网。</p>
<p>但 NAT只是一种过渡技术，从根本上解决问题，是采用支持更大地址空间的下一代 IP 技术，即 IPv6 协议，它提供了几乎用不完的地址空间。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>需要在专用网连接到互联网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个有效的外部全球 IP 地址。</p>
<p>所有使用本地地址的主机在和外界通信时，都要在 NAT 路由器上将其本地地址转换成全球 IP 地址，才能和互联网连接。</p>
<p>NAT 解决了 IPv4 地址不够用的问题，另外 NAT 屏蔽了私网用户真实地址，提高了私网用户的安全性。</p>
<h1 id="NAT-技术"><a href="#NAT-技术" class="headerlink" title="NAT 技术"></a>NAT 技术</h1><p>IP 地址中预留了 3 个私有地址网段，在私有网络内，可以任意使用。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/2.png" class="">

<p>其余的 IP 地址可以在互联网上使用，由 IANA 统一管理，称为公网地址。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/3.png" class="">

<p>典型的 NAT 组网模型，网络通常是被划分为私网和公网两部分，各自使用独立的地址空间。私网使用私有地址<code>10.0.0.0/24</code>，而公网使用公网地址。为了让主机 A 和 B 访问互联网上的服务器<code>Server</code>，需要在网络边界部署一台 NAT 设备用于执行地址转换。NAT 设备通常是路由器或防火墙。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/4.png" class="">

<h2 id="基本-NAT"><a href="#基本-NAT" class="headerlink" title="基本 NAT"></a>基本 NAT</h2><p>基本 NAT 是最简单的一种地址转换方式，它只对数据包的 IP 层参数进行转换，它可分为静态 NAT 和动态 NAT。</p>
<p>静态 NAT 是公网 IP 地址和私有 IP 地址有一对一的关系，一个公网 IP 地址对应一个私有 IP 地址，建立和维护一张静态地址映射表。</p>
<p>动态 NAT 是公网 IP 地址和私有 IP 地址有一对多的关系，同一个公网 IP 地址分配给不同的私网用户使用，使用时间必须错开。它包含一个公有 IP 地址池和一张动态地址映射表。</p>
<h3 id="举个动态-NAT-栗子"><a href="#举个动态-NAT-栗子" class="headerlink" title="举个动态 NAT 栗子"></a>举个动态 NAT 栗子</h3><p>私网主机 A（<code>10.0.0.1</code>）需要访问公网的服务器 Server（<code>61.144.249.229</code>），在路由器 RT 上配置 NAT，地址池为<code>219.134.180.11 ~ 219.134.180.20</code>，地址转换过程如下：</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/5.png" class="">

<p>A 向 Server 发送报文，网关是<code>10.0.0.254</code>，源地址是<code>10.0.0.1</code>，目的地址是<code>61.144.249.229</code>。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/6.png" class="">

<p>RT 收到 IP 报文后，查找路由表，将 IP 报文转发至出接口，由于出接口上配置了 NAT，因此 RT 需要将源地址<code>10.0.0.1</code>转换为公网地址。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/7.png" class="">

<p>RT 从地址池中查找第一个可用的公网地址<code>219.134.180.11</code>，用这个地址替换数据包的源地址，转换后的数据包源地址为<code>219.134.180.11</code>，目的地址不变。这叫 SNAT（<code>Source Network Address Translation</code>，源地址转换）。同时 RT 在自己的 NAT 表中添加一个表项，记录私有地址<code>10.0.0.1</code>到公网地址<code>219.134.180.11</code>的映射。RT 再将报文转发给目的地址<code>61.144.249.229</code>。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/8.png" class="">

<p>Server 收到报文后做相应处理。</p>
<p>Server 发送回应报文，报文的源地址是<code>61.144.249.229</code>，目的地址是<code>219.134.180.11</code>。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/9.png" class="">

<p>RT 收到报文，发现报文的目的地址<code>219.134.180.11</code>在 NAT 地址池内，于是检查 NAT 表，找到对应表项后，使用私有地址<code>10.0.0.1</code>替换公网地址<code>219.134.180.11</code>，转换后的报文源地址不变，目的地址为<code>10.0.0.1</code>。RT 在将报文转发给 A。这也叫 DNAT（<code>Destination Network Address Translation</code>，目的地址转换）。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/10.png" class="">

<p>A 收到报文，地址转换过程结束。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/11.png" class="">

<p>如果 B 也要访问 Server，则 RT 会从地址池中分配另一个可用公网地址<code>219.134.180.12</code>，并在 NAT 表中添加一个相应的表项，记录 B 的私有地址<code>10.0.0.2</code>到公网地址<code>219.134.180.12</code>的映射关系。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/12.png" class="">

<p>整个过程下来，NAT 悄悄的改了 IP 数据包的发送和接收端 IP 地址，但对真正的发送方和接收方来说，他们却对这件事情，一无所知。</p>
<p>这就是 基本 NAT 的工作原理。</p>
<p>当 NAT 路由器具有<code>n</code>个全球 IP 地址时，专用网内最多可以同时有<code>n</code>台主机接入到互联网。这样就可以使专用网内较多数量的主机，轮流使用 NAT 路由器有限数量的全球 IP 地址。</p>
<p>通过 NAT 路由器的通信必须由专用网内的主机发起。专用网内部的主机不能充当服务器用，因为互联网上的客户无法请求专用网内的服务器提供服务。</p>
<p>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。</p>
<p>使用端口号的 NAT 叫做网络地址与端口号转换 NAPT(<code>Network Address and Port Translation</code>)，而不使用端口号的 NAT 就叫做基本的 NAT。</p>
<h2 id="NAPT"><a href="#NAPT" class="headerlink" title="NAPT"></a>NAPT</h2><p>在基础 NAT 中，私有地址和公网地址存在一对一地址转换的对应关系，即一个公网地址同时只能分配给一个私有地址。它只解决了公网和私网的通信问题，并没有解决公网地址不足的问题。</p>
<p>NAPT 对数据包的 IP 地址、协议类型、传输层端口号同时进行转换，可以明显提高公网 IP 地址的利用率。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/13.png" class="">
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>私网主机 A（ 10.0.0.1 ）需要访问公网的服务器 Server 的 WWW 服务（ 61.144.249.229 ），在路由器 RT 上配置 NAPT ，地址池为 219.134.180.11 ~ 219.134.180.20 ，地址转换过程如下：</p>
<p>A 向 Server 发送报文，网关是 RT（ 10.0.0.254 ），源地址和端口是 10.0.0.1:1024 ，目的地址和端口是 61.144.249.229:80 。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/14.png" class="">

<p>RT 收到 IP 报文后，查找路由表，将 IP 报文转发至出接口，由于出接口上配置了 NAPT ，因此 RT 需要将源地址 10.0.0.1:1024 转换为公网地址和端口。</p>
<p>RT 从地址池中查找第一个可用的公网地址 219.134.180.11 ，用这个地址替换数据包的源地址，并查找这个公网地址的一个可用端口，例如 2001 ，用这个端口替换源端口。转换后的数据包源地址为 219.134.180.11:2001 ，目的地址和端口不变。同时 RT 在自己的 NAT 表中添加一个表项，记录私有地址 10.0.0.1:1024 到 公网地址 219.134.180.11:2001 的映射。RT 再将报文转发给目的地址 61.144.249.229 。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/15.png" class="">

<p>Server 收到报文后做相应处理。</p>
<p>Server 发送回应报文，报文的源地址是 61.144.249.229:80 ，目的地址是 219.134.180.11:2001 。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/16.png" class="">

<p>RT 收到报文，发现报文的目的地址在 NAT 地址池内，于是检查 NAT 表，找到对应表项后，使用私有地址和端口 10.0.0.1:1024 替换公网地址 219.134.180.11:2001，转换后的报文源地址和端口不变，目的地址和端口为 10.0.0.1:1024 。RT 再将报文转发给 A 。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/17.png" class="">

<p>A 收到报文，地址转换过程结束。</p>
<p>如果 B 也要访问 Server ，则 RT 会从地址池中分配同一个公网地址 219.134.180.11 ，但分配另一个端口 3001 ，并在 NAT 表中添加一个相应的表项，记录 B 的私有地址 10.0.0.2:1024 到公网地址 219.134.180.12:3001 的映射关系。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/18.png" class="">

<p>如果局域网内有多个设备，他们就会映射到不同的公网端口上，毕竟端口最大可达 65535，完全够用。这样大家都可以相安无事。</p>
<p>像这种同时转换 IP 和端口的技术，就是 NAPT（<code>Network Address Port Transfer</code>, 网络地址端口转换）。</p>
<p>那这么说只有用到端口的网络协议才能被 NAT 识别出来并转发？</p>
<p>但这怎么解释<code>ping</code>命令？<code>ping</code>基于 ICMP 协议，而 ICMP 协议报文里并不带端口信息。我依然可以正常的<code>ping</code>通公网机器并收到回包。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/19.png" class="">

<p>事实上针对 ICMP 协议，NAT 路由器做了特殊处理。<code>ping</code>报文头里有个<code>Identifier</code>的信息，它其实指的是放出<code>ping</code>命令的进程<code>id</code>。</p>
<p>对 NAT 路由器来说，这个<code>Identifier</code>的作用就跟端口一样。</p>
<p>另外，当我们去抓包的时候，就会发现有两个<code>Identifier</code>，一个后面带个BE（<code>Big Endian</code>），另一个带个LE（<code>Little Endian</code>）。</p>
<p>其实他们都是同一个数值，只不过大小端不同，读出来的值不一样。就好像同样的数字 345，反着读就成了 543。这是为了兼容不同操作系统下大小端不同的情况。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/20.png" class="">

<h2 id="Easy-IP"><a href="#Easy-IP" class="headerlink" title="Easy IP"></a>Easy IP</h2><p>在标准的 NAPT 配置中需要创建公网地址池，也就是必须先知道公网 IP 地址的范围。而在拨号接入的上网方式中，公网 IP 地址是由运营商动态分配的，无法事先确定，标准的 NAPT 无法做地址转换。要解决这个问题，就要使用 Easy IP。</p>
<p>Easy IP 又称为基于接口的地址转换。在地址转换时，Easy IP 的工作原理与 NAPT 相同，对数据包的 IP 地址、协议类型、传输层端口号同时进行转换。但 Easy IP 直接使用公网接口的 IP 地址作为转换后的源地址。Easy IP 适用于拨号接入互联网，动态获取公网 IP 地址的场合。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/43.png" class="">

<p>Easy IP 无需配置地址池，只需要配置一个 ACL（访问控制列表），用来指定需要进行 NAT 转换的私有 IP 地址范围。</p>
<h2 id="NAT-Server"><a href="#NAT-Server" class="headerlink" title="NAT Server"></a>NAT Server</h2><p>从基本 NAT 和 NAPT 的工作原理可知，NAT 表项由私网主机主动向公网主机发起访问而生成，公网主机无法主动向私网主机发起连接。因此 NAT 隐藏了内部网络结构，具有屏蔽主机的作用。但是在实际应用中，内网网络可能需要对外提供服务，例如 Web 服务，常规的 NAT 就无法满足需求了。</p>
<p>为了满足公网用户访问私网内部服务器的需求，需要使用 NAT Server 功能，将私网地址和端口静态映射成公网地址和端口，供公网用户访问。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/44.png" class="">

<h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>A 的私网地址为<code>10.0.0.1</code>，端口 8080 提供 Web 服务，在对公网提供 Web 服务时，要求端口号为 80 。在 NAT 设备上启动 NAT Server 功能，将私网 IP 地址和端口<code>10.0.0.1:8080</code>映射成公网 IP 地址和端口<code>219.134.180.11:80</code>，这样公网主机 C 就可以通过<code>219.134.180.11:80</code>访问 A 的 Web 服务。</p>
<h2 id="NAT-ALG"><a href="#NAT-ALG" class="headerlink" title="NAT ALG"></a>NAT ALG</h2><p>基本 NAT 和 NAPT 只能识别并修改 IP 报文中的 IP 地址和端口号信息，无法修改报文内携带的信息，因此对于一些 IP 报文内携带网络信息的协议，例如 FTP、DNS、SIP、H.323 等，是无法正确转换的。</p>
<p>ALG 能够识别应用层协议内的网络信息，在转换 IP 地址和端口号时，也会对应用层数据中的网络信息进行正确的转换。</p>
<h3 id="举个栗子：ALG-处理-FTP-的-Active-模式"><a href="#举个栗子：ALG-处理-FTP-的-Active-模式" class="headerlink" title="举个栗子：ALG 处理 FTP 的 Active 模式"></a>举个栗子：ALG 处理 FTP 的 Active 模式</h3><p>FTP 是一种基于 TCP 的协议，用于在客户端和服务器间传输文件。FTP 协议工作时建立 2 个通道：<code>Control</code>通道和<code>Data</code>通道。<code>Control</code>用于传输 FTP 控制信息，<code>Data</code>通道用于传输文件数据。</p>
<p>私网 A（<code>10.0.0.1</code>）访问公网 Server（<code>61.144.249.229</code>）的 FTP 服务，在 RT 上配置 NAPT，地址池为<code>219.134.180.11 ~ 219.134.180.20</code>，地址转换过程如下：</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/45.png" class="">

<p>A 发送到 Server 的 FTP Control 通道建立请求，报文源地址和端口为<code>10.0.0.1:1024</code>，目的地址和端口为<code>61.144.249.229:21</code>，携带数据是 <code>IP = 10.0.0.1 port=5001</code>，即告诉 Server 自己使用 TCP 端口 5001 传输<code>Data</code>。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/46.png" class="">

<p>RT 收到报文，建立<code>10.0.0.1:1024</code>到<code>219.134.180.11:2001</code>的映射关系，转换源 IP 地址和 TCP 端口。根据目的端口 21，RT 识别出这是一个 FTP 报文，因此还要检查应用层数据，发现原始数据为<code>IP = 10.0.0.1 port=5001</code>，于是为<code>Data</code>通道<code>10.0.0.1:5001</code>建立第二个映射关系：<code>10.0.0.1:5001</code>到<code>219.134.180.11:2002</code>，转换后的报文源地址和端口为<code>219.134.180.11:2001</code>，目的地址和端口不变，携带数据为<code>IP = 219.134.180.11 port=2002</code>。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/47.png" class="">

<p>Server 收到报文，向 A 回应<code>command okay</code>报文，FTP Control 通道建立成功。同时 Server 根据应用层数据确定 A 的<code>Data</code>通道网络参数为 <code>219.134.180.11:2002</code>。</p>
<p>A 需要从 FTP 服务器下载文件，于是发起文件请求报文。Server 收到请求后，发起<code>Data</code>通道建立请求，IP 报文的源地址和端口为<code>61.144.249.229:20</code>，目的地址和端口为<code>219.134.180.11:2002</code>，并携带 FTP 数据。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/48.png" class="">

<h2 id="NAT-缺点"><a href="#NAT-缺点" class="headerlink" title="NAT 缺点"></a>NAT 缺点</h2><p>由于 NAT&#x2F;NAPT 都依赖于自己的转换表，因此会有以下的问题：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>解决的方法主要有两种方法。</p>
<p>第一种就是改用 IPv6</p>
<p>IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP 地址，就不搞那么多花里胡哨的地址转换了。</p>
<p>第二种 NAT 穿透技术</p>
<p>NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。</p>
<p>也就是说，在 NAT 穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。</p>
<p>说人话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。</p>
<h1 id="内网穿透是什么"><a href="#内网穿透是什么" class="headerlink" title="内网穿透是什么"></a>内网穿透是什么</h1><p>使用了 NAT 上网的话，前提得内网机器主动请求公网 IP，这样 NAT 才能将内网的 IP 端口转成外网 IP 端口。</p>
<p>反过来公网的机器想主动请求内网机器，就会被拦在 NAT 路由器上，此时由于 NAT 路由器并没有任何相关的 IP 端口的映射记录，因此也就不会转发数据给内网里的任何一台机器。</p>
<p>举个现实中的场景就是，你在你家里的电脑上启动了一个 HTTP 服务，地址是<code>192.168.30.5:5000</code>，此时你在公司办公室里想通过手机去访问一下，却发现访问不了。</p>
<p>那问题就来了，有没有办法让外网机器访问到内网的服务？</p>
<p>有。</p>
<p>说到底，因为 NAT 的存在，我们只能从内网主动发起连接，否则 NAT 设备不会记录相应的映射关系，没有映射关系也就不能转发数据。</p>
<p>所以我们就在公网上加一台服务器x，并暴露一个访问域名，再让内网的服务主动连接服务器x，这样 NAT 路由器上就有对应的映射关系。接着，所有人都去访问服务器x，服务器x将数据转发给内网机器，再原路返回响应，这样数据就都通了。这就是所谓的内网穿透。</p>
<p>像上面提到的服务器x，你也不需要自己去搭，已经有很多现成的方案，比如花某壳。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/21.png" class="">

<h3 id="为什么我在公司里访问不了家里的电脑？"><a href="#为什么我在公司里访问不了家里的电脑？" class="headerlink" title="为什么我在公司里访问不了家里的电脑？"></a>为什么我在公司里访问不了家里的电脑？</h3><p>那是因为家里的电脑在局域网内，局域网和广域网之间有个 NAT 路由器。由于 NAT 路由器的存在，外网服务无法主动连通局域网内的电脑。</p>
<h3 id="两个内网的聊天软件如何建立通讯"><a href="#两个内网的聊天软件如何建立通讯" class="headerlink" title="两个内网的聊天软件如何建立通讯"></a>两个内网的聊天软件如何建立通讯</h3><p>我家机子是在我们小区的局域网里，班花家的机子也是在她们小区的局域网里。都在局域网里，且 NAT 只能从内网连到外网，那我电脑上登录的QQ是怎么和班花电脑里的QQ连上的呢？</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/22.png" class="">

<p>上面这个问法其实是存在个误解，误以为两个qq客户端应用是直接建立连接的。</p>
<p>然而实际上并不是，两个qq客户端之间还隔了一个服务器。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/23.png" class="">

<p>也就是说，两个在内网的客户端登录qq时都会主动向公网的聊天服务器建立连接，这时两方的 NAT 路由器中都会记录有相应的映射关系。当在其中一个qq上发送消息时，数据会先到服务器，再通过服务器转发到另外一个客户端上。反过来也一样，通过这个方式让两台内网的机子进行数据传输。</p>
<h2 id="两个内网的应用如何直接建立连接"><a href="#两个内网的应用如何直接建立连接" class="headerlink" title="两个内网的应用如何直接建立连接"></a>两个内网的应用如何直接建立连接</h2><p>上面的情况，是两个客户端通过第三方服务器进行通讯，但有些场景就是要抛开第三端，直接进行两端通信，比如P2P下载，这种该怎么办呢？</p>
<p>这种情况下，其实也还是离不开第三方服务器的帮助。</p>
<p>假设还是 A 和 B 两个局域网内的机子，A 内网对应的 NAT 设备叫<code>NAT_A</code>，B 内网里的 NAT 设备叫<code>NAT_B</code>，和一个第三方服务器<code>server</code>。</p>
<p>流程如下。</p>
<p>step1和2: A 主动去连<code>server</code>，此时A对应的<code>NAT_A</code>就会留下 A 的内网地址和外网地址的映射关系，<code>server</code>也拿到了 A 对应的外网 IP 地址和端口。</p>
<p>step3和4: B 的操作和 A 一样，主动连第三方<code>server</code>，<code>NAT_B</code>内留下 B 的内网地址和外网地址的映射关系，然后<code>server</code>也拿到了 B 对应的外网 IP 地址和端口。</p>
<p>step5和step6以及step7: 重点来了。此时<code>server</code>发消息给 A，让 A 主动发 UDP 消息到 B 的外网 IP 地址和端口。此时<code>NAT_B</code>收到这个 A 的 UDP 数据包时，这时候根据<code>NAT_B</code>的设置不同，导致这时候有可能<code>NAT_B</code>能直接转发数据到 B，那此时 A 和 B 就通了。但也有可能不通，直接丢包，不过丢包没关系，这个操作的目的是给<code>NAT_A</code>上留下有关 B 的映射关系。</p>
<p>step8和step9以及step10: 跟step5一样熟悉的配方，此时<code>server</code>再发消息给 B，让 B 主动发 UDP 消息到 A 的外网 IP 地址和端口。<code>NAT_B</code>上也留下了关于 A 到映射关系，这时候由于之前<code>NAT_A</code>上有过关于 B 的映射关系，此时<code>NAT_A</code>就能正常接受 B 的数据包，并将其转发给 A。到这里 A 和 B 就能正常进行数据通信了。这就是所谓的 NAT 打洞。</p>
<p>step11: 注意，之前我们都是用的 UDP 数据包，目的只是为了在两个局域网的 NAT 上打个洞出来，实际上大部分应用用的都是 TCP 连接，所以，这时候我们还需要在 A 主动向 B 发起 TCP 连接。到此，我们就完成了两端之间的通信。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/24.png" class="">

<p>这里估计大家会有疑惑。</p>
<p>端口已经被 UDP 用过了，TCP 再用，那岂不是端口重复占用（address already in use）？</p>
<p>其实并不会，端口重复占用的报错常见于两个 TCP 连接在不使用<code>SO_REUSEADDR</code>的情况下，重复使用了某个 IP 端口。而 UDP 和 TCP 之间却不会报这个错。之所以会有这个错，主要是因为在一个linux内核中，内核收到网络数据时，会通过五元组（传输协议，源 IP，目的 IP，源端口，目的端口）去唯一确定数据接受者。当五元组都一模一样的时候，内核就不知道该把数据发给谁。而 UDP 和 TCP 之间”传输协议”不同，因此五元组也不同，所以也就不会有上面的问题。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/25.png" class="">

<p>NAPT 还分为好多种类型，上面的 NAT 打洞方案，都能成功吗？</p>
<p>关于 NAPT，确实还细分为好几种类型。我们现在常见的都是锥形 NAT。上面的打洞方案适用于大部分场景，这其中包括限制最多的端口受限锥形 NAT。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/26.png" class="">

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>IPV4 地址有限，但通过 NAT 路由器，可以使得整个内网 N 多台机器，对外只使用一个公网 IP，大大节省了 IP 资源。</p>
<p>内网机子主动连接公网 IP，中间的 NAT 会将内网机子的内网 IP 转换为公网 IP，从而实现内网和外网的数据交互。</p>
<p>普通的 NAT 技术，只会修改网络包中的发送端和接收端 IP 地址，当内网设备较多时，将有可能导致冲突。因此一般都会使用 NAPT 技术，同时修改发送端和接收端的 IP 地址和端口。</p>
<p>由于 NAT 的存在，公网 IP 是无法访问内网服务的，但通过内网穿透技术，就可以让公网 IP 访问内网服务。一波操作下来，就可以在公司的网络里访问家里的电脑。</p>
<h1 id="NAT-实战"><a href="#NAT-实战" class="headerlink" title="NAT 实战"></a>NAT 实战</h1><h2 id="基本-NAT-实验"><a href="#基本-NAT-实验" class="headerlink" title="基本 NAT 实验"></a>基本 NAT 实验</h2><h3 id="实验拓扑图"><a href="#实验拓扑图" class="headerlink" title="实验拓扑图"></a>实验拓扑图</h3><img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/27.png" class="">

<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><ul>
<li>ENSP 模拟器</li>
<li>PC 通过公网地址访问互联网</li>
</ul>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>根据接口 IP 地址表，配置各个设备的接口地址。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/28.png" class="">
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/29.png" class="">
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/30.png" class="">
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/31.png" class="">

<p>在 RT 上配置 NAT 配置。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/32.png" class="">

<p>配置基本 NAT 只需要一条命令：把私有 IP 地址转换成公网 IP 地址，在接口视图下配置<code>nat static global global-address inside host-address</code>命令。默认路由是网关路由器上的常见配置。使用<code>display nat static</code>命令查看 RT 上的静态 NAT 配置。</p>
<p>在 PC 上验证联网功能。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/33.png" class="">

<p>抓包查看 NAT 转换效果。分别抓包 RT 的内网口<code>G0/0/0</code>和外网口<code>G0/0/1</code>的报文，看出发送的<code>Echo Request</code>报文和接收的<code>Echo Reply</code>报文都有进行 NAT 转换。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/34.png" class="">
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/35.png" class="">

<h2 id="NAPT-实验"><a href="#NAPT-实验" class="headerlink" title="NAPT 实验"></a>NAPT 实验</h2><h3 id="实验拓扑图-1"><a href="#实验拓扑图-1" class="headerlink" title="实验拓扑图"></a>实验拓扑图</h3><img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/36.png" class="">

<h3 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h3><ul>
<li>RT 使用 NAPT 功能</li>
<li>ISP 分配 4 个可用的公网地址：<code>202.0.0.3 ~ 202.0.0.6</code></li>
<li>VLAN 10 的用户使用两个公网地址</li>
<li>VLAN 20 的用户使用另外两个公网地址</li>
</ul>
<h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>根据接口 IP 地址表，配置各个设备的接口地址。配置命令可参考上一个实验步骤 1。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/37.png" class="">

<p>在 RT 上配置 NAPT 配置。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/38.png" class="">

<p>在 NAPT 的配置中，使用基本 ACL 来指定私有 IP 地址范围。ACL 2010 指定 VLAN 10 的 IP 地址空间，ACL 2020 指定 VLAN 20 的 IP 地址空间。使用<code>nat address-group group-index start-address end-address</code>命令指定公网 IP 地址范围，分别指定了两个 NAT 地址组，编号分别选择了 1 和 2。在外网接口上，使用<code>nat outbound acl-number address-group group-index</code>，绑定 NAT 转换关系。</p>
<p>使用<code>display nat address-group</code>命令查看 RT 上的 NAT 地址组配置。命令<code>display nat outbound</code>查看出方向 NAT 的转换关系。</p>
<p>分别在 PC 10 和 PC 20 上验证上网功能。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/39.png" class="">


<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/40.png" class="">

<p>抓包查看 NAT 转换效果。分别抓包 RT 的内网口<code>G0/0/1</code>和外网口<code>G0/0/0</code>的报文，查看 VLAN 10 的用户出发送的<code>Echo Request</code>报文和接收的<code>Echo Reply</code>报文都有进行 NAT 转换。</p>
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/41.png" class="">
<img src="/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/42.png" class="">

<h2 id="其它常用-NAT-命令"><a href="#其它常用-NAT-命令" class="headerlink" title="其它常用 NAT 命令"></a>其它常用 NAT 命令</h2><p>NAT Server 是在接口视图下配置，命令格式为：<code>nat server protocol &#123; tcp | udp &#125; global global-address global-port inside host-address host-port</code>。</p>
<p>检查 NAT Server 配置信息命令：<code>display nat server</code>。</p>
<p>检查 NAT 会话命令：<code>display nat session all</code>。</p>
<p>启动 NAT ALG 功能命令：<code>nat alg all enable</code>。</p>
<p>查看 NAT ALG 功能命令：<code>display nat alg</code>。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/NAT%E8%AF%A6%E8%A7%A3/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IPv6%E8%AF%A6%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            IPv6详解
          
        </div>
      </a>
    
    
      <a href="/2023/03/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/RIP%E8%AF%A6%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">RIP详解</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>