<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>OSPF详解 |  学海无涯</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?b1b5dee3bb1719c8a439f8070118dc80";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


      <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->
      <link href="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.css" rel="stylesheet">
      <script src="https://cdn.bootcdn.net/ajax/libs/sweetalert2/11.7.3/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-计算机网络/OSPF详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  OSPF详解
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2023-03-22T12:36:11.000Z" itemprop="datePublished">2023-03-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">30 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="RIP-缺陷"><a href="#RIP-缺陷" class="headerlink" title="RIP 缺陷"></a>RIP 缺陷</h1><p>提及 OSFP 时，还得先从 RIP 说起。</p>
<p>RIP 以跳数来计算到达目的网络的最优路径，在实际应用时并不合适，以网络带宽和链路时延来衡量网络质量会更合理。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/1.png" class="">

<p>RIP 支持的最大跳数是 16，无法用于搭建大规模的网络。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/2.png" class="">

<p>RIP 的收敛速度慢，RIP 会对不可达路由的信息更新进行抑制，原路由失效，新路由要等到抑制时间结束后，才能更新。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/3.png" class="">

<p>RIP 的更新周期长，一个路由器突然离线，其它路由器要很长时间才能发现。</p>
<p>RIP 使用广播发送全部路由信息，网络规模越大，路由信息占用的网络资源也越大。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/4.png" class="">

<p>因此，RIP 路由并不适合大规模的网络，而 OSPF 协议解决了这些问题，得到了广泛的使用。</p>
<h1 id="OSPF-原理"><a href="#OSPF-原理" class="headerlink" title="OSPF 原理"></a>OSPF 原理</h1><p>OSPF，是<code>Open Shortest Path First</code>的缩写，译为开放最短路径优先。OSPF 是基于链路状态（<code>Link State</code>）的自治系统内部路由协议，用来替代 RIP 协议，通用的是 OSPFv2。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/5.png" class="">

<p>与距离矢量协议不同，链路状态协议使用最短路径优先算法（<code>Shortest Path First，SPF</code>）计算和选择路由。这类路由协议关系网络链路或接口的状态，比如 up、down、IP 地址、掩码、带宽、利用率和时延等。每台路由器将已知的链路状态向其它路由器通告，让网络上每台路由器对网络结构有相同的了解。然后，路由器以此为依据，使用 SPF 算法计算和选择路由。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/6.png" class="">

<p>OSPF 协议使用组播发送协议包，节约资源，又减少对其它网络设备的干扰。</p>
<p>OSPF 将协议包封装在 IP 包中，协议号 89。由于 IP 协议是无连接的，OSPF 定义了一些机制保证协议包安全可靠的传输。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/7.png" class="">

<p>总之，OSPF 协议比 RIP 有更大的扩展、快速收敛和安全可靠等特性，采用路由增量更新保证路由同步，减少对网络资源的浪费。</p>
<h1 id="OSPF-协议简介"><a href="#OSPF-协议简介" class="headerlink" title="OSPF 协议简介"></a>OSPF 协议简介</h1><img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/8.png" class="">

<p>OSPF 协议有四个主要过程：</p>
<ul>
<li>寻找邻居<br>OSPF 协议启动后，先寻找网络中的邻居，也就是通过<code>Hello</code>报文确认可以双向通信。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/9.png" class=""></li>
<li>建立邻接关系<br>一部分路由器形成邻居关系后，就开始进行建立邻接关系。建立了邻居关系的路由器才能互相传递链路状态信息。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/10.png" class=""></li>
<li>链路状态信息同步<br>建立邻接关系的 OSPF 路由器在网络中交互 LSA（链路状态通告），最后形成包含网络完整链路状态信息的 LSDB（链路状态数据库）。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/11.png" class=""></li>
<li>计算路由<br>LSDB 同步完成后，OSPF 区域内的每个路由器对网络结构有相同的认识，邻居路由器之间形成完全的邻接关系。然后，每台路由器根据 LSDB 的信息使用 SPF（最短路径优先）算法独立计算出路由。<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/12.png" class=""></li>
</ul>
<h1 id="OSPF-协议过程"><a href="#OSPF-协议过程" class="headerlink" title="OSPF 协议过程"></a>OSPF 协议过程</h1><p>将 OSPF 的四个过程展开来讲，就是一个个邻居状态的切换，不同的邻居状态有不同的行为。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/13.png" class="">

<h3 id="Down（失效）"><a href="#Down（失效）" class="headerlink" title="Down（失效）"></a>Down（失效）</h3><p>OSPF 邻居的初始状态，表示接口没有收到邻居发来的<code>Hello</code>报文。</p>
<h3 id="Init（初始）"><a href="#Init（初始）" class="headerlink" title="Init（初始）"></a>Init（初始）</h3><p>收到邻居发送的<code>Hello</code>报文，但是报文内没有自己的<code>Router-ID</code>，邻居状态就是<code>Init</code>。这个状态表示，直连链路上有一个 OSPF 路由器，但是还未确认双向通信。接下来，路由器会把对方的<code>Router-ID</code>添加到发送的<code>Hello</code>报文中。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/14.png" class="">

<h3 id="Attempt（尝试）"><a href="#Attempt（尝试）" class="headerlink" title="Attempt（尝试）"></a>Attempt（尝试）</h3><p>只在 NBMA 网络中出现。当路由器的 NBMA 接口启动后，邻居状态从<code>Down</code>切换到<code>Attempt</code>。这种状态下，路由器周期性的向邻居发送<code>Hello</code>报文，但是未收到邻居的有效<code>Hello</code>报文。当路由器收到邻居发送的没有自己<code>Router-ID</code>的<code>Hello</code>报文后，就将邻居状态切换到<code>Init</code>。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/15.png" class="">

<h3 id="2-Way（双向通信）"><a href="#2-Way（双向通信）" class="headerlink" title="2-Way（双向通信）"></a>2-Way（双向通信）</h3><p>路由器收到邻居的<code>Hello</code>报文，报文里有自己的<code>Router-ID</code>时，状态切换成<code>2-Way</code>，表示两个路由器形成了可以双向通信的邻居关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/16.png" class="">

<h3 id="选举-DR-和-BDR"><a href="#选举-DR-和-BDR" class="headerlink" title="选举 DR 和 BDR"></a>选举 DR 和 BDR</h3><p>如果路由器是在一个 MA 网络，邻居状态在<code>2-Way</code>后，会进行 DR 和 BDR 选举。</p>
<h3 id="ExSart（交换开始）"><a href="#ExSart（交换开始）" class="headerlink" title="ExSart（交换开始）"></a>ExSart（交换开始）</h3><p>接来下，路由器会进入<code>ExStart</code>状态，发送空的 DD 报文，用于协商<code>Master/Slave</code>，<code>Router-ID</code>最大的路由器成为<code>Master</code>路由器，DD 报文的序列号由<code>Master</code>路由器决定。协商<code>Master/Slave</code>的报文是空的、不携带 LSA 头部的 DD 报文，这时报文的 I 位被设置成 1。</p>
<h3 id="Exchange（交换）"><a href="#Exchange（交换）" class="headerlink" title="Exchange（交换）"></a>Exchange（交换）</h3><p>接下来，路由器进入<code>Exchange</code>状态，向邻居发送描述自己 LSDB 的 DD 报文，DD 报文中包含 LSA 头部。DD 报文逐个发送，每个报文中都有 DD 序列号，DD 序列号由<code>Master</code>路由器决定，序列号在 DD 报文的交互过程中递增，确保交互过程的有序性和可靠性。</p>
<h3 id="Loading（加载）"><a href="#Loading（加载）" class="headerlink" title="Loading（加载）"></a>Loading（加载）</h3><p>接下来，路由器进入<code>Loading</code>状态，路由器向邻居发送 LSR 请求 LSA 的完整信息。邻居使用 LSU 进行回应，LSU 报文里有 LSA 的完整信息。在收到 LSU 报文后，路由器需要发送 LSAck 对 LSA 进行确认。</p>
<h3 id="Full（完整）"><a href="#Full（完整）" class="headerlink" title="Full（完整）"></a>Full（完整）</h3><p>当接口上需要请求的 LSA 列表为空时，表示路由器已经完成了和邻居的 LSDB 同步，没有再需要请求的 LSA 了，这时邻居的状态就是<code>Full</code>。</p>
<p>路由计算<br>接下来，路由器开始计算路由。先评估一台路由器到另一台路由器需要的度量值。OSPF 协议是根据路由器的每一个接口的度量值决定最短路径的。一条路由的开销是指到达目的网络的路径上所有路由器接口的度量值总和。</p>
<p>度量值和接口带宽有关，路由器的接口度量值是根据公式 100&#x2F;带宽（Mbps）计算出来的，它作为评估路由器之间网络资源的参考值。另外也可以通过命令手工指定路由器的度量值。</p>
<h1 id="MA-和-NBMA-网络"><a href="#MA-和-NBMA-网络" class="headerlink" title="MA 和 NBMA 网络"></a>MA 和 NBMA 网络</h1><p>MA 网络，即多路访问网络，是在同一个共享介质中连接多个设备的网络。网络中的任意两台设备都能直接进行二层通信。MA 网络有两种，一种是 BMA 网络，即广播型多路访问网络，比如以太网，典型场景就是一台以太网交换机连接着多台路由器，如果有一个广播数据发出来，整个网络中的路由器都能收到。另一种是 NBMA 网络，即非广播型多路访问网络，NBMA 类型的网络已经看不到了，它允许多台路由器接入，但是没有广播能力，无法使用组播或广播，只能配置成单播发送 OSPF 报文。帧中继、X.25 都是这类网络。</p>
<h1 id="DR-和-BDR"><a href="#DR-和-BDR" class="headerlink" title="DR 和 BDR"></a>DR 和 BDR</h1><p>在 MA 网络中，<code>n</code>台路由器都两两建立邻接关系，那么就有<code>n(n-1)/2</code>个邻接关系，会消耗大量的路由器资源，增加网络中 LSA 的泛洪数量。为了优化邻接关系数量，减少不必要的协议流量，OSPF 会在每一个 MA 网络中选举一个 DR（指定路由器）和一个 BDR（备用指定路由器）。</p>
<p>既不是 DR 也不是 BDR 的路由器叫做 DROther，MA网络中所有 DROther 只和 DR 及 BDR 建立 OSPF 邻接关系，BDR 也和 DR 建立邻接关系，DROther 之间只停留在<code>2-Way</code>状态。这样，就有<code>2(n-2)+1</code>个邻接关系，数量得到优化。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/17.png" class="">

<p>DR 在 LSDB 同步方面有关键性的作用，会侦听网络中的拓扑变化信息，并将变更信息通知给其它路由器。DR 会生成一种 Type-2 LSA，这个 LSA 包含个 MA 网络中所有 OSPF 路由器的<code>Router-ID</code>，也包括 DR 自己的。BDR 会监控 DR 状态，当 DR 发生故障时就接替它的工作。</p>
<p>DR、BDR 的选举通过<code>Hello</code>报文实现，发生在<code>2-Way</code>状态之后。<code>Hello</code>报文有路由器接口的 DR 优先级，取值范围是<code>0~255</code>，默认值为 1，DR 优先级为 0 的接口没有 DR 和 BDR 的选举资格。</p>
<p>当接口激活 OSPF 后，它会查看网络中是否存在 DR，如果有就使用已经存在的 DR，也就是 DR 不可抢占，否则选择最高优先级的路由器成为 DR，当优先级相等时，选择<code>Router-ID</code>最大的路由器成为 DR。之后还会进行 BDR 的选举，选举过程与 DR 类似。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/38.png" class="">

<p>需要注意的是，DR 和 BDR 是一个接口级别的概念。某台路由器是 DR，这种说法不准确，严谨的说法是：某台路由器的某个接口在这个 MA 网络中是 DR。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/18.png" class="">

<p>在一个 MA 网络中，DR 要确保接入到网络中的所有路由器有相同的 LSDB，也就是确保 LSDB 同步。DR 使用组播地址<code>224.0.0.5</code>向网络中发送 LSU 报文，所有 OSPF 路由器都会侦听这个组播地址，并与 DR 同步 LSDB。而 DROther 感知到拓扑变化时，向<code>224.0.0.6</code>发送 LSU 报文通告这个变化，DR 和 BDR 会侦听这个组播地址。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/19.png" class="">

<h1 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h1><p>每种路由协议对度量值的定义是不同的，OSPF 使用<code>Cost</code>（开销）作为路由度量值，<code>Cost</code>值越小，则路径（路由）越优。每一个激活 OSPF 的接口都有一个接口的<code>Cost</code>值，值等于 100&#x2F;接口带宽 Mbit&#x2F;s，计算结果取整数部分，当结果小于 1 时，值取 1。这个值也可以人为修改，修改值会直接影响<code>Cost</code>值的计算，从而影响网络中 OSPF 路由的选择。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/21-0.png" class="">

<p>同步 OSPF 区域内每台路由器的 LSDB，路由器通过交互 LSA 实现 LSDB 的同步。LSA 不但携带了网络连接状况信息，而且携带各接口的<code>Cost</code>信息。</p>
<p>由于一条 LSA 是对一台路由器或一个网段拓扑结构的描述，整个 LSDB 就形成了对整个网络的拓扑结构的描述。所有路由器得到一张完全相同的图。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/21.png" class="">

<p>使用 SPF（最短路径优先算法）计算出路由。OSPF 路由器用 SPF 算法以自己为根节点，计算出一棵最短路径树。这棵树上，由根到各个节点的累计开销最小，也就是从根到各个节点的路径都是最优的，这样就获得了由根去往各个节点的路由。计算完成后，路由器将路由加入到 OSPF 路由表。当 SPF 算法发现有两条到达目的网络的路由的<code>Cost</code>值相同，会将这两条路由都加入到 OSPF 路由表中，形成等价路由。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/22.png" class="">
<h1 id="Router-ID"><a href="#Router-ID" class="headerlink" title="Router-ID"></a>Router-ID</h1><p><code>Router-ID</code>用于标识 OSPF 路由器，是一个 32 位的数值，跟 IPv4 地址格式一样。连续的 OSPF 路由器组成的网络叫做 OSPF 域，域内<code>Router-ID</code>必须唯一，也就是在同一个域内不允许出现两台相同<code>Router-ID</code>的路由器。<code>Router-ID</code>可以手动设置，也可以自动生成，常见的做法是把设备的<code>Router-ID</code>指定为设备的<code>Loopback</code>接口的 IP 地址。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/15-1.png" class="">

<h2 id="Loopback-接口"><a href="#Loopback-接口" class="headerlink" title="Loopback 接口"></a>Loopback 接口</h2><p><code>Loopback</code>接口也就是本地回环接口，是一种软件的、逻辑的接口，不只网络设备支持<code>Loopback</code>接口，Windows 主机或 Linux 主机也支持。根据业务需求，在网络设备上创建<code>Loopback</code>接口，并配置 IP 地址。<code>Loopback</code>接口非常稳定，除非手动进行关闭或删除，否则是永远不会失效的。正因如此，<code>Loopback</code>接口常用于设备网管、网络测试、网络协议应用等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为设备创建一个 Loopback 接口，并配置接口的 IP 地址</span></span><br><span class="line">[router]interface loopback 0</span><br><span class="line">[router-loopback0]ip address 1.1.1.1 32</span><br><span class="line">[router-loopback0]quit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 OSPF 进程，并配置设备的 Router-ID 为 1.1.1.1</span></span><br><span class="line">[router]ospf 1 router-id 1.1.1.1</span><br></pre></td></tr></table></figure>
<h1 id="报文类型及格式"><a href="#报文类型及格式" class="headerlink" title="报文类型及格式"></a>报文类型及格式</h1><p>OSPF 协议的报文直接使用 IP 封装，在 IP 报文头部对应的协议号是 89。通常 OSPF 的协议报文使用组播地址作为目的 IP 地址，有两个组播 IP 地址是 OSPF 专用。</p>
<ul>
<li><code>224.0.0.5</code>：这个组播 IP 地址是指所有的 OSPF 路由器。</li>
<li><code>224.0.0.6</code>：这个组播 IP 地址是指所有的 OSPF DR 路由器。</li>
</ul>
<p>OSPF 一共定义了五种报文，各有各的用途。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">报文名称</th>
<th align="center">报文说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">Hello</td>
<td align="center">用于发现直连链路上的 OSPF 邻居，以及维护 OSPF 邻居关系</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">DD<br>Database Description<br>数据库描述</td>
<td align="center">用于描述LSDB，报文中携带的是 LSA 的头部数据，不是完整的 LSA 内容</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">LSR<br>Link State Request<br>链路状态请求</td>
<td align="center">向 OSPF 邻居请求 LSA</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">LSU<br>Link State Update<br>链路状态更新</td>
<td align="center">用于发送 LSA，报文中携带的是完整的 LSA 数据</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">LSAck<br>Link State Acknowledgment<br>链路状态确认</td>
<td align="center">设备收到 LSU 后，LSAck对接收的 LSA 进行确认</td>
</tr>
</tbody></table>
<p>路由器的接口一旦激活 OSPF，就会开始发送<code>Hello</code>报文。<code>Hello</code>报文的一个重要功能就是发现直连链路上的 OSPF 邻居。发现邻居后，就开始邻接关系的建立。这个过程中，DD 报文用于发送 LSA 的头部摘要。通过 DD 报文的交互，路由器知道了对方所有的 LSA，而 LSR 向对方请求完整的 LSA。LSU 对 LSR 进行回应，或者主动更新 LSA，LSU 包含完整的 LSA 数据。LSAck 保证 OSPF 更新机制的可靠性。此外，<code>Hello</code>报文负责 OSPF 邻居关系的维护，两台直连路由器形成邻接关系后，双方仍然周期性的发送<code>Hello</code>报文，告知对方自己是在线状态。</p>
<p>所有 OSPF 报文是相同的头部，这个头部的长度是 24 字节。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/24.png" class="">

<ul>
<li>版本：OSPFv2 的值为 2。</li>
<li>类型：表示 OSPF 报文的类型。值与报文类型对应关系是：<code>1–Hello；2–DD；3–LSR；4–LSU；5–LSAck</code>。</li>
<li>报文长度：整个 OSPF 报文的长度，单位是字节。</li>
<li>路由器 ID：路由器的 OSPF <code>Router-ID</code>。</li>
<li>区域 ID：表示所属的区域 ID，是一个 4 字节的数值。</li>
<li>校验和：用来校验报文有效性。</li>
<li>认证类型：表示报文使用的认证类型。</li>
<li>认证数据：用于报文认证的内容。</li>
</ul>
<h2 id="Hello-报文"><a href="#Hello-报文" class="headerlink" title="Hello 报文"></a>Hello 报文</h2><p><code>Hello</code>报文用于发现直连链路上的邻居，以及维护邻居关系。<code>Hello</code>报文携带邻居关系建立的各项参数，建立邻居关系的过程中，会检查这些参数，只有参数匹配，才能正确建立邻居关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/25.png" class="">

<ul>
<li>网络掩码：这个字段表示接口的网络掩码。如果两台路由器是通过以太网接口连接，那么直连的两个接口必须配置相同的网络掩码。如果收到的<code>Hello</code>报文中“网络掩码”字段与自己接口的不同，就忽略这个<code>Hello</code>报文，不会建立邻居关系。</li>
<li><code>Hello</code>间隔：接口周期性发送<code>Hello</code>报文的时间间隔，单位是秒。两台路由器要建立邻居关系，需要接口的<code>Hello</code>间隔相同，否则邻居关系无法建立。默认情况下，OSPF 路由器在 P2P 或 Broadcast 类型的接口上，<code>Hello</code>间隔是 10 秒，在 NBMA 及 P2MP 类型的接口上，<code>Hello</code>间隔是 30 秒。</li>
<li>选项：这个字段一共 8 比特，每个比特位都表示路由器的某个特性。路由器通过设置相应的「选项」比特位来通告自己支持某种特性或拥有某种能力。</li>
<li>路由器优先级：路由器优先级，也叫做 DR 优先级，用于 DR 和 BDR 的选举。默认情况下，OSPF 接口的 DR 优先级是 1，这个值也可以通过命令进行修改。</li>
<li>路由器失效时间：路由器等待对方发送<code>Hello</code>报文的时间，超过这个时间就认为是路由器已离线。路由器建立邻居关系，也需要双方接口的路由器失效时间相同。默认情况下，路由器失效时间是<code>Hello</code>间隔的 4 倍。</li>
<li>指定路由器：网络中 DR 的接口 IP 地址。如果值为<code>0.0.0.0</code>，表示没有 DR&#96;，或 DR 还未选举出来。</li>
<li>备份指定路由器：网络中 BDR 的接口 IP 地址。如果值为<code>0.0.0.0</code>，表示没有 BDR，或 BDR 还未选举出来。</li>
<li>邻居：表示邻居的<code>Router-ID</code>，是在直连链路上发现的有效邻居，如果发现多个邻居，就包含多个邻居字段。</li>
</ul>
<h2 id="DD-报文"><a href="#DD-报文" class="headerlink" title="DD 报文"></a>DD 报文</h2><p>DD 报文用于描述 LSDB，这个报文携带的是 LSDB 中 LSA 的头部数据，并非完整的 LSA 内容。互为邻居的路由器使用空的 DD 报文来协商主&#x2F;从（<code>Master/Slave</code>），空的 DD 报文不包含任何 LSA 头部信息。<code>Router-ID</code>更大的路由器成为<code>Master</code>路由器。</p>
<p><code>Master/Slave</code>确定后，双方开始使用 DD 报文描述各自的 LSDB，这时的 DD 报文包含 LSDB 里的 LSA 头部信息。路由器可以使用多个 DD 报文来描述 LSDB，为了确保 DD 报文传输的有序和可靠，<code>Master</code>路由器使用“DD Sequence Number（DD 序列号）”字段主导整个 LSDB 交互过程。比如：<code>Master</code>路由器发送一个 DD 序列号是 100 的 DD 报文给<code>Slave</code>路由器，<code>Slave</code>收到这个报文后，才发送自己的 DD 报文，而 DD 序列号也使用 100。<code>Master</code>路由器发送下一个 DD 报文（DD 序列号是 101），<code>Slave</code>路由器才会发送 DD 报文。这个过程一直持续，直到 LSDB 同步完成。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/20.png" class="">

<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/26.png" class="">

<ul>
<li>接口最大传输单元（<code>Interface Maximum Transmission Unit</code>）：接口的 MTU。默认情况下，接口发送的 DD 报文中，无论接口实际的 MTU 值是多少，值都为 0。</li>
<li>选项：路由器支持的 OSPF 可选项。</li>
<li>I 位（<code>Initial Bit</code>）：初始化位，协商<code>Master/Slave</code>路由器时，值为 1，<code>Master/Slave</code>选举完成后，值为 0。</li>
<li>M 位（<code>More Bit</code>）：如果值为 1，表示后续还有 DD 报文；如果值为 0，表示这是最后一个 DD 报文。</li>
<li>MS 位（<code>Master Bit</code>）：<code>Master</code>路由器发送的 DD 报文中，值为 1，<code>Slave</code>路由器则值为 0。</li>
<li>DD 序列号：DD 报文的序列号，在 DD 报 文交互过程中，逐次加 1，确保传输的有序和可靠。DD 序列号必须由<code>Master</code>路由器决定，而<code>Slave</code>路由器只能使用<code>Master</code>路由器发送的 DD 序列号来发送自己的 DD 报文。</li>
<li>LSA 头部：当路由器使用 DD 报文描述自己的 LSDB 时，LSA 头部信息就在这里。一个 DD 报文可能包含一条或多条 LSA 头部信息。</li>
</ul>
<h2 id="LSR-报文"><a href="#LSR-报文" class="headerlink" title="LSR 报文"></a>LSR 报文</h2><p>在与 OSPF 邻居交换 DD 报文后，路由器就知道了邻居的 LSDB 摘要，向邻居发送 LSR 报文请求所需 LSA 的完整数据。LSR 报文的链路状态类型（<code>Link-State Type</code>）、链路状态 ID（<code>Link-State ID</code>）、通告路由器（<code>Advertising Router</code>）三个字段表示路由器请求的 LSA。如果请求多个 LSA，那么 LSR 可能包含多个三元组。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/27.png" class="">

<ul>
<li>链路状态类型：表示 LSA 类型。OSPF 有多种 LSA 类型，每种 LSA 描述 OSPF 网络的某个部分，使用不同的类型编号。常见的 LSA 类型值和 LSA 名称是：<code>1–Router LSA，2–Network LSA，3–Network Summary LSA，4–ASBR Summary LSA，5–AS External LSA</code>。</li>
<li>链路状态标识：LSA 的标识。不同的 LSA 类型，字段的定义不同。</li>
<li>通告路由器：生成这条 LSA 的路由器的<code>Router-ID</code>。</li>
</ul>
<h2 id="LSU-报文"><a href="#LSU-报文" class="headerlink" title="LSU 报文"></a>LSU 报文</h2><p>路由器收到邻居发送的 LSR 后，会使用 LSU 报文进行回应，在 LSU 报文中包含请求 LSA 的完整信息，一个 LSU 报文可以包含多个 LSA。另外，当路由器感知到网络发生变化时，也会触发 LSU 报文的泛洪，及时把网络变化通告给其它路由器。在 BMA 网络中，非 DR、BDR 路由器向组播地址<code>224.0.0.6</code>发送 LSU 报文，而 DR 和 BDR 会侦听这个组播地址，DR 在接收 LSU 报文后向<code>224.0.0.5</code>发送 LSU 报文，从而将更新信息泛洪到整个 OSPF 区域，所有的 OSPF 路由器都会侦听<code>224.0.0.5</code>这个组播地址。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/28.png" class="">

<h2 id="LSAck-报文"><a href="#LSAck-报文" class="headerlink" title="LSAck 报文"></a>LSAck 报文</h2><p>当一台路由器收到邻居发送的 LSU 报文时，为了确认 LSA 已经送达，需要对报文中的 LSA 进行确认，就是回复一个 LSAck 报文。LSAck 报文包含路由器确认的 LSA 头部信息。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/29.png" class="">

<h1 id="OSPF-三张表"><a href="#OSPF-三张表" class="headerlink" title="OSPF 三张表"></a>OSPF 三张表</h1><p>OSPF 使用三种表格确保能正常运行。</p>
<h2 id="邻居表（Peer-Table）"><a href="#邻居表（Peer-Table）" class="headerlink" title="邻居表（Peer Table）"></a>邻居表（Peer Table）</h2><p>在 OSPF 交互 LSA 之前，两台直连路由器需要建立 OSPF 邻居关系。当一个接口激活 OSPF 后，就会周期性的发送 OSPF <code>Hello</code>报文，同时侦听<code>Hello</code>报文从而发现直连链路上的邻居。在接口上发现邻居后，邻居的信息会写入路由器的 OSPF 邻居表，随后一个邻接关系的建立过程也开始了。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/30.png" class="">

<h2 id="链路状态数据库（Link-State-Database-，LSDB）"><a href="#链路状态数据库（Link-State-Database-，LSDB）" class="headerlink" title="链路状态数据库（Link-State Database ，LSDB）"></a>链路状态数据库（Link-State Database ，LSDB）</h2><p>OSPF 路由器在网络中泛洪的链路状态信息，叫做 LSA（<code>Link-State Advertisement</code>，链路状态通告）。路由器搜集 LSA 并添加到自己的 LSDB 中，路由器通过 LSDB 获取网络的完整信息。OSPF 定义了多种类型的 LSA ，这些 LSA 各有用途，最终目的是让路由器知道网络的拓扑结构以及网段信息，并计算出最短路径树，从而发现到达全网各个网段的路由。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/31.png" class="">

<h2 id="OSPF-路由表（Routing-Table）"><a href="#OSPF-路由表（Routing-Table）" class="headerlink" title="OSPF 路由表（Routing Table）"></a>OSPF 路由表（Routing Table）</h2><p>OSPF 根据 LSDB 中的数据，运行 SPF 算法，得到一棵以自己为根、无环的最短路径树，基于这棵树，OSPF 能够发现到达网络中各个网段的最佳路径，从而得到路由信息，并添加到 OSPF 路由表中。当然，这些 OSPF 路由表中的路由最终是否被添加到全局路由器，还需要经过比较路由优先级等过程。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/32.png" class="">

<h1 id="邻接关系"><a href="#邻接关系" class="headerlink" title="邻接关系"></a>邻接关系</h1><p>OSPF 有两个概念：邻居关系和邻接关系。假如两台路由器通过网线直连，在双方互联的接口上激活 OSPF，路由器接口开始发送和侦听<code>Hello</code>报文，通过<code>Hello</code>报文发现彼此，并确认双向通信后，就形成了邻居关系。</p>
<p>之后，两台路由器会开始交互空的 DD 报文协商<code>Master/Slave</code>，再交互包含 LSA 头部信息的 DD 报文，以便同步自己的 LSDB，然后通过 LSR 和 LSU 报文交互双方的 LSA。当两者的 LSDB 同步完成后，两台路由器形成对网络拓扑的一致认知，并开始独立计算路由。这时，两台路由器形成了邻接关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/33.png" class="">

<h1 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h1><p>OSPF 的许多功能或特性都是基于接口实现的，当一个接口激活 OSPF 后，这个接口会维护很多 OSPF 变量，比如：接入的区域 ID 、接口 Cost 值、DR 优先级、邻居列表、认证类型等，其中接口的网络类型（ Network-Type ）是非常重要的一个变量。OSPF 接口的网络类型跟接口的数据链路层封装有关，在不同网络类型的接口上，OSPF 的操作有所不同。</p>
<h2 id="1、点对点类型（-Point-to-Point-，P2P-）"><a href="#1、点对点类型（-Point-to-Point-，P2P-）" class="headerlink" title="1、点对点类型（ Point-to-Point ，P2P ）"></a>1、点对点类型（ Point-to-Point ，P2P ）</h2><p>P2P 网络是在一条链路上只能连接两台路由器的环境。典型的例子就是 PPP 链路，当两台路由器通过 PPP 链路直连时，接口的封装协议就是 PPP ，接口激活 OSPF 后，网络类型就是 P2P 。OSPF 在 P2P 网络类型中，接口以组播方式发送协议报文，组播地址是 224.0.0.5 ，报文类型包括 Hello 报文、DD 报文、LSR 报文、LSU 报文和 LSAck 报文。默认情况下，P2P 类型接口的 Hello 报文发送间隔是 10 秒。P2P 类型的网络中，不会选举 DR 和 BDR 。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/34.png" class="">

<h2 id="2、广播型多路访问类型（Broadcast-Multi-Access-，BMA）"><a href="#2、广播型多路访问类型（Broadcast-Multi-Access-，BMA）" class="headerlink" title="2、广播型多路访问类型（Broadcast Multi-Access ，BMA）"></a>2、广播型多路访问类型（Broadcast Multi-Access ，BMA）</h2><p>BMA 网络中可以多台路由器接入，任意两台路由器之间都能进行二层通信，一台路由器发送出去的广播数据，其它所有路由器都能收到，是一个支持广播的网络环境。以太网就是典型的 BMA 网络。当多台路由器接入到 BMA 网络时，比如多台路由器连接在同一台二层交换机上，这些路由器的接口激活 OSPF 就会开始发送组播的<code>Hello</code>报文，从而发现网络中的其它路由器。BMA 网络中，会选举 DR 和 BDR，所有非 DR、BDR 路由器仅与 DR 和 BDR 建立邻接关系。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/35.png" class="">

<p>OSPF 在 BMA 网络中，接口以组播方式发送<code>Hello</code>报文、LSU 报文以及 LSAck 报文，单播方式发送 DD 报文及 LSR 报文。当路由器需要向 DR 和 BDR 发送 OSPF 报文时，使用<code>224.0.0.6</code>这个组播地址作为目的 IP 地址；当需要向所有的 OSPF 路由器发送报文时，使用<code>224.0.0.5</code>。默认情况下，广播类型接口的<code>Hello</code>报文发送间隔是 10 秒。</p>
<h2 id="3、非广播型多路访问类型（Non-Broadcast-Multi-Access-，NBMA）"><a href="#3、非广播型多路访问类型（Non-Broadcast-Multi-Access-，NBMA）" class="headerlink" title="3、非广播型多路访问类型（Non-Broadcast Multi-Access ，NBMA）"></a>3、非广播型多路访问类型（Non-Broadcast Multi-Access ，NBMA）</h2><p>NBMA 网络也允许多台路由器接入，但是不具备广播能力，这时组播发送的<code>Hello</code>报文在 NBMA 网络中可能会有问题。为了让 OSPF 路由器之间能够顺利发现彼此，并正确建立邻接关系，还需要手动配置，比如使用单播方式发送 OSPF 报文等。帧中继、X.25 就是 NBMA 网络，不过现在已经几乎看不到这类型网络了。NBMA 网络中，也会进行 DR 和 BDR 选举。默认情况下，NBMA 类型接口的<code>Hello</code>报文发送间隔是 30 秒。</p>
<h2 id="4、点对多点类型（Point-to-Multipoint-，P2MP）"><a href="#4、点对多点类型（Point-to-Multipoint-，P2MP）" class="headerlink" title="4、点对多点类型（Point-to-Multipoint ，P2MP）"></a>4、点对多点类型（Point-to-Multipoint ，P2MP）</h2><p>P2MP 网络中，路由器接口的数据链路层封装不会自动设置，必须手动指定。P2MP 类似将多条 P2P 链路的一头进行捆绑的网络。在 P2MP 网络中无需选举 DR、BDR。OSPF 在 P2MP 类型的接口上以组播方式发送<code>Hello</code>报文，以单播方式发送其它报文。默认情况下，<code>Hello</code>报文发送间隔是 30 秒。</p>
<p>了解了这么多的网络类型，即使两个路由器的直连接口的网络类型不同，也能建立 OSPF 邻接关系，但是 OSPF 路由计算容易出现问题，因为网络类型会影响 LSA 对接口的描述，关系到路由器对网络拓扑的理解和路由计算。因此，OSPF 邻接的路由器，互联接口的网络类型必须一致。</p>
<p>即使在以太网中只有两台路由器，OSPF 也会选举 DR 和 BDR，实际上没必要且浪费时间，因为从逻辑上看是点对点的连接，选举 DR 和 BDR 实在是画蛇添足。因此，为了提高 OSPF 的效率，加快邻接关系的建立过程，可以把互联接口的网络类型修改为 P2P。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/36.png" class="">


<h1 id="区域和多区域"><a href="#区域和多区域" class="headerlink" title="区域和多区域"></a>区域和多区域</h1><p>连续的 OSPF 路由器组成的网络叫做 OSPF 域（<code>Domain</code>），为了保证每台路由器都能正常的计算路由，就要求域内所有的路由器同步 LSDB，才能达到对整个 OSPF 网络的一致认知。当网络规模越来越大时，每台路由器维护的 LSDB 变得臃肿，计算庞大的 LSDB 需要消耗更多的设备资源，加重设备的负担。另外，网络拓扑的变化，引起所有域内的路由器重新计算，而域内路由无法进行汇总，每台路由器需要维护的路由表也越来越大，又是一个不能忽略的资源消耗。</p>
<p>因此，OSPF 引入了区域（<code>Area</code>）的概念。在一个大规模的网络中，会把 OSPF 域分成多个区域。某些 LSA 的泛洪只在单个区域内部，同一个区域内的路由器维护一套相同的 LSDB ，对区域内的网络有一致的认知。每个区域独立进行 SPF 计算，区域内的拓扑结构对区域外是不可见的，而且区域内部的拓扑变化通知被限制在区域内，避免对区域外部造成影响。如果一台路由器的多个接口分别接入多个不同的区域，那么它会为每个区域分别维护一套 LSDB 。多区域的设计极大程度的限制了 LSA 的泛洪，有效的把拓扑变化的影响控制在区域内，另外在区域边界路由器上可以进行路由汇总，减少网络中的路由条目数量。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/40.png" class="">

<p>OSPF 的每一个区域都由一个编号，不同的编号表示不同的区域，这个区域编号也叫做区域 ID（<code>Area-ID</code>）。区域 ID 是一个 32 位二进制数，与 IPv4 地址的格式一样，比如<code>Area 0.0.0.1</code>，为了方便起见，也会用十进制数表示，<code>Area 0.0.0.1</code>简化成<code>Area1</code>，<code>Area 0.0.0.255</code>简化成<code>Area255</code>，<code>Area 0.0.1.0</code>简化成<code>Area256</code>。</p>
<p>一个 OSPF 域中，允许存在多个区域，其中有一个中心区域，也就是骨干区域<code>Area0</code>（或<code>Area 0.0.0.0</code>）。OSPF 要求域内的所有非骨干区域（区域 ID 不是 0 的区域）必须与<code>Area0</code>相连。如果一个域内有多个区域，那么有且只有一个<code>Area0</code>，<code>Area0</code>负责在区域之间发布区域间的路由。因此，所有的 ABR（<code>Area Border Router</code>，区域边界路由器）至少有一个接口属于<code>Area0</code>，所以<code>Area0</code>包含所有的 ABR。有点类似星型结构，骨干区域在中间，每个非骨干区域是分支。</p>
<p>任何一个非骨干区域都必须与<code>Area0</code>相连，当网络中某个区域没有与<code>Area0</code>相连时，这个区域的路由计算就会出问题。OSPF 的区域间路由都由<code>Area0</code>中转，任何两个非骨干区域之间是不能直接交互路由的。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/41.png" class="">

<p>解决方法是修改 OSPF 的网络设计，与<code>Area0</code>直接相连。如果不能改或改动成本大等问题，可以考虑使用 OSPF 虚链路（<code>Virtual Link</code>）。<code>Virtual Link</code>是一种逻辑的链路，不是一条真实的链路。通过搭建一条<code>Virtual Link</code>，可以把原来没有与骨干区域直连的区域给连接起来。</p>
<p>另一个可能的问题是，骨干区域不连续或被分隔开。非骨干区域交互区域路由时，容易引发路由环路。因此，OSPF 要求 ABR 只能将自己直连的区域内部路由通告给<code>Area0</code>，而不能将自己到达其它区域的域间路由通告给<code>Area0</code>。另外，ABR 可以将自己直连区域的内部路由和到达其它区域的域间路由通告给非骨干区域。这样就能规避网络规划不合理导致的路由环路。解决问题最好的办法是修改 OSPF 的规划，当然建立<code>Virtual Link</code>也可以临时解决这个问题。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/42.png" class="">

<p>实际部署中，Virtual Link 并不是一种常规的技术，而是一种临时方案，合理的 OSPF 网络规划依然是一个最佳的选择。</p>
<h1 id="OSPF-路由器角色"><a href="#OSPF-路由器角色" class="headerlink" title="OSPF 路由器角色"></a>OSPF 路由器角色</h1><p>在 OSPF 中，有多种路由器角色，在 OSPF 网络中都发挥着不同的作用。实际上，OSPF 不仅在路由器上使用，许多交换机、防火墙，甚至 Linux 主机都能实现。这里说的 OSPF 路由器，实际上是以路由器为代表。</p>
<img src="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/43.png" class="">

<p>内部路由器（<code>Internal Router，IR</code>）：所有接口都在同一个 OSPF 区域内的路由器。图中 R1、R4、R5 是 IR。</p>
<p>区域边界路由器（<code>Area Border Router，ABR</code>）：接入多个区域的路由器，并非所有接入多个区域的路由器都是 ABR。它至少有一个接口在<code>Area0</code>中，同时还有其它接口在其它区域中。ABR 负责在区域之间传递路由信息，因此必须连接到<code>Area0</code>，同时连接着其它区域。图中 R2、R3 是 ABR。</p>
<p>骨干路由器（<code>Backbone Router，BR</code>）：至少有一个接口接入<code>Area0</code>的路由器，那它就是一台骨干路由器，另外 ABR 也是骨干路由器。图中 R1、R2、R3、R6 是 BR。</p>
<p>AS 边界路由器（<code>AS Boundary Router，ASBR</code>）：工作在 OSPF 自治系统（<code>Autonomous System ，AS</code>）边界的路由器。ASBR 将 OSPF 域外的路由引入到本域，外部路由在整个 OSPF 域内传递。并不是同时运行多种路由协议的路由器就一定是 ASBR，ASBR 一定是将外部路由重分发到 OSPF，或者执行了路由重分发操作的路由器。图中 R6 是 ASBR。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSPF%E8%AF%A6%E8%A7%A3/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            交换机基础
          
        </div>
      </a>
    
    
      <a href="/2023/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IPv6%E8%AF%A6%E8%A7%A3/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">IPv6详解</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2017-2023
        <i class="ri-heart-fill heart_icon"></i> WSQ
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="学海无涯"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>